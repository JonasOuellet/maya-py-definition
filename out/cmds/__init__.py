def insertListItem(*args, **kwargs):
    """
    
    """
    pass


def RenderSequence(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CylindricalProjection(*args, **kwargs):
    """
    unknown
    """
    pass


def SurfaceFlow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ClosestPointOn(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorRestoreLastClosedTab(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def lookThru(*args, farClip=0.0, nearClip=0.0, q=True, query=True, **kwargs):
    """
    This command sets a particular camera to look through in a view  This command may also be
    used to view the negative z axis of lights or other DAG objects  The standard camera tools
    can then be used to place the object   Note: if there are multiple objects under the
    transform selected, cameras and lights take precedence
    
    :param farClip: (C) Used when setting clip far plane for a new look thru camera  Will not
    affect the attributes of an existing camera  Clip values must come before shape
    :type farClip: float
    :param nearClip: (C) Used when setting near clip plane for a new look thru camera  Will not
    affect the attributes of an existing camera  Clip values must come before shap
    :type nearClip: float
    
    :returns: 
    :rtype: None
    """
    pass


def pixelMove(*args, **kwargs):
    """
    The pixelMove command moves objects by what appears as pixel units based on the current
    view  It takes two integer arguments which specify the direction in screen space an object
    should appear to move  The vector between the center pixel of the view and the specified
    offset is mapped to some world space vector which defines the relative amount to m
    
    
    :returns: 
    :rtype: None
    """
    pass


def arnoldIpr(*args, **kwargs):
    """
    
    """
    pass


def UVEditorToggleTextureBorderDisplay(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeRefreshAllSwatchesOnDisk(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolyExtrudeVertices(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeGraphRearrange(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BevelPolygon(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def IKHandleTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BakeSpringAnimationOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SubstituteGeometryOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def colorAtPoint(*args, coordU=0.0, coordV=0.0, maxU=1.0, maxV=1.0, minU=0.0, minV=0.0,
                 output="", samplesU=1, samplesV=1, **kwargs):
    """
    The colorAtPoint command is used to query textures or ocean shaders at passed in uv
    coordinates  (For ocean shaders uv is x and z in worldspace )  The return value is a
    floating point array whose size is determined by either the number of input uv arguments
    passed in and the the queried value  One can query alpha only, rgb only, or rgba values 
    The
    
    :param coordU: (C M) Input u coordinate to sample texture at
    :type coordU: float
    :param coordV: (C M) Input v coordinate to sample texture at
    :type coordV: float
    :param maxU: (C) DEFAULT 1.0 Maximum u bounds to sample
    :type maxU: float
    :param maxV: (C) DEFAULT 1.0 Maximum v bounds to sample
    :type maxV: float
    :param minU: (C) DEFAULT 0.0 Minimum u bounds to sample
    :type minU: float
    :param minV: (C) DEFAULT 0.0 Minimum v bounds to sample
    :type minV: float
    :param output: (C) Type of data to output: A = alpha only RGB = color only RGBA = color and
    alpha
    :type output: string
    :param samplesU: (C) DEFAULT 1 The number of points to sample in the U dimension
    :type samplesU: int
    :param samplesV: (C) DEFAULT 1 The number of points to sample in the V dimension
    :type samplesV: int
    
    :returns: 
    :rtype: None
    """
    pass


def blendCtx(*args, **kwargs):
    """
    
    """
    pass


def clearCache(*args, allNodes=True, computed=True, dirty=True, **kwargs):
    """
    Even though dependency graph values are computed or dirty they may still occupy space
    temporarily within the nodes  This command goes in to all of the data that can be
    regenerated if required and removes it from the caches (datablocks), thus clearing up space
    in memory
    
    :param allNodes: (C) If toggled then all nodes in the graph are cleared  Otherwise only
    those nodes that are selected are cleared
    :type allNodes: boolean
    :param computed: (C) If toggled then remove all data that is computable  (Warning: If the
    data is requested for redraw then the recompute will immediately fill the data b
    :type computed: boolean
    :param dirty: (C) If toggled then remove all heavy data that is dirty
    :type dirty: boolean
    
    :returns: Number of items removed from caches
    :rtype: int
    """
    pass


def dR_viewLeft(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sbs_IsSubstanceRelocalized(*args, **kwargs):
    """
    
    """
    pass


def textureDeformer(*args, after=True, afterReference=True, before=True, deformerTools=True,
                    direction="", envelope=0.0, exclusive="", frontOfChain=True, geometry="",
                    geometryIndices=True, ignoreSelected=True, includeHiddenSelections=False,
                    name="", offset=0.0, parallel=True, pointSpace="", prune=True, remove=True,
                    split=True, strength=0.0, vectorOffset=None, vectorSpace="",
                    vectorStrength=None, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a texture deformer for the object  The selected objects are the input
    geometry objects  The deformer node name will be returned
    
    :param after: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type after: boolean
    :param afterReference: (C E) The -afterReference flag is used to specify deformer ordering
    in a hybrid way that choses between -before and -after automatically  If the geometry b
    :type afterReference: boolean
    :param before: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type before: boolean
    :param deformerTools: (Q) Returns the name of the deformer tool objects (if any) as string
    string ..
    :type deformerTools: boolean
    :param direction: (C) Set the deformation direction of texture deformer It can only handle
    three types: "Normal", "Handle" and "Vector"  "Normal" each vertices use its own
    :type direction: string
    :param envelope: (C) Set the envelope of texture deformer  Envelope determines the percent
    of deformation  The final result is (color * normal * strength + offset) * enve
    :type envelope: float
    :param exclusive: (C Q) Puts the deformation set in a deform partition
    :type exclusive: string
    :param frontOfChain: (C E) This command is used to specify that the new deformer node
    should be placed ahead (upstream) of existing deformer and skin nodes in the shape's histo
    :type frontOfChain: boolean
    :param geometry: (Q E M) The specified object will be added to the list of objects being
    deformed by this deformer object, unless the -rm flag is also specified  When queried
    :type geometry: string
    :param geometryIndices: (Q) Complements the -geometry flag in query mode  Returns the multi
    index of each geometry
    :type geometryIndices: boolean
    :param ignoreSelected: (C) Tells the command to not deform objects on the current selection
    list
    :type ignoreSelected: boolean
    :param includeHiddenSelections: (C) Apply the deformer to any visible and hidden objects in
    the selection list  Default is false
    :type includeHiddenSelections: boolean
    :param name: (C) Used to specify the name of the node being created
    :type name: string
    :param offset: (C) Set the offset of texture deformer  Offset plus a translation on the
    final deformed vertices
    :type offset: float
    :param parallel: (C E) Inserts the new deformer in a parallel chain to any existing
    deformers in the history of the object  A blendShape is inserted to blend the parallel r
    :type parallel: boolean
    :param pointSpace: (C) Set the point space of texture deformer  It can only handle three
    strings: "World", "Local" and "UV"  "World" map world space to color space  "Local"
    :type pointSpace: string
    :param prune: (E) Removes any points not being deformed by the deformer in its current
    configuration from the deformer set
    :type prune: boolean
    :param remove: (E M) Specifies that objects listed after the -g flag should be removed from
    this deformer
    :type remove: boolean
    :param split: (C E) Branches off a new chain in the dependency graph instead of
    inserting/appending the deformer into/onto an existing chain  Works in create mode (and e
    :type split: boolean
    :param strength: (C) Set the strength of texture deformer  Strength determines how strong
    the object is deformed
    :type strength: float
    :param vectorOffset: (C) Set the vector offset of texture deformer  Vector offset indicates
    the offset of the deformation on the vector mode
    :type vectorOffset: [float, float, float]
    :param vectorSpace: (C) Set the vector space of texture deformer  It can only handle three
    strings: "Object", "World" and "Tangent"  "Object" use color vector in object spac
    :type vectorSpace: string
    :param vectorStrength: (C) Set the vector strength of texture deformer  Vector strength
    determines how strong the object is deformed on the vector mode
    :type vectorStrength: [float, float, float]
    
    :returns: Texture deformer node name
    :rtype: string
    """
    pass


def CreateHairOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SwapBlendShapeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgCreateIgSplineEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyDelVertex(*args, caching=True, constructionHistory=True, name="", nodeState=0, q=True,
                  query=True, e=True, edit=True, **kwargs):
    """
    Deletes vertices  Joins two edges which have a common vertex  The vertices must be
    connected to exactly two edges (so-called "winged")
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def NodeEditorDeleteNodes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def subdEditUV(*args, angle=0.0, pivotU=0.0, pivotV=0.0, relative=True, rotateRatio=1.0,
               rotation=True, scale=True, scaleU=0.0, scaleV=0.0, uValue=0.0, uvSetName="",
               vValue=0.0, q=True, query=True, **kwargs):
    """
    Command edits uvs on subdivision surfaces  When used with the query flag, it returns the uv
    values associated with the specified components
    
    :param angle: (C Q) Specifies the angle value (in degrees) that the uv values are to be
    rotated by
    :type angle: float
    :param pivotU: (C Q) Specifies the pivot value, in the u direction, about which the scale
    or rotate is to be performed
    :type pivotU: float
    :param pivotV: (C Q) Specifies the pivot value, in the v direction, about which the scale
    or rotate is to be performed
    :type pivotV: float
    :param relative: (C Q) Specifies whether this command is editing the values relative to the
    currently existing values  Default is true;
    :type relative: boolean
    :param rotateRatio: (C Q) Specifies the ratio value that the uv values are to be rotated by
    Default is 1.0
    :type rotateRatio: float
    :param rotation: (C Q) Specifies whether this command is editing the values with rotation
    values
    :type rotation: boolean
    :param scale: (C Q) Specifies whether this command is editing the values with scale values
    :type scale: boolean
    :param scaleU: (C Q) Specifies the scale value in the u direction
    :type scaleU: float
    :param scaleV: (C Q) Specifies the scale value in the v direction
    :type scaleV: float
    :param uValue: (C Q) Specifies the value, in the u direction - absolute if relative flag is
    false.
    :type uValue: float
    :param uvSetName: (C Q) Specifies the name of the uv set to edit uvs on  If not specified
    will use the current uv set if it exists
    :type uvSetName: string
    :param vValue: (C Q) Specifies the value, in the v direction - absolute if relative flag is
    false.
    :type vValue: float
    
    :returns: Success or Failure.
    :rtype: boolean
    """
    pass


def OutlinerToggleTimeEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def timerX(*args, startTime=0.0, **kwargs):
    """
    Used to calculate elapsed time  This command returns sub-second accurate time values  It is
    useful from scripts for timing the length of operations  Call this command before and after
    the operation you wish to time  On the first call, do not use any flags  It will return the
    start time  Save this value  After the operation, call this command a seco
    
    :param startTime: (C) When this flag is used, the command returns the elapsed time since
    the specified start time
    :type startTime: float
    
    :returns: This command returns a different value depending on
    the flag used. If no flag is
    used, then the start time
    is returned. If the "-st" flag is used, then it returns
    the
    elapsed time since the start time.
    :rtype: float
    """
    pass


def pointLight(*args, decayRate=0, discRadius=0.0, exclusive=True, intensity=0.0, name="",
               position=None, rgb=None, rotation=None, shadowColor=None, shadowDither=0.0,
               shadowSamples=0, softShadow=True, useRayTraceShadows=True, q=True, query=True,
               e=True, edit=True, **kwargs):
    """
    The pointLight command is used to edit the parameters of existing pointLights, or to create
    new ones  The default behaviour is to create a new pointlight
    
    :param decayRate: (C Q E) decay rate of the light (0-no decay, 1-slow, 2-realistic,
    3-fast)
    :type decayRate: int
    :param discRadius: (C Q E) radius of the disc around the light
    :type discRadius: float
    :param exclusive: (C Q E) This flag is obsolete
    :type exclusive: boolean
    :param intensity: (C Q E) intensity of the light (expressed as a percentage)
    :type intensity: float
    :param name: (C Q E) specify the name of the light
    :type name: string
    :param position: (C Q E) This flag is obsolete
    :type position: [float, float, float]
    :param rgb: (C Q E) color of the light (0-1)
    :type rgb: [float, float, float]
    :param rotation: (C Q E) This flag is obsolete
    :type rotation: [float, float, float]
    :param shadowColor: (C Q E) the shadow color
    :type shadowColor: [float, float, float]
    :param shadowDither: (C Q E) dither the shadow
    :type shadowDither: float
    :param shadowSamples: (C Q E) number of shadow samples
    :type shadowSamples: int
    :param softShadow: (C Q E) soft shadow
    :type softShadow: boolean
    :param useRayTraceShadows: (C Q E) ray trace shadows
    :type useRayTraceShadows: boolean
    
    :returns: Light shape name
    :rtype: string
    """
    pass


def polyMergeFacet(*args, caching=True, constructionHistory=True, firstFacet=0, mergeMode=0,
                   name="", nodeState=0, secondFacet=0, q=True, query=True, e=True, edit=True,
                   **kwargs):
    """
    The second face becomes a hole in the first face.
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param firstFacet: (C Q E) The number of the first (outer) face to merge
    :type firstFacet: int
    :param mergeMode: (C Q E) This flag specifies how faces are merged: 0: moves second face to
    first one 1: moves both faces to average 2: moves first face to second one 3, 4, 5:
    :type mergeMode: int
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param secondFacet: (C Q E) The number of the second (hole) face to merge
    :type secondFacet: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def XgPreview(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyBoolOp(*args, faceAreaThreshold=0.0001, operation=0, preserveColor=False,
               useThresholds=False, vertexDistanceThreshold=0.001, caching=True, mergeUVSets=0,
               nodeState=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a new poly as the result of a boolean operation on input polys : union,
    intersection, difference
    
    :param faceAreaThreshold: (C Q E) Area threshold to determine whether faces should be
    collapsed before boolean  Attribute is ignored unless useThresholds is set to true Default:
    0.000
    :type faceAreaThreshold: float
    :param operation: (C Q E) Boolean operation type  1=union, 2=difference, 3=intersection 
    Default type is union  Default: kBoolOpUnion
    :type operation: int
    :param preserveColor: (C Q E) If true, boolean op will compute color for the new mesh  If
    false, the new mesh won't have any color set  Default: false
    :type preserveColor: boolean
    :param useThresholds: (C Q E) If true, merge vertices with separations less then
    vertexDistanceThreshold and collapse faces with areas less then faceAreaThreshold  If false,
    do no
    :type useThresholds: boolean
    :param vertexDistanceThreshold: (C Q E) Tolerance to determine whether vertices (and edges)
    should be merged before boolean operation is applied  Attribute is ignored unless
    useThresholds i
    :type vertexDistanceThreshold: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param mergeUVSets: (C Q E) Specify how UV sets will be merged on the output mesh  0 = "No
    Merge": Each UV set on each mesh will become a new UV set in the output  1 = "Merge By
    :type mergeUVSets: int
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    
    :returns: Object name and node name.
    :rtype: string[]
    """
    pass


def SelectShortestEdgePathTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def LightCentricLightLinkingEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_gridAllTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorCreateIterateCompound(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UVCameraBasedProjection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xformConstraint(*args, alongNormal=0, live=True, type="", q=True, query=True, e=True,
                    edit=True, **kwargs):
    """
    This command allows you to change the transform constraint used by the transform tools
    during component transforms
    
    :param alongNormal: (Q E) When set the transform constraint will first be applied along the
    vertex normals of the components being transformed  When queried, returns the curre
    :type alongNormal: int
    :param live: (Q) Query-only flag that can be used to check whether the current live surface
    will be used as a transform constraint
    :type live: boolean
    :param type: (C Q E) Set the type of transform constraint to use  When queried, returns the
    current transform constraint as a string  none - no constraint surface - const
    :type type: string
    
    :returns: 
    :rtype: None
    """
    pass


def copyKey(*args, animLayer="", animation="keysOrObjects.", attribute="", clipboard="",
            controlPoints=False, float=None, forceIndependentEulerAngles=True, hierarchy="",
            includeUpperBound=True, index=0, option="", shape=True, time=None, **kwargs):
    """
    This command operates on a keyset  A keyset is defined as a group of keys within a
    specified time range on one or more animation curves   The animation curves comprising a
    keyset depend on the value of the "-animation" flag:  keysOrObjects: Any active keys, when
    no target objects or -attribute flags appear on the command line, or All animation curv
    
    :param animLayer: (C) Specifies that the keys getting copied should come from this
    specified animation layer  If no keys on the object exist on this layer, then no keys ar
    :type animLayer: string
    :param animation: (C) Where this command should get the animation to act on  Valid values
    are "objects," "keys," and "keysOrObjects" Default: "keysOrObjects." (See Descrip
    :type animation: string
    :param attribute: (C M) List of attributes to select In query mode, this flag needs a
    value
    :type attribute: string
    :param clipboard: (C) Specifies the clipboard to which animation is copied  Valid
    clipboards are "api" and "anim"  The default clipboard is: anim
    :type clipboard: string
    :param controlPoints: (C) This flag explicitly specifies whether or not to include the
    control points of a shape (see "-s" flag) in the list of attributes  Default: false  (No
    :type controlPoints: boolean
    :param float: (C M) value uniquely representing a non-time-based key (or key range) on a
    time-based animCurve  Valid floatRange include single values (-f 10) or a string
    :type float: floatrange
    :param forceIndependentEulerAngles: (C) Specifies that the rotation curves should always be
    placed on the clipboard as independent Euler Angles  The default value is false
    :type forceIndependentEulerAngles: boolean
    :param hierarchy: (C) Hierarchy expansion options  Valid values are "above," "below," "both,
    " and "none." (Not valid for "pasteKey" cmd.) In query mode, this flag needs a
    :type hierarchy: string
    :param includeUpperBound: (C) When the -t/time or -f/float flags represent a range of keys,
    this flag determines whether the keys at the upper bound of the range are included in t
    :type includeUpperBound: boolean
    :param index: (C M) index of a key on an animCurve In query mode, this flag needs a value
    :type index: int
    :param option: (C) The option to use when performing the copyKey operation  Valid options
    are "keys," and "curve." The default copy option is: keys
    :type option: string
    :param shape: (C) Consider attributes of shapes below transforms as well, except
    "controlPoints"  Default: true  (Not valid for "pasteKey" cmd.) In query mode, this fl
    :type shape: boolean
    :param time: (C M) time uniquely representing a key (or key range) on a time-based
    animCurve  See the code examples below on how to format for a single frame or frame r
    :type time: timerange
    
    :returns: Number of animation curves copied.
    :rtype: int
    """
    pass


def CopySkinWeightsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def vectorize(*args, browserView=True, byFrame=0.0, camera="", combineFillsEdges=True,
              currentFrame=True, curveTolerance=0.0, customExtension="", detailLevel=0,
              edgeColor=None, edgeDetail=True, edgeStyle="", edgeWeight=0.0, endFrame=0.0,
              filenameFormat="", fillStyle="", flashVersion=0, frameRate=0, height=0,
              hiddenEdges=True, highlightLevel=0, highlights=True, imageFormat="", layer=None,
              minEdgeAngle=0.0, outlinesAtIntersections=True, outputFileName="",
              pixelAspectRatio=0.0, reflectionDepth=0, reflections=True, renderLayers=True,
              renderOptimization="", renderView=True, secondaryCurveFitting=True, shadows=True,
              showBackFaces=True, startFrame=0.0, svgAnimation="", svgCompression=True, width=0,
              **kwargs):
    """
    This command renders Maya scenes to various vector and raster formats using the Maya Vector
    renderer
    
    :param browserView: (C) Specifies whether to preview the render in the browser  This option
    is swf only
    :type browserView: boolean
    :param byFrame: (C) Specifies the frame increment
    :type byFrame: float
    :param camera: (C) Specifies the camera to render
    :type camera: string
    :param combineFillsEdges: (C) Specifies whether fills and edges should be combined as a
    single object in Flash  This option is swf only
    :type combineFillsEdges: boolean
    :param currentFrame: (C) Specifies whether to render the current frame only
    :type currentFrame: boolean
    :param curveTolerance: (C) Specifies the curve tolerance  Valid values are in the range:
    0.0 to 15.0  The curve tolerance determines how aggressively the renderer tries to fit
    :type curveTolerance: float
    :param customExtension: (C) Specifies a custom extension to use for the filename  Any
    non-empty string is valid
    :type customExtension: string
    :param detailLevel: (C) Specifies the detail level  Valid values are: 0 to 50  The smaller
    the value, the more polygons may be combined to produce smaller files  A higher va
    :type detailLevel: int
    :param edgeColor: (C) Specifies the red, green, and blue components of the edge color 
    Valid values are: 0 to 255 for each color component
    :type edgeColor: [int, int, int]
    :param edgeDetail: (C) Specifies whether edge detail should be rendered; ie  edges that
    have an angle between the face normals of any two adjacent polygons sharing an edge
    :type edgeDetail: boolean
    :param edgeStyle: (C) Specifies the edge style  Valid values are: "Outline", "EntireMesh",
    "None"
    :type edgeStyle: string
    :param edgeWeight: (C) Specifies the edge weight to be used for all edges in points  There
    are 72 points per inch  A value of 0.0 specifies hairline edge weight
    :type edgeWeight: float
    :param endFrame: (C) Specifies the end frame
    :type endFrame: float
    :param filenameFormat: (C) Specifies the file name format  Valid values are: "name",
    "name.ext", "name.#.ext", "name.ext.#", "name.#", "name#.ext", "name_#.ext"
    :type filenameFormat: string
    :param fillStyle: (C) Specifies the fill style  Valid values are: "SingleColor", "TwoColor",
    "FourColor", "FullColor", "AverageColor", "AreaGradient", "MeshGradient", "Non
    :type fillStyle: string
    :param flashVersion: (C) Specifies the Flash version of the swf output  Valid values are: 3,
    4, 5  This option is swf only
    :type flashVersion: int
    :param frameRate: (C) Specifies the frame rate  This option is for svg and swf only
    :type frameRate: int
    :param height: (C) Specifies the height of the output image in pixels
    :type height: int
    :param hiddenEdges: (C) Specifies whether hidden edges should be rendered; ie  edges that
    have are not visible from the camera
    :type hiddenEdges: boolean
    :param highlightLevel: (C) Specifies the highlight level  Valid values are: 1 to 8  The
    value specifies how many concentric rings will be used to render an object's highlight
    :type highlightLevel: int
    :param highlights: (C) Specifies whether highlights should be rendered  This option has no
    effect for ai, eps, and svg  This option is for the SingleColor, AverageColor, an
    :type highlights: boolean
    :param imageFormat: (C) Specifies the image format to render  Valid values for the Windows
    and Mac platforms are: "swf", "eps", "ai", "svg", "jpg", "iff", "sgi", "tga", "tif
    :type imageFormat: string
    :param layer: (C) Render the specified render layer  Only this render layer will be
    rendered, regardless of the renderable attribute value of the render layer  The lay
    :type layer: name
    :param minEdgeAngle: (C) Specifies the minimum edge angle in degrees  Valid values are: 0.0
    to 90.0  This angle is the minimum angle between adjacent polygon face normals tha
    :type minEdgeAngle: float
    :param outlinesAtIntersections: (C) Specifies if edges should be drawn when two polygons
    intersect  By default this flag is enabled
    :type outlinesAtIntersections: boolean
    :param outputFileName: (C) Specifies the output file name
    :type outputFileName: string
    :param pixelAspectRatio: (C) Specifes the pixel aspect ratio
    :type pixelAspectRatio: float
    :param reflectionDepth: (C) Specifies the reflection depth  Valid values are: 1 to 4  The
    value specifies how many levels of reflection will be applied  This option has no effec
    :type reflectionDepth: int
    :param reflections: (C) Specifies whether reflections should be rendered  This option has
    no effect for ai, eps, and svg
    :type reflections: boolean
    :param renderLayers: (C) Specifies whether render layers should be rendered into separate
    files
    :type renderLayers: boolean
    :param renderOptimization: (C) Specifies the render optimization  Valid values are: "Safe",
    "Good", "Aggressive"  "Safe" will remove redundant geometry  "Good" removes redundant ge
    :type renderOptimization: string
    :param renderView: (C) Specifies whether to display the rendered image to the render view 
    This option is not applicable when batch rendering
    :type renderView: boolean
    :param secondaryCurveFitting: (C) Specifies whether to do secondary curve fitting
    :type secondaryCurveFitting: boolean
    :param shadows: (C) Specifies whether shadows should be rendered  This option has no effect
    for ai, eps, and svg
    :type shadows: boolean
    :param showBackFaces: (C) Specifies whether back faces will should be rendered; ie  faces
    whose normals are pointed away from the camera
    :type showBackFaces: boolean
    :param startFrame: (C) Specifies the start frame
    :type startFrame: float
    :param svgAnimation: (C) Specifies the SVG animation type  Valid values are: "Native",
    "HTMLScript"  This option is SVG only
    :type svgAnimation: string
    :param svgCompression: (C) Specifies whether the SVG output should be compressed  This
    option is svg only
    :type svgCompression: boolean
    :param width: (C) Specifies the width of the output image in pixels
    :type width: int
    
    :returns: 
    :rtype: None
    """
    pass


def NodeEditorGraphDownstream(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ProfilerToolCpuView(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyInfo(*args, edgeToFace=True, edgeToVertex=True, faceNormals=True, faceToEdge=True,
             faceToVertex=True, invalidEdges=True, invalidVertices=True, laminaFaces=True,
             nonManifoldEdges=True, nonManifoldUVEdges=True, nonManifoldUVs=True,
             nonManifoldVertices=True, vertexToEdge=True, vertexToFace=True, **kwargs):
    """
    Command queries topological information on polygonal objects and components  So, the
    command will require the following to be specified: - selection list to query
    
    :param edgeToFace: (C) Returns the faces that share the specified edge  Requires edges to
    be selected
    :type edgeToFace: boolean
    :param edgeToVertex: (C) Returns the vertices defining an edge  Requires edges to be
    selected
    :type edgeToVertex: boolean
    :param faceNormals: (C) Returns face normals of the specified object  If faces are selected
    the command returns the face normals of selected faces  Else it returns the face
    :type faceNormals: boolean
    :param faceToEdge: (C) Returns the edges defining a face  Requires faces to be selected
    :type faceToEdge: boolean
    :param faceToVertex: (C) Returns the vertices defining a face  Requires faces to be
    selected
    :type faceToVertex: boolean
    :param invalidEdges: (C) Find all edges that are not associated with any face in the mesh
    :type invalidEdges: boolean
    :param invalidVertices: (C) Find all vertices that are not associated with any face in the
    mesh
    :type invalidVertices: boolean
    :param laminaFaces: (C) Find all lamina faces in the specified objects
    :type laminaFaces: boolean
    :param nonManifoldEdges: (C) Find all non-manifold edges in the specified objects
    :type nonManifoldEdges: boolean
    :param nonManifoldUVEdges: (C) Find all non-manifold UV edges in the specified objects
    :type nonManifoldUVEdges: boolean
    :param nonManifoldUVs: (C) Find all non-manifold UVs in the specified objects
    :type nonManifoldUVs: boolean
    :param nonManifoldVertices: (C) Find all non-manifold vertices in the specified objects
    :type nonManifoldVertices: boolean
    :param vertexToEdge: (C) Returns the Edges connected to a vertex  Requires vertices to be
    selected
    :type vertexToEdge: boolean
    :param vertexToFace: (C) Returns the faces that share the specified vertex  Requires
    vertices to be selected
    :type vertexToFace: boolean
    
    :returns: Components
    :rtype: string
    """
    pass


def CreatePolygonConeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_selectModeDisableTweakMarquee(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def QualityDisplayMarkingMenuPopDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_moveTweakTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def floatSliderGrp(*args, adjustableColumn=0, adjustableColumn2=0, adjustableColumn3=0,
                   adjustableColumn4=0, adjustableColumn5=0, adjustableColumn6=0, annotation="",
                   backgroundColor=None, changeCommand=None, columnAlign=None,
                   columnAlign2=None, columnAlign3=None, columnAlign4=None, columnAlign5=None,
                   columnAlign6=None, columnAttach=None, columnAttach2=None, columnAttach3=None,
                   columnAttach4=None, columnAttach5=None, columnAttach6=None,
                   columnOffset2=None, columnOffset3=None, columnOffset4=None,
                   columnOffset5=None, columnOffset6=None, columnWidth=None, columnWidth1=0,
                   columnWidth2=None, columnWidth3=None, columnWidth4=None, columnWidth5=None,
                   columnWidth6=None, defineTemplate="", docTag="", dragCallback=None,
                   dragCommand=None, dropCallback=None, enable=True, enableBackground=True,
                   enableKeyboardFocus=True, exists=True, extraLabel="", field=True,
                   fieldMaxValue=0.0, fieldMinValue=0.0, fieldStep=0.0, fullPathName=True,
                   height=0, highlightColor=None, isObscured=True, label="", manage=True,
                   maxValue=0.0, minValue=0.0, noBackground=True, numberOfPopupMenus=True,
                   parent="", popupMenuArray=True, precision=0, preventOverride=True,
                   rowAttach=None, sliderStep=0.0, statusBarMessage="", step=0.0,
                   useTemplate="", value=0.0, visible=True, visibleChangeCommand=None, width=0,
                   q=True, query=True, e=True, edit=True, **kwargs):
    """
    All of the group commands position their individual controls in columns starting at column
    1  The layout of each control (ie  column) can be customized using the -cw/columnWidth,
    -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumn flags  By
    default, columns are left aligned with no offset and are 100 pixels wide  Only o
    
    :param adjustableColumn: (C E) Specifies which column has an adjustable size that changes
    with the sizing of the layout  The column value is a 1-based index  Passing 0 as argument
    :type adjustableColumn: int
    :param adjustableColumn2: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly two columns
    :type adjustableColumn2: int
    :param adjustableColumn3: (C E) Specifies that the column has an adjustable size that
    changes with the size of the parent layout  Ignored if there are not exactly three columns
    :type adjustableColumn3: int
    :param adjustableColumn4: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly four columns
    :type adjustableColumn4: int
    :param adjustableColumn5: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly five columns
    :type adjustableColumn5: int
    :param adjustableColumn6: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly six columns
    :type adjustableColumn6: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Command string executed when the value of the slider changes 
    It will be executed only once after a drag of the slider
    :type changeCommand: script
    :param columnAlign: (C E M) Arguments are : column number, alignment type  Possible
    alignments are: left | right | center  Specifies alignment type for the specified column
    :type columnAlign: [int, string]
    :param columnAlign2: (C E) Sets the text alignment of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "center"
    :type columnAlign2: [string, string]
    :param columnAlign3: (C E) Sets the text alignment for all three columns  Ignored if there
    are not exactly three columns  Valid values are "left", "right", and "center"
    :type columnAlign3: [string, string, string]
    :param columnAlign4: (C E) Sets the text alignment for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "center"
    :type columnAlign4: [string, string, string, string]
    :param columnAlign5: (C E) Sets the text alignment for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "center"
    :type columnAlign5: [string, string, string, string, string]
    :param columnAlign6: (C E) Sets the text alignment for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "center"
    :type columnAlign6: [string, string, string, string, string, string]
    :param columnAttach: (C E M) Arguments are : column number, attachment type, and offset 
    Possible attachments are: left | right | both  Specifies column attachment types and offe
    :type columnAttach: [int, string, int]
    :param columnAttach2: (C E) Sets the attachment type of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "both"
    :type columnAttach2: [string, string]
    :param columnAttach3: (C E) Sets the attachment type for all three columns  Ignored if
    there are not exactly three columns  Valid values are "left", "right", and "both"
    :type columnAttach3: [string, string, string]
    :param columnAttach4: (C E) Sets the attachment type for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "both"
    :type columnAttach4: [string, string, string, string]
    :param columnAttach5: (C E) Sets the attachment type for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "both"
    :type columnAttach5: [string, string, string, string, string]
    :param columnAttach6: (C E) Sets the attachment type for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "both"
    :type columnAttach6: [string, string, string, string, string, string]
    :param columnOffset2: (C E) This flag is used in conjunction with the -columnAttach2 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the tw
    :type columnOffset2: [int, int]
    :param columnOffset3: (C E) This flag is used in conjunction with the -columnAttach3 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the th
    :type columnOffset3: [int, int, int]
    :param columnOffset4: (C E) This flag is used in conjunction with the -columnAttach4 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fo
    :type columnOffset4: [int, int, int, int]
    :param columnOffset5: (C E) This flag is used in conjunction with the -columnAttach5 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fi
    :type columnOffset5: [int, int, int, int, int]
    :param columnOffset6: (C E) This flag is used in conjunction with the -columnAttach6 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the si
    :type columnOffset6: [int, int, int, int, int, int]
    :param columnWidth: (C E M) Arguments are : column number, column width  Sets the width of
    the specified column where the first parameter specifies the column (1 based index) an
    :type columnWidth: [int, int]
    :param columnWidth1: (C E) Sets the width of the first column  Ignored if there is not
    exactly one column
    :type columnWidth1: int
    :param columnWidth2: (C E) Sets the column widths of both columns  Ignored if there are not
    exactly two columns
    :type columnWidth2: [int, int]
    :param columnWidth3: (C E) Sets the column widths for all 3 columns  Ignored if there are
    not exactly 3 columns
    :type columnWidth3: [int, int, int]
    :param columnWidth4: (C E) Sets the column widths for all 4 columns  Ignored if there are
    not exactly 4 columns
    :type columnWidth4: [int, int, int, int]
    :param columnWidth5: (C E) Sets the column widths for all 5 columns  Ignored if there are
    not exactly 5 columns
    :type columnWidth5: [int, int, int, int, int]
    :param columnWidth6: (C E) Sets the column widths for all 6 columns  Ignored if there are
    not exactly 6 columns
    :type columnWidth6: [int, int, int, int, int, int]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dragCommand: (C E) Command string executed repeatedly during a drag of the slider
    :type dragCommand: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param extraLabel: (C Q E) If present on creation this specifies that there will be an
    extra label appearing after the slider  Sets the string to be the text for the extra labe
    :type extraLabel: string
    :param field: (C) Indicates whether the group will have an editable float field present
    that reflects the value of the slider
    :type field: boolean
    :param fieldMaxValue: (C Q E) Maximum value that may be entered in the field  This value
    may be set to any value greater than the -max/maxValue flag  By default, it is equal to th
    :type fieldMaxValue: float
    :param fieldMinValue: (C Q E) Minimum value that may be entered in the field  This value
    may be set to any value less than the -min/minValue flag  By default, it is equal to the -
    :type fieldMinValue: float
    :param fieldStep: (C Q E) Increment for the field
    :type fieldStep: float
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) If present on creation the group will have static text
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param maxValue: (C Q E) Maximum value for both the slider and the field
    :type maxValue: float
    :param minValue: (C Q E) Minimum value for both the slider and the field
    :type minValue: float
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param precision: (C E) Number of digits to the right of the decimal
    :type precision: int
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rowAttach: (C E M) Arguments are : column, attachment type, offset  Possible
    attachments are: top | bottom | both  Specifies attachment types and offsets for the
    entire
    :type rowAttach: [int, string, int]
    :param sliderStep: (C Q E) The slider step value represents the amount the value will
    increase or decrease when you click either side of the slider
    :type sliderStep: float
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param step: (C Q E) Increment for both the slider and field
    :type step: float
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param value: (C Q E) Value of the group
    :type value: float
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name of the control.
    :rtype: string
    """
    pass


def ScaleKeys(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSplineSelectReplaceBySelectedFaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PinSelection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PerspGraphOutlinerLayout(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def toolHasOptions(*args, **kwargs):
    """
    This command queries a tool to see if it has options  If it does, it returns true 
    Otherwise it returns false
    
    
    :returns: True if the queried tool has options, otherwise false.
    :rtype: boolean
    """
    pass


def CreateIllustratorCurves(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UVPlanarProjectionOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DoUnghost(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddOceanPreviewPlane(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BreakLightLinks(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateContainerOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateClusterOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def deleteGeometryCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PartialCreaseSubdivSurface(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetBifrostInitialState(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TangentsClamped(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_extrudeTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RemoveWire(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_curveSnapPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OneClickAcknowledge(*args, **kwargs):
    """
    
    """
    pass


def PreInfinityCycleOffset(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AveragePolygonNormals(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmBindPatches(*args, **kwargs):
    """
    
    """
    pass


def TogglePaintAtDepth(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreatePond(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def bevelPlus(*args, bevelInside=False, capSides=4, constructionHistory=True, innerStyle=0,
              joinSurfaces=True, name="", normalsOutwards=True, numberOfSides=4, outerStyle=0,
              polygon=0, range=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The bevelPlus command creates a new bevel surface for the specified curves using a given
    style curve  The first curve should be the "outside" curve, and the (optional) rest of them
    should be inside of the first one  For predictable results, the curves should be planar and
    all in the same plane
    
    :param bevelInside: (C Q E) If true, ensure surface always remains within the original
    profile curve Default: false
    :type bevelInside: boolean
    :param capSides: (C Q) How to cap the bevel  1 - no caps 2 - cap at start only 3 - cap at
    end only 4 - cap at start and end Default:4
    :type capSides: int
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param innerStyle: (C Q E) Similar to outerStyle, this style is applied to all but the
    first (outer) curve specified
    :type innerStyle: int
    :param joinSurfaces: (C Q E) Attach bevelled surfaces into one surface for each input curve
     Default:true
    :type joinSurfaces: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param normalsOutwards: (C Q E) If enabled, the normals point outwards on the resulting
    NURBS or poly surface
    :type normalsOutwards: boolean
    :param numberOfSides: (C Q E) How to apply the bevel  1 - no bevels 2 - bevel at start only
    3 - bevel at end only 4 - bevel at start and end Default: 4
    :type numberOfSides: int
    :param outerStyle: (C Q E) Choose a style to use for the bevel of the first (outer) curve 
    There are 15 predefined styles (values 0 to 14 can be used to select them)  For those
    :type outerStyle: int
    :param polygon: (C) The value of this argument controls the type of the object created by
    this operation 0: nurbs surface 1: polygon (use nurbsToPolygonsPref to set the
    :type polygon: int
    :param range: (C) Force a curve range on complete input curve
    :type range: boolean
    
    :returns: Object name(s) and node name
    :rtype: string[]
    """
    pass


def BatchRenderOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def adskAssetListUI(*args, **kwargs):
    """
    
    """
    pass


def RemoveFromContainerOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ScaleConstraintOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def iconTextStaticLabel(*args, align="", annotation="", backgroundColor=None, defineTemplate="",
                        disabledImage="", docTag="", dragCallback=None, dropCallback=None,
                        enable=True, enableBackground=True, enableKeyboardFocus=True,
                        exists=True, flipX=True, flipY=True, font="", fullPathName=True,
                        height=0, highlightColor=None, image="", image1="", image2="",
                        image3="", imageOverlayLabel="", isObscured=True, label="",
                        labelOffset=0, ltVersion="", manage=True, marginHeight=0, marginWidth=0,
                        noBackground=True, numberOfPopupMenus=True, overlayLabelBackColor=None,
                        overlayLabelColor=None, parent="", popupMenuArray=True,
                        preventOverride=True, rotation=0.0, statusBarMessage="", style="",
                        useAlpha=True, useTemplate="", version="", visible=True,
                        visibleChangeCommand=None, width=0, q=True, query=True, e=True,
                        edit=True, **kwargs):
    """
    This control supports up to 3 icon images and 4 different display styles  The icon image
    displayed is the one that best fits the current size of the control given its current style
      This command creates an iconTextStaticLabel
    
    :param align: (C Q E) The label alignment  Alignment values are "left", "right", and
    "center"  By default, the label is aligned "center"  Currently only available when -st
    :type align: string
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param disabledImage: (C Q E) Image used when the button is disabled  Image size must be
    the same as the image specified with the i/image flag  This is a Windows only flag
    :type disabledImage: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param flipX: (C Q E) Is the image flipped horizontally?
    :type flipX: boolean
    :param flipY: (C Q E) Is the image flipped vertically?
    :type flipY: boolean
    :param font: (C Q E) The font for the text  Valid values are "boldLabelFont",
    "smallBoldLabelFont", "tinyBoldLabelFont", "plainLabelFont", "smallPlainLabelFont",
    "oblique
    :type font: string
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param image: (C Q E) If you are not providing images with different sizes then you may use
    this flag for the control's image  If the "iconOnly" style is set, the icon wil
    :type image: string
    :param image1: (C Q E) First of three possible icons  The icon that best fits the current
    size of the control will be displayed
    :type image1: string
    :param image2: (C Q E) Second of three possible icons  The icon that best fits the current
    size of the control will be displayed
    :type image2: string
    :param image3: (C Q E) Third of three possible icons  The icon that best fits the current
    size of the control will be displayed
    :type image3: string
    :param imageOverlayLabel: (C Q E) A short string, up to 6 characters, representing a label
    that will be displayed on top of the image
    :type imageOverlayLabel: string
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) The text that appears in the control
    :type label: string
    :param labelOffset: (C Q E) The label offset  Default is 0  Currently only available when
    -st/style is set to "iconAndTextCentered"
    :type labelOffset: int
    :param ltVersion: (C Q E) This flag is used to specify the Maya LT version that this
    control feature was introduced, if the version flag is not specified, or if the version fl
    :type ltVersion: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param marginHeight: (C Q E) The number of pixels above and below the control content  The
    default value is 1 pixel
    :type marginHeight: int
    :param marginWidth: (C Q E) The number of pixels on either side of the control content  The
    default value is 1 pixel
    :type marginWidth: int
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param overlayLabelBackColor: (C Q E) The RGBA color of the shadow behind the label defined
    by imageOverlayLabel  Default is 50% transparent black: 0 0 0 .5
    :type overlayLabelBackColor: [float, float, float, float]
    :param overlayLabelColor: (C Q E) The RGB color of the label defined by imageOverlayLabel 
    Default is a light grey: .8 .8 .8
    :type overlayLabelColor: [float, float, float]
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rotation: (C Q E) The rotation value of the image in radians
    :type rotation: float
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param style: (C Q E) The draw style of the control  Valid styles are "iconOnly",
    "textOnly", "iconAndTextHorizontal", "iconAndTextVertical", and "iconAndTextCentered"  (N
    :type style: string
    :param useAlpha: (C Q E) Is the image using alpha channel?
    :type useAlpha: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param version: (C Q E) Specify the version that this control feature was introduced  The
    argument should be given as a string of the version number (e.g  "2013", "2014")  C
    :type version: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the iconTextStaticLabel created.
    :rtype: string
    """
    pass


def renderSetup(*args, **kwargs):
    """
    
    """
    pass


def HypershadeGraphClearGraph(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSetSmoothBrushTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OutTangentLinear(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def EnterEditModeRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideCameraManipulators(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def cmdShell(*args, annotation="", backgroundColor=None, clear=True, command="",
             defineTemplate="", docTag="", dragCallback=None, dropCallback=None, enable=True,
             enableBackground=True, enableKeyboardFocus=True, exists=True, fullPathName=True,
             height=0, highlightColor=None, isObscured=True, manage=True, noBackground=True,
             numberOfHistoryLines=0, numberOfPopupMenus=True, numberOfSavedLines=0, parent="",
             popupMenuArray=True, preventOverride=True, prompt="", statusBarMessage="",
             useTemplate="", visible=True, visibleChangeCommand=None, width=0, q=True,
             query=True, e=True, edit=True, **kwargs):
    """
    This command creates a scrolling field that behaves similar to a unix shell for entering
    user input  You may specify the number of lines that will be remembered by the field with
    the -nsl/numberOfSavedLines flag  The default number of lines saved is 100  The shellField
    also maintains a command history buffer  You can specify the number of input lin
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param clear: (C) Erases all visible text, and also deletes any text that had scrolled of
    the top of the field  After clearing the field it will be blank, and you will
    :type clear: boolean
    :param command: (C Q E) Command executed when the contents change
    :type command: string
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfHistoryLines: (C Q E) The number of input lines to be saved in the command
    history buffer  You can cycle through this buffer by pressing the up and down arrow keys 
    Valid
    :type numberOfHistoryLines: int
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param numberOfSavedLines: (C Q E) The total number of lines (the scrolled lines and
    currently visible lines) that will be remembered by the field  Any lines beyond this number
    will be
    :type numberOfSavedLines: int
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param prompt: (C Q E) The text that is used as a prompt
    :type prompt: string
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def RandomizeFolliclesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddTargetShapeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OpenScene(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def duplicate(*args, inputConnections=True, instanceLeaf=True, name="", parentOnly=True,
              renameChildren=True, returnRootsOnly=True, smartTransform=True,
              transformsOnly=True, upstreamNodes=True, **kwargs):
    """
    This command duplicates the given objects  If no objects are given, then the selected list
    is duplicated   The smart transform feature allows duplicate to transform newly duplicated
    objects based on previous transformations between duplications   Example: Duplicate an
    object and move it to a new location  Duplicate it again with the smart duplicate
    
    :param inputConnections: (C) Input connections to the node to be duplicated, are also
    duplicated  This would result in a fan-out scenario as the nodes at the input side are not
    d
    :type inputConnections: boolean
    :param instanceLeaf: (C) instead of duplicating leaf DAG nodes, instance them
    :type instanceLeaf: boolean
    :param name: (C) name to give duplicated object(s)
    :type name: string
    :param parentOnly: (C) Duplicate only the specified DAG node and not any of its children
    :type parentOnly: boolean
    :param renameChildren: (C) rename the child nodes of the hierarchy, to make them unique
    :type renameChildren: boolean
    :param returnRootsOnly: (C) return only the root nodes of the new hierarchy  When used with
    upstreamNodes flag, the upstream nodes will be omitted in the result  This flag contr
    :type returnRootsOnly: boolean
    :param smartTransform: (C) remembers last transformation and applies it to duplicated
    object(s)
    :type smartTransform: boolean
    :param transformsOnly: (C) Duplicate only transform nodes and not any shapes
    :type transformsOnly: boolean
    :param upstreamNodes: (C) the upstream nodes leading upto the selected nodes (along with
    their connections) are also duplicated
    :type upstreamNodes: boolean
    
    :returns: : names of the objects created
    :rtype: string[]
    """
    pass


def WarpImageOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectAllRigidConstraints(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSplineCacheReplace(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def StitchEdgesToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def allNodeTypes(*args, includeAbstract=True, **kwargs):
    """
    This command returns a list containing the type names of every kind of creatable node
    registered with the system  Note that some node types are abstract and cannot be created 
    These will not show up on this list  (e.g  transform and polyShape both inherit from
    dagObject, but dagObject cannot be created directly so it will not appear on this list.)
    
    :param includeAbstract: (C) Show every node type, even the abstract ones which cannot be
    created via the 'createNode' command  These will have the suffix "(abstract)" appended t
    :type includeAbstract: boolean
    
    :returns: List of node types
    :rtype: string[]
    """
    pass


def dR_targetWeldPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GoalOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nurbsUVSet(*args, create=True, useExplicit=True, q=True, query=True, e=True, edit=True,
               **kwargs):
    """
    Allows user to toggle between implicit and explicit UVs on a NURBS object  Also provides a
    facility to create, delete, rename and set the current explicit UVSet  An implicit UVSet is
    non-editable  It uses the parametric make-up of the NURBS object to determine the location
    of UVs (isoparm intersections)  NURBS objects also support explicit UVSets w
    
    :param create: (C Q E) Creates an explicit UV set on the specified surface  If the surface
    already has an explicit UV set this flag will do nothing  Use the -ue/useExplicit
    :type create: boolean
    :param useExplicit: (C Q E) Toggles the usage of explicit/implicit UVs  When true, explicit
    UVs will be used, otherwise the object will use implicit UVs
    :type useExplicit: boolean
    
    :returns: Success or Failure.
    :rtype: boolean
    """
    pass


def NodeEditorRedockTornOffTab(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectAllLights(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateEmitter(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyPipe(*args, axis=None, caching=True, constructionHistory=True, createUVs=True,
             height=2.0, name="", nodeState=0, object=True, radius=1.0, roundCap=False,
             subdivisionsAxis=20, subdivisionsCaps=1, subdivisionsHeight=1, texture=True,
             thickness=0.5, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The polyPipe command creates a new polygonal pipe
    
    :param axis: (C Q E) This flag specifies the primitive axis used to build the pipe  Q: When
    queried, this flag returns a float[3]
    :type axis: [float, float, float]
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param createUVs: (C Q E) Create UVs or not  Default: true
    :type createUVs: boolean
    :param height: (C Q E) Height of the pipe  Default: 2.0
    :type height: float
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param object: (C) Create the result, or just the dependency node (where applicable)
    :type object: boolean
    :param radius: (C Q E) Radius of the pipe  Default: 1.0
    :type radius: float
    :param roundCap: (C Q E) To indicate whether we need a round cap Default: false
    :type roundCap: boolean
    :param subdivisionsAxis: (C Q E) Subdivisions around the axis  Default: 20
    :type subdivisionsAxis: int
    :param subdivisionsCaps: (C Q E) Subdivisions along the thickness caps  Default: 1
    :type subdivisionsCaps: int
    :param subdivisionsHeight: (C Q E) Subdivisions along the height  Default: 1
    :type subdivisionsHeight: int
    :param texture: (C Q E) Apply texture or not  this is an old attribute  This is unsupported
    and would be removed in a future release  Default: true
    :type texture: boolean
    :param thickness: (C Q E) Thickness of the pipe  Default: 0.5
    :type thickness: float
    
    :returns: Object name and node name.
    :rtype: string[]
    """
    pass


def CombinePolygons(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_moveRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddKeysToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def duplicateSurface(*args, caching=True, constructionHistory=True, faceCountU=1, faceCountV=1,
                     firstFaceU=0, firstFaceV=0, local=True, mergeItems=True, name="",
                     nodeState=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The duplicateSurface command takes a surface patch (face) and and returns the 3D surface 
    Connected patches are returned as a single surface
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param faceCountU: (C Q E) Number of faces in U direction Default: 1
    :type faceCountU: int
    :param faceCountV: (C Q E) Number of faces in V direction Default: 1
    :type faceCountV: int
    :param firstFaceU: (C Q E) First face (U direction index) Default: 0
    :type firstFaceU: int
    :param firstFaceV: (C Q E) First face (V direction index) Default: 0
    :type firstFaceV: int
    :param local: (C) Copy the transform of the surface and connect to the local space version
    instead
    :type local: boolean
    :param mergeItems: (C) Merge component results where possible  For example, instead of
    returning a[1] and a[2], return a[1:2]
    :type mergeItems: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def CreatePolygonCubeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def IntersectCurve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nClothDeleteHistory(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SewUVs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectUVOverlappingComponentsPerObject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleAnimationDetails(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorUnmuteAllTracks(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def WireDropoffLocator(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXResetImport(*args, **kwargs):
    """
    
    """
    pass


def GhostObject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorPickWalkUp(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def colorInputWidgetGrp(*args, adjustableColumn=0, adjustableColumn2=0, adjustableColumn3=0,
                        adjustableColumn4=0, adjustableColumn5=0, adjustableColumn6=0,
                        annotation="", backgroundColor=None, changeCommand=None,
                        columnAlign=None, columnAlign2=None, columnAlign3=None,
                        columnAlign4=None, columnAlign5=None, columnAlign6=None,
                        columnAttach=None, columnAttach2=None, columnAttach3=None,
                        columnAttach4=None, columnAttach5=None, columnAttach6=None,
                        columnOffset2=None, columnOffset3=None, columnOffset4=None,
                        columnOffset5=None, columnOffset6=None, columnWidth=None,
                        columnWidth1=0, columnWidth2=None, columnWidth3=None, columnWidth4=None,
                        columnWidth5=None, columnWidth6=None, defineTemplate="", docTag="",
                        dragCallback=None, dropCallback=None, enable=True,
                        enableBackground=True, enableKeyboardFocus=True, exists=True,
                        forceDragRefresh=True, fullPathName=True, height=0, highlightColor=None,
                        hsvValue=None, isObscured=True, label="", manage=True,
                        noBackground=True, numberOfPopupMenus=True, parent="",
                        popupMenuArray=True, preventOverride=True, rgbValue=None,
                        rowAttach=None, statusBarMessage="", useTemplate="", visible=True,
                        visibleChangeCommand=None, width=0, q=True, query=True, e=True,
                        edit=True, **kwargs):
    """
    All of the group commands position their individual controls in columns starting at column
    1  The layout of each control (ie  column) can be customized using the -cw/columnWidth,
    -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumn flags  By
    default, columns are left aligned with no offset and are 100 pixels wide  Only o
    
    :param adjustableColumn: (C E) Specifies which column has an adjustable size that changes
    with the sizing of the layout  The column value is a 1-based index  Passing 0 as argument
    :type adjustableColumn: int
    :param adjustableColumn2: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly two columns
    :type adjustableColumn2: int
    :param adjustableColumn3: (C E) Specifies that the column has an adjustable size that
    changes with the size of the parent layout  Ignored if there are not exactly three columns
    :type adjustableColumn3: int
    :param adjustableColumn4: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly four columns
    :type adjustableColumn4: int
    :param adjustableColumn5: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly five columns
    :type adjustableColumn5: int
    :param adjustableColumn6: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly six columns
    :type adjustableColumn6: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Command string executed when slider value changes
    :type changeCommand: script
    :param columnAlign: (C E M) Arguments are : column number, alignment type  Possible
    alignments are: left | right | center  Specifies alignment type for the specified column
    :type columnAlign: [int, string]
    :param columnAlign2: (C E) Sets the text alignment of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "center"
    :type columnAlign2: [string, string]
    :param columnAlign3: (C E) Sets the text alignment for all three columns  Ignored if there
    are not exactly three columns  Valid values are "left", "right", and "center"
    :type columnAlign3: [string, string, string]
    :param columnAlign4: (C E) Sets the text alignment for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "center"
    :type columnAlign4: [string, string, string, string]
    :param columnAlign5: (C E) Sets the text alignment for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "center"
    :type columnAlign5: [string, string, string, string, string]
    :param columnAlign6: (C E) Sets the text alignment for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "center"
    :type columnAlign6: [string, string, string, string, string, string]
    :param columnAttach: (C E M) Arguments are : column number, attachment type, and offset 
    Possible attachments are: left | right | both  Specifies column attachment types and offe
    :type columnAttach: [int, string, int]
    :param columnAttach2: (C E) Sets the attachment type of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "both"
    :type columnAttach2: [string, string]
    :param columnAttach3: (C E) Sets the attachment type for all three columns  Ignored if
    there are not exactly three columns  Valid values are "left", "right", and "both"
    :type columnAttach3: [string, string, string]
    :param columnAttach4: (C E) Sets the attachment type for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "both"
    :type columnAttach4: [string, string, string, string]
    :param columnAttach5: (C E) Sets the attachment type for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "both"
    :type columnAttach5: [string, string, string, string, string]
    :param columnAttach6: (C E) Sets the attachment type for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "both"
    :type columnAttach6: [string, string, string, string, string, string]
    :param columnOffset2: (C E) This flag is used in conjunction with the -columnAttach2 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the tw
    :type columnOffset2: [int, int]
    :param columnOffset3: (C E) This flag is used in conjunction with the -columnAttach3 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the th
    :type columnOffset3: [int, int, int]
    :param columnOffset4: (C E) This flag is used in conjunction with the -columnAttach4 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fo
    :type columnOffset4: [int, int, int, int]
    :param columnOffset5: (C E) This flag is used in conjunction with the -columnAttach5 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fi
    :type columnOffset5: [int, int, int, int, int]
    :param columnOffset6: (C E) This flag is used in conjunction with the -columnAttach6 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the si
    :type columnOffset6: [int, int, int, int, int, int]
    :param columnWidth: (C E M) Arguments are : column number, column width  Sets the width of
    the specified column where the first parameter specifies the column (1 based index) an
    :type columnWidth: [int, int]
    :param columnWidth1: (C E) Sets the width of the first column  Ignored if there is not
    exactly one column
    :type columnWidth1: int
    :param columnWidth2: (C E) Sets the column widths of both columns  Ignored if there are not
    exactly two columns
    :type columnWidth2: [int, int]
    :param columnWidth3: (C E) Sets the column widths for all 3 columns  Ignored if there are
    not exactly 3 columns
    :type columnWidth3: [int, int, int]
    :param columnWidth4: (C E) Sets the column widths for all 4 columns  Ignored if there are
    not exactly 4 columns
    :type columnWidth4: [int, int, int, int]
    :param columnWidth5: (C E) Sets the column widths for all 5 columns  Ignored if there are
    not exactly 5 columns
    :type columnWidth5: [int, int, int, int, int]
    :param columnWidth6: (C E) Sets the column widths for all 6 columns  Ignored if there are
    not exactly 6 columns
    :type columnWidth6: [int, int, int, int, int, int]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param forceDragRefresh: (C) If used then force refresh on drag
    :type forceDragRefresh: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param hsvValue: (C Q E) Color in hue, saturation, and value format
    :type hsvValue: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) Label text for the group
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rgbValue: (C Q E) Color in red, green, and blue format
    :type rgbValue: [float, float, float]
    :param rowAttach: (C E M) Arguments are : column, attachment type, offset  Possible
    attachments are: top | bottom | both  Specifies attachment types and offsets for the
    entire
    :type rowAttach: [int, string, int]
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: (the name of the created group)
    :rtype: string
    """
    pass


def scaleComponents(*args, pivot=None, rotation=None, **kwargs):
    """
    This is a limited version of the scale command  First, it only works on selected components
     You provide a pivot in world space, and you can provide a rotation  This rotation affects
    the scaling, so that rather than scaling in X, Y, Z, this is scaling in X, Y, and Z after
    they have been rotated by the given rotation   This allows selected component
    
    :param pivot: (C) The pivot position in world space (default is origin)
    :type pivot: [float, float, float]
    :param rotation: (C) The rotational offset for the scaling (default is none)
    :type rotation: [float, float, float]
    
    :returns: 
    :rtype: None
    """
    pass


def RemoveBlendShape(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ThreeBottomSplitViewArrangement(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def attrFieldGrp(*args, adjustableColumn=0, adjustableColumn2=0, adjustableColumn3=0,
                 adjustableColumn4=0, adjustableColumn5=0, adjustableColumn6=0, annotation="",
                 attribute="", backgroundColor=None, changeCommand=None, columnAlign=None,
                 columnAlign2=None, columnAlign3=None, columnAlign4=None, columnAlign5=None,
                 columnAlign6=None, columnAttach=None, columnAttach2=None, columnAttach3=None,
                 columnAttach4=None, columnAttach5=None, columnAttach6=None, columnOffset2=None,
                 columnOffset3=None, columnOffset4=None, columnOffset5=None, columnOffset6=None,
                 columnWidth=None, columnWidth1=0, columnWidth2=None, columnWidth3=None,
                 columnWidth4=None, columnWidth5=None, columnWidth6=None, defineTemplate="",
                 docTag="", dragCallback=None, dropCallback=None, enable=True,
                 enableBackground=True, enableKeyboardFocus=True, exists=True, extraButton=True,
                 extraButtonCommand=None, extraButtonIcon="", extraLabel="",
                 forceAddMapButton=True, fullPathName=True, height=0, hideMapButton=True,
                 highlightColor=None, isObscured=True, label="", manage=True, maxValue=0.0,
                 minValue=0.0, noBackground=True, numberOfFields=0, numberOfPopupMenus=True,
                 parent="", popupMenuArray=True, precision=0, preventOverride=True,
                 rowAttach=None, statusBarMessage="", step=0.0, useTemplate="", visible=True,
                 visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
                 **kwargs):
    """
    All of the group commands position their individual controls in columns starting at column
    1  The layout of each control (ie  column) can be customized using the -cw/columnWidth,
    -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumn flags  By
    default, columns are left aligned with no offset and are 100 pixels wide  Only o
    
    :param adjustableColumn: (C E) Specifies which column has an adjustable size that changes
    with the sizing of the layout  The column value is a 1-based index  Passing 0 as argument
    :type adjustableColumn: int
    :param adjustableColumn2: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly two columns
    :type adjustableColumn2: int
    :param adjustableColumn3: (C E) Specifies that the column has an adjustable size that
    changes with the size of the parent layout  Ignored if there are not exactly three columns
    :type adjustableColumn3: int
    :param adjustableColumn4: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly four columns
    :type adjustableColumn4: int
    :param adjustableColumn5: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly five columns
    :type adjustableColumn5: int
    :param adjustableColumn6: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly six columns
    :type adjustableColumn6: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param attribute: (C Q E) The name of a unique attribute of type vector  This newly created
    field will be attached to the attribute, so that modifications to one will change t
    :type attribute: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) The command string is executed when the value of any of the
    floatFields change
    :type changeCommand: script
    :param columnAlign: (C E M) Arguments are : column number, alignment type  Possible
    alignments are: left | right | center  Specifies alignment type for the specified column
    :type columnAlign: [int, string]
    :param columnAlign2: (C E) Sets the text alignment of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "center"
    :type columnAlign2: [string, string]
    :param columnAlign3: (C E) Sets the text alignment for all three columns  Ignored if there
    are not exactly three columns  Valid values are "left", "right", and "center"
    :type columnAlign3: [string, string, string]
    :param columnAlign4: (C E) Sets the text alignment for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "center"
    :type columnAlign4: [string, string, string, string]
    :param columnAlign5: (C E) Sets the text alignment for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "center"
    :type columnAlign5: [string, string, string, string, string]
    :param columnAlign6: (C E) Sets the text alignment for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "center"
    :type columnAlign6: [string, string, string, string, string, string]
    :param columnAttach: (C E M) Arguments are : column number, attachment type, and offset 
    Possible attachments are: left | right | both  Specifies column attachment types and offe
    :type columnAttach: [int, string, int]
    :param columnAttach2: (C E) Sets the attachment type of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "both"
    :type columnAttach2: [string, string]
    :param columnAttach3: (C E) Sets the attachment type for all three columns  Ignored if
    there are not exactly three columns  Valid values are "left", "right", and "both"
    :type columnAttach3: [string, string, string]
    :param columnAttach4: (C E) Sets the attachment type for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "both"
    :type columnAttach4: [string, string, string, string]
    :param columnAttach5: (C E) Sets the attachment type for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "both"
    :type columnAttach5: [string, string, string, string, string]
    :param columnAttach6: (C E) Sets the attachment type for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "both"
    :type columnAttach6: [string, string, string, string, string, string]
    :param columnOffset2: (C E) This flag is used in conjunction with the -columnAttach2 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the tw
    :type columnOffset2: [int, int]
    :param columnOffset3: (C E) This flag is used in conjunction with the -columnAttach3 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the th
    :type columnOffset3: [int, int, int]
    :param columnOffset4: (C E) This flag is used in conjunction with the -columnAttach4 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fo
    :type columnOffset4: [int, int, int, int]
    :param columnOffset5: (C E) This flag is used in conjunction with the -columnAttach5 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fi
    :type columnOffset5: [int, int, int, int, int]
    :param columnOffset6: (C E) This flag is used in conjunction with the -columnAttach6 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the si
    :type columnOffset6: [int, int, int, int, int, int]
    :param columnWidth: (C E M) Arguments are : column number, column width  Sets the width of
    the specified column where the first parameter specifies the column (1 based index) an
    :type columnWidth: [int, int]
    :param columnWidth1: (C E) Sets the width of the first column  Ignored if there is not
    exactly one column
    :type columnWidth1: int
    :param columnWidth2: (C E) Sets the column widths of both columns  Ignored if there are not
    exactly two columns
    :type columnWidth2: [int, int]
    :param columnWidth3: (C E) Sets the column widths for all 3 columns  Ignored if there are
    not exactly 3 columns
    :type columnWidth3: [int, int, int]
    :param columnWidth4: (C E) Sets the column widths for all 4 columns  Ignored if there are
    not exactly 4 columns
    :type columnWidth4: [int, int, int, int]
    :param columnWidth5: (C E) Sets the column widths for all 5 columns  Ignored if there are
    not exactly 5 columns
    :type columnWidth5: [int, int, int, int, int]
    :param columnWidth6: (C E) Sets the column widths for all 6 columns  Ignored if there are
    not exactly 6 columns
    :type columnWidth6: [int, int, int, int, int, int]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param extraButton: (C) Add an extra icon button to the end of this control (before extra
    label)
    :type extraButton: boolean
    :param extraButtonCommand: (C E) The command string is executed when the extra button is
    clicked
    :type extraButtonCommand: script
    :param extraButtonIcon: (C Q E) The icon file name of the extra button
    :type extraButtonIcon: string
    :param extraLabel: (C Q E) set an optional string that will be positioned to the right of
    all the fields
    :type extraLabel: string
    :param forceAddMapButton: (C) Force adding a map button to this control  If this option is
    true, option hideMapButton is suppressed
    :type forceAddMapButton: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param hideMapButton: (C) Force the map button to remain hidden for this control
    :type hideMapButton: boolean
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) By default, the label of this field will be the name of the attribute
     This flag can be used to override that name with whatever the user wants
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param maxValue: (C Q E) Sets the maximum value for all fields
    :type maxValue: float
    :param minValue: (C Q E) Sets the minimum value for all fields
    :type minValue: float
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfFields: (C) sets the number of fields  Only allowed values are 2 to 4  If
    not specified, defaults to 3  NOTE: if the -at flag is used when this widget is created
    :type numberOfFields: int
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param precision: (C E) Sets the precision for all fields
    :type precision: int
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rowAttach: (C E M) Arguments are : column, attachment type, offset  Possible
    attachments are: top | bottom | both  Specifies attachment types and offsets for the
    entire
    :type rowAttach: [int, string, int]
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param step: (C Q E) Sets the increment for all fields
    :type step: float
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The full name of the control.
    :rtype: string
    """
    pass


def NodeEditorGridToggleVisibility(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FullHotboxDisplay(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NextKey(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def particleExists(*args, **kwargs):
    """
    This command is used to query if a particle or soft object with the given name exists 
    Either the transform or shape name can be used as well as the name of the soft object
    
    
    :returns: True if there is a particle object or soft object by the given
    name, false
    otherwise.
    :rtype: boolean
    """
    pass


def tolerance(*args, angular=0.0, linear=0.0, q=True, query=True, **kwargs):
    """
    This command sets tolerances used by modelling operations that require a tolerance, such as
    surface fillet  Linear tolerance is also known as "positional" tolerance  Angular tolerance
    is also known as "tangential" tolerance
    
    :param angular: (C Q) Sets the angular, or "tangential" tolerance
    :type angular: float
    :param linear: (C Q) Sets the linear, or "positonal" tolerance
    :type linear: float
    
    :returns: 
    :rtype: None
    """
    pass


def CreatePolygonCone(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BufferCurveSnapshot(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreatePolygonPipeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ProjectTangent(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def curveOnSurface(*args, append=True, degree=3, knot=0.0, name="", periodic=True,
                   positionUV=None, replace=True, **kwargs):
    """
    The curve command creates a new curve from a list of control vertices (CVs)  A string is
    returned containing the pathname to the newly created curve  You can create a curve from
    points either in world space or object (local) space, either with weights or without  You
    can replace an existing curve by using the "-r/replace" flag  You can append a poi
    
    :param append: (C) Appends point(s) to the end of an existing curve  If you use this flag,
    you must specify the name of the curve to append to, at the end of the comman
    :type append: boolean
    :param degree: (C) The degree of the new curve  Default is 3  Note that you need (degree+1)
    curve points to create a visible curve span  eg  you must place 4 points for
    :type degree: float
    :param knot: (C M) A knot value in a knot vector  One flag per knot value  There must be
    (numberOfPoints + degree - 1) knots and the knot vector must be non-decreasing
    :type knot: float
    :param name: (C) Name of the curve
    :type name: string
    :param periodic: (C) If on, creates a curve that is periodic  Default is off
    :type periodic: boolean
    :param positionUV: (C M) The uv position of a point
    :type positionUV: [float, float]
    :param replace: (C) Replaces an entire existing curve  If you use this flag, you must
    specify the name of the curve to replace, at the end of the command  (See examples
    :type replace: boolean
    
    :returns: - name of new curve-on-surface
    :rtype: string
    """
    pass


def DeltaMush(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ConvertSelectionToVertices(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RoundTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideFluids(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ProjectCurveOnSurfaceOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def notifyPostRedo(*args, **kwargs):
    """
    
    """
    pass


def Group(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def internalVar(*args, userAppDir=True, userBitmapsDir=True, userHotkeyDir=True,
                userMarkingMenuDir=True, userPrefDir=True, userPresetsDir=True,
                userScriptDir=True, userShelfDir=True, userTmpDir=True, userWorkspaceDir=True,
                **kwargs):
    """
    This command returns the values of internal variables  No modification of these variables
    is supported
    
    :param userAppDir: (C) Return the user application directory
    :type userAppDir: boolean
    :param userBitmapsDir: (C) Return the user bitmaps prefs directory
    :type userBitmapsDir: boolean
    :param userHotkeyDir: (C) Return the user hotkey directory
    :type userHotkeyDir: boolean
    :param userMarkingMenuDir: (C) Return the user marking menu directory
    :type userMarkingMenuDir: boolean
    :param userPrefDir: (C) Return the user preference directory
    :type userPrefDir: boolean
    :param userPresetsDir: (C) Return the user presets directory
    :type userPresetsDir: boolean
    :param userScriptDir: (C) Return the user script directory
    :type userScriptDir: boolean
    :param userShelfDir: (C) Return the user shelves directory
    :type userShelfDir: boolean
    :param userTmpDir: (C) Return a temp directory  Will check for TMPDIR environment variable,
    otherwise will return the current directory
    :type userTmpDir: boolean
    :param userWorkspaceDir: (C) Return the user workspace directory (also known as the
    projects directory)
    :type userWorkspaceDir: boolean
    
    :returns: The value of the variable specified by the flag use.
    :rtype: string
    """
    pass


def ToggleToolbox(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def hikCharacterToolWidget(*args, **kwargs):
    """
    
    """
    pass


def shapePanel(*args, control=True, copy="", createString=True, defineTemplate="", docTag="",
               editString=True, exists=True, init=True, isUnique=True, label="",
               menuBarRepeatLast=True, menuBarVisible=True, needsInit=True, parent="",
               popupMenuProcedure=None, replacePanel="", shapeEditor=True, tearOff=True,
               tearOffCopy="", tearOffRestore=True, unParent=True, useTemplate="", q=True,
               query=True, e=True, edit=True, **kwargs):
    """
    This command creates a panel that derives from the base panel class that houses a
    shapeEditor
    
    :param control: (Q) Returns the top level control for this panel  Usually used for getting
    a parent to attach popup menus  CAUTION: panels may not have controls at times
    :type control: boolean
    :param copy: (E) Makes this panel a copy of the specified panel  Both panels must be of the
    same type
    :type copy: string
    :param createString: (E) Command string used to create a panel
    :type createString: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Attaches a tag to the Maya panel
    :type docTag: string
    :param editString: (E) Command string used to edit a panel
    :type editString: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param init: (C E) Initializes the panel's default state  This is usually done
    automatically on file -new and file -open
    :type init: boolean
    :param isUnique: (Q) Returns true if only one instance of this panel type is allowed
    :type isUnique: boolean
    :param label: (Q E) Specifies the user readable label for the panel
    :type label: string
    :param menuBarRepeatLast: (C Q E) Controls whether clicking on the menu header with the
    middle mouse button would repeat the last selected menu item
    :type menuBarRepeatLast: boolean
    :param menuBarVisible: (C Q E) Controls whether the menu bar for the panel is displayed
    :type menuBarVisible: boolean
    :param needsInit: (Q E) (Internal) On Edit will mark the panel as requiring initialization 
    Query will return whether the panel is marked for initialization  Used during fil
    :type needsInit: boolean
    :param parent: (C) Specifies the parent layout for this panel
    :type parent: string
    :param popupMenuProcedure: (Q E) Specifies the procedure called for building the panel's
    popup menu(s)  The default value is "buildPanelPopupMenu"  The procedure should take one
    stri
    :type popupMenuProcedure: script
    :param replacePanel: (E) Will replace the specified panel with this panel  If the target
    panel is within the same layout it will perform a swap
    :type replacePanel: string
    :param shapeEditor: (Q) Query only flag that returns the name of an editor to be associated
    with the panel
    :type shapeEditor: boolean
    :param tearOff: (Q E) Will tear off this panel into a separate window with a paneLayout as
    the parent of the panel  When queried this flag will return if the panel has bee
    :type tearOff: boolean
    :param tearOffCopy: (C) Will create this panel as a torn of copy of the specified source
    panel
    :type tearOffCopy: string
    :param tearOffRestore: (C E) Restores panel if it is torn off and focus is given to it  If
    docked, becomes the active panel in the docked window  This should be the default flag
    :type tearOffRestore: boolean
    :param unParent: (E) Specifies that the panel should be removed from its layout  This
    (obviously) cannot be used with query
    :type unParent: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: The name of the panel
    :rtype: string
    """
    pass


def DeleteChannels(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GetFBIKExample(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def jointLattice(*args, after=True, afterReference=True, before=True, creasing=0.0,
                 deformerTools=True, exclusive="", frontOfChain=True, geometry="",
                 geometryIndices=True, ignoreSelected=True, includeHiddenSelections=False,
                 joint="", lengthIn=0.0, lengthOut=0.0, lowerBindSkin="", lowerTransform="",
                 name="", parallel=True, prune=True, remove=True, rounding=0.0, split=True,
                 upperBindSkin="", upperTransform="", widthLeft=0.0, widthRight=0.0, q=True,
                 query=True, e=True, edit=True, **kwargs):
    """
    This command creates/edits/queries a jointLattice deformer  The name of the created/edited
    object is returned  Usually you would make use of this functionality through the higher
    level flexor command
    
    :param after: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type after: boolean
    :param afterReference: (C E) The -afterReference flag is used to specify deformer ordering
    in a hybrid way that choses between -before and -after automatically  If the geometry b
    :type afterReference: boolean
    :param before: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type before: boolean
    :param creasing: (C Q E) Affects the bulging of lattice points on the inside of the bend 
    Positive/negative values cause the points to bulge outwards/inwards  Default value i
    :type creasing: float
    :param deformerTools: (Q) Returns the name of the deformer tool objects (if any) as string
    string ..
    :type deformerTools: boolean
    :param exclusive: (C Q) Puts the deformation set in a deform partition
    :type exclusive: string
    :param frontOfChain: (C E) This command is used to specify that the new deformer node
    should be placed ahead (upstream) of existing deformer and skin nodes in the shape's histo
    :type frontOfChain: boolean
    :param geometry: (Q E M) The specified object will be added to the list of objects being
    deformed by this deformer object, unless the -rm flag is also specified  When queried
    :type geometry: string
    :param geometryIndices: (Q) Complements the -geometry flag in query mode  Returns the multi
    index of each geometry
    :type geometryIndices: boolean
    :param ignoreSelected: (C) Tells the command to not deform objects on the current selection
    list
    :type ignoreSelected: boolean
    :param includeHiddenSelections: (C) Apply the deformer to any visible and hidden objects in
    the selection list  Default is false
    :type includeHiddenSelections: boolean
    :param joint: (C) Specifies the joint which will be used to drive the bulging behaviours
    :type joint: string
    :param lengthIn: (C Q E) Affects the location of lattice points on the parent bone 
    Positive/negative values cause the points to move away/towards the joint  Changing this pa
    :type lengthIn: float
    :param lengthOut: (C Q E) Affects the location of lattice points on the child bone 
    Positive/negative values cause the points to move away/towards the joint  Changing this
    par
    :type lengthOut: float
    :param lowerBindSkin: (C) Specifies the node which is performing the bind skin operation on
    the geometry associated with the lower bone
    :type lowerBindSkin: string
    :param lowerTransform: (C) Specifies which dag node is being used to rigidly transform the
    lower part of the lattice which this node is going to deform  If this flag is not spe
    :type lowerTransform: string
    :param name: (C) Used to specify the name of the node being created
    :type name: string
    :param parallel: (C E) Inserts the new deformer in a parallel chain to any existing
    deformers in the history of the object  A blendShape is inserted to blend the parallel r
    :type parallel: boolean
    :param prune: (E) Removes any points not being deformed by the deformer in its current
    configuration from the deformer set
    :type prune: boolean
    :param remove: (E M) Specifies that objects listed after the -g flag should be removed from
    this deformer
    :type remove: boolean
    :param rounding: (C Q E) Affects the bulging of lattice points on the outside of the bend 
    Positive/negative values cause the points to bulge outwards/inwards  Default value
    :type rounding: float
    :param split: (C E) Branches off a new chain in the dependency graph instead of
    inserting/appending the deformer into/onto an existing chain  Works in create mode (and e
    :type split: boolean
    :param upperBindSkin: (C) Specifies the node which is performing the bind skin operation on
    the geometry associated with the upper bone
    :type upperBindSkin: string
    :param upperTransform: (C) Specifies which dag node is being used to rigidly transform the
    upper part of the lattice which this node is going to deform  If this flag is not spe
    :type upperTransform: string
    :param widthLeft: (C Q E) Affects the bulging of lattice points on the left side of the
    bend  Positive/negative values cause the points to bulge outwards/inwards  Default valu
    :type widthLeft: float
    :param widthRight: (C Q E) Affects the bulging of lattice points on the right side of the
    bend  Positive/negative values cause the points to bulge outwards/inwards  Default val
    :type widthRight: float
    
    :returns: Name of joint lattice algorithm node created/edited.
    :rtype: string
    """
    pass


def PublishNode(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorReduceTraversalDepth(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowDeformers(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def IPRRenderIntoNewWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def InteractiveBindSkinOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def clearNClothStartState(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def LassoTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FlareOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ParticleToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def particleInstancer(*args, addObject=True, aimAxis="", aimDirection="", aimPosition="",
                      aimUpAxis="", aimWorldUp="", attributeMapping=True, cycle="none",
                      cycleStartObject="", cycleStep=0.0, cycleStepUnits="frames", index=0,
                      instanceId="", levelOfDetail="geometry", name="", object="",
                      objectIndex="", particleAge="", position="worldPosition",
                      removeObject=True, rotation="", rotationOrder="", rotationType="",
                      rotationUnits="", scale="", shear="", visibility="", q=True, query=True,
                      e=True, edit=True, **kwargs):
    """
    This command is used to create a particle instancer node and set the proper attributes in
    the particle shape and in the instancer node  It will also create the connections needed
    between the particle shape and the instancer node
    
    :param addObject: (C E) This flag indicates that objects specified by the -object flag will
    be added to the instancer node as instanced objects
    :type addObject: boolean
    :param aimAxis: (C Q E) This flag sets or queries the particle attribute name to be used
    for the aim axis of the instanced objects
    :type aimAxis: string
    :param aimDirection: (C Q E) This flag sets or queries the particle attribute name to be
    used for the aim direction of the instanced objects
    :type aimDirection: string
    :param aimPosition: (C Q E) This flag sets or queries the particle attribute name to be
    used for the aim position of the instanced objects
    :type aimPosition: string
    :param aimUpAxis: (C Q E) This flag sets or queries the particle attribute name to be used
    for the aim up axis of the instanced objects
    :type aimUpAxis: string
    :param aimWorldUp: (C Q E) This flag sets or queries the particle attribute name to be used
    for the aim world up of the instanced objects
    :type aimWorldUp: string
    :param attributeMapping: (Q) This flag queries the particle attribute mapping list
    :type attributeMapping: boolean
    :param cycle: (C Q E) This flag sets or queries the cycle attribute for the instancer node 
    The options are "none", "sequential"  The default is "none"
    :type cycle: string
    :param cycleStartObject: (C Q E) This flag sets or queries the particle attribute name to
    be used for the cycle start object of the instanced objects
    :type cycleStartObject: string
    :param cycleStep: (C Q E) This flag sets or queries the cycle step attribute for the
    instancer node  This attribute indicates the size of the step in frames or seconds (see cy
    :type cycleStep: float
    :param cycleStepUnits: (C Q E) This flag sets or queries the cycle step unit attribute for
    the instancer node  The options are "frames" or "seconds"  The default is "frames"
    :type cycleStepUnits: string
    :param index: (Q) This flag is used to query the name of the ith instanced object
    :type index: int
    :param instanceId: (Q) This flag queries the particle attribute name to be used for the id
    of the instanced objects
    :type instanceId: string
    :param levelOfDetail: (C Q E) This flag sets or queries the level of detail of the
    instanced objects  The options are "geometry", "boundingBox" or "boundingBoxes"  The
    default is
    :type levelOfDetail: string
    :param name: (C Q) This flag sets or queries the name of the instancer node
    :type name: string
    :param object: (C Q E M) This flag indicates which objects will be add/removed from the
    list of instanced objects  The flag is used in conjuction with the -addObject and -rem
    :type object: string
    :param objectIndex: (C Q E) This flag sets or queries the particle attribute name to be
    used for the object index of the instanced objects
    :type objectIndex: string
    :param particleAge: (C Q E) This flag sets or queries the particle attribute name to be
    used for the age of the instanced objects
    :type particleAge: string
    :param position: (C Q E) DEFAULT "worldPosition" This flag sets or queries the particle
    attribute name to be used for the positions of the instanced objects  By default the a
    :type position: string
    :param removeObject: (E) This flag indicates that objects specified by the -object flag
    will be removed from the instancer node as instanced objects
    :type removeObject: boolean
    :param rotation: (C Q E) This flag sets or queries the particle attribute name to be used
    for the rotation of the instanced objects
    :type rotation: string
    :param rotationOrder: (C Q E) This flag specifies the rotation order associated with the
    rotation flag  The options are XYZ, XZY, YXZ, YZX, ZXY, or ZYX  By default the attribute i
    :type rotationOrder: string
    :param rotationType: (C Q E) This flag sets or queries the particle attribute name to be
    used for the rotation type of the instanced objects
    :type rotationType: string
    :param rotationUnits: (C Q E) This flag specifies the rotation units associated with the
    rotation flag  The options are degrees or radians  By default the attribute is degrees
    :type rotationUnits: string
    :param scale: (C Q E) This flag sets or queries the particle attribute name to be used for
    the scale of the instanced objects
    :type scale: string
    :param shear: (C Q E) This flag sets or queries the particle attribute name to be used for
    the shear of the instanced objects
    :type shear: string
    :param visibility: (C Q E) This flag sets or queries the particle attribute name to be used
    for the visibility of the instanced objects
    :type visibility: string
    
    :returns: Command result
    :rtype: string
    """
    pass


def cMuscleWeightPrune(*args, **kwargs):
    """
    
    """
    pass


def ProfilerToolToggleRecording(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AttachCurve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def radioButton(*args, align="", annotation="", backgroundColor=None, changeCommand=None,
                collection="", data=0, defineTemplate="", docTag="", dragCallback=None,
                dropCallback=None, editable=True, enable=True, enableBackground=True,
                enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
                highlightColor=None, isObscured=True, label="", manage=True, noBackground=True,
                numberOfPopupMenus=True, offCommand=None, onCommand=None, parent="",
                popupMenuArray=True, preventOverride=True, recomputeSize=True, select=True,
                statusBarMessage="", useTemplate="", visible=True, visibleChangeCommand=None,
                width=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a radio button that is added to the most recently created radio
    collection if the -cl/collection flag is not used
    
    :param align: (C Q E) This flag is obsolete and should no longer be used  The radio button
    label will always be left-aligned
    :type align: string
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Command executed when the radio button's state is changed  Note
    that this flag should not be used in conjunction with onCommand and offCommand  That
    :type changeCommand: script
    :param collection: (C) To explicitly add a radio button to a collection of radio buttons
    specify the name of the radio collection
    :type collection: string
    :param data: (C Q E) Internal data associated with the radio button
    :type data: int
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param editable: (C Q E) The edit state of the radio button  By default, this flag is set
    to true and the radio button value may be changed by clicking on it  If false then t
    :type editable: boolean
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) The label text  The default label is the name of the control
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param offCommand: (C E) Command executed when the radio button is turned off
    :type offCommand: script
    :param onCommand: (C E) Command executed when the radio button is turned on
    :type onCommand: script
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param recomputeSize: (C Q E) If true then the control will recompute it's size to just fit
    the size of the label  If false then the control size will remain fixed as you change t
    :type recomputeSize: boolean
    :param select: (C Q E) Select the radio button
    :type select: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def FilePathEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def adskSceneMetadataCmd(*args, **kwargs):
    """
    
    """
    pass


def addMetadata(*args, channelName="", channelType="", indexType="", scene=True, streamName="",
                structure="", q=True, query=True, **kwargs):
    """
    Defines the attachment of a metadata structure to one or more selected objects  This
    creates a placeholder with an empty metadata Stream for later population through the
    editMetadata command  It's similar in concept to the addAttr command for nodes - a data
    description is added but no data is actually set   When assigning a metadata structure you
    m
    
    :param channelName: (C Q) Name of the Channel type to which the structure is to be added
    (e.g  "vertex")  In query mode, this flag can accept a value
    :type channelName: string
    :param channelType: (C Q) Obsolete - use the 'channelName' flag instead  In query mode,
    this flag can accept a value
    :type channelType: string
    :param indexType: (C Q) Name of the index type the new Channel should be using  If not
    specified this defaults to a simple numeric index  Of the native types only a mesh "ve
    :type indexType: string
    :param scene: (C Q) Use this flag when you want to add metadata to the scene as a whole
    rather than to any individual nodes  If you use this flag and have nodes selected
    :type scene: boolean
    :param streamName: (C Q) Name of the empty stream being created  In query mode not
    specifying a value will return a list of streams on the named channel type  In query mode,
    :type streamName: string
    :param structure: (C Q) Name of the structure which defines the metadata to be attached to
    the object  In query mode this will return the name of the structure attached at a
    :type structure: string
    
    :returns: List of nodes to which a new Stream was successfully added (create mode)
    :rtype: string[]
    """
    pass


def replaceCacheFrames(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BakeSpringAnimation(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CurveUtilitiesMarkingMenuPopDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def displayCull(*args, backFaceCulling=True, q=True, query=True, **kwargs):
    """
    This command is responsible for setting the display culling property of back faces of
    surfaces
    
    :param backFaceCulling: (C Q) Enable/disable culling of back faces
    :type backFaceCulling: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def SetFocusToCommandLine(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShapeEditorDuplicateTarget(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeMoveTabUp(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def buttonManip(*args, icon="", **kwargs):
    """
    This creates a button manipulator  This manipulator has a position in space and a triad
    manip for positioning  When you click on the top part of the manip, the command defined by
    the first argument is executed  The command is associated with the manipulator when it is
    created   If a dag object is included on the command line, the manip will be pare
    
    :param icon: (C) Specify an icon to represent the manipulator
    :type icon: string
    
    :returns: 
    :rtype: None
    """
    pass


def ScriptPaintToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PlaybackToggle(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dynSelectCtx(*args, **kwargs):
    """
    
    """
    pass


def DeleteAllControllers(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UnpublishRootTransform(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UVCentricUVLinkingEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NewSceneOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SurfaceBooleanUnionToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nurbsCurveToBezier(*args, **kwargs):
    """
    The nurbsCurveToBezier command attempts to convert an existing NURBS curve to a Bezier
    curve
    
    
    :returns: (object name and node name)
    :rtype: string[]
    """
    pass


def polyCopyUV(*args, caching=True, constructionHistory=True, createNewMap=True, name="",
               nodeState=0, uvSetName="", uvSetNameInput="", worldSpace=True, q=True,
               query=True, e=True, edit=True, **kwargs):
    """
    Copy some UVs from a UV set into another
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param createNewMap: (C) Set to true if a new map should be created
    :type createNewMap: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param uvSetName: (C) Name of the UV set to be created
    :type uvSetName: string
    :param uvSetNameInput: (C Q E) Specifies name of the input uv set to read the UV
    description from  Default is the current UV set
    :type uvSetNameInput: string
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def AddPondSurfaceLocator(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SubdivProxyOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddAnimationOffsetOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OutlinerRenameSelectedItem(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_rotateRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def art3dPaintCtx(*args, accopacity=False, afterStrokeCmd="", alphablendmode="", assigntxt=True,
                  attrnames="", beforeStrokeCmd="", brushalignment=True, brushdepth=0.0,
                  brushfeedback=True, brushtype="", clear=True, commonattr="", dragSlider="",
                  dynclonemode=True, exists=True, expandfilename=True, exportaspectratio=0.0,
                  exportfilemode="luminance/rgb", exportfilesave="", exportfilesizex=0,
                  exportfilesizey=0, exportfiletype="", extendFillColor=True, fileformat="",
                  filetxtaspectratio=1, filetxtsizex=256, filetxtsizey=256, floodOpacity=0.0,
                  floodall=True, floodselect=True, history=True, image1="", image2="",
                  image3="", importfileload="", importfilemode="alpha", importreassign=False,
                  keepaspectratio=True, lastRecorderCmd="", lastStampName="", lowerradius=0.0,
                  makeStroke=0, mappressure="none", name="", opacity=1.0, outline=True,
                  outwhilepaint=False, paintmode="screen", paintoperationtype="Paint",
                  painttxtattr="Color", painttxtattrname="", pfxScale=0.0, pfxWidth=0.0,
                  pickColor=True, pickValue=True, playbackCursor=None, playbackPressure=0.0,
                  preserveclonesource=True, pressureMapping1=0, pressureMapping2=0,
                  pressureMapping3=0, pressureMax1=0.0, pressureMax2=0.0, pressureMax3=0.0,
                  pressureMin1=0.0, pressureMin2=0.0, pressureMin3=0.0, profileShapeFile="",
                  projective=False, radius=1.0, record=True, reflection=False,
                  reflectionaboutorigin=True, reflectionaxis="x", reloadtexfile=True,
                  resizeratio=0.0, resizetxt=True, rgbcolor=None, rgbflood=None,
                  saveTextureOnStroke=False, saveonstroke=False, savetexture=True,
                  screenRadius=0.0, selectclonesource=True, shadernames="", shapeattr=False,
                  shapenames="", showactive=True, soloAsDiffuse=False, stampDepth=0.0,
                  stampProfile="", stampSpacing=1.0, strokesmooth="",
                  surfaceConformedBrushVertices=True, tablet=True, tangentOutline=True,
                  textureFilenames=True, updateEraseTex=True, usepressure=False,
                  worldRadius=0.0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This is a tool context command for 3d Paint tool
    
    :param accopacity: (C Q E) Sets opacity accumulation on/off  C: Default is false (Except
    for sculpt tool for which it is true by default)  Q: When queried, it returns a boolean
    :type accopacity: boolean
    :param afterStrokeCmd: (C Q E) The passed string is executed as a MEL command immediately
    after the end of a stroke  C: Default is no command  Q: When queried, it returns the curre
    :type afterStrokeCmd: string
    :param alphablendmode: (C Q E) Specifies the blend mode used while painting RGB channel 
    Currently, we support the following blend modes: "Default" "Lighten" "Darken" "Difference"
    :type alphablendmode: string
    :param assigntxt: (E) Sends a request to the tool to allocate and assign file textures to
    the specified attibute on the selected shaders
    :type assigntxt: boolean
    :param attrnames: (C Q E) Name of attributes
    :type attrnames: string
    :param beforeStrokeCmd: (C Q E) The passed string is executed as a MEL command immediately
    before the start of a stroke  C: Default is no command  Q: When queried, it returns the cu
    :type beforeStrokeCmd: string
    :param brushalignment: (C Q E) Specifies the path brush alignemnt  If true, the brush will
    align to stroke path, otherwise it will align to up vector  C: Default is true  Q: When q
    :type brushalignment: boolean
    :param brushdepth: (C Q E) Depth of the brush
    :type brushdepth: float
    :param brushfeedback: (C Q E) Specifies if the brush additional feedback should be drawn 
    C: Default is TRUE  Q: When queried, it returns a boolean
    :type brushfeedback: boolean
    :param brushtype: (C Q E) Name of the brush type
    :type brushtype: string
    :param clear: (C E) Floods all cvs/vertices to the current value
    :type clear: boolean
    :param commonattr: (Q) Returns a string with the names of all common to all the shaders
    paintable attributes and supported by the Paint Texture Tool
    :type commonattr: string
    :param dragSlider: (C E) Sets the current brush drag state for resizing or offsetting the
    brush (like the 'b' and 'm' default hotkeys)  The string argument is one of: "radius
    :type dragSlider: string
    :param dynclonemode: (C Q E) Enable or disable dynamic clone mode
    :type dynclonemode: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param expandfilename: (C E) If true, it will expand the name of the export file and
    concatenate it with the surface name  Otherwise it will take the name as it is  C: Default
    is
    :type expandfilename: boolean
    :param exportaspectratio: (C Q E) Value of aspect ratio for export
    :type exportaspectratio: float
    :param exportfilemode: (C Q E) Specifies the export channel.The valid entries here are:
    "alpha", "luminance", "rgb", "rgba"  C: Default is "luminance/rgb"  Q: When queried, it
    retu
    :type exportfilemode: string
    :param exportfilesave: (E) Exports the attribute map and saves to a specified file
    :type exportfilesave: string
    :param exportfilesizex: (C Q E) Specifies the width of the attribute map to export  C:
    Default width is 256  Q: When queried, it returns an integer
    :type exportfilesizex: int
    :param exportfilesizey: (C Q E) Specifies the width of the attribute map to export  C:
    Default width is 256  Q: When queried, it returns an integer
    :type exportfilesizey: int
    :param exportfiletype: (C Q E) Specifies the image file format  It can be one of the
    following: "iff", "tiff", "jpeg", "alias", "rgb", "fit" "postScriptEPS", "softimage",
    "wavefron
    :type exportfiletype: string
    :param extendFillColor: (C Q E) States if the painted textures will be automatically
    postprocessed on each stroke to fill in the background color  Default is true
    :type extendFillColor: boolean
    :param fileformat: (C Q E) Name of the file format
    :type fileformat: string
    :param filetxtaspectratio: (C Q E) Specifies the aspect ration of the texture width and
    height  Default is 1
    :type filetxtaspectratio: float
    :param filetxtsizex: (C Q E) Specifies the width of the texture  Default is 256
    :type filetxtsizex: int
    :param filetxtsizey: (C Q E) Specifies the height of the texture  Default is 256
    :type filetxtsizey: int
    :param floodOpacity: (C Q E) Value of the flood opacity
    :type floodOpacity: float
    :param floodall: (C Q E) Turn on to flood everything
    :type floodall: boolean
    :param floodselect: (C Q E) Should the selected area be flooded?
    :type floodselect: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param importfileload: (E) Load the attribute map a specified file
    :type importfileload: string
    :param importfilemode: (C Q E) Specifies the channel to import  The valid entries here are:
    "alpha", "luminance", "red", "green", "blue", and "rgb" C: Default is "alpha"  Q: When q
    :type importfilemode: string
    :param importreassign: (C Q E) Specifies if the multiply atrribute maps are to be
    reassigned while importing  Only maps previously exported from within Artisan can be
    reassigned  C
    :type importreassign: boolean
    :param keepaspectratio: (C Q E) States if the aspect ratio of the file texture sizes should
    remain constant  Default is true  boolean
    :type keepaspectratio: boolean
    :param lastRecorderCmd: (C Q E) Value of last recorded command
    :type lastRecorderCmd: string
    :param lastStampName: (C Q E) Value of the last stamp name
    :type lastStampName: string
    :param lowerradius: (C Q E) Sets the lower size of the brush (only apply on tablet)
    :type lowerradius: float
    :param makeStroke: (C Q E M) Stroke point values
    :type makeStroke: int
    :param mappressure: (C Q E) Sets the tablet pressure mapping when the table is used  There
    are four options: "none" - the pressure has no effect, "opacity" - the pressure is map
    :type mappressure: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param opacity: (C Q E) Sets the brush opacity  C: Default is 1.0  Q: When queried, it
    returns a float
    :type opacity: float
    :param outline: (C Q E) Specifies if the brush should be drawn  C: Default is TRUE  Q: When
    queried, it returns a boolean
    :type outline: boolean
    :param outwhilepaint: (C Q E) Specifies if the brush outline should be drawn while painting
     C: Default is FALSE  Q: When queried, it returns a boolean
    :type outwhilepaint: boolean
    :param paintmode: (C Q E) Specifies the paint mode  There are two possibilities: "screen"
    and "tangent"  C: Default is "screen"  Q: When queried, it returns a string
    :type paintmode: string
    :param paintoperationtype: (C Q E) Specifies the operation type used by the Paint Tool 
    Currently, we support the following paint modes: "Paint", "Smear", "Blur", "Erase" and
    "Clone"
    :type paintoperationtype: string
    :param painttxtattr: (C Q E) Specifies the attribute on the shader which the user wants to
    paint  Currently, we support the following attributes: "Color", "Transparency", "Ambien
    :type painttxtattr: string
    :param painttxtattrname: (Q E) Returns a string with the names of all paintable attributes
    supported by the Paint Texture Tool
    :type painttxtattrname: string
    :param pfxScale: (Q E) Specifies the scale for Paint Effect brushes
    :type pfxScale: float
    :param pfxWidth: (Q E) Specifies the width for Paint Effect brushes
    :type pfxWidth: float
    :param pickColor: (C Q E) Set pick color mode on or off
    :type pickColor: boolean
    :param pickValue: (C Q E) Toggle for picking
    :type pickValue: boolean
    :param playbackCursor: (C Q E M) Values for the playback cursor
    :type playbackCursor: [float, float]
    :param playbackPressure: (C Q E M) Valus for the playback pressure
    :type playbackPressure: float
    :param preserveclonesource: (C Q E) Whether or not to preserve a clone source
    :type preserveclonesource: boolean
    :param pressureMapping1: (C Q E) First pressure mapping value
    :type pressureMapping1: int
    :param pressureMapping2: (C Q E) Second pressure mapping value
    :type pressureMapping2: int
    :param pressureMapping3: (C Q E) Third pressure mapping value
    :type pressureMapping3: int
    :param pressureMax1: (C Q E) First pressure maximum value
    :type pressureMax1: float
    :param pressureMax2: (C Q E) Second pressure maximum value
    :type pressureMax2: float
    :param pressureMax3: (C Q E) Third pressure maximum value
    :type pressureMax3: float
    :param pressureMin1: (C Q E) First pressure minimum value
    :type pressureMin1: float
    :param pressureMin2: (C Q E) Second pressure minimum value
    :type pressureMin2: float
    :param pressureMin3: (C Q E) Third pressure minimum value
    :type pressureMin3: float
    :param profileShapeFile: (Q E) Passes a name of the image file for the stamp shape profile
    :type profileShapeFile: string
    :param projective: (C Q E) Specifies the projective paint mode  C: Default is 'false'  Q:
    When queried, it returns a boolean
    :type projective: boolean
    :param radius: (C Q E) Sets the size of the brush  C: Default is 1.0 cm  Q: When queried,
    it returns a float
    :type radius: float
    :param record: (C Q E) Toggle on for recording
    :type record: boolean
    :param reflection: (C Q E) Specifies the reflection mode  C: Default is 'false'  Q: When
    queried, it returns a boolean
    :type reflection: boolean
    :param reflectionaboutorigin: (C Q E) Toggle on to reflect about the origin
    :type reflectionaboutorigin: boolean
    :param reflectionaxis: (C Q E) Specifies the reflection axis  There are three
    possibilities: "x", "y" and "z"  C: Default is "x"  Q: When queried, it returns a string
    :type reflectionaxis: string
    :param reloadtexfile: (E) Sends a request to the tool to reload the texture from the disc
    :type reloadtexfile: boolean
    :param resizeratio: (Q E) Specifies the scale by which to resize the current textures
    :type resizeratio: float
    :param resizetxt: (E) Sends a request to the tool to resize all the currently in use
    textures
    :type resizetxt: boolean
    :param rgbcolor: (C Q E) Colour value
    :type rgbcolor: [float, float, float]
    :param rgbflood: (C Q E) Color of the flood
    :type rgbflood: [float, float, float]
    :param saveTextureOnStroke: (C Q E) States if the original texture will be automatically
    saved on each stroke  Default is false
    :type saveTextureOnStroke: boolean
    :param saveonstroke: (C Q E) States if the temporary texture will be automatically saved on
    each stroke  Default is false
    :type saveonstroke: boolean
    :param savetexture: (E) Sends a request to the tool to save the texture to the disc
    :type savetexture: boolean
    :param screenRadius: (C Q E) Brush radius on the screen
    :type screenRadius: float
    :param selectclonesource: (C Q E) Toggle on to select the clone source
    :type selectclonesource: boolean
    :param shadernames: (Q) Returns a string with the names of all shaders assigned to selected
    surfaces
    :type shadernames: string
    :param shapeattr: (Q E) States if the attribute to paint is an attribute of the shape and
    not the shader  Default is false
    :type shapeattr: boolean
    :param shapenames: (Q) Returns a string with the names of all surfaces which are being
    painted on
    :type shapenames: string
    :param showactive: (C Q E) Sets on/off the display of the surface isoparms  C: Default is
    TRUE  Q: When queried, it returns a boolean
    :type showactive: boolean
    :param soloAsDiffuse: (Q E) States if the currently paintable texture will be rendered as
    as diffuse texture in the viewport  Default is false
    :type soloAsDiffuse: boolean
    :param stampDepth: (C Q E) Depth of the stamps
    :type stampDepth: float
    :param stampProfile: (C Q E) Sets the brush profile of the current stamp  Currently, the
    following profiles are supported: "gaussian", "poly", "solid" and "square"  C: Default is
    :type stampProfile: string
    :param stampSpacing: (C Q E) Specifies the stamp spacing  Default is 1.0
    :type stampSpacing: float
    :param strokesmooth: (C Q E) Stroke smoothing type name
    :type strokesmooth: string
    :param surfaceConformedBrushVertices: (C Q E) Enables/disables the the display of the
    effective brush area as affected vertices
    :type surfaceConformedBrushVertices: boolean
    :param tablet: (Q) Returns true if the tablet device is present, false if it is absent
    :type tablet: boolean
    :param tangentOutline: (C Q E) Enables/disables the display of the brush circle tangent to
    the surface
    :type tangentOutline: boolean
    :param textureFilenames: (Q) Returns a string array with the names of all the painted file
    textures
    :type textureFilenames: boolean
    :param updateEraseTex: (C Q E) Should the erase texture update?
    :type updateEraseTex: boolean
    :param usepressure: (C Q E) Sets the tablet pressure on/off  C: Default is false  Q: When
    queried, it returns a boolean
    :type usepressure: boolean
    :param worldRadius: (C Q E) Radius in worldspace
    :type worldRadius: float
    
    :returns: 
    :rtype: None
    """
    pass


def DisableGlobalStitch(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolygonHardenEdge(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def perCameraVisibility(*args, camera=None, exclusive=True, hide=True, remove=True,
                        removeAll=True, removeCamera=True, q=True, query=True, **kwargs):
    """
    The perCameraVisibility command creates, queries and removes visibility relationships
    between DAG objects and cameras  These relationships are applied in any viewport that uses
    the cameras involved  (They are not used e.g  in rendering.) Objects can be set to be
    exclusive to a camera (meaning they will only be displayed in viewports using that came
    
    :param camera: (C Q) Specify the camera for the operation
    :type camera: name
    :param exclusive: (C Q) Set objects as being exclusive to the given camera
    :type exclusive: boolean
    :param hide: (C Q) Set objects as being hidden from the given camera
    :type hide: boolean
    :param remove: (C) Used with exclusive or hide, removes the objects instead of adding them
    :type remove: boolean
    :param removeAll: (C) Remove all exclusivity/hidden objects for all cameras
    :type removeAll: boolean
    :param removeCamera: (C) Remove all exclusivity/hidden objects for the given camera
    :type removeCamera: boolean
    
    :returns: Command result
    :rtype: string[]
    """
    pass


def dR_paintRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateHairCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TranslateToolWithSnapMarkingMenuPopDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def deleteUI(*args, collection=True, control=True, editor=True, layout=True, menu=True,
             menuItem=True, panel=True, panelConfig=True, radioMenuItemCollection=True,
             toolContext=True, uiTemplate=True, window=True, **kwargs):
    """
    This command deletes UI objects such as windows and controls  Deleting a layout or window
    will also delete all of its children  If a flag is used then all objects being deleted must
    be of the specified type  This command may not be edited or queried   NOTE: it is
    recommended that the type flags be used to disambiguate different kinds of objects wit
    
    :param collection: (C) Object names for deletion are all radio or tool collections
    :type collection: boolean
    :param control: (C) Object names for deletion are all controls
    :type control: boolean
    :param editor: (C) Object names for deletion are all editors
    :type editor: boolean
    :param layout: (C) Object names for deletion are all layouts
    :type layout: boolean
    :param menu: (C) Object names for deletion are all menus
    :type menu: boolean
    :param menuItem: (C) Object names for deletion are all menu items
    :type menuItem: boolean
    :param panel: (C) Object names for deletion are all panels
    :type panel: boolean
    :param panelConfig: (C) Object names for deletion are panel configurations
    :type panelConfig: boolean
    :param radioMenuItemCollection: (C) Object names for deletion are all radio menu item
    collections
    :type radioMenuItemCollection: boolean
    :param toolContext: (C) Object names for deletion are all tool contexts
    :type toolContext: boolean
    :param uiTemplate: (C) Object names for deletion are all UI templates
    :type uiTemplate: boolean
    :param window: (C) Object names for deletion are all windows
    :type window: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def characterize(*args, activatePivot=True, addAuxEffector=True, addFloorContactPlane=True,
                 addMissingEffectors=True, attributeFromHIKProperty="",
                 attributeFromHIKPropertyMode="", autoActivateBodyPart=True,
                 changePivotPlacement=True, effectors="", fkSkeleton="", name="",
                 pinHandFeet=True, placeNewPivot=True, posture="biped", sourceSkeleton="",
                 stancePose="", type="name", q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command is used to scan a joint hierarchy for predefined joint names or labels  If the
    required joints are found, human IK effectors will be created to control the skeleton using
    full-body IK  Alternatively, you can manually create all of the components required for
    fullbody IK, and use this command to hook them up  Fullbody IK needs 3 major c
    
    :param activatePivot: (E) Activates a pivot that has been properly placed  After activating
    this new pivot, you will now be able to rotate and translate about this pivot  A pi
    :type activatePivot: boolean
    :param addAuxEffector: (E) Adds an auxilliary (secondary) effector to an existing effector
    :type addAuxEffector: boolean
    :param addFloorContactPlane: (E) Adds a floor contact plane to one of the hands or feet 
    With this plane, you will be able to adjust the floor contact height  Select a hand or foot
    e
    :type addFloorContactPlane: boolean
    :param addMissingEffectors: (E) This flag tells the characterize command to look for any
    effectors that can be added to the skeleton  For example, if the user has deleted some
    effec
    :type addMissingEffectors: boolean
    :param attributeFromHIKProperty: (Q) Query for the attribute name associated with a
    MotionBuilder property
    :type attributeFromHIKProperty: string
    :param attributeFromHIKPropertyMode: (Q) Query for the attribute name associated with a
    MotionBuilder property mode
    :type attributeFromHIKPropertyMode: string
    :param autoActivateBodyPart: (Q E) Query or change whether auto activation of character
    nodes representing body parts should be enabled
    :type autoActivateBodyPart: boolean
    :param changePivotPlacement: (E) Reverts a pivot back into pivot placement mode  A pivot
    that is in placement mode will not participate in full body manipulation until it has been
    ac
    :type changePivotPlacement: boolean
    :param effectors: (C) Specify the effectors to be used by human IK by providing 2 pieces of
    information for each effector: 1) the partial path of the effector and 2) the n
    :type effectors: string
    :param fkSkeleton: (C E) Specify the fk skeleton to be used by human IK by providing 2
    pieces of information for each joint of the FK skeleton: 1) the partial path of the joi
    :type fkSkeleton: string
    :param name: (C) At characterization (FBIK creation) time, use this flag to name your FBIK
    character  This will affect the name of the hikHandle node and the control
    :type name: string
    :param pinHandFeet: (C) When the character is first being characterized, pin the hands and
    feet by default
    :type pinHandFeet: boolean
    :param placeNewPivot: (E) Creates a new pivot and puts it into placement mode  Note that
    you will not be able to do full body manipulation about this pivot until you have acti
    :type placeNewPivot: boolean
    :param posture: (C) Specifies the posture of the character  Valid options are "biped" and
    "quadruped"  The default is "biped"
    :type posture: string
    :param sourceSkeleton: (C E) This flag can be used to characterize a skeleton that has not
    been named or labelled according to the FBIK guidelines  It specifies the association b
    :type sourceSkeleton: string
    :param stancePose: (C Q) Specify the default stance pose to be used by human IK  The stance
    pose is specified by providing 2 pieces of information for each joint involved in
    :type stancePose: string
    :param type: (C) Specifies the technique used by the characterization to identify the joint
    type  Valid options are "label" and "name"  When "label" is used, the join
    :type type: string
    
    :returns: Names of full body IK effectors that were created.
    :rtype: string
    """
    pass


def curveBezierCtx(*args, **kwargs):
    """
    
    """
    pass


def DeleteAllClusters(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def saveFluid(*args, currentTime=0, endTime=0, startTime=0, q=True, query=True, e=True,
              edit=True, **kwargs):
    """
    A command to save the current state of the fluid to the initial state cache  The grids to
    be saved are determined by the cache attributes: cacheDensity, cacheVelocity, etc  These
    attributes are normally set from the options on Set Initial State  The cache must be set up
    before invoking this command
    
    :param currentTime: (C Q E) cache state of fluid at current time
    :type currentTime: int
    :param endTime: (C Q E) end Time for cacheing
    :type endTime: int
    :param startTime: (C Q E) start Time for cacheing
    :type startTime: int
    
    :returns: 
    :rtype: None
    """
    pass


def RemoveBrushSharing(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nucleusGetnClothExample(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorRippleEditTogglePress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleLayerBar(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleModelEditorBars(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowNURBSCurves(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreatePolygonCylinderOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyUVOverlap(*args, nonOverlappingComponents=True, overlappingComponents=True, **kwargs):
    """
    Return the required result on the specified components
    
    :param nonOverlappingComponents: (C) Return non-overlapping components based on
    selected/specified components
    :type nonOverlappingComponents: boolean
    :param overlappingComponents: (C) Return overlapping components based on selected/specified
    components
    :type overlappingComponents: boolean
    
    :returns: List of poly components
    :rtype: selectionItem[]
    """
    pass


def PaintOperationMarkingMenuPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def geometryReplaceCacheFramesOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectIsolate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ConvertSelectionToUVBorder(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DecreaseExposureCoarse(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TogglePanZoomPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ApplySettingsToLastStroke(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteAllMotionPaths(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DetachVertexComponent(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateConstraintOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_conform(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def STRSTweakModeOn(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def listInputDevices(*args, free=True, primary=True, secondary=True, **kwargs):
    """
    This command lists all input devices that maya knows about
    
    :param free: (C) List the free devices
    :type free: boolean
    :param primary: (C) List the primary devices
    :type primary: boolean
    :param secondary: (C) List the secondary devices
    :type secondary: boolean
    
    :returns: Command result
    :rtype: string[]
    """
    pass


def MakePondBoats(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowNRigids(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SculptMeshUnfreezeAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowHairSystems(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RigidBindSkinOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyColorDel(*args, caching=True, colorSetName="", constructionHistory=True, name="",
                 nodeState=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Deletes color from selected components
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param colorSetName: (C Q E) The name of the color set to work on
    :type colorSetName: string
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def SelectUVNonOverlappingComponentsPerObject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DisplayIntermediateObjects(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowNCloths(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MergeVertices(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ConnectNodeToIKFK(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def hikRigAlign(*args, **kwargs):
    """
    
    """
    pass


def hikManip(*args, **kwargs):
    """
    
    """
    pass


def polyCollapseEdge(*args, caching=True, constructionHistory=True, name="", nodeState=0,
                     q=True, query=True, e=True, edit=True, **kwargs):
    """
    Turns each selected edge into a point
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def NodeEditorShapeMenuStateNoShapes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreatePolygonPyramidOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TrimTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TangentsFlat(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def timeEditorTracks(*args, activeClipWeight=None, activeClipWeightId=None, addTrack=0,
                     allClips=True, allTracks=True, allTracksRecursive=True, composition=True,
                     path="", plugIndex=0, removeTrack=0, removeTrackByPath="",
                     reorderTrack=None, resetMute=True, resetSolo=True, selectedTracks=True,
                     trackGhost=True, trackIndex=0, trackMuted=True, trackName="",
                     trackSolo=True, trackType=1, q=True, query=True, e=True, edit=True,
                     **kwargs):
    """
    Time Editor tracks commands
    
    :param activeClipWeight: (Q) Get the clip weight at the specified time
    :type activeClipWeight: time
    :param activeClipWeightId: (Q) Get the clip ID carrying the active clip weight at the
    specified time
    :type activeClipWeightId: time
    :param addTrack: (E) Add new track at the track index specified  Indices are 0-based 
    Specify -1 to add the track at the end
    :type addTrack: int
    :param allClips: (Q) Return a list of clip IDs under the specified track
    :type allClips: boolean
    :param allTracks: (Q) Return a list of strings for all the immediate tracks for the given
    tracks node in the format "tracksNode:trackIndex"
    :type allTracks: boolean
    :param allTracksRecursive: (Q) Return a list of strings for all the tracks for the given
    tracks node, or return a list of strings for all tracks of all tracks nodes in the format
    "
    :type allTracksRecursive: boolean
    :param composition: (Q) Return the composition the specified track belongs to
    :type composition: boolean
    :param path: (E) Full path of a track node or a track on which to operate  For example:
    composition1|track1|group; composition1|track1  In query mode, this flag can a
    :type path: string
    :param plugIndex: (Q E) Get the plug index of the specified track
    :type plugIndex: int
    :param removeTrack: (E M) Remove track at given index  It is a multi-use flag
    :type removeTrack: int
    :param removeTrackByPath: (E M) Remove track at given path  It is a multi-use flag  For
    example: composition1|track1|group|track1;
    :type removeTrackByPath: string
    :param reorderTrack: (E) Move the track relative to other tracks  The first argument is the
    track index (0-based)  The second argument can be a positive or negative number to
    :type reorderTrack: [int, int]
    :param resetMute: (C) Reset all the muted tracks in the active composition
    :type resetMute: boolean
    :param resetSolo: (C) Reset the soloing of all tracks on the active composition
    :type resetSolo: boolean
    :param selectedTracks: (Q) Return a list of the indices for all the selected tracks for the
    given tracks node, or return a list of strings for all selected tracks of all tracks
    :type selectedTracks: boolean
    :param trackGhost: (Q E) Ghost all clips under track
    :type trackGhost: boolean
    :param trackIndex: (Q E) Specify the track index  This flag is used in conjunction with the
    other flags  In query mode, this flag can accept a value
    :type trackIndex: int
    :param trackMuted: (Q E) Return whether the track is muted
    :type trackMuted: boolean
    :param trackName: (Q E) Display name of the track
    :type trackName: string
    :param trackSolo: (Q E) Return whether the track is soloed
    :type trackSolo: boolean
    :param trackType: (Q E) Specify the track type  Can only be used together with -at/addTrack
     Does not work by itself  In query mode, return the integer corresponding to the
    :type trackType: int
    
    :returns: In edit mode, return the newly created Track index.
    :rtype: Int
    """
    pass


def FlipTubeDirection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AnimLayerRelationshipEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def hotkeyCtx(*args, addClient="", clientArray=True, currentClient="", insertTypeAt=None,
              removeAllClients=True, removeClient="", removeType="", type="", typeArray=True,
              typeExists="", q=True, query=True, **kwargs):
    """
    This command sets the hotkey context for the entire application
    
    :param addClient: (C M) Associates a client to the given hotkey context type  This flag
    needs to be used with the flag "type" which specifies the context type
    :type addClient: string
    :param clientArray: (Q) Returns an array of the all context clients associated to the
    hotkey context type  This flag needs to be used with the flag "type" which specifies th
    :type clientArray: boolean
    :param currentClient: (C Q) Current client for the given hotkey context type  This flag
    needs to be used with the flag "type" which specifies the context type
    :type currentClient: string
    :param insertTypeAt: (C) Inserts a new hotkey context type in the front of the given type 
    The first argument specifies an existing type  If it's empty, the new context type
    :type insertTypeAt: [string, string]
    :param removeAllClients: (C) Removes all the clients associated to the hotkey context type 
    This flag needs to be used with the flag "type" which specifies the context type
    :type removeAllClients: boolean
    :param removeClient: (C M) Removes a client associated to the hotkey context type  This
    flag needs to be used with the flag "type" which specifies the context type
    :type removeClient: string
    :param removeType: (C) Removes the given hotkey context type
    :type removeType: string
    :param type: (C Q) Specifies the context type  It's used together with the other flags such
    as "currentClient", "addClient", "removeClient" and so on
    :type type: string
    :param typeArray: (Q) Returns a string array containing the names of all hotkey context
    types, ordered by priority
    :type typeArray: boolean
    :param typeExists: (Q) Returns true|false depending upon whether the specified hotkey
    context type exists  In query mode, this flag needs a value
    :type typeExists: string
    
    :returns: 
    :rtype: None
    """
    pass


def dR_viewBack(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dynWireCtx(*args, **kwargs):
    """
    
    """
    pass


def loadPrefObjects(*args, **kwargs):
    """
    This command loads preference dependency nodes from "userPrefObjects.ma", if it exists,
    from the user preference directory
    
    
    :returns: True if successful.
    :rtype: boolean
    """
    pass


def polyCompare(*args, colorSetIndices=True, colorSets=True, edges=True, faceDesc=True,
                userNormals=True, uvSetIndices=True, uvSets=True, vertices=True, **kwargs):
    """
    Compares two Polygonal Geometry objects with a fine control on what to compare
    
    :param colorSetIndices: (C) Compare poly1, poly2 for matching Color Indices
    :type colorSetIndices: boolean
    :param colorSets: (C) Compare poly1, poly2 for matching Color Sets
    :type colorSets: boolean
    :param edges: (C) Compare poly1, poly2 for matching Edges
    :type edges: boolean
    :param faceDesc: (C) Compare poly1, poly2 for matching Face Descriptions  Face descriptions
    describe the topology of a face, for example number and orientation of edges,
    :type faceDesc: boolean
    :param userNormals: (C) Compare poly1, poly2 for matching User Normals
    :type userNormals: boolean
    :param uvSetIndices: (C) Compare poly1, poly2 for matching UV Indices
    :type uvSetIndices: boolean
    :param uvSets: (C) Compare poly1, poly2 for matching UV Sets
    :type uvSets: boolean
    :param vertices: (C) Compare poly1, poly2 for matching Vertices
    :type vertices: boolean
    
    :returns: 0 if successful, non-zero if poly1 and poly2 are not determined to be equal based
    on requested flags.
    The non-zero value depends on which attributes are different:
    
    Vertices
    = 1          
    Edges = 2             
    Face Descriptions = 4 
    UV Sets = 8           
    UV
    Indices = 16       
    Color Sets = 32       
    Color Indices = 64    
    User Normals = 128   
    
    
    So a return value of 3, for example, indicates both vertices and edges are different.
    :rtype: int
    """
    pass


def softMod(*args, after=True, afterReference=True, before=True, bindState=True,
            curveInterpolation=0, curvePoint=0.0, curveValue=0.0, deformerTools=True,
            envelope=1.0, exclusive="", falloffAroundSelection=True, falloffBasedOnX=True,
            falloffBasedOnY=True, falloffBasedOnZ=True, falloffCenter=None, falloffMasking=True,
            falloffMode=0, falloffRadius=0.0, frontOfChain=True, geometry="",
            geometryIndices=True, ignoreSelected=True, includeHiddenSelections=False, name="",
            parallel=True, prune=True, relative=True, remove=True, resetGeometry=True,
            split=True, weightedNode=None, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The softMod command creates a softMod or edits the membership of an existing softMod  The
    command returns the name of the softMod node upon creation of a new softMod
    
    :param after: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type after: boolean
    :param afterReference: (C E) The -afterReference flag is used to specify deformer ordering
    in a hybrid way that choses between -before and -after automatically  If the geometry b
    :type afterReference: boolean
    :param before: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type before: boolean
    :param bindState: (C) Specifying this flag adds in a compensation to ensure the softModed
    objects preserve their spatial position when softModed  This is required to preve
    :type bindState: boolean
    :param curveInterpolation: (C M) Ramp interpolation corresponding to the specified
    curvePoint position  Integer values of 0-3 are valid, corresponding to "none", "linear",
    "smooth" a
    :type curveInterpolation: int
    :param curvePoint: (C M) Position of ramp value on normalized 0-1 scale  This flag may only
    be used in conjunction with the curveInterpolation and curveValue flags
    :type curvePoint: float
    :param curveValue: (C M) Ramp value corresponding to the specified curvePoint position 
    This flag may only be used in conjunction with the curveInterpolation and curvePoint f
    :type curveValue: float
    :param deformerTools: (Q) Returns the name of the deformer tool objects (if any) as string
    string ..
    :type deformerTools: boolean
    :param envelope: (C Q E) Set the envelope value for the deformer  Default is 1.0
    :type envelope: float
    :param exclusive: (C Q) Puts the deformation set in a deform partition
    :type exclusive: string
    :param falloffAroundSelection: (C) Falloff will be calculated around any selected
    components
    :type falloffAroundSelection: boolean
    :param falloffBasedOnX: (C) Falloff will be calculated using the X component
    :type falloffBasedOnX: boolean
    :param falloffBasedOnY: (C) Falloff will be calculated using the Y component
    :type falloffBasedOnY: boolean
    :param falloffBasedOnZ: (C) Falloff will be calculated using the Z component
    :type falloffBasedOnZ: boolean
    :param falloffCenter: (C) Set the falloff center point of the softMod
    :type falloffCenter: [float, float, float]
    :param falloffMasking: (C) Deformation will be restricted to selected components
    :type falloffMasking: boolean
    :param falloffMode: (C) Set the falloff method used for the softMod
    :type falloffMode: int
    :param falloffRadius: (C) Set the falloff radius of the softMod
    :type falloffRadius: float
    :param frontOfChain: (C E) This command is used to specify that the new deformer node
    should be placed ahead (upstream) of existing deformer and skin nodes in the shape's histo
    :type frontOfChain: boolean
    :param geometry: (Q E M) The specified object will be added to the list of objects being
    deformed by this deformer object, unless the -rm flag is also specified  When queried
    :type geometry: string
    :param geometryIndices: (Q) Complements the -geometry flag in query mode  Returns the multi
    index of each geometry
    :type geometryIndices: boolean
    :param ignoreSelected: (C) Tells the command to not deform objects on the current selection
    list
    :type ignoreSelected: boolean
    :param includeHiddenSelections: (C) Apply the deformer to any visible and hidden objects in
    the selection list  Default is false
    :type includeHiddenSelections: boolean
    :param name: (C) Used to specify the name of the node being created
    :type name: string
    :param parallel: (C E) Inserts the new deformer in a parallel chain to any existing
    deformers in the history of the object  A blendShape is inserted to blend the parallel r
    :type parallel: boolean
    :param prune: (E) Removes any points not being deformed by the deformer in its current
    configuration from the deformer set
    :type prune: boolean
    :param relative: (C) Enable relative mode for the softMod  In relative mode, Only the
    transformations directly above the softMod are used by the softMod  Default is off
    :type relative: boolean
    :param remove: (E M) Specifies that objects listed after the -g flag should be removed from
    this deformer
    :type remove: boolean
    :param resetGeometry: (E) Reset the geometry matrices for the objects being deformed by the
    softMod  This flag is used to get rid of undesirable effects that happen if you sca
    :type resetGeometry: boolean
    :param split: (C E) Branches off a new chain in the dependency graph instead of
    inserting/appending the deformer into/onto an existing chain  Works in create mode (and e
    :type split: boolean
    :param weightedNode: (C Q E) Transform node in the DAG above the softMod to which all
    percents are applied  The second node specifies the descendent of the first node from
    where
    :type weightedNode: [string, string]
    
    :returns: [] (the softMod node name and the softMod handle name)
    :rtype: string
    """
    pass


def AddSelectionAsCombinationTarget(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSetClumpBrushTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateCurveFromPoly(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Vortex(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSetWidthBrushToolOption(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def snapTogetherCtx(*args, clearSelection=True, exists=True, history=True, image1="", image2="",
                    image3="", name="", setOrientation=True, snapPolygonFace=False, q=True,
                    query=True, e=True, edit=True, **kwargs):
    """
    The snapTogetherCtx command creates a tool for snapping surfaces together
    
    :param clearSelection: (C Q E) Sets whether the tool should clear the selection on entry to
    the tool  Default true
    :type clearSelection: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param setOrientation: (C Q E) Sets whether the tool should orient as well as moving an
    item  Default true
    :type setOrientation: boolean
    :param snapPolygonFace: (C Q E) Sets whether the tool should snap the cursor to polygon
    face centers  Default false
    :type snapPolygonFace: boolean
    
    :returns: (name of the new context)
    :rtype: string
    """
    pass


def stringArrayIntersector(*args, allowDuplicates=False, defineTemplate="", exists=True,
                           intersect=None, reset=True, useTemplate="", q=True, query=True,
                           e=True, edit=True, **kwargs):
    """
    The stringArrayIntersector command creates and edits an object which is able to efficiently
    intersect large string arrays  The intersector object maintains a sense of "the
    intersection so far", and updates the intersection when new string arrays are provided
    using the -i/intersect flag   Note that the string intersector object may be deleted using
    
    
    :param allowDuplicates: (C) Should the intersector allow duplicates in the input arrays
    (true), or combine all duplicate entries into a single, unique entry (false)  This flag m
    :type allowDuplicates: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param intersect: (C E) Intersect the specified string array with the current intersection
    being maintained by the intersector
    :type intersect: string[]
    :param reset: (E) Reset the intersector to begin a new intersection
    :type reset: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: The name of the intersector.
    :rtype: string
    """
    pass


def ToggleShelf(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateOcean(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SnapToCurve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RotateToolMarkingMenuPopDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NonSacredTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sets(*args, addElement=None, afterFilters=True, clear=None, color=0, copy=None, edges=True,
         editPoints=True, empty=True, facets=True, flatten=None, forceElement=None,
         include=None, intersection=None, isIntersecting=None, isMember=None, layer=True,
         name="", noSurfaceShader=True, noWarnings=True, nodesOnly=True, remove=None,
         renderable=True, size=True, split=None, subtract=None, text="", union=None,
         vertices=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command is used to create a set, query some state of a set, or perform operations to
    update the membership of a set  A set is a logical grouping of an arbitrary collection of
    objects, attributes, or components of objects  Sets are dependency nodes  Connections from
    objects to a set define membership in the set   Sets are used throughout Maya i
    
    :param addElement: (E) Adds the list of items to the given set  If some of the items cannot
    be added to the set because they are in another set which is in the same partiti
    :type addElement: name
    :param afterFilters: (E) Default state is false  This flag is valid in edit mode only  This
    flag is for use on sets that are acted on by deformers such as sculpt, lattice, bl
    :type afterFilters: boolean
    :param clear: (E) An operation which removes all items from the given set making the set
    empty
    :type clear: name
    :param color: (C Q E) Defines the hilite color of the set  Must be a value in range [-1, 7]
    (one of the user defined colors)  -1 marks the color has being undefined and th
    :type color: int
    :param copy: (C) Copies the members of the given set to a new set  This flag is for use in
    creation mode only
    :type copy: name
    :param edges: (C Q) Indicates the new set can contain edges only  This flag is for use in
    creation or query mode only  The default value is false
    :type edges: boolean
    :param editPoints: (C Q) Indicates the new set can contain editPoints only  This flag is
    for use in creation or query mode only  The default value is false
    :type editPoints: boolean
    :param empty: (C) Indicates that the set to be created should be empty  That is, it ignores
    any arguments identifying objects to be added to the set  This flag is only
    :type empty: boolean
    :param facets: (C Q) Indicates the new set can contain facets only  This flag is for use in
    creation or query mode only  The default value is false
    :type facets: boolean
    :param flatten: (E) An operation that flattens the structure of the given set  That is, any
    sets contained by the given set will be replaced by its members so that the s
    :type flatten: name
    :param forceElement: (E) For use in edit mode only  Forces addition of the items to the set
     If the items are in another set which is in the same partition as the given set,
    :type forceElement: name
    :param include: (E) Adds the list of items to the given set  If some of the items cannot be
    added to the set, a warning will be issued  This is a less strict version of
    :type include: name
    :param intersection: (C) An operation that returns a list of items which are members of all
    the sets in the list
    :type intersection: name
    :param isIntersecting: (C) An operation which tests whether the sets in the list have
    common members
    :type isIntersecting: name
    :param isMember: (C) An operation which tests whether all the given items are members of
    the given set
    :type isMember: name
    :param layer: (C) OBSOLETE  DO NOT USE
    :type layer: boolean
    :param name: (C) Assigns string as the name for a new set  This flag is only valid for
    operations that create a new set
    :type name: string
    :param noSurfaceShader: (C) If set is renderable, do not connect it to the default surface
    shader  Flag has no meaning or effect for non renderable sets  This flag is for use in
    :type noSurfaceShader: boolean
    :param noWarnings: (C) Indicates that warning messages should not be reported such as when
    trying to add an invalid item to a set  (used by UI)
    :type noWarnings: boolean
    :param nodesOnly: (Q) This flag is usable with the -q/query flag but is ignored if used
    with another queryable flags  This flag modifies the results of the set membership
    :type nodesOnly: boolean
    :param remove: (E) Removes the list of items from the given set
    :type remove: name
    :param renderable: (C Q) This flag indicates that a special type of set should be created 
    This type of set (shadingEngine as opposed to objectSet) has certain restrictions o
    :type renderable: boolean
    :param size: (Q) Use the size flag to query the length of the set
    :type size: boolean
    :param split: (C) Produces a new set with the list of items and removes each item in the
    list of items from the given set
    :type split: name
    :param subtract: (C) An operation between two sets which returns the members of the first
    set that are not in the second set
    :type subtract: name
    :param text: (C Q E) Defines an annotation string to be stored with the set
    :type text: string
    :param union: (C) An operation that returns a list of all the members of all sets listed
    :type union: name
    :param vertices: (C Q) Indicates the new set can contain vertices only  This flag is for
    use in creation or query mode only  The default value is false
    :type vertices: boolean
    
    :returns: For creation operations (name of the set that was created or edited)
    :rtype: string
    """
    pass


def CycleFBIKReachKeyingOption(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddBifrostGuide(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ReversePolygonNormalsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DisableTimeChangeUndoConsolidation(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GraphEditorNormalizedView(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ProfilerToolReset(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def stitchSurfacePoints(*args, bias=1.0, caching=True, cvIthIndex=1, cvJthIndex=1,
                        fixBoundary=False, nodeState=0, parameterU=10000, parameterV=10000,
                        positionalContinuity=True, stepCount=20, tangentialContinuity=False,
                        togglePointNormals=False, togglePointPosition=True,
                        toggleTolerance=False, tolerance=0.1, cascade=False,
                        constructionHistory=True, equalWeight=True, keepG0Continuity=True,
                        keepG1Continuity=False, name="", object=True, replaceOriginal=True,
                        q=True, query=True, e=True, edit=True, **kwargs):
    """
    The stitchSurfacePoints command aligns two or more surface points along the boundaries
    together to a single point  In the process, a node to average the points is created  The
    points are averaged together in a weighted fashion  The points may be control vertices
    along the boundaries  If the points are CVs then they are stitched together only with
    p
    
    :param bias: (C Q E) Blend CVs in between input surface and result from stitch  A value of
    0.0 returns the input surface  Default: 1.0
    :type bias: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param cvIthIndex: (C Q E M) The ith boundary CV index on the input surface  Default: -1
    :type cvIthIndex: int
    :param cvJthIndex: (C Q E M) The jth boundary CV index on the input surface  Default: -1
    :type cvJthIndex: int
    :param fixBoundary: (C Q E) Fix Boundary CVs while solving for any G1 constraints  Default:
    false
    :type fixBoundary: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param parameterU: (C Q E M) The U parameter value on surface for a point constraint 
    Default: -10000
    :type parameterU: float
    :param parameterV: (C Q E M) The V parameter value on surface for a point constraint 
    Default: -10000
    :type parameterV: float
    :param positionalContinuity: (C Q E M) Toggle on (off) G0 continuity at edge corresponding
    to multi index  Default: true
    :type positionalContinuity: boolean
    :param stepCount: (C Q E M) Step count for the number of discretizations  Default: 20
    :type stepCount: int
    :param tangentialContinuity: (C Q E M) Toggle on (off) G1 continuity across edge
    corresponding to multi index  Default: false
    :type tangentialContinuity: boolean
    :param togglePointNormals: (C Q E) Toggle on (off) normal point constraints on the surface 
    Default: false
    :type togglePointNormals: boolean
    :param togglePointPosition: (C Q E) Toggle on (off) position point constraints on the
    surface  Default: true
    :type togglePointPosition: boolean
    :param toggleTolerance: (C Q E M) Toggle on (off) so as to use Tolerance or specified steps
    for discretization  Default: false
    :type toggleTolerance: boolean
    :param tolerance: (C Q E M) Tolerance to use while discretizing the edge  Default: 0.1
    :type tolerance: float
    :param cascade: (C) Cascade the created stitch node  (Only if the surface has a stitch
    history) Default is 'false'
    :type cascade: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param equalWeight: (C) Assign equal weights to all the points being stitched together 
    Default is 'true'  If false, the first point is assigned a weight of 1.0 and the rest
    :type equalWeight: boolean
    :param keepG0Continuity: (C) Stitch together the points with positional continuity  Default
    is 'true'
    :type keepG0Continuity: boolean
    :param keepG1Continuity: (C) Stitch together the points with tangent continuity  Default is
    'false'
    :type keepG1Continuity: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def PolyExtrudeFaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def trackCtx(*args, alternateContext=True, exists=True, history=True, image1="", image2="",
             image3="", name="", toolName="", trackGeometry=True, trackScale=0.0, q=True,
             query=True, e=True, edit=True, **kwargs):
    """
    This command can be used to create a track context
    
    :param alternateContext: (C Q) Set the ALT+MMB and ALT+SHIFT+MMB to refer to this context
    :type alternateContext: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param toolName: (C Q) Name of the specific tool to which this command refers
    :type toolName: string
    :param trackGeometry: (C Q E) Toggle whether the drag should try to track geometry  The
    context will compute a track plane by intersecting the initial press with geometry or the
    l
    :type trackGeometry: boolean
    :param trackScale: (C Q E) Specify the distance to the track plane from the camera  The
    smaller the scale the slower the drag
    :type trackScale: float
    
    :returns: The name of the context
    :rtype: string
    """
    pass


def ProfilerToolShowSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NURBSSmoothnessFineOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_activeHandleXYZ(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def EnableParticles(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def undo(*args, **kwargs):
    """
    Takes the most recent command from the undo list and undoes it
    
    
    :returns: 
    :rtype: None
    """
    pass


def subdLayoutUV(*args, caching=True, nodeState=0, constructionHistory=True, flipReversed=True,
                 layout=0, layoutMethod=0, name="", percentageSpace=0.0, rotateForBestFit=0,
                 scale=0, separate=0, worldSpace=True, q=True, query=True, e=True, edit=True,
                 **kwargs):
    """
    Move UVs in the texture plane to avoid overlaps
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param flipReversed: (C Q E) If this flag is turned on, the reversed UV pieces are fliped
    :type flipReversed: boolean
    :param layout: (C Q E) How to move the UV pieces, after cuts are applied: 0 No move is
    applied  1 Layout the pieces along the U axis  2 Layout the pieces in a square shape
    :type layout: int
    :param layoutMethod: (C Q E) Which layout method to use: 0 Block Stacking  1 Shape
    Stacking
    :type layoutMethod: int
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param percentageSpace: (C Q E) When layout is set to square, this value is a percentage of
    the texture area which is added around each UV piece  It can be used to ensure each UV pi
    :type percentageSpace: float
    :param rotateForBestFit: (C Q E) 0 No rotation is applied  1 Only allow 90 degree rotations
     2 Allow free rotations
    :type rotateForBestFit: int
    :param scale: (C Q E) How to scale the pieces, after move and cuts: 0 No scale is applied 
    1 Uniform scale to fit in unit square  2 Non proportional scale to fit in unit s
    :type scale: int
    :param separate: (C Q E) Which UV edges should be cut: 0 No cuts  1 Cut only along folds  2
    Make all necessary cuts to avoid all intersections
    :type separate: int
    :param worldSpace: (C Q E) If true, performs the operation in world space coordinates as
    opposed to local space
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def mpBirailCtx(*args, **kwargs):
    """
    
    """
    pass


def u3dTopoValid(*args, **kwargs):
    """
    
    """
    pass


def AssignHairConstraintOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CustomPolygonDisplay(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowMeshScrapeToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PointOnPolyConstraintOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateDirectionalLightOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_tweakRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def EnableAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def refreshEditorTemplates(*args, **kwargs):
    """
    This command refreshes all cached attribute editor templates, including those copied from
    the standard AE  These are the templates constructed internally on a per node type basis 
    This is useful if attribute elements have changed and the templates need to be re-evaluated
    accordingly
    
    
    :returns: 
    :rtype: None
    """
    pass


def MatchTranslation(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SurfaceFlowOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExtrudeEdgeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorSelectDownStream(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddToContainer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateHair(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TestTextureOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeOpenBrowserWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyDelEdge(*args, caching=True, cleanVertices=True, constructionHistory=True, name="",
                nodeState=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Deletes selected edges, and merges neighboring faces  If deletion leaves winged vertices,
    they may be deleted as well
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param cleanVertices: (C Q E) If on : delete resulting winged vertices  C: Default is "off"
     Q: When queried, this flag returns an int
    :type cleanVertices: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def ProfilerToolShowSelectedRepetition(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def clipMatching(*args, clipDst=None, clipSrc=None, matchRotation=0, matchTranslation=0,
                 **kwargs):
    """
    This command is used to compute an offset to apply on a source clip in order to
    automatically align it to a destination clip at a specified match element  For this command
    to work, offset objects must be specified for the character
    
    :param clipDst: (C) The clip to match so that the source clip can be offsetted correctly 
    This flag takes in a clip name and the percentage value ranging from 0.0 to 1.0
    :type clipDst: [string, float]
    :param clipSrc: (C) The clip to offset so that it aligns with the destination clip  This
    flag takes in a clip name and the percentage value ranging from 0.0 to 1.0 in or
    :type clipSrc: [string, float]
    :param matchRotation: (C) This flag sets the rotation match type  By default, it is set to
    not match the rotation  0 - None 1 - Match full rotation 2 - Match projected rotatio
    :type matchRotation: int
    :param matchTranslation: (C) This flag sets the translation match type  By default, it is
    set to not match the translation  0 - None 1 - Match full translation 2 - Match projecte
    :type matchTranslation: int
    
    :returns: 
    :rtype: None
    """
    pass


def XgmSetSelectBrushTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NormalizeUVsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def condition(*args, delete=True, dependency="", initialize=True, script="", state=True, q=True,
              query=True, e=True, edit=True, **kwargs):
    """
    This command creates a new named condition object whose true/false value is calculated by
    running a mel script  This new condition can then be used for dimming, or controlling other
    scripts, or whatever
    
    :param delete: (C) Deletes the condition
    :type delete: boolean
    :param dependency: (C M) Each -dependency flag specifies another condition that the new
    condition will be dependent on  When any of these conditions change, the new-state-scr
    :type dependency: string
    :param initialize: (C) Initializes the condition, by forcing it to run its script as soon
    as it is created  If this flag is not specified, the script will not run until one
    :type initialize: boolean
    :param script: (C) The script that determines the new state of the condition
    :type script: string
    :param state: (C Q E) Sets the state of the condition  This can be used to create a
    manually triggered condition: you could create a condition without any dependencies and
    :type state: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def TwoPointArcToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GrowPolygonSelectionRegion(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def makeLive(*args, none=True, **kwargs):
    """
    This commmand makes an object live  A live object defines the surface on which to create
    objects and to move object relative to  Only construction planes, nurbs surfaces and
    polygon meshes can be made live   The makeLive command expects one of these types of
    objects as an explicit argument  If no argument is explicitly specified, then there are a
    n
    
    :param none: (C) If the -n/none flag, the live object will become dormant  Use of this flag
    causes any arguments to be ignored
    :type none: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def fluidDeleteCacheFrames(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def blendShapeEditor(*args, control=True, defineTemplate="", docTag="", exists=True, filter="",
                     forceMainConnection="", highlightConnection="", lockMainConnection=True,
                     mainListConnection="", panel="", parent="", selectionConnection="",
                     stateString=True, targetControlList=True, targetList=True, unParent=True,
                     unlockMainConnection=True, updateMainConnection=True, useTemplate="",
                     verticalSliders=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates an editor that derives from the base editor class that has controls
    for blendShape, control nodes
    
    :param control: (Q) Query only  Returns the top level control for this editor  Usually used
    for getting a parent to attach popup menus  Caution: It is possible for an ed
    :type control: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Attaches a tag to the editor
    :type docTag: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param filter: (C Q E) Specifies the name of an itemFilter object to be used with this
    editor  This filters the information coming onto the main list of the editor
    :type filter: string
    :param forceMainConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type forceMainConnection: string
    :param highlightConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its highlight list  Not all editors have a highlight list 
    F
    :type highlightConnection: string
    :param lockMainConnection: (C E) Locks the current list of objects within the
    mainConnection, so that only those objects are displayed within the editor  Further changes
    to the origi
    :type lockMainConnection: boolean
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type mainListConnection: string
    :param panel: (C Q) Specifies the panel for this editor  By default if an editor is created
    in the create callback of a scripted panel it will belong to that panel  If a
    :type panel: string
    :param parent: (C Q E) Specifies the parent layout for this editor  This flag will only
    have an effect if the editor is currently un-parented
    :type parent: string
    :param selectionConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its own selection list  As the user selects things in this
    e
    :type selectionConnection: string
    :param stateString: (Q) Query only flag  Returns the MEL command that will create an editor
    to match the current editor state  The returned command string uses the string va
    :type stateString: boolean
    :param targetControlList: (Q) 
    :type targetControlList: boolean
    :param targetList: (Q) 
    :type targetList: boolean
    :param unParent: (C E) Specifies that the editor should be removed from its layout  This
    cannot be used in query mode
    :type unParent: boolean
    :param unlockMainConnection: (C E) Unlocks the mainConnection, effectively restoring the
    original mainConnection (if it is still available), and dynamic updates
    :type unlockMainConnection: boolean
    :param updateMainConnection: (C E) Causes a locked mainConnection to be updated from the
    orginal mainConnection, but preserves the lock state
    :type updateMainConnection: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param verticalSliders: (C Q E) 
    :type verticalSliders: boolean
    
    :returns: The name of the editor
    :rtype: string
    """
    pass


def TimeEditorClipScaleStart(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RepeatLastActionAtMousePosition(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AnimationSweep(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CutCurve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def matchTransform(*args, pivots=True, position=True, rotation=True, scale=True, **kwargs):
    """
    This command modifies the source object's transform to match the target object's transform 
     If no flags are specified then the command will match position, rotation and scaling
    
    :param pivots: (C) Match the source object(s) scale/rotate pivot positions to the target
    transform's pivot
    :type pivots: boolean
    :param position: (C) Match the source object(s) position to the target object
    :type position: boolean
    :param rotation: (C) Match the source object(s) rotation to the target object
    :type rotation: boolean
    :param scale: (C) Match the source object(s) scale to the target transform
    :type scale: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def DeleteAttribute(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polySplitCtx(*args, enablesnap=True, exists=True, image1="", image2="", image3="",
                 magnetsnap=0, precsnap=0.0, smoothingangle=0.0, snaptoedge=True, subdivision=1,
                 q=True, query=True, e=True, edit=True, **kwargs):
    """
    Create a new context to split facets on polygonal objects
    
    :param enablesnap: (C Q E) Enable/disable custom magnet snapping to start/middle/end of
    edge
    :type enablesnap: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param magnetsnap: (C Q E) number of extra magnets to snap onto, regularly spaced along the
    edge
    :type magnetsnap: int
    :param precsnap: (C Q E) precision for custom magnet snapping  Range[0,100]  Value 100
    means any click on an edge will snap to either extremities or magnets
    :type precsnap: float
    :param smoothingangle: (C Q E) the threshold that controls whether newly created edges are
    hard or soft
    :type smoothingangle: float
    :param snaptoedge: (C Q E) Enable/disable snapping to edge  If enabled any click in the
    current face will snap to the closest valid edge  If there is no valid edge, the click w
    :type snaptoedge: boolean
    :param subdivision: (C Q E) number of sub-edges to add between 2 consecutive edge points 
    Default is 1
    :type subdivision: int
    
    :returns: 
    :rtype: None
    """
    pass


def HypergraphIncreaseDepth(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyCube(*args, axis=None, caching=True, constructionHistory=True, createUVs=3, depth=1.0,
             height=1.0, name="", nodeState=0, object=True, subdivisionsDepth=1,
             subdivisionsHeight=1, subdivisionsWidth=1, subdivisionsX=1, subdivisionsY=1,
             subdivisionsZ=1, texture=1, width=1.0, q=True, query=True, e=True, edit=True,
             **kwargs):
    """
    The cube command creates a new polygonal cube
    
    :param axis: (C Q E) This flag specifies the primitive axis used to build the cube  Q: When
    queried, this flag returns a float[3]
    :type axis: [float, float, float]
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param createUVs: (C Q E) Create UVs or not  0: No UVs 1: No Normalization 2: Normalize
    Each Face Separately 3: Normalize Collectively 4: Normalize and Preserve Aspect Ratio D
    :type createUVs: int
    :param depth: (C Q E) Depth of the cube  Default: 1.0
    :type depth: float
    :param height: (C Q E) Height of the cube  Default: 1.0
    :type height: float
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param object: (C) Create the result, or just the dependency node (where applicable)
    :type object: boolean
    :param subdivisionsDepth: (C Q E) Subdivisions along the depth of the cube  Default: 1
    :type subdivisionsDepth: int
    :param subdivisionsHeight: (C Q E) Subdivisions along the height of the cube  Default: 1
    :type subdivisionsHeight: int
    :param subdivisionsWidth: (C Q E) Subdivisions along the width of the cube  Default: 1
    :type subdivisionsWidth: int
    :param subdivisionsX: (C Q E) This specifies the number of subdivisions in the X direction
    for the cube  C: Default is 1  Q: When queried, this flag returns an int
    :type subdivisionsX: int
    :param subdivisionsY: (C Q E) This flag specifies the number of subdivisions in the Y
    direction for the cube  C: Default is 1  Q: When queried, this flag returns an int
    :type subdivisionsY: int
    :param subdivisionsZ: (C Q E) This flag specifies the number of subdivisions in the Z
    direction for the cube  C: Default is 1  Q: When queried, this flag returns an int
    :type subdivisionsZ: int
    :param texture: (C Q E) What texture mechanism to be applied 0=No textures; 1=Object;
    2=Faces Default: 1
    :type texture: int
    :param width: (C Q E) Width of the cube  Default: 1.0
    :type width: float
    
    :returns: Object name and node name.
    :rtype: string[]
    """
    pass


def gradientControl(*args, adaptiveScaling=True, annotation="", attribute=None,
                    backgroundColor=None, defineTemplate="", docTag="", dragCallback=None,
                    dropCallback=None, enable=True, enableBackground=True,
                    enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
                    highlightColor=None, isObscured=True, manage=True, noBackground=True,
                    numberOfControls=0, numberOfPopupMenus=True, parent="", popupMenuArray=True,
                    preventOverride=True, refreshOnRelease=0, selectedColorControl="",
                    selectedInterpControl="", selectedPositionControl="",
                    staticNumberOfControls=False, staticPositions=False, statusBarMessage="",
                    upperLimitControl="", useTemplate="", verticalLayout=False, visible=True,
                    visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
                    **kwargs):
    """
    This command creates a control that displays the gradient attribute specified  The gradient
    attribute must be of the correct form and naming  It should be a multi attribute with each
    entry a compound composed of:  Either a color compound or a float value (the control will
    automatically detect which and display a ramp or graph accordingly)  A single
    
    :param adaptiveScaling: (C Q E) Allow the ramp widget display to scale vertically to
    accommodate values greater than 1.0  True if adaptive scaling is enabled, false (the
    default) if
    :type adaptiveScaling: boolean
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param attribute: (C) Specifies the name of the gradient attribute to control
    :type attribute: name
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfControls: (Q) Returns the number of controls in the ramp widget
    :type numberOfControls: int
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param refreshOnRelease: (C Q E) Define how updates are dispatched during interactive
    editing of the ramp widget  True causes updates to only dispatch after releasing the mouse
    butto
    :type refreshOnRelease: int
    :param selectedColorControl: (C E) Specifies the name of a color control to edit the
    selected color
    :type selectedColorControl: string
    :param selectedInterpControl: (C E) Specifies the name of an enum control to edit the
    selected interpolation
    :type selectedInterpControl: string
    :param selectedPositionControl: (C E) Specifies the name of a float slider to edit the
    selected position
    :type selectedPositionControl: string
    :param staticNumberOfControls: (C Q E) When 'true', this flag disables the
    creation/deletion of ramp entries (control points) via ramp widget interaction  Default is
    false
    :type staticNumberOfControls: boolean
    :param staticPositions: (C Q E) When 'true', this flag disables the interactive
    modification of ramp entry positions  Default is false
    :type staticPositions: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param upperLimitControl: (C Q E) Specify the name of a text control which is updated with
    the current upper display limit for the ramp  This option is only effective when
    adaptiveSca
    :type upperLimitControl: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param verticalLayout: (C Q E) When 'true', this makes the control orient vertically rather
    than horizontally  The default is `false` or horizontal
    :type verticalLayout: boolean
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the port created or modified
    :rtype: string
    """
    pass


def FrameSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def viewManip(*args, bottomLeft=True, bottomRight=True, compassAngle=0.0, dragSnap=True,
              drawCompass=True, fitToView=True, frontParameters="", goDefault=True, goHome=True,
              homeParameters="", levelCamera=True, minOpacity=0.0, namespace="", postCommand="",
              preCommand="", preserveSceneUp=True, resetFront=True, resetHome=True,
              restoreCenter=True, selectionLockParameters="", setFront=True, setHome=True,
              size="", toggleSelectionLock=True, topLeft=True, topRight=True, visible=True,
              zoomToFitScene=True, q=True, query=True, **kwargs):
    """
    Mel access to the view cube manipulator
    
    :param bottomLeft: (C Q) Positions the cube in the bottom left of the screen
    :type bottomLeft: boolean
    :param bottomRight: (C Q) Positions the cube in the bottom right of the screen
    :type bottomRight: boolean
    :param compassAngle: (C Q) Angle (in degrees) to rotate the compass
    :type compassAngle: float
    :param dragSnap: (C Q) Enable snapping of orbit direction to view cube part directions
    during drag operation
    :type dragSnap: boolean
    :param drawCompass: (C Q) Show compass below the view cube
    :type drawCompass: boolean
    :param fitToView: (C) Fits the scene bounding box to the active view
    :type fitToView: boolean
    :param frontParameters: (C Q) Parameter string for the front position
    :type frontParameters: string
    :param goDefault: (C Q) Go to the default position
    :type goDefault: boolean
    :param goHome: (C Q) Go to the home position
    :type goHome: boolean
    :param homeParameters: (C Q) Parameter string for the home position
    :type homeParameters: string
    :param levelCamera: (C) Flattens the camera view rotation relative to the ground plane
    :type levelCamera: boolean
    :param minOpacity: (C Q) Opacity level (in range [0,1]) on view cube when the cursor is
    away from it (it is fully opaque when the cursor is in the view cube area)
    :type minOpacity: float
    :param namespace: (C Q) Namespace to use for the object
    :type namespace: string
    :param postCommand: (C Q) Command to run after moving
    :type postCommand: string
    :param preCommand: (C Q) Command to run before moving
    :type preCommand: string
    :param preserveSceneUp: (C Q) Specify whether the scene "up" direction should be preserved
    :type preserveSceneUp: boolean
    :param resetFront: (C Q) Reset the front position
    :type resetFront: boolean
    :param resetHome: (C Q) Reset the home position
    :type resetHome: boolean
    :param restoreCenter: (C) Repositions the pivot point for orbiting/tumbling the scene to
    the center of the scene's bounding box
    :type restoreCenter: boolean
    :param selectionLockParameters: (C Q) String containing the selection lock parameters
    :type selectionLockParameters: string
    :param setFront: (C) Set the front view to the current one
    :type setFront: boolean
    :param setHome: (C) Set the home view to the current one
    :type setHome: boolean
    :param size: (C Q) Set or query the size of the View Cube, which can be one of "tiny",
    "small", "normal", "large" or "auto"  When set to "auto" the View Cube will be au
    :type size: string
    :param toggleSelectionLock: (C) Toggle the selection lock
    :type toggleSelectionLock: boolean
    :param topLeft: (C Q) Positions the cube in the top left of the screen
    :type topLeft: boolean
    :param topRight: (C Q) Positions the cube in the top right of the screen
    :type topRight: boolean
    :param visible: (C Q) Shows/hides the view manip
    :type visible: boolean
    :param zoomToFitScene: (C Q) Zoom the camera during animated transitions to fit the scene
    object in the viewport
    :type zoomToFitScene: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def TimeEditorSceneAuthoringToggle(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddPondDynamicLocatorOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DecreaseCheckerDensity(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ChangeEdgeWidth(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ModifyPaintValuePress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def confirmDialog(*args, annotation="", backgroundColor=None, button="", cancelButton="",
                  defaultButton="", dismissString="", icon="", message="", messageAlign="",
                  parent="", title="", **kwargs):
    """
    The confirmDialog command creates a modal dialog with a message to the user and a variable
    number of buttons to dismiss the dialog  The dialog is dismissed when the user presses any
    button or chooses the close item from the window menu  In the case where a button is
    pressed then the name of the button selected is returned  If the dialog is dismisse
    
    :param annotation: (C M) set the annotation for the buttons
    :type annotation: string
    :param backgroundColor: (C) The background color of the dialog  The arguments correspond to
    the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type backgroundColor: [float, float, float]
    :param button: (C M) Create a button with the given string as it's text
    :type button: string
    :param cancelButton: (C) The cancel button is activated by pressing the escape key  Note
    that this flag does not create a button, it simply indicates which button created via
    :type cancelButton: string
    :param defaultButton: (C) The default button is activated by pressing the enter key  Note
    that this flag does not create a button, it simply indicates which button created via
    :type defaultButton: string
    :param dismissString: (C) The string returned when the user selects the 'Close' item from
    the Window Manager menu  If this flag is not set then the string "dismiss" is returne
    :type dismissString: string
    :param icon: (C) The user can specify one of the four standard icons -- "question",
    "information", "warning" and "critical"  The question icon indicates that the mess
    :type icon: string
    :param message: (C) The message text appearing in the dialog
    :type message: string
    :param messageAlign: (C) Align the message left, center, or right
    :type messageAlign: string
    :param parent: (C) Specify the parent window for the dialog  The dialog will be centered on
    this window and raise and lower with it's parent  By default, the dialog is
    :type parent: string
    :param title: (C) The dialog title
    :type title: string
    
    :returns: Indicates how the dialog was dismissed. If a button is
    pressed then the label of
    the button is returned. If the dialog is
    closed then the value for the flag dismissString
    is
    returned.
    :rtype: string
    """
    pass


def HypershadeGraphRemoveSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BakeCustomPivotOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UVAutomaticProjection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddBifrostCamera(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def scaleKey(*args, animation="keysOrObjects.", attribute="", controlPoints=False, float=None,
             floatPivot=0.0, floatScale=0.0, hierarchy="", includeUpperBound=True, index=0,
             newEndFloat=0.0, newEndTime=None, newStartFloat=0.0, newStartTime=None,
             scaleSpecifiedKeys=True, shape=True, time=None, timePivot=None, timeScale=0.0,
             valuePivot=0.0, valueScale=0.0, **kwargs):
    """
    This command operates on a keyset  A keyset is defined as a group of keys within a
    specified time range on one or more animation curves   The animation curves comprising a
    keyset depend on the value of the "-animation" flag:  keysOrObjects: Any active keys, when
    no target objects or -attribute flags appear on the command line, or All animation curv
    
    :param animation: (C) Where this command should get the animation to act on  Valid values
    are "objects," "keys," and "keysOrObjects" Default: "keysOrObjects." (See Descrip
    :type animation: string
    :param attribute: (C M) List of attributes to select In query mode, this flag needs a
    value
    :type attribute: string
    :param controlPoints: (C) This flag explicitly specifies whether or not to include the
    control points of a shape (see "-s" flag) in the list of attributes  Default: false  (No
    :type controlPoints: boolean
    :param float: (C M) value uniquely representing a non-time-based key (or key range) on a
    time-based animCurve  Valid floatRange include single values (-f 10) or a string
    :type float: floatrange
    :param floatPivot: (C) Scale pivot along the x-axis for float-input animCurves
    :type floatPivot: float
    :param floatScale: (C) Amount of scale along the x-axis for float-input animCurves
    :type floatScale: float
    :param hierarchy: (C) Hierarchy expansion options  Valid values are "above," "below," "both,
    " and "none." (Not valid for "pasteKey" cmd.) In query mode, this flag needs a
    :type hierarchy: string
    :param includeUpperBound: (C) When the -t/time or -f/float flags represent a range of keys,
    this flag determines whether the keys at the upper bound of the range are included in t
    :type includeUpperBound: boolean
    :param index: (C M) index of a key on an animCurve In query mode, this flag needs a value
    :type index: int
    :param newEndFloat: (C) The end of the float range to which the float-input targets should
    be scaled
    :type newEndFloat: float
    :param newEndTime: (C) The end of the time range to which the targets should be scaled
    :type newEndTime: time
    :param newStartFloat: (C) The start of the float range to which the float-input targets
    should be scaled
    :type newStartFloat: float
    :param newStartTime: (C) The start of the time range to which the time-input targets should
    be scaled
    :type newStartTime: time
    :param scaleSpecifiedKeys: (C) Determines if only the specified keys are affected by the
    scale  If false, other keys may be adjusted with the scale  The default is true
    :type scaleSpecifiedKeys: boolean
    :param shape: (C) Consider attributes of shapes below transforms as well, except
    "controlPoints"  Default: true  (Not valid for "pasteKey" cmd.) In query mode, this fl
    :type shape: boolean
    :param time: (C M) time uniquely representing a key (or key range) on a time-based
    animCurve  See the code examples below on how to format for a single frame or frame r
    :type time: timerange
    :param timePivot: (C) Scale pivot along the time-axis for time-input animCurves
    :type timePivot: time
    :param timeScale: (C) Amount of scale along the time-axis for time-input animCurves
    :type timeScale: float
    :param valuePivot: (C) Scale pivot along the value-axis
    :type valuePivot: float
    :param valueScale: (C) Amount of scale along the value-axis
    :type valueScale: float
    
    :returns: Number of curves on which scale was performed
    :rtype: int
    """
    pass


def xgmCopyDescription(*args, **kwargs):
    """
    
    """
    pass


def nClothCacheOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def deleteAttr(*args, attribute="", name="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command is used to delete a dynamic attribute from a node or nodes  The attribute can
    be specified by using either the long or short name  Only one dynamic attribute can be
    deleted at a time  Static attributes cannot be deleted  Children of a compound attribute
    cannot be deleted  You must delete the complete compound attribute  This command ha
    
    :param attribute: (C) Specify either the long or short name of the attribute
    :type attribute: string
    :param name: (C) The name of the node
    :type name: string
    
    :returns: 
    :rtype: None
    """
    pass


def polyNormal(*args, caching=True, constructionHistory=True, name="", nodeState=0,
               normalMode=0, userNormalMode=True, q=True, query=True, e=True, edit=True,
               **kwargs):
    """
    Control the normals of an object  This command works on faces or polygonal objects
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param normalMode: (C Q E) Normal mode : 0=reverse, 1=propagate, 2=conform, 3=reverseAndCut,
    4=reverseAndPropagate Default: 0
    :type normalMode: int
    :param userNormalMode: (C Q E) Determines if user normals needs to be reversed as well 
    Default: true
    :type userNormalMode: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def dR_quadDrawRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PreInfinityOscillate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def WireTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSetPartBrushTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def pathAnimation(*args, bank=False, bankScale=1.0, bankThreshold=90, curve="", endTimeU=None,
                  endU=0.0, follow=False, followAxis="", fractionMode=False, inverseFront=False,
                  inverseUp=False, name="", startTimeU=None, startU=0.0, upAxis="",
                  useNormal=True, worldUpObject=None, worldUpType="", worldUpVector=None,
                  q=True, query=True, e=True, edit=True, **kwargs):
    """
    The pathAnimation command constructs the necessary graph nodes and their interconnections
    for a motion path animation  Motion path animation requires a curve and one or more other
    objects  During the animation, the objects will be moved along the 3D curve or the
    curveOnSurface.  There are two ways to specify the moving objects:  by explicitly
    speci
    
    :param bank: (Q) If on, enable alignment of the up axis of the moving object(s) to the
    curvature of the path geometry  Default is false  When queried, this flag retur
    :type bank: boolean
    :param bankScale: (Q) This flag specifies a factor to scale the amount of bank angle 
    Default is 1.0 When queried, this flag returns a float
    :type bankScale: float
    :param bankThreshold: (Q) This flag specifies the limit of the bank angle  Default is 90
    degrees When queried, this flag returns an angle
    :type bankThreshold: float
    :param curve: (Q) This flag specifies the name of the curve for the path  Default is NONE
    When queried, this flag returns a string
    :type curve: string
    :param endTimeU: (Q M) This flag specifies the ending time of the animation for the u
    parameter  Default is NONE  When queried, this flag returns a time
    :type endTimeU: time
    :param endU: (Q) This flag specifies the ending value of the u parameterization for the
    animation  Default is the end parameterization value of the curve  When querie
    :type endU: float
    :param follow: (Q) If on, enable alignment of the front axis of the moving object(s) 
    Default is false  When queried, this flag returns a boolean
    :type follow: boolean
    :param followAxis: (Q) This flag specifies which object local axis to be aligned to the
    tangent of the path curve  Default is y When queried, this flag returns a string
    :type followAxis: string
    :param fractionMode: (Q) If on, evaluation on the path is based on the fraction of length
    of the path curve  Default is false  When queried, this flag returns a boolean
    :type fractionMode: boolean
    :param inverseFront: (Q) This flag specifies whether or not to align the front axis of the
    moving object(s) to the opposite direction of the tangent vector of the path geomet
    :type inverseFront: boolean
    :param inverseUp: (Q) This flag specifies whether or not to align the up axis of the moving
    object(s) to the opposite direction of the normal vector of the path geometry
    :type inverseUp: boolean
    :param name: (Q) This flag specifies the name for the new motion path node  (instead of the
    default name) When queried, this flag returns a string
    :type name: string
    :param startTimeU: (Q M) This flag specifies the starting time of the animation for the u
    parameter  Default is the the current time  When queried, this flag returns a time
    :type startTimeU: time
    :param startU: (Q) This flag specifies the starting value of the u parameterization for the
    animation  Default is the start parameterization value of the curve  When qu
    :type startU: float
    :param upAxis: (Q) This flag specifies which object local axis to be aligned a computed up
    direction  Default is z When queried, this flag returns a string
    :type upAxis: string
    :param useNormal: (C Q E) This flag is now obsolete  Use -wut/worldUpType instead
    :type useNormal: boolean
    :param worldUpObject: (C Q E) Set the DAG object to use for worldUpType "object" and
    "objectrotation"  See -wut/worldUpType for greater detail  The default value is no up
    object,
    :type worldUpObject: name
    :param worldUpType: (C Q E) Set the type of the world up vector computation  The
    worldUpType can have one of 5 values: "scene", "object", "objectrotation", "vector", or
    "normal"
    :type worldUpType: string
    :param worldUpVector: (C Q E) Set world up vector  This is the vector in world coordinates
    that up vector should align with  See -wut/worldUpType for greater detail  If not given
    :type worldUpVector: [float, float, float]
    
    :returns: (name of the created motionPath node)
    :rtype: string
    """
    pass


def StraightenUVBorder(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def createPolySphereCtx(*args, **kwargs):
    """
    
    """
    pass


def AddSelectionAsInBetweenTargetShape(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateRigidBodySolver(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def flagTest(*args, **kwargs):
    """
    
    """
    pass


def ShatterOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyProjection(*args, constructionHistory=True, createNewMap=True, imageCenterX=0.5,
                   imageCenterY=0.5, imageScaleU=1, imageScaleV=1, insertBeforeDeformers=True,
                   keepImageRatio=True, mapDirection="", projectionCenterX=0.0,
                   projectionCenterY=0.0, projectionCenterZ=0.0, projectionScaleU=0.0,
                   projectionScaleV=0.0, rotateX=0.0, rotateY=0.0, rotateZ=0.0, rotationAngle=0,
                   seamCorrect=True, smartFit=True, type="", uvSetName="", **kwargs):
    """
    Creates a mapping on the selected polygonal faces  When construction history is created,
    the name of the new node is returned  In other cases, the command returns nothing
    
    :param constructionHistory: (C) Turn the construction history on or off (where applicable)
    :type constructionHistory: boolean
    :param createNewMap: (C) Create new map if it does not exist
    :type createNewMap: boolean
    :param imageCenterX: (C) Specifies the X (U) translation of the projected UVs  Default is
    0.5
    :type imageCenterX: float
    :param imageCenterY: (C) Specifies the Y (V) translation of the projected UVs  Default is
    0.5
    :type imageCenterY: float
    :param imageScaleU: (C) Specifies the U scale factor of the projected UVs  Default is 1
    :type imageScaleU: float
    :param imageScaleV: (C) Specifies the V scale factor of the projected UVs  Default is 1
    :type imageScaleV: float
    :param insertBeforeDeformers: (C) Specifies if the projection node should be inserted
    before or after deformer nodes already applied to the shape  Inserting the projection after
    the d
    :type insertBeforeDeformers: boolean
    :param keepImageRatio: (C) Specifies if the xy scaling in the planar projection has to be
    uniform  By setting this flag, the texture aspect ratio is preserved  This flag is ign
    :type keepImageRatio: boolean
    :param mapDirection: (C) Specifies the direction of the projection  By specifying this flag,
    the projection placement values (pcx, pcy, pcz, rx, ry, rz, psu, psv) are interna
    :type mapDirection: string
    :param projectionCenterX: (C) Specifies the X coordinate of the center of the projection
    manipulator
    :type projectionCenterX: float
    :param projectionCenterY: (C) Specifies the Y coordinate of the center of the projection
    manipulator
    :type projectionCenterY: float
    :param projectionCenterZ: (C) Specifies the Z coordinate of the center of the projection
    manipulator
    :type projectionCenterZ: float
    :param projectionScaleU: (C) Specifies the U scale component of the projection manipulator
    :type projectionScaleU: float
    :param projectionScaleV: (C) Specifies the V scale component of the projection manipulator
    :type projectionScaleV: float
    :param rotateX: (C) Specifies the X-axis rotation of the projection manipulator
    :type rotateX: float
    :param rotateY: (C) Specifies the Y-axis rotation of the projection manipulator
    :type rotateY: float
    :param rotateZ: (C) Specifies the Z-axis rotation of the projection manipulator
    :type rotateZ: float
    :param rotationAngle: (C) Specifies the rotation of the projected UVs in the UV space 
    Default is 0
    :type rotationAngle: float
    :param seamCorrect: (C) Specifies if seam correction has to be done for spherical and
    cylindrical projections  This flag is ignored, if the planar projection is specified
    :type seamCorrect: boolean
    :param smartFit: (C) Specifies if the projection manipulator has to be placed fitting the
    object  Used for cylindrical and spherical projections  For smart fitting the pl
    :type smartFit: boolean
    :param type: (C) Specify the type of mapping to be performed  Valid values for the STRING
    are "planar" "cylindrical" "spherical" Default is planar
    :type type: string
    :param uvSetName: (C) Specifies name of the uv set to work on
    :type uvSetName: string
    
    :returns: Name of node created
    :rtype: string
    """
    pass


def snapshotBeadCtx(*args, exists=True, history=True, image1="", image2="", image3="",
                    inTangent=True, name="", outTangent=True, q=True, query=True, e=True,
                    edit=True, **kwargs):
    """
    Creates a context for manipulating in and/or out tangent beads on the motion trail
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param inTangent: (Q E) Indicates that we will be showing beads for the in tangent when
    entering the context
    :type inTangent: boolean
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param outTangent: (Q E) Indicates that we will be showing beads for the out tangent when
    entering the context
    :type outTangent: boolean
    
    :returns: (name of the new context)
    :rtype: string
    """
    pass


def ToggleVisibilityAndKeepSelectionOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def iterOnNurbs(*args, **kwargs):
    """
    
    """
    pass


def CreatePolygonSoccerBallOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowPolygonSurfaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowAttributeEditorOrChannelBox(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ActivateFullBodyPivot(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PaintEffectsToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HardwareRenderBuffer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def LoadHIKPropertySetState(*args, **kwargs):
    """
    
    """
    pass


def ShowShadingGroupAttributeEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def readTake(*args, angle="", device="", frequency=0.0, linear="", noTime=True, take="",
             **kwargs):
    """
    This action reads a take (.mov) file to a defined device
    
    :param angle: (C) Sets the angular unit used in the take  Valid strings are "deg", "degree",
    "rad", and "radian"  C: The default is the current user angular unit
    :type angle: string
    :param device: (C) Specifies the device into which the take data is read  This is a
    required argument
    :type device: string
    :param frequency: (C) The timestamp is ignored and the specified frequency is used  If
    timeStamp data is not in the .mov file, the -noTimestamp flag should also be used  T
    :type frequency: float
    :param linear: (C) Sets the linear unit used in the take  Valid strings are "mm",
    "millimeter", "cm", "centimeter", "m", "meter", "km", "kilometer", "in", "inch", "ft",
    :type linear: string
    :param noTime: (C) Specifies if the take (.mov) file contains time stamps  C: The default
    is to assume time stamps are part of the take file
    :type noTime: boolean
    :param take: (C) Reads the specified take file  It is safest to pass the full path to the
    flag
    :type take: string
    
    :returns: 
    :rtype: None
    """
    pass


def GraphEditorAbsoluteView(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadePinSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def renderThumbnailUpdate(*args, forceUpdate="", q=True, query=True, **kwargs):
    """
    Toggle the updating of object thumbnails  These are visible in tools like the Attribute
    Editor and Hypershade  All thumbnails everywhere will not update to reflect changes to the
    object until this command is used to toggle to true unless a specific thumbnail is forced
    to render using the -forceUpdate flag
    
    :param forceUpdate: (C) Force the thumbnail to update
    :type forceUpdate: string
    
    :returns: 
    :rtype: None
    """
    pass


def ShowMeshImprintToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CopySkinWeights(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CurveSmoothnessRough(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HIKFullBodyMode(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def popListItem(*args, **kwargs):
    """
    
    """
    pass


def ToggleModelingToolkit(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FrameAllInAllViews(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TransferAttributeValuesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyListComponentConversion(*args, border=True, fromEdge=True, fromFace=True, fromUV=True,
                                fromVertex=True, fromVertexFace=True, internal=True,
                                toEdge=True, toFace=True, toUV=True, toVertex=True,
                                toVertexFace=True, uvShell=True, vertexFaceAllEdges=True,
                                **kwargs):
    """
    This command converts poly components from one or more types to another one or more types,
    and returns the list of the conversion  It does not change anything of the current database
    
    :param border: (C) Indicates that the converted components must be on the border of the
    selection  If it is not provided, the converted components will be the related o
    :type border: boolean
    :param fromEdge: (C) 
    :type fromEdge: boolean
    :param fromFace: (C) 
    :type fromFace: boolean
    :param fromUV: (C) 
    :type fromUV: boolean
    :param fromVertex: (C) 
    :type fromVertex: boolean
    :param fromVertexFace: (C) Indicates the component type to convert from  If none of them is
    provided, it is assumed to be all of them, including poly objects
    :type fromVertexFace: boolean
    :param internal: (C) Indicates that the converted components must be totally envolved by
    the source components  E.g  a converted face must have all of its surrounding ver
    :type internal: boolean
    :param toEdge: (C) 
    :type toEdge: boolean
    :param toFace: (C) 
    :type toFace: boolean
    :param toUV: (C) 
    :type toUV: boolean
    :param toVertex: (C) 
    :type toVertex: boolean
    :param toVertexFace: (C) Indicates the component type to convert to  If none of them is
    provided, it is assumed to the object
    :type toVertexFace: boolean
    :param uvShell: (C) Will return UV components within the same UV shell  Only works with
    -tuv and -fuv flags
    :type uvShell: boolean
    :param vertexFaceAllEdges: (C) When converting from face vertices to edges, indicates that
    all edges with an end at the face vertex should be included  Without this flag, the defau
    :type vertexFaceAllEdges: boolean
    
    :returns: List of poly components
    :rtype: selectionItem[]
    """
    pass


def HypershadeGraphAddSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ConnectionEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleKeepHardEdgeCulling(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TransformNoSelectOffTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def insertKeyCtx(*args, breakdown=True, exists=True, history=True, image1="", image2="",
                 image3="", name="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a context which may be used to insert keys within the graph editor
    
    :param breakdown: (Q E) Specifies whether or not to create breakdown keys
    :type breakdown: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: Context name
    :rtype: string
    """
    pass


def TimeEditorClipTrimStart(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmSelectedPrims(*args, **kwargs):
    """
    
    """
    pass


def SaveCurrentLayout(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmPatchInfo(*args, **kwargs):
    """
    
    """
    pass


def SelectToolMarkingMenuPopDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_extrudeBevelRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddPondDynamicBuoy(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dgeval(*args, src=True, verbose=True, **kwargs):
    """
    The dgeval command is used to force a dependency graph evaluate of a node or plug  Used for
    debugging to find propagation problems   Normally the selection list is used to determine
    which objects to evaluate, but you can add to the selection list by specifying which
    objects you want on the command line
    
    :param src: (C) This flag is obsolete  Do not use
    :type src: boolean
    :param verbose: (C) If this flag is used then the results of the evaluation(s) is/are
    printed on stdout
    :type verbose: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def SelectUVNonOverlappingComponents(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RegionKeysTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GpuCacheExportSelection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExportOfflineFileFromRefEd(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleLatticePoints(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleFaceMetadata(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PlanarProjection(*args, **kwargs):
    """
    unknown
    """
    pass


def OutTangentAuto(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def scaleKeyCtx(*args, exists=True, history=True, image1="", image2="", image3="", name="",
                scaleSpecifiedKeys=True, type="", q=True, query=True, e=True, edit=True,
                **kwargs):
    """
    This command creates a context which may be used to scale keyframes within the graph editor
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param scaleSpecifiedKeys: (Q E) Determines if only the specified keys should be scaled  If
    false, the non-selected keys will be adjusted during the scale  The default is true
    :type scaleSpecifiedKeys: boolean
    :param type: (Q E) rect | manip Specifies the type of scale manipulator to use (Note:
    "rect" is a manipulator style context, and "manip" is a gestural style context)
    :type type: string
    
    :returns: Scale type, if the type flag was queried
    :rtype: string
    """
    pass


def softSelectOptionsCtx(*args, **kwargs):
    """
    
    """
    pass


def floatSlider(*args, annotation="", backgroundColor=None, changeCommand=None,
                defineTemplate="", docTag="", dragCallback=None, dragCommand=None,
                dropCallback=None, enable=True, enableBackground=True, enableKeyboardFocus=True,
                exists=True, fullPathName=True, height=0, highlightColor=None, horizontal=True,
                isObscured=True, manage=True, maxValue=0.0, minValue=0.0, noBackground=True,
                numberOfPopupMenus=True, parent="", popupMenuArray=True, preventOverride=True,
                statusBarMessage="", step=0.0, useTemplate="", value=0.0, visible=True,
                visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
                **kwargs):
    """
    Create a slider control that accepts only float values and is bound by a minimum and
    maximum value  The slider displays a marker indicating the current value of the slider
    relative to its minimum and maximum values  Click and drag the marker, or on the slider
    itself to change the current value
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Command executed when the value changes  This command is not
    invoked when the value changes via the -v/value flag
    :type changeCommand: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dragCommand: (C E) Command executed when the value changes by dragging the slider's
    value marker
    :type dragCommand: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param horizontal: (C Q) Orientation of the slider  This flag is true by default, which
    corresponds to a horizontally oriented slider
    :type horizontal: boolean
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param maxValue: (C Q E) Upper limit of the slider
    :type maxValue: float
    :param minValue: (C Q E) Lower limit of the slider
    :type minValue: float
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param step: (C Q E) The step value represents the amount the value will increase or
    decrease when you click either side of the slider
    :type step: float
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param value: (C Q E) Value of the slider
    :type value: float
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def addExtension(*args, nodeType="", attributeType="", binaryTag="", cachedInternally=True,
                 category="", dataType="", defaultValue=0.0, disconnectBehaviour=0, enumName="",
                 exists=True, fromPlugin=True, hasMaxValue=True, hasMinValue=True,
                 hasSoftMaxValue=True, hasSoftMinValue=True, hidden=True, indexMatters=True,
                 internalSet=True, keyable=True, longName="", maxValue=0.0, minValue=0.0,
                 multi=True, niceName="", numberOfChildren=0, parent="", proxy="",
                 readable=True, shortName="", softMaxValue=0.0, softMinValue=0.0, storable=True,
                 usedAsColor=True, usedAsFilename=True, usedAsProxy=True, writable=True, q=True,
                 query=True, e=True, edit=True, **kwargs):
    """
    This command is used to add an extension attribute to a node type  Either the longName or
    the shortName or both must be specified  If neither a dataType nor an attributeType is
    specified, a double attribute will be added  The dataType flag can be specified more than
    once indicating that any of the supplied types will be accepted (logical-or)   To a
    
    :param nodeType: (C Q E) Specifies the type of node to which the attribute will be added 
    See the nodeType command for the names of different node types
    :type nodeType: string
    :param attributeType: (C Q) Specifies the attribute type, see above table for more details 
    Note that the attribute types "float", "matrix" and "string" are also MEL keywords an
    :type attributeType: string
    :param binaryTag: (C Q) This flag is obsolete and does not do anything any more
    :type binaryTag: string
    :param cachedInternally: (C Q) Whether or not attribute data is cached internally in the
    node  This flag defaults to true for writable attributes and false for non-writable
    attribu
    :type cachedInternally: boolean
    :param category: (C Q E M) An attribute category is a string associated with the attribute
    to identify it  (e.g  the name of a plugin that created the attribute, version inform
    :type category: string
    :param dataType: (C Q M) Specifies the data type  See "setAttr" for more information on
    data type names
    :type dataType: string
    :param defaultValue: (C Q E) Specifies the default value for the attribute (can only be
    used for numeric attributes)
    :type defaultValue: float
    :param disconnectBehaviour: (C Q) defines the Disconnect Behaviour 2 Nothing, 1 Reset, 0
    Delete
    :type disconnectBehaviour: int
    :param enumName: (C Q E) Flag used to specify the ui names corresponding to the enum values
     The specified string should contain a colon-separated list of the names, with opt
    :type enumName: string
    :param exists: (C Q) Returns true if the attribute queried is a user-added, dynamic
    attribute; false if not
    :type exists: boolean
    :param fromPlugin: (C Q) Was the attribute originally created by a plugin? Normally set
    automatically when the API call is made - only added here to support storing it in a f
    :type fromPlugin: boolean
    :param hasMaxValue: (C Q E) Flag indicating whether an attribute has a maximum value  (can
    only be used for numeric attributes)
    :type hasMaxValue: boolean
    :param hasMinValue: (C Q E) Flag indicating whether an attribute has a minimum value  (can
    only be used for numeric attributes)
    :type hasMinValue: boolean
    :param hasSoftMaxValue: (C Q) Flag indicating whether a numeric attribute has a soft
    maximum
    :type hasSoftMaxValue: boolean
    :param hasSoftMinValue: (C Q) Flag indicating whether a numeric attribute has a soft
    minimum
    :type hasSoftMinValue: boolean
    :param hidden: (C Q) Will this attribute be hidden from the UI?
    :type hidden: boolean
    :param indexMatters: (C Q) Sets whether an index must be used when connecting to this
    multi-attribute  Setting indexMatters to false forces the attribute to non-readable
    :type indexMatters: boolean
    :param internalSet: (C Q) Whether or not the internal cached value is set when this
    attribute value is changed  This is an internal flag used for updating UI elements
    :type internalSet: boolean
    :param keyable: (C Q) Is the attribute keyable by default?
    :type keyable: boolean
    :param longName: (C Q) Sets the long name of the attribute
    :type longName: string
    :param maxValue: (C Q E) Specifies the maximum value for the attribute (can only be used
    for numeric attributes)
    :type maxValue: float
    :param minValue: (C Q E) Specifies the minimum value for the attribute (can only be used
    for numeric attributes)
    :type minValue: float
    :param multi: (C Q) Makes the new attribute a multi-attribute
    :type multi: boolean
    :param niceName: (C Q E) Sets the nice name of the attribute for display in the UI  Setting
    the attribute's nice name to a non-empty string overrides the default behaviour of
    :type niceName: string
    :param numberOfChildren: (C Q) How many children will the new attribute have?
    :type numberOfChildren: int
    :param parent: (C Q) Attribute that is to be the new attribute's parent
    :type parent: string
    :param proxy: (C Q) Proxy another node's attribute  Proxied plug will be connected as
    source  The UsedAsProxy flag is automatically set in this case
    :type proxy: string
    :param readable: (C Q) Can outgoing connections be made from this attribute?
    :type readable: boolean
    :param shortName: (C Q) Sets the short name of the attribute
    :type shortName: string
    :param softMaxValue: (C Q E) Soft maximum, valid for numeric attributes only  Specifies the
    upper default limit used in sliders for this attribute
    :type softMaxValue: float
    :param softMinValue: (C Q E) Soft minimum, valid for numeric attributes only  Specifies the
    upper default limit used in sliders for this attribute
    :type softMinValue: float
    :param storable: (C Q) Can the attribute be stored out to a file?
    :type storable: boolean
    :param usedAsColor: (C Q) Is the attribute to be used as a color definition? Must have 3
    DOUBLE or 3 FLOAT children to use this flag  The attribute type "-at" should be "doubl
    :type usedAsColor: boolean
    :param usedAsFilename: (C Q) Is the attribute to be treated as a filename definition? This
    flag is only supported on attributes with data type "-dt" of "string"
    :type usedAsFilename: boolean
    :param usedAsProxy: (C Q) Set if the specified attribute should be treated as a proxy to
    another attributes
    :type usedAsProxy: boolean
    :param writable: (C Q) Can incoming connections be made to this attribute?
    :type writable: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def xgmPartBrushToolCmd(*args, **kwargs):
    """
    
    """
    pass


def NodeEditorCreateCompound(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolygonBooleanDifference(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleBorderEdges(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateNURBSCubeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def planarSrf(*args, caching=True, degree=3, keepOutside=False, nodeState=0, tolerance=0.01,
              constructionHistory=True, name="", object=True, polygon=0, range=True, q=True,
              query=True, e=True, edit=True, **kwargs):
    """
    This command computes a planar trimmed surface given planar boundary curves that form a
    closed region
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param degree: (C Q E) The degree of the resulting surface: 1 - linear, 3 - cubic Default:
    3
    :type degree: int
    :param keepOutside: (C Q E) If true, keep the regions outside the given curves  Default:
    false
    :type keepOutside: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param tolerance: (C Q E) The distance tolerance for the cvs of the curves to be in the
    same plane  Default: 0.01
    :type tolerance: float
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param polygon: (C) The value of this argument controls the type of the object created by
    this operation 0: nurbs surface 1: polygon (use nurbsToPolygonsPref to set the
    :type polygon: int
    :param range: (C) Force a curve range on complete input curve
    :type range: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def connectDynamic(*args, addScriptHandler=None, collisions="", delete=True, emitters="",
                   fields="", removeScriptHandler=0, **kwargs):
    """
    Dynamic connection specifies that the force fields, emitters, or collisions of an object
    affect another dynamic object  The dynamic object that is connected to a field, emitter, or
    collision object is influenced by those fields, emitters and collision objects  
    Connections are made to individual fields, emitters, collisions  So, if an object owns
    s
    
    :param addScriptHandler: (C) Registers a script that will be given a chance to handle calls
    to the dynamicConnect command  This flag allows other dynamics systems to override the
    :type addScriptHandler: script
    :param collisions: (C M) Connects each object to the collision models of the given object
    :type collisions: string
    :param delete: (C) Deletes existing connections
    :type delete: boolean
    :param emitters: (C M) Connects each object to the emitters of the given object
    :type emitters: string
    :param fields: (C M) Connects each object to the fields of the given object
    :type fields: string
    :param removeScriptHandler: (C) This flag is used to remove a callback that was previously
    registered with the addScriptHandler flag  The argument to this flag is the numerical id r
    :type removeScriptHandler: int
    
    :returns: Command result
    :rtype: string
    """
    pass


def polyMergeEdge(*args, caching=True, constructionHistory=True, firstEdge=0, mergeMode=1,
                  mergeTexture=False, name="", nodeState=0, secondEdge=0, q=True, query=True,
                  e=True, edit=True, **kwargs):
    """
    Sews two border edges together.
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param firstEdge: (C Q E) First edge to merge  Invalid default value to force the value to
    be set  Default: -1
    :type firstEdge: int
    :param mergeMode: (C Q E) Merge mode : 0=first, 1=halfway between both edges, 2=second 
    Default: 1
    :type mergeMode: int
    :param mergeTexture: (C Q E) Boolean which is used to decide if uv coordinates should be
    merged or not - along with the geometry  Default: false
    :type mergeTexture: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param secondEdge: (C Q E) Second edge to merge  Invalid default value to force the value
    to be set  Default: -1
    :type secondEdge: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def movieInfo(*args, counter=True, dropFrame=True, frameCount=True, frameDuration=True,
              height=True, movieTexture=True, negTimesOK=True, numFrames=True, quickTime=True,
              timeCode=True, timeCodeTrack=True, timeScale=True, twentyFourHourMax=True,
              width=True, **kwargs):
    """
    movieInfo provides a mechanism for querying information about movie files
    
    :param counter: (C) Query the 'counter' flag of the movie's timecode format  If this is
    true, the timecode returned by the -timeCode flag will be a simple counter  If fa
    :type counter: boolean
    :param dropFrame: (C) Query the 'drop frame' flag of the movie's timecode format
    :type dropFrame: boolean
    :param frameCount: (C) Query the number of frames in the movie file
    :type frameCount: boolean
    :param frameDuration: (C) Query the frame duration of the movie's timecode format
    :type frameDuration: boolean
    :param height: (C) Query the height of the movie
    :type height: boolean
    :param movieTexture: (C) If set, the string argument is interpreted as the name of a movie
    texture node, and the command then operates on the movie loaded by that node
    :type movieTexture: boolean
    :param negTimesOK: (C) Query the 'neg times OK' flag of the movie's timecode format
    :type negTimesOK: boolean
    :param numFrames: (C) Query the whole number of frames per second of the movie's timecode
    format
    :type numFrames: boolean
    :param quickTime: (C) Query whether the movie is a QuickTime movie
    :type quickTime: boolean
    :param timeCode: (C) Query the timecode of the current movie frame
    :type timeCode: boolean
    :param timeCodeTrack: (C) Query whether the movie has a timecode track
    :type timeCodeTrack: boolean
    :param timeScale: (C) Query the timescale of the movie's timecode format
    :type timeScale: boolean
    :param twentyFourHourMax: (C) Query the '24 hour max' flag of the movie's timecode format
    :type twentyFourHourMax: boolean
    :param width: (C) Query the width of the movie
    :type width: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def ToggleAttributeEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GlobalStitchOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ReattachSkeletonJoints(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def hikBodyPart(*args, **kwargs):
    """
    
    """
    pass


def CharacterAnimationEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def EnableNucleuses(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ConvertInstanceToObject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nurbsBoolean(*args, caching=True, nodeState=0, operation=0, tolerance=0.01,
                 constructionHistory=True, name="", nsrfsInFirstShell=0, object=True,
                 smartConnection=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command performs a boolean operation
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param operation: (C Q E) Type of Boolean operation  Default: 0
    :type operation: int
    :param tolerance: (C Q E) fitting tolerance  Default: 0.01
    :type tolerance: float
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param nsrfsInFirstShell: (C) The number of selection items comprising the first shell
    :type nsrfsInFirstShell: int
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param smartConnection: (C) Look for any of the selection items having a boolean operation
    as history  Default is true
    :type smartConnection: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def CreatePolyFromPreview(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateConstraintClipOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ctxTraverse(*args, down=True, left=True, right=True, up=True, **kwargs):
    """
    This command tells the current context to do a traversal   Some contexts will ignore this
    command  Individual contexts determine what up/down left/right mean
    
    :param down: (C) Move "down" as defined by the current context
    :type down: boolean
    :param left: (C) Move "left" as defined by the current context
    :type left: boolean
    :param right: (C) Move "right" as defined by the current context
    :type right: boolean
    :param up: (C) Move "up" as defined by the current context
    :type up: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def ToggleCullingVertices(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def editDisplayLayerMembers(*args, fullNames=True, noRecurse=True, q=True, query=True,
                            **kwargs):
    """
    This command is used to query and edit membership of display layers  No equivalent 'remove'
    command is necessary since all objects must be in exactly one display layer  Removing an
    object from a layer can be accomplished by adding it to a different layer
    
    :param fullNames: (Q) (Query only.) If set then return the full DAG paths of the objects in
    the layer  Otherwise return just the name of the object
    :type fullNames: boolean
    :param noRecurse: (C Q) If set then only add selected objects to the display layer 
    Otherwise all descendants of the selected objects will also be added
    :type noRecurse: boolean
    
    :returns: Number of objects added to the layer
    :rtype: int
    """
    pass


def UngroupOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorCreateClipOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_autoWeldTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_connectTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ikSystem(*args, allowRotation=True, autoPriority=True, autoPriorityMC=True,
             autoPrioritySC=True, list=None, snap=True, solve=True, solverTypes=True, q=True,
             query=True, e=True, edit=True, **kwargs):
    """
    The ikSystem command is used to set the global snapping flag for handles and set the global
    solve flag for solvers  The standard edit (-e) and query (-q) flags are used for edit and
    query functions
    
    :param allowRotation: (Q E) Set true to allow rotation of an ik handle with keys set on
    translation
    :type allowRotation: boolean
    :param autoPriority: (E) set autoPriority for all ikHandles
    :type autoPriority: boolean
    :param autoPriorityMC: (E) set autoPriority for all multiChain handles
    :type autoPriorityMC: boolean
    :param autoPrioritySC: (E) set autoPriority for all singleChain handles
    :type autoPrioritySC: boolean
    :param list: (Q E) returns the solver execution order when in query mode(list of strings)
    changes execution order when in edit mode (int old position, int new position)
    :type list: [int, int]
    :param snap: (Q E) Set global snapping
    :type snap: boolean
    :param solve: (Q E) Set global solve
    :type solve: boolean
    :param solverTypes: (Q) returns a list of valid solverTypes ( query only )
    :type solverTypes: boolean
    
    :returns: Command result
    :rtype: string
    """
    pass


def NCreateEmitter(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowCameraManipulators(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def scriptedPanel(*args, control=True, copy="", createString=True, defineTemplate="", docTag="",
                  editString=True, exists=True, init=True, isUnique=True, label="",
                  menuBarRepeatLast=True, menuBarVisible=True, needsInit=True, parent="",
                  popupMenuProcedure=None, replacePanel="", tearOff=True, tearOffCopy="",
                  tearOffRestore=True, type="", unParent=True, useTemplate="", q=True,
                  query=True, e=True, edit=True, **kwargs):
    """
    This command will create an instance of the specified scriptedPanelType  A panel is a
    collection of UI objects (buttons, fields, graphical views) that are grouped together  A
    panel can be moved around as a group within the application interface, and torn off to
    exist in its own window  The panel takes care of maintaining the state of its UI when it
    
    :param control: (Q) Returns the top level control for this panel  Usually used for getting
    a parent to attach popup menus  CAUTION: panels may not have controls at times
    :type control: boolean
    :param copy: (E) Makes this panel a copy of the specified panel  Both panels must be of the
    same type
    :type copy: string
    :param createString: (E) Command string used to create a panel
    :type createString: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Attaches a tag to the Maya panel
    :type docTag: string
    :param editString: (E) Command string used to edit a panel
    :type editString: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param init: (C E) Initializes the panel's default state  This is usually done
    automatically on file -new and file -open
    :type init: boolean
    :param isUnique: (Q) Returns true if only one instance of this panel type is allowed
    :type isUnique: boolean
    :param label: (Q E) Specifies the user readable label for the panel
    :type label: string
    :param menuBarRepeatLast: (C Q E) Controls whether clicking on the menu header with the
    middle mouse button would repeat the last selected menu item
    :type menuBarRepeatLast: boolean
    :param menuBarVisible: (C Q E) Controls whether the menu bar for the panel is displayed
    :type menuBarVisible: boolean
    :param needsInit: (Q E) (Internal) On Edit will mark the panel as requiring initialization 
    Query will return whether the panel is marked for initialization  Used during fil
    :type needsInit: boolean
    :param parent: (C) Specifies the parent layout for this panel
    :type parent: string
    :param popupMenuProcedure: (Q E) Specifies the procedure called for building the panel's
    popup menu(s)  The default value is "buildPanelPopupMenu"  The procedure should take one
    stri
    :type popupMenuProcedure: script
    :param replacePanel: (E) Will replace the specified panel with this panel  If the target
    panel is within the same layout it will perform a swap
    :type replacePanel: string
    :param tearOff: (Q E) Will tear off this panel into a separate window with a paneLayout as
    the parent of the panel  When queried this flag will return if the panel has bee
    :type tearOff: boolean
    :param tearOffCopy: (C) Will create this panel as a torn of copy of the specified source
    panel
    :type tearOffCopy: string
    :param tearOffRestore: (C E) Restores panel if it is torn off and focus is given to it  If
    docked, becomes the active panel in the docked window  This should be the default flag
    :type tearOffRestore: boolean
    :param type: (C Q) This flag specifies the type of scripted panel to create
    :type type: string
    :param unParent: (E) Specifies that the panel should be removed from its layout  This
    (obviously) cannot be used with query
    :type unParent: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: The name of the scripted panel.
    :rtype: string
    """
    pass


def SmoothingLevelIncrease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def doubleProfileBirailSurface(*args, blendFactor=0.5, caching=True, nodeState=0,
                               tangentContinuityProfile1=False, tangentContinuityProfile2=False,
                               transformMode=0, constructionHistory=True, name="", object=True,
                               polygon=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The arguments are 4 cuves called "profile1" "profile2" "rail1" "rail2"   This command
    builds a railed surface by sweeping profile "profile1" along the two given rail curves
    "rail1", "rail2" until "profile2" is reached  By using the -blend control, the railed
    surface creation could be biased more towards one of the two profile curves  The curves (
    b
    
    :param blendFactor: (C Q E) A blend factor applied in between the two profiles  The amount
    of influence 'inputProfile1' has in the surface creation  Default: 0.5
    :type blendFactor: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param tangentContinuityProfile1: (C Q E) Need tangent continuity across the input profile
    at inputProfile1  Default: false
    :type tangentContinuityProfile1: boolean
    :param tangentContinuityProfile2: (C Q E) Need tangent continuity across the input curve at
    inputProfile2  Default: false
    :type tangentContinuityProfile2: boolean
    :param transformMode: (C Q E) transform mode ( Non proportional, proportional )  Non
    proportional is default value  Default: 0
    :type transformMode: int
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param polygon: (C) The value of this argument controls the type of the object created by
    this operation 0: nurbs surface 1: polygon (use nurbsToPolygonsPref to set the
    :type polygon: int
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def filter(*args, name="", type="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    Creates or modifies a filter node  Filter nodes are used by applyTake to modify recorded
    device data before assigning it to the param curves for the attached attributes
    
    :param name: (C Q E) Name for created filter
    :type name: string
    :param type: (C Q E) Resamples input data a fixed output rate using the closest sample
    point
    :type type: string
    
    :returns: filter name
    :rtype: string
    """
    pass


def SelectUVMask(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UnmirrorSmoothProxy(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleXGenDisplayHUD(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def copyFlexor(*args, **kwargs):
    """
    This command copies an existing bone or joint flexor from one bone (joint) to another  The
    attributes of the flexor and their connections as well as any tweaks in on the latticeFfd
    are copied from the original to the new flexor  If the selected bone (joint) appears to be
    a mirror reflection of the bone (joint) of the existing flexor then the transf
    
    
    :returns: The name of the new flexor node
    :rtype: string
    """
    pass


def InitialFluidStates(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmMelRender(*args, **kwargs):
    """
    
    """
    pass


def GraphEditorDisplayTangentActive(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddDynamicBuoy(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def isolateSelect(*args, addDagObject=None, addSelected=True, addSelectedObjects=True,
                  loadSelected=True, removeDagObject=None, removeSelected=True, state=True,
                  update=True, viewObjects=True, q=True, query=True, **kwargs):
    """
    This command turns on/off isolate select mode in a specified modeling view, specified as
    the argument  Isolate select mode is a display mode where the currently selected objects
    are added to a list and only those objects are displayed in the view  It allows for
    selective viewing of specific objects and object components
    
    :param addDagObject: () Add the specified object to the set of objects to be displayed in
    the view
    :type addDagObject: name
    :param addSelected: () Add the currently active objects to the set of objects to be
    displayed in the view
    :type addSelected: boolean
    :param addSelectedObjects: () Add selected objects to the set of objects to be displayed in
    the view  This flag differs from addSelected in that it will ignore selected components
    :type addSelectedObjects: boolean
    :param loadSelected: () Replace the objects being displayed with the currently active
    objects
    :type loadSelected: boolean
    :param removeDagObject: () Remove the specified object from the set of objects to be
    displayed in the view
    :type removeDagObject: name
    :param removeSelected: () Remove the currently active objects to the set of objects to be
    displayed in the view
    :type removeSelected: boolean
    :param state: (Q) Turns isolate select mode on/off
    :type state: boolean
    :param update: () Update the view's list of objects due to a change to the set of objects
    to be displayed
    :type update: boolean
    :param viewObjects: (Q) Returns the name (if any) of the objectSet which contains the list
    of objects visible in the view if isolate select mode is on  If isolate select mod
    :type viewObjects: boolean
    
    :returns: When used with query
    :rtype: boolean
    """
    pass


def skeletonEmbed(*args, mergedMesh=True, segmentationMethod=0, segmentationResolution=256,
                  q=True, query=True, **kwargs):
    """
    This command is used to embed a skeleton inside meshes
    
    :param mergedMesh: (Q) When specified, the query command merges selected meshes together
    and returns a Python object representing the merged mesh
    :type mergedMesh: boolean
    :param segmentationMethod: (C) Specifies which segmentation algorithm to use to determine
    what is inside the mesh and what is outside the mesh  By default, boundary-and-fill-and-gr
    :type segmentationMethod: int
    :param segmentationResolution: (C) Specifies which segmentation resolution to use for the
    voxel grid  By default, 256x256x256 voxels will be used
    :type segmentationResolution: int
    
    :returns: 
    :rtype: None
    """
    pass


def SculptGeometryTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HyperGraphPanelRedoViewChange(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BifMeshExport(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GridUVOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UpdateReferenceSurface(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def reorderDeformers(*args, name="", **kwargs):
    """
    This command changes the order in which 2 deformation nodes affect the output geometry  The
    first string argument is the name of deformer1, the second is deformer2, followed by the
    list of objects they deform   It inserts deformer2 before deformer1  Currently supported
    deformer nodes include: sculpt, cluster, jointCluster, lattice, wire, jointLatti
    
    :param name: (C) This flag is obsolete and is not used
    :type name: string
    
    :returns: 
    :rtype: None
    """
    pass


def NormalizeUVs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Snap2PointsTo2PointsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ImportWorkspaceFiles(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SaveScene(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreatePose(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ResetProperty2State(*args, **kwargs):
    """
    
    """
    pass


def OutlinerExpandAllSelectedItems(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ConvertSelectionToUVPerimeter(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OutlinerToggleShapes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MapUVBorderOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MoveSewUVs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyAutoProjection(*args, layoutMethod=0, pivot=None, pivotX=0.0, pivotY=0.0, pivotZ=0.0,
                       rotate=None, rotateX=0.0, rotateY=0.0, rotateZ=0.0, scale=None,
                       scaleX=1.0, scaleY=1.0, scaleZ=1.0, translate=None, translateX=0.0,
                       translateY=0.0, translateZ=0.0, caching=True, constructionHistory=True,
                       createNewMap=True, insertBeforeDeformers=True, layout=0, name="",
                       nodeState=0, optimize=0, percentageSpace=0.0, planes=6,
                       projectBothDirections=True, scaleMode=0, skipIntersect=True,
                       uvSetName="", worldSpace=True, q=True, query=True, e=True, edit=True,
                       **kwargs):
    """
    Projects a map onto an object, using several orthogonal projections simultaneously
    
    :param layoutMethod: (C Q E) Set which layout method to use: 0 Block Stacking  1 Shape
    Stacking
    :type layoutMethod: int
    :param pivot: (C Q E) This flag specifies the pivot for scaling and rotation  C: Default is
    0.0 0.0 0.0  Q: When queried, this flag returns a float[3]
    :type pivot: [float, float, float]
    :param pivotX: (C Q E) This flag specifies the X pivot for scaling and rotation  C: Default
    is 0.0  Q: When queried, this flag returns a float
    :type pivotX: float
    :param pivotY: (C Q E) This flag specifies the Y pivot for scaling and rotation  C: Default
    is 0.0  Q: When queried, this flag returns a float
    :type pivotY: float
    :param pivotZ: (C Q E) This flag specifies the Z pivot for scaling and rotation  C: Default
    is 0.0  Q: When queried, this flag returns a float
    :type pivotZ: float
    :param rotate: (C Q E) This flag specifies the rotation angles around X, Y, Z  C: Default
    is 0.0 0.0 0.0  Q: When queried, this flag returns a float[3]
    :type rotate: [float, float, float]
    :param rotateX: (C Q E) This flag specifies the rotation angle around X  C: Default is 0.0 
    Q: When queried, this flag returns a float
    :type rotateX: float
    :param rotateY: (C Q E) This flag specifies the rotation angle around Y  C: Default is 0.0 
    Q: When queried, this flag returns a float
    :type rotateY: float
    :param rotateZ: (C Q E) This flag specifies the rotation angle around Z  C: Default is 0.0 
    Q: When queried, this flag returns a float
    :type rotateZ: float
    :param scale: (C Q E) This flag specifies the scaling vector  C: Default is 1.0 1.0 1.0  Q:
    When queried, this flag returns a float[3]
    :type scale: [float, float, float]
    :param scaleX: (C Q E) This flag specifies X for scaling vector  C: Default is 1.0  Q: When
    queried, this flag returns a float
    :type scaleX: float
    :param scaleY: (C Q E) This flag specifies Y for scaling vector  C: Default is 1.0  Q: When
    queried, this flag returns a float
    :type scaleY: float
    :param scaleZ: (C Q E) This flag specifies Z for scaling vector  C: Default is 1.0  Q: When
    queried, this flag returns a float
    :type scaleZ: float
    :param translate: (C Q E) This flag specifies the translation vector  C: Default is 0.0 0.0
    0.0  Q: When queried, this flag returns a float[3]
    :type translate: [float, float, float]
    :param translateX: (C Q E) This flag specifies the X translation vector  C: Default is 0.0 
    Q: When queried, this flag returns a float
    :type translateX: float
    :param translateY: (C Q E) This flag specifies the Y translation vector  C: Default is 0.0 
    Q: When queried, this flag returns a float
    :type translateY: float
    :param translateZ: (C Q E) This flag specifies the Z translation vector  C: Default is 0.0 
    Q: When queried, this flag returns a float
    :type translateZ: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param createNewMap: (C) Set to true if a new map should be created
    :type createNewMap: boolean
    :param insertBeforeDeformers: (C) Set to true if the new node created should inserted
    before any deformer nodes
    :type insertBeforeDeformers: boolean
    :param layout: (C Q E) What layout algorithm should be used: 0 UV pieces are set to no
    layout  1 UV pieces are aligned along the U axis  2 UV pieces are moved in a square s
    :type layout: int
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param optimize: (C Q E) Use two different flavors for the cut generation  0 Every face is
    assigned to the best plane  This optimizes the map distortion  1 Small UV pieces ar
    :type optimize: int
    :param percentageSpace: (C Q E) When layout is set to square, this value is a percentage of
    the texture area which is added around each UV piece  It can be used to ensure each UV pi
    :type percentageSpace: float
    :param planes: (C Q E) Number of intermediate projections used  Valid numbers are 4, 5, 6,
    8, and 12  C: Default is 6
    :type planes: int
    :param projectBothDirections: (C Q E) This flag specifies which reference to use  If "on" :
    projections are mirrored on directly opposite faces  If "off" : projections are not
    mirrored on
    :type projectBothDirections: boolean
    :param scaleMode: (C Q E) How to scale the pieces, after projections: 0 No scale is applied
     1 Uniform scale to fit in unit square  2 Non proportional scale to fit in unit squ
    :type scaleMode: int
    :param skipIntersect: (C Q E) When on, self intersection of UV pieces are not tested  This
    makes the projection faster and produces fewer pieces, but may lead to overlaps in UV sp
    :type skipIntersect: boolean
    :param uvSetName: (C) Name of the UV set to be created
    :type uvSetName: string
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def PreviousFrame(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXPushSettings(*args, **kwargs):
    """
    
    """
    pass


def MirrorJointOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowMeshSculptToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TogglePolyDisplayHardEdgesColor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def meshIntersectTest(*args, **kwargs):
    """
    
    """
    pass


def dR_modeUV(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CharacterSetEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DuplicateNURBSPatchesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXImportConstraints(*args, **kwargs):
    """
    
    """
    pass


def HypershadeOpenSpreadSheetWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddAttribute(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def angleBetween(*args, caching=True, constructionHistory=True, euler=True, nodeState=0,
                 vector1=None, vector1X=0.0, vector1Y=0.0, vector1Z=0.0, vector2=None,
                 vector2X=0.0, vector2Y=0.0, vector2Z=0.0, **kwargs):
    """
    Returns the axis and angle required to rotate one vector onto another  If the construction
    history (ch) flag is ON, then the name of the new dependency node is returned
    
    :param caching: (C) Toggle caching for all attributes so that no recomputation is needed
    :type caching: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param euler: (C) return the rotation as 3 Euler angles instead of axis + angle
    :type euler: boolean
    :param nodeState: (C) This is implemented in the depend node base class and applies to all
    nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param vector1: (C) vector from which to compute the rotation
    :type vector1: [float, float, float]
    :param vector1X: (C) X coordinate of the vector from which to compute the rotation
    :type vector1X: float
    :param vector1Y: (C) Y coordinate of the vector from which to compute the rotation
    :type vector1Y: float
    :param vector1Z: (C) Z coordinate of the vector from which to compute the rotation
    :type vector1Z: float
    :param vector2: (C) vector to which to compute the rotation
    :type vector2: [float, float, float]
    :param vector2X: (C) X coordinate of the vector to which to compute the rotation
    :type vector2X: float
    :param vector2Y: (C) Y coordinate of the vector to which to compute the rotation
    :type vector2Y: float
    :param vector2Z: (C) Z coordinate of the vector to which to compute the rotation
    :type vector2Z: float
    
    :returns: 3 Euler angles or axis and angle
    :rtype: float[]
    """
    pass


def NParticleToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BridgeEdgeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def VisualizeMetadataOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_meshColorOverrideTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def getParticleAttr(*args, array=True, attribute="", object="", **kwargs):
    """
    This action will return either an array of values, or the average value and maximum offset,
    for a specied per-particle attribute of a particle object or component  If a particle
    component is specified on the command line, values are returned for that component only  If
    an object name is given instead, values are returned for all particles in that o
    
    :param array: (C) Tells the action whether you want a full array of data  If set true, the
    action returns an array of floats containing the values for all the specifie
    :type array: boolean
    :param attribute: (C) Tells the action which attribute you want the value of  Must be a
    per-particle attribute
    :type attribute: string
    :param object: (C) This flag is obsolete  Instead of using it, please pass the name of the
    object and/or components you want on the command line  See the examples
    :type object: string
    
    :returns: Command result
    :rtype: float[]
    """
    pass


def ShapeEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleMeshFaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleCurrentContainerHud(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GetFKIdFromEffectorId(*args, **kwargs):
    """
    
    """
    pass


def HypershadeSortByTime(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def popPinning(*args, **kwargs):
    """
    
    """
    pass


def xgmSplineSelect(*args, **kwargs):
    """
    
    """
    pass


def texMoveUVShellContext(*args, exists=True, image1="", image2="", image3="", iterations=0,
                          mask=True, position=True, shellBorder=0.0, q=True, query=True, e=True,
                          edit=True, **kwargs):
    """
    This command can be used to create, edit, or query a texture editor move manip context 
    Note that the above flags control the global behaviour of all texture editor move manip
    contexts  Changing one context independently is not allowed  Changing a context's behaviour
    using the above flags, will change all existing texture editor move manip contexts
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param iterations: (Q E) Sets or queries the number of iterations to perform
    :type iterations: int
    :param mask: (Q E) Sets or queries masking on the shell
    :type mask: boolean
    :param position: (Q) Returns the current position of the manipulator
    :type position: boolean
    :param shellBorder: (Q E) Sets or queries the size of the shell border
    :type shellBorder: float
    
    :returns: (the name of the new context)
    :rtype: string
    """
    pass


def attrEnumOptionMenuGrp(*args, adjustableColumn=0, adjustableColumn2=0, adjustableColumn3=0,
                          adjustableColumn4=0, adjustableColumn5=0, adjustableColumn6=0,
                          annotation="", attribute=None, backgroundColor=None, columnAlign=None,
                          columnAlign2=None, columnAlign3=None, columnAlign4=None,
                          columnAlign5=None, columnAlign6=None, columnAttach=None,
                          columnAttach2=None, columnAttach3=None, columnAttach4=None,
                          columnAttach5=None, columnAttach6=None, columnOffset2=None,
                          columnOffset3=None, columnOffset4=None, columnOffset5=None,
                          columnOffset6=None, columnWidth=None, columnWidth1=0,
                          columnWidth2=None, columnWidth3=None, columnWidth4=None,
                          columnWidth5=None, columnWidth6=None, defineTemplate="", docTag="",
                          dragCallback=None, dropCallback=None, enable=True,
                          enableBackground=True, enableKeyboardFocus=True, enumeratedItem=None,
                          exists=True, fullPathName=True, height=0, highlightColor=None,
                          isObscured=True, label="", manage=True, noBackground=True,
                          numberOfPopupMenus=True, parent="", popupMenuArray=True,
                          preventOverride=True, rowAttach=None, statusBarMessage="",
                          useTemplate="", visible=True, visibleChangeCommand=None, width=0,
                          q=True, query=True, e=True, edit=True, **kwargs):
    """
    All of the group commands position their individual controls in columns starting at column
    1  The layout of each control (ie  column) can be customized using the -cw/columnWidth,
    -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumn flags  By
    default, columns are left aligned with no offset and are 100 pixels wide  Only o
    
    :param adjustableColumn: (C E) Specifies which column has an adjustable size that changes
    with the sizing of the layout  The column value is a 1-based index  Passing 0 as argument
    :type adjustableColumn: int
    :param adjustableColumn2: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly two columns
    :type adjustableColumn2: int
    :param adjustableColumn3: (C E) Specifies that the column has an adjustable size that
    changes with the size of the parent layout  Ignored if there are not exactly three columns
    :type adjustableColumn3: int
    :param adjustableColumn4: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly four columns
    :type adjustableColumn4: int
    :param adjustableColumn5: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly five columns
    :type adjustableColumn5: int
    :param adjustableColumn6: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly six columns
    :type adjustableColumn6: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param attribute: (C E) The name of an attribute  The button will be attached to the
    attribute so the button can be kept in synch with the attribute
    :type attribute: name
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param columnAlign: (C E M) Arguments are : column number, alignment type  Possible
    alignments are: left | right | center  Specifies alignment type for the specified column
    :type columnAlign: [int, string]
    :param columnAlign2: (C E) Sets the text alignment of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "center"
    :type columnAlign2: [string, string]
    :param columnAlign3: (C E) Sets the text alignment for all three columns  Ignored if there
    are not exactly three columns  Valid values are "left", "right", and "center"
    :type columnAlign3: [string, string, string]
    :param columnAlign4: (C E) Sets the text alignment for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "center"
    :type columnAlign4: [string, string, string, string]
    :param columnAlign5: (C E) Sets the text alignment for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "center"
    :type columnAlign5: [string, string, string, string, string]
    :param columnAlign6: (C E) Sets the text alignment for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "center"
    :type columnAlign6: [string, string, string, string, string, string]
    :param columnAttach: (C E M) Arguments are : column number, attachment type, and offset 
    Possible attachments are: left | right | both  Specifies column attachment types and offe
    :type columnAttach: [int, string, int]
    :param columnAttach2: (C E) Sets the attachment type of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "both"
    :type columnAttach2: [string, string]
    :param columnAttach3: (C E) Sets the attachment type for all three columns  Ignored if
    there are not exactly three columns  Valid values are "left", "right", and "both"
    :type columnAttach3: [string, string, string]
    :param columnAttach4: (C E) Sets the attachment type for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "both"
    :type columnAttach4: [string, string, string, string]
    :param columnAttach5: (C E) Sets the attachment type for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "both"
    :type columnAttach5: [string, string, string, string, string]
    :param columnAttach6: (C E) Sets the attachment type for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "both"
    :type columnAttach6: [string, string, string, string, string, string]
    :param columnOffset2: (C E) This flag is used in conjunction with the -columnAttach2 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the tw
    :type columnOffset2: [int, int]
    :param columnOffset3: (C E) This flag is used in conjunction with the -columnAttach3 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the th
    :type columnOffset3: [int, int, int]
    :param columnOffset4: (C E) This flag is used in conjunction with the -columnAttach4 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fo
    :type columnOffset4: [int, int, int, int]
    :param columnOffset5: (C E) This flag is used in conjunction with the -columnAttach5 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fi
    :type columnOffset5: [int, int, int, int, int]
    :param columnOffset6: (C E) This flag is used in conjunction with the -columnAttach6 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the si
    :type columnOffset6: [int, int, int, int, int, int]
    :param columnWidth: (C E M) Arguments are : column number, column width  Sets the width of
    the specified column where the first parameter specifies the column (1 based index) an
    :type columnWidth: [int, int]
    :param columnWidth1: (C E) Sets the width of the first column  Ignored if there is not
    exactly one column
    :type columnWidth1: int
    :param columnWidth2: (C E) Sets the column widths of both columns  Ignored if there are not
    exactly two columns
    :type columnWidth2: [int, int]
    :param columnWidth3: (C E) Sets the column widths for all 3 columns  Ignored if there are
    not exactly 3 columns
    :type columnWidth3: [int, int, int]
    :param columnWidth4: (C E) Sets the column widths for all 4 columns  Ignored if there are
    not exactly 4 columns
    :type columnWidth4: [int, int, int, int]
    :param columnWidth5: (C E) Sets the column widths for all 5 columns  Ignored if there are
    not exactly 5 columns
    :type columnWidth5: [int, int, int, int, int]
    :param columnWidth6: (C E) Sets the column widths for all 6 columns  Ignored if there are
    not exactly 6 columns
    :type columnWidth6: [int, int, int, int, int, int]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param enumeratedItem: (C M) Enumerated item and the corresponding string  If this flag is
    not supplied when the control is created, then the command will try to read the values
    :type enumeratedItem: [int, string]
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) Text for the control
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rowAttach: (C E M) Arguments are : column, attachment type, offset  Possible
    attachments are: top | bottom | both  Specifies attachment types and offsets for the
    entire
    :type rowAttach: [int, string, int]
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The full name of the control on creation.
    :rtype: string
    """
    pass


def GetHIKMatrixDecomposition(*args, **kwargs):
    """
    
    """
    pass


def nurbsEditUV(*args, angle=0.0, pivotU=0.0, pivotV=0.0, relative=True, rotateRatio=1.0,
                rotation=True, scale=True, scaleU=0.0, scaleV=0.0, uValue=0.0, vValue=0.0,
                q=True, query=True, **kwargs):
    """
    Command Edits UVs on NURBS objects  When used with the query flag, it returns the UV values
    associated with the specified components
    
    :param angle: (C Q) Specifies the angle value (in degrees) by which the UV values are to be
    rotated
    :type angle: float
    :param pivotU: (C Q) Specifies the pivot value, in the u direction, about which the scale
    or rotate is to be performed
    :type pivotU: float
    :param pivotV: (C Q) Specifies the pivot value, in the v direction, about which the scale
    or rotate is to be performed
    :type pivotV: float
    :param relative: (C Q) Specifies whether this command is editing the values relative to the
    currently existing values  Default is true;
    :type relative: boolean
    :param rotateRatio: (C Q) Specifies the ratio value by which the UV values are to be
    rotated  Default is 1.0
    :type rotateRatio: float
    :param rotation: (C Q) Specifies whether this command is editing the values with rotation
    values
    :type rotation: boolean
    :param scale: (C Q) Specifies whether this command is editing the values with scale values
    :type scale: boolean
    :param scaleU: (C Q) Specifies the scale value in the u direction
    :type scaleU: float
    :param scaleV: (C Q) Specifies the scale value in the v direction
    :type scaleV: float
    :param uValue: (C Q) Specifies the value, in the u direction - absolute if relative flag is
    false.
    :type uValue: float
    :param vValue: (C Q) Specifies the value, in the v direction - absolute if relative flag is
    false.
    :type vValue: float
    
    :returns: Success or Failure.
    :rtype: boolean
    """
    pass


def ResetTransformations(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AssignHairConstraint(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def LockContainer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideSubdivSurfaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolygonSelectionConstraints(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShapeEditorNewGroup(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TransferAttributeValues(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteKeys(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DuplicateFaceOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def offsetSurface(*args, caching=True, distance=1.0, method=0, nodeState=0,
                  constructionHistory=True, name="", object=True, q=True, query=True, e=True,
                  edit=True, **kwargs):
    """
    The offset command creates new offset surfaces from the selected surfaces  The default
    method is a surface offset, which offsets relative to the surface itself  The CV offset
    method offsets the CVs directly rather than the surface, so is usually slightly less
    accurate but is faster  The offset surface will always have the same degree, number of CVs
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param distance: (C Q E) Offset distance Default: 1.0
    :type distance: float
    :param method: (C Q E) Offset method 0 - Surface Fit 1 - CV Fit Default: 0
    :type method: int
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def paintPointsContext(*args, **kwargs):
    """
    
    """
    pass


def twoPointArcCtx(*args, degree=0, exists=True, history=True, image1="", image2="", image3="",
                   name="", spans=4, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The twoPointArcCtx command creates a new context for creating two point circular arcs
    
    :param degree: (C Q E) Valid values are 1 or 3  Default degree 3
    :type degree: int
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param spans: (C Q E) Default is 4
    :type spans: int
    
    :returns: Name of the new context
    :rtype: string
    """
    pass


def IncreaseGammaCoarse(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def toggleDisplacement(*args, **kwargs):
    """
    This command toggles the displacement preview of the polygon  This command is NOT un-doable
    
    
    :returns: 
    :rtype: None
    """
    pass


def mayaDpiSetting(*args, mode=0, realScaleValue=True, scaleValue=0.0, systemDpi=True, q=True,
                   query=True, **kwargs):
    """
    Provide Maya interface scaling based on system DPI or custom scale setting or no scaling 
    Please note that the change will only take effect after relaunching Maya
    
    :param mode: (C Q) Specifies the interface scaling mode: 0 - System Dpi Based Scaling 1 -
    Custom Scaling (Must provide the custom scale value with flag "-scaleValue") 2
    :type mode: int
    :param realScaleValue: (Q) This is a query mode only flag which returns the real scale
    value depending on current scaling mode and defined scale value: mode 0 - Return the curr
    :type realScaleValue: boolean
    :param scaleValue: (C Q) Specifies the custom scale of the interface if scaling mode is 1 
    The allowed values are [1.0, 1.25, 1.5, 2.0]  In query mode, return the scale value
    :type scaleValue: float
    :param systemDpi: (Q) This is a query mode only flag which returns the current system dpi
    value
    :type systemDpi: boolean
    
    :returns: Scale mode or system DPI value, as queried
    :rtype: int
    """
    pass


def workspaceControl(*args, checksPlugins=True, close=True, closeCommand=None, collapse=True,
                     defineTemplate="", dockToControl=None, dockToMainWindow=None,
                     dockToPanel=None, duplicatable=True, exists=True, floating=True,
                     height=True, heightProperty="", horizontal=True, initCallback="",
                     initialHeight=0, initialWidth=0, label="", loadImmediately=True,
                     minimumHeight=0, minimumWidth=0, r=True, requiredControl="",
                     requiredPlugin="", resizeHeight=0, resizeWidth=0, restore=True,
                     retain=True, stateString="", tabPosition=None, tabToControl=None,
                     uiScript=None, useTemplate="", visible=True, visibleChangeCommand=None,
                     width=True, widthProperty="", q=True, query=True, e=True, edit=True,
                     **kwargs):
    """
    Creates and manages the widget used to host windows in a layout that enables docking and
    stacking windows together
    
    :param checksPlugins: (C E) Sets whether the UI (as defined by the uiScript) checks the
    loaded state of one or more plug-ins in its code  The UI will not be loaded until the aut
    :type checksPlugins: boolean
    :param close: (E) Closes the workspace control
    :type close: boolean
    :param closeCommand: (C E) Command that gets executed when the workspace control is closed
    :type closeCommand: script
    :param collapse: (C Q E) Collapse or expand the tab widget parent of the workspace control
    :type collapse: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param dockToControl: (C E) Dock this workspace control next to the given control  The
    first argument is the control name, the second is dock position relative to the control (v
    :type dockToControl: [string, string]
    :param dockToMainWindow: (C E) Dock this workspace control into the main window  The first
    argument is the dock position along the sides of the main window (valid values are: "left
    :type dockToMainWindow: [string, boolean]
    :param dockToPanel: (C E) Dock this workspace control into the workspace docking panel that
    the given workspace control is in  The first argument is the control name, the seco
    :type dockToPanel: [string, string, boolean]
    :param duplicatable: (C Q E) Controls whether or not this workspace control can be
    duplicated  The default duplicate state is controlled by whether or not the panel is unique
     Un
    :type duplicatable: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param floating: (C Q E) Whether the workspace control is floating
    :type floating: boolean
    :param height: (Q) Query only flag returning the current height of the control
    :type height: boolean
    :param heightProperty: (C Q E) Set height property of the workspace control  Valid values
    are: fixed - Cannot be resized manually and will not be given any extra space while maximi
    :type heightProperty: string
    :param horizontal: (C Q E) Orientation of the control  This flag is true by default, which
    corresponds to a horizontally oriented widget  Note: currently only "Toolbox" and "Sh
    :type horizontal: boolean
    :param initCallback: (C Q E) Adds a mel command to be executed when the control is added to
    the layout  The command should be a mel proc and it will be called with the workspaceC
    :type initCallback: string
    :param initialHeight: (C E) The initial height of the workspace control when first shown
    :type initialHeight: int
    :param initialWidth: (C E) The initial width of the workspace control when first shown
    :type initialWidth: int
    :param label: (C Q E) The label text  The default label is the name of the workspace
    control
    :type label: string
    :param loadImmediately: (C E) Sets whether the UI (as defined by the uiScript) will be
    built immediately on workspace control creation (true) or delayed until the control is
    actua
    :type loadImmediately: boolean
    :param minimumHeight: (C Q E) Sets the minimum height of control to the given value  If
    given value is 0 (False), minimum height is set to 0  If given value is 1 (True), minimum
    h
    :type minimumHeight: int
    :param minimumWidth: (C Q E) Sets the minimum width of control to the given value  This
    flag parameter was changed from bool to int in 2018 and old settings are still respected a
    :type minimumWidth: int
    :param r: (Q E) Raises a workspace control to the top and makes it active  In Query mode,
    this flag will return whether the workspace control is active or not  Note
    :type r: boolean
    :param requiredControl: (C E M) The name of a workspace control that needs to be open in
    order for this workspace control to properly function  This workspace control will not be
    cr
    :type requiredControl: string
    :param requiredPlugin: (C E M) The name of a plug-in that needs to be loaded in order to
    build the workspace control UI
    :type requiredPlugin: string
    :param resizeHeight: (E) Resizes a floating workspace control's height to the given value
    :type resizeHeight: int
    :param resizeWidth: (E) Resizes a floating workspace control's width to the given value
    :type resizeWidth: int
    :param restore: (C E) Restores the control according to the following rules: If collapsed
    then the control will be expanded If hidden then the control will be shown If min
    :type restore: boolean
    :param retain: (C) Sets whether the workspace control is retained (i.e  only hidden) or
    deleted when closed  Default value is true
    :type retain: boolean
    :param stateString: (C Q E) String containing the state of the control  Can be used with
    the initCallback flag
    :type stateString: string
    :param tabPosition: (C Q E) Changes the tab position  The possible values are: "north",
    "east" and "west"  The boolean value, if set to true, changes the tab positions of all th
    :type tabPosition: [string, boolean]
    :param tabToControl: (C E) Tab this workspace control into the given control  The first
    argument is the control name, the second is the index position within the containing tab
    :type tabToControl: [string, int]
    :param uiScript: (C E) The specified script will be invoked to build the UI of the
    workspaceControl  This is a required flag
    :type uiScript: script
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the workspace control  A control is created
    visible by default  If the control is created as not visible, the control will be cr
    :type visible: boolean
    :param visibleChangeCommand: (C E) Command that gets executed when visible state of the
    workspace control changes
    :type visibleChangeCommand: script
    :param width: (Q) Query only flag returning the current width of the control
    :type width: boolean
    :param widthProperty: (C Q E) Set width property of the workspace control  Valid values
    are: fixed - Cannot be resized manually and will not be given any extra space while
    maximiz
    :type widthProperty: string
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def tangentConstraint(*args, aimVector=None, layer="", name="", remove=True, targetList=True,
                      upVector=None, weight=0.0, weightAliasList=True, worldUpObject=None,
                      worldUpType="", worldUpVector=None, q=True, query=True, e=True, edit=True,
                      **kwargs):
    """
    Constrain an object's orientation based on the tangent of the target curve[s] at the
    closest point[s] to the object   A tangentConstraint takes as input one or more NURBS
    curves (the targets) and a DAG transform node (the object)  The tangentConstraint orients
    the constrained object such that the aimVector (in the object's local coordinate system)
    
    
    :param aimVector: (C Q E) Set the aim vector  This is the vector in local coordinates that
    points at the target  If not given at creation time, the default value of (1.0, 0.0,
    :type aimVector: [float, float, float]
    :param layer: (C E) Specify the name of the animation layer where the constraint should be
    added
    :type layer: string
    :param name: (C Q E) Sets the name of the constraint node to the specified name  Default
    name is constrainedObjectName_constraintType
    :type name: string
    :param remove: (E) removes the listed target(s) from the constraint
    :type remove: boolean
    :param targetList: (Q) Return the list of target objects
    :type targetList: boolean
    :param upVector: (C Q E) Set local up vector  This is the vector in local coordinates that
    aligns with the world up vector  If not given at creation time, the default value o
    :type upVector: [float, float, float]
    :param weight: (C Q E) Sets the weight value for the specified target(s)  If not given at
    creation time, the default value of 1.0 is used
    :type weight: float
    :param weightAliasList: (Q) Returns the names of the attributes that control the weight of
    the target objects  Aliases are returned in the same order as the targets are returned
    :type weightAliasList: boolean
    :param worldUpObject: (C Q E) Set the DAG object use for worldUpType "object" and
    "objectrotation"  See worldUpType for greater detail  The default value is no up object,
    which is
    :type worldUpObject: name
    :param worldUpType: (C Q E) Set the type of the world up vector computation  The
    worldUpType can have one of 5 values: "scene", "object", "objectrotation", "vector", or
    "none"
    :type worldUpType: string
    :param worldUpVector: (C Q E) Set world up vector  This is the vector in world coordinates
    that up vector should align with  See -wut/worldUpType (below)for greater detail  If not
    :type worldUpVector: [float, float, float]
    
    :returns: Name of the created constraint node
    :rtype: string[]
    """
    pass


def ConvertSelectionToFacePerimeter(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddToContainerOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SculptMeshActivateBrushSize(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FreeformFilletOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OpenCloseCurveOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_objectEdgesOnlyTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GraphEditorLockChannel(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UnitizeUVs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def shadingLightRelCtx(*args, exists=True, history=True, image1="", image2="", image3="",
                       name="", offCommand="", onCommand="", shadingCentric=True, q=True,
                       query=True, e=True, edit=True, **kwargs):
    """
    This command creates a context that can be used for associating lights to shading groups 
    You can put the context into shading-centric mode by using the -shadingCentric flag and
    specifying true  This means that the shading group is selected first then lights associated
    with the shading group are highlighted  Subsequent selections result in assignme
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param offCommand: (C Q E) command to be issued when context is turned on
    :type offCommand: string
    :param onCommand: (C Q E) command to be issued when context is turned on
    :type onCommand: string
    :param shadingCentric: (C Q E) shading-centric mode
    :type shadingCentric: boolean
    
    :returns: Name of the context created.
    :rtype: string
    """
    pass


def SetInitialStateOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NURBSTexturePlacementTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreaseProxyEdgeToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MakeBoatsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UndoViewChange(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def mrShaderManager(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def EPCurveToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateAreaLightOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DisconnectJoint(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgCreateDescription(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def geometryCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def editDisplayLayerGlobals(*args, baseId=0, currentDisplayLayer=None, mergeType=0,
                            useCurrent=True, q=True, query=True, **kwargs):
    """
    Edit the parameter values common to all display layers  Some of these paremeters, eg 
    baseId and mergeType, are stored as preferences and some, eg  currentDisplayLayer, are
    stored in the file
    
    :param baseId: (C Q) Set base layer ID  This is the number at which new layers start
    searching for a unique ID
    :type baseId: int
    :param currentDisplayLayer: (C Q) Set current display layer; ie  the one that all new
    objects are added to
    :type currentDisplayLayer: name
    :param mergeType: (C Q) Set file import merge type  Valid values are 0, none, 1, by number,
    and 2, by name
    :type mergeType: int
    :param useCurrent: (C Q) Set whether or not to enable usage of the current display layer as
    the destination for all new nodes
    :type useCurrent: boolean
    
    :returns: Command success
    :rtype: boolean
    """
    pass


def ToggleObjectDetails(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nClothMakeCollide(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PaintFluidsToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PublishRootTransformOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXProperties(*args, **kwargs):
    """
    
    """
    pass


def HypershadeConvertToFileTextureOptionBox(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def editRenderLayerMembers(*args, fullNames=True, noRecurse=True, remove=True, q=True,
                           query=True, **kwargs):
    """
    This command is used to query and edit memberships to render layers  Only transform and
    geometry nodes may be members  At render time, all descendants of the members of a render
    layer will also be included in the render layer
    
    :param fullNames: (Q) (Query only.) If set then return the full DAG paths of the objects in
    the layer  Otherwise return just the name of the object
    :type fullNames: boolean
    :param noRecurse: (C) If set then only add selected objects to the render layer  Otherwise
    all descendants of the selected objects will also be added  This flag may be app
    :type noRecurse: boolean
    :param remove: (C) Remove the specified objects from the render layer
    :type remove: boolean
    
    :returns: Number of objects added to the layer
    :rtype: int
    """
    pass


def preferredRenderer(*args, fallback="", makeCurrent=True, q=True, query=True, **kwargs):
    """
    Command to set the preferred renderer  This command can be used to query the preferred
    renderer and to set the current renderer as the preferred one  It also allows users to
    specify a preferred fallback renderer
    
    :param fallback: (C Q) Sets the preferred fallback renderer
    :type fallback: string
    :param makeCurrent: (C) Sets the current renderer as the preferred one
    :type makeCurrent: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def setParticleAttr(*args, attribute="", floatValue=0.0, object="", randomFloat=0.0,
                    randomVector=None, relative=False, vectorValue=None, **kwargs):
    """
    This action will set the value of the chosen attribute for every particle or selected
    component in the selected or passed particle object  Components should not be passed to the
    command line  For setting the values of components, the components must be selected and
    only the particle object's names should be passed to this action  If the attribute i
    
    :param attribute: (C) Tells the action which attribute you want to set
    :type attribute: string
    :param floatValue: (C) Tells what you want the value to be set to of a float attribute
    :type floatValue: float
    :param object: (C) If this flag is passed and the STRING is the name of a particle object's
    transform or shape, then ONLY that object will be edited, ignoring the selec
    :type object: string
    :param randomFloat: (C) Tells the command to add a random value from -FLOAT to +FLOAT to
    the results of each particle  The default is 0.0
    :type randomFloat: float
    :param randomVector: (C) Tells the command to add a random value from <<-x,-y,-z>> to <<x,y,
    z>> to the results of each particle  The default 0 0 0
    :type randomVector: [float, float, float]
    :param relative: (C) If this is set to TRUE (the default is FALSE), then the float or
    vector value will be added to the current value for each particle
    :type relative: boolean
    :param vectorValue: (C) Tells what you want the value to be set to of a vector attribute
    :type vectorValue: [float, float, float]
    
    :returns: 
    :rtype: None
    """
    pass


def ContourProjectionOptions(*args, **kwargs):
    """
    unknown
    """
    pass


def ToggleShowBufferCurves(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmSelectBrushToolCmd(*args, **kwargs):
    """
    
    """
    pass


def ikSpringSolverCallbacks(*args, **kwargs):
    """
    
    """
    pass


def unknownNode(*args, plugin=True, realClassName=True, realClassTag=True, q=True, query=True,
                **kwargs):
    """
    Allows querying of the data stored for unknown nodes (nodes that are defined by a plug-in
    that Maya could not load when loading a scene file)
    
    :param plugin: (Q) In query mode return the name of the plug-in from which the unknown node
    originated  If no plug-in then the empty string is returned
    :type plugin: boolean
    :param realClassName: (Q) Return the real class name of the node
    :type realClassName: boolean
    :param realClassTag: (Q) Return the real class IFF tag of the node
    :type realClassTag: boolean
    
    :returns: in query mode
    :rtype: string[]
    """
    pass


def SmoothingLevelDecrease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PaintGrid(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def translator(*args, defaultFileRule=True, defaultOptions="", extension=True,
               fileCompression="", filter=True, list=True, loaded=True, objectType=True,
               optionsScript=True, readSupport=True, writeSupport=True, q=True, query=True,
               **kwargs):
    """
    Set or query parameters associated with the file translators specified in as the argument
    
    :param defaultFileRule: (Q) Returns the default file rule value, can return "" as well
    :type defaultFileRule: boolean
    :param defaultOptions: (Q) Return/set a string of default options used by this translator
    :type defaultOptions: string
    :param extension: (Q) Returns the default file extension for this translator
    :type extension: boolean
    :param fileCompression: (Q) Specifies the compression action to take when a file is saved 
    Possible values are "compressed", "uncompressed" "asCompressed"
    :type fileCompression: string
    :param filter: (Q) Returns the filter string used for this translator
    :type filter: boolean
    :param list: (Q) Return a string array of all the translators that are loaded
    :type list: boolean
    :param loaded: (Q) Returns true if the given translator is currently loaded
    :type loaded: boolean
    :param objectType: (Q) This flag is obsolete  This will now return the same results as
    defaultFileRule going forward
    :type objectType: boolean
    :param optionsScript: (Q) Query the name of the options script to use to post the user
    options UI  When this script is invoked it will expect the name of the parent layout in
    :type optionsScript: boolean
    :param readSupport: (Q) Returns true if this translator supports read operations
    :type readSupport: boolean
    :param writeSupport: (Q) Returns true if this translator supports write operations
    :type writeSupport: boolean
    
    :returns: or string array depending upon which flags are specified.
    :rtype: boolean
    """
    pass


def quit(*args, abort=True, exitCode=0, force=True, **kwargs):
    """
    This command is used to exit the application
    
    :param abort: (C) Will quit without saving like -force, but will also prevent
    preferences/hotkeys/colors from being saved  Use at your own risk
    :type abort: boolean
    :param exitCode: (C) Specifies the exit code to be returned once the application exits  The
    default exit code is 0
    :type exitCode: int
    :param force: (C) If specified, this flag will force a quit without saving or prompting for
    saving changes  Use at your own risk
    :type force: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def assignShaderToType(*args, **kwargs):
    """
    
    """
    pass


def ToggleFrameRate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideNRigids(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DetachSurfacesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def hide(*args, allObjects=True, clearLastHidden=True, clearSelection=True,
         invertComponents=True, returnHidden=True, testVisibility=True, **kwargs):
    """
    The hide command is used to make objects invisible  If no flags are used, the objects
    specified, or the active objects if none are specified, will be made invisible
    
    :param allObjects: (C) Make everything invisible (top level objects)
    :type allObjects: boolean
    :param clearLastHidden: (C) Clear the last hidden list
    :type clearLastHidden: boolean
    :param clearSelection: (C) Clear selection after the operation
    :type clearSelection: boolean
    :param invertComponents: (C) Hide components that are not specified
    :type invertComponents: boolean
    :param returnHidden: (C) Hide objects, but also return list of hidden objects
    :type returnHidden: boolean
    :param testVisibility: (C) Do not change visibility, just test it (returns 1 is invisible,
    2 if visible, 3 if partially visible)
    :type testVisibility: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def xgmPoints(*args, **kwargs):
    """
    
    """
    pass


def ShowMeshAmplifyToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def itemFilterType(*args, text="", type=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command queries a named itemFilter object  This object can be attached to
    selectionConnection objects, or to editors, in order to filter the item lists going through
    them  Using union and intersection filters, complex composite filters can be created
    
    :param text: (Q E) Defines an annotation string to be stored with the filter
    :type text: string
    :param type: (Q) Query the type of the filter object  Possible return values are:
    itemFilter, attributeFilter, renderFilter, or unknownFilter
    :type type: boolean
    
    :returns: Single command result
    :rtype: string
    """
    pass


def ParticleFill(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def listCameras(*args, orthographic=True, perspective=True, **kwargs):
    """
    Command to list all cameras  If no flags are given, both perspective and orthographic
    cameras will be displayed  This command returns an array of camera names  When the
    transform name uniquely identifies the camera it is used, otherwise the shape name will be
    returned
    
    :param orthographic: (C) Display all orthographic cameras
    :type orthographic: boolean
    :param perspective: (C) Display all perspective cameras
    :type perspective: boolean
    
    :returns: Command result
    :rtype: string[]
    """
    pass


def threePointArcCtx(*args, degree=0, exists=True, history=True, image1="", image2="",
                     image3="", name="", spans=8, q=True, query=True, e=True, edit=True,
                     **kwargs):
    """
    The threePointArcCtx command creates a new context for creating 3 point arcs
    
    :param degree: (C Q E) VAlid values are 1 or 3  Default degree 3
    :type degree: int
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param spans: (C Q E) Default is 8
    :type spans: int
    
    :returns: (name of the new context)
    :rtype: string
    """
    pass


def subdMapCut(*args, caching=True, constructionHistory=True, name="", nodeState=0, q=True,
               query=True, e=True, edit=True, **kwargs):
    """
    Cut along edges of the texture mapping  The cut edges become map borders
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def NodeEditorUnpinSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RemoveFromCharacterSet(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SubdivSurfaceHierarchyMode(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def partition(*args, addSet=None, name="", removeSet=None, render=False, q=True, query=True,
              e=True, edit=True, **kwargs):
    """
    This command is used to create, query or add/remove sets to a partition  If a partition
    name needs to be specified, it is the first argument, other arguments represent the set
    names   Without any flags, the command will create a partition with a default name  Any
    sets which are arguments to the command will be added to the partition   A set can be 
    
    :param addSet: (C) Adds the list of sets to the named partition
    :type addSet: name
    :param name: (C) Assigns the given name to new partition  Valid only for create mode
    :type name: string
    :param removeSet: (C) Removes the list of sets from the named partition
    :type removeSet: name
    :param render: (C Q) New partition can contain render sets  For use in creation mode only 
    Default is false  Can also be used with query flag - returns boolean
    :type render: boolean
    
    :returns: Name of the partition that was created or edited
    :rtype: string
    """
    pass


def flow(*args, divisions=None, localCompute=True, localDivisions=None, objectCentered=True,
         q=True, query=True, e=True, edit=True, **kwargs):
    """
    The flow command creates a deformation lattice to `bend' the object that is animated along
    a curve of a motion path animation  The motion path animation has to have the follow option
    set to be on
    
    :param divisions: (Q) This flag specifies the number of lattice slices in x,y,z  The
    default values are 2 5 2  When queried, it returns the uint32_t uint32_t uint32_t
    :type divisions: [int, int, int]
    :param localCompute: (Q) This flag specifies whether or not to have local control over the
    object deformation  Default value: is on when the lattice is around the curve, and
    :type localCompute: boolean
    :param localDivisions: (Q) This flag specifies the extent of the region of effect  Default
    values are 2 2 2  When queried, it returns the uint32_t uint32_t uint32_t
    :type localDivisions: [int, int, int]
    :param objectCentered: (Q) This flag specifies whether to create the lattice around the
    selected object at its center, or to create the lattice around the curve  Default value
    :type objectCentered: boolean
    
    :returns: The names of the created flow node and associated
    lattice nodes.
    :rtype: string[]
    """
    pass


def CreateReferenceOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dgPerformance(*args, **kwargs):
    """
    
    """
    pass


def WrinkleTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleTextureBorderEdges(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmSetArchiveSize(*args, **kwargs):
    """
    
    """
    pass


def polyBlendColor(*args, baseColorName="", blendFunc=0, blendWeightA=0.0, blendWeightB=0.0,
                   blendWeightC=0.0, blendWeightD=0.0, caching=True, constructionHistory=True,
                   dstColorName="", name="", nodeState=0, srcColorName="", q=True, query=True,
                   e=True, edit=True, **kwargs):
    """
    Takes two color sets and blends them together into a third specified color set
    
    :param baseColorName: (Q E) Name of the color set to blend from
    :type baseColorName: string
    :param blendFunc: (Q E) Type of blending function to use
    :type blendFunc: int
    :param blendWeightA: (Q E) Blend weight for linear and bilinear blending functions
    :type blendWeightA: float
    :param blendWeightB: (Q E) Blend weight for bilinear and channel blending functions
    :type blendWeightB: float
    :param blendWeightC: (Q E) Blend weight for channel functions
    :type blendWeightC: float
    :param blendWeightD: (Q E) Blend weight for channel functions
    :type blendWeightD: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param dstColorName: (Q E) Name of the color set to copy to
    :type dstColorName: string
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param srcColorName: (Q E) Name of the color set to copy from
    :type srcColorName: string
    
    :returns: The node name.
    :rtype: string
    """
    pass


def ProfilerToolShowAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowNonlinears(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ConformPolygonOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_preferencesTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def encodeString(*args, **kwargs):
    """
    This action will take a string and encode any character that would need to be escaped
    before being sent to some other command  Such characters include:
    
    
    :returns: Command result
    :rtype: string
    """
    pass


def hotkeySet(*args, current=True, delete=True, exists=True, export="", hotkeySetArray=True,
              ip="", rename="", source="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    Manages hotkey sets in Maya  A hotkey set holds hotkey to command mapping information 
    Default hotkey sets are hotkey sets that are shipped together with Maya  They are locked
    and cannot be altered   A new hotkey set is always duplicated from an existing hotkey set 
    In create mode, users can choose to specify which hotkey set to duplicate by using 
    
    :param current: (C Q E) Sets the hotkey set as the current active hotkey set  In query mode,
    returns the name of the current hotkey set
    :type current: boolean
    :param delete: (E) Deletes the hotkey set if it exists  Other flags are ignored  Returns
    true|false depending on the delete operation
    :type delete: boolean
    :param exists: (C) Returns true|false depending upon whether the specified object exists 
    Other flags are ignored
    :type exists: boolean
    :param export: (E) Exports a hotkey set  The argument is used to specify a full path of the
    output file
    :type export: string
    :param hotkeySetArray: (Q) Returns a string array of all existing hotkey set names
    :type hotkeySetArray: boolean
    :param ip: (E) Imports a hotkey set  The argument is used to specify a full path of the
    hotkey set file to import
    :type ip: string
    :param rename: (E) Renames an existing hotkey set  All white spaces will be replaced with
    '_' during operation
    :type rename: string
    :param source: (C) Specifies the source hotkey set  If flag is not provided, the current
    active hotkey set is used
    :type source: string
    
    :returns: The name of the hotkey set.
    :rtype: string
    """
    pass


def InsertKnotOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ImportOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeGraphUpDownstream(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PickWalkUseController(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateCluster(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RemoveConstraintTargetOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ConnectJoint(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RestoreUIElements(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def circularFillet(*args, caching=True, nodeState=0, positionTolerance=0.01, primaryRadius=1.0,
                   secondaryRadius=1.0, tangentTolerance=0.01, constructionHistory=True,
                   curveOnSurface=True, name="", object=True, q=True, query=True, e=True,
                   edit=True, **kwargs):
    """
    The cmd is used to compute the rolling ball surface fillet ( circular fillet ) between two
    given NURBS surfaces  To generate trim curves on the surfaces, use -cos true
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param positionTolerance: (C Q E) C(0) Tolerance For Fillet Surface Default: 0.01
    :type positionTolerance: float
    :param primaryRadius: (C Q E) primary Radius Default: 1.0
    :type primaryRadius: float
    :param secondaryRadius: (C Q E) secondary Radius Default: 1.0
    :type secondaryRadius: float
    :param tangentTolerance: (C Q E) G(1) Tolerance For Fillet Surface Default: 0.01
    :type tangentTolerance: float
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param curveOnSurface: (C) If possible, create 2D curve as a result
    :type curveOnSurface: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    
    :returns: Object name, node name.
    :rtype: string[]
    """
    pass


def ubercam(*args, **kwargs):
    """
    Use this command to create a "ubercam" with equivalent behavior to all cameras used by
    shots in the sequencer
    
    
    :returns: Ubercam name
    :rtype: string
    """
    pass


def dR_setExtendEdge(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CycleBackgroundColor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def spaceLocator(*args, absolute=True, name="", position=None, relative=True, q=True,
                 query=True, e=True, edit=True, **kwargs):
    """
    The command creates a locator at the specified position in space  By default it is created
    at (0,0,0)
    
    :param absolute: (C E) If set, the locator's position is in world space
    :type absolute: boolean
    :param name: (C E) Name for the locator
    :type name: string
    :param position: (C Q E) Location in 3-dimensional space where locator is to be created
    :type position: [float, float, float]
    :param relative: (C E) If set, the locator's position is relative to its local space  The
    locator is created in relative mode by default
    :type relative: boolean
    
    :returns: The name for the new locator in space.
    :rtype: string[]
    """
    pass


def SelectSimilarOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowMeshFillToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ikSystemInfo(*args, globalSnapHandle=True, q=True, query=True, **kwargs):
    """
    This action modifies and queries the current ikSystem controls
    
    :param globalSnapHandle: (C Q) If this flag is off, all ikHandles will not be snapped
    :type globalSnapHandle: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def layout(*args, annotation="", backgroundColor=None, childArray=True, defineTemplate="",
           docTag="", dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
           enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
           highlightColor=None, isObscured=True, manage=True, noBackground=True,
           numberOfChildren=True, numberOfPopupMenus=True, parent="", popupMenuArray=True,
           preventOverride=True, statusBarMessage="", useTemplate="", visible=True,
           visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
           **kwargs):
    """
    This command allows you to edit or query the properties of any layout  The argument is the
    name of the layout
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param childArray: (Q) Returns a string array of the names of the layout's immediate
    children
    :type childArray: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfChildren: (Q) Returns in an int the number of immediate children of the
    layout
    :type numberOfChildren: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: 
    :rtype: None
    """
    pass


def MirrorSubdivSurface(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteAllImagePlanes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def window(*args, backgroundColor=None, closeCommand=None, defineTemplate="", docTag="",
           dockCorner=None, dockStation=True, dockingLayout="", exists=True, frontWindow=True,
           height=0, iconName="", iconify=True, interactivePlacement=True, leftEdge=0,
           mainMenuBar=True, mainWindow=True, maximizeButton=True, menuArray=True, menuBar=True,
           menuBarCornerWidget=None, menuBarResize=True, menuBarVisible=True, menuIndex=None,
           minimizeButton=True, minimizeCommand=None, nestedDockingEnabled=True,
           numberOfMenus=True, parent="", resizeToFitChildren=True, restoreCommand=None,
           retain=True, sizeable=True, state="", title="", titleBar=True, titleBarMenu=True,
           toolbox=True, topEdge=0, topLeftCorner=None, useTemplate="", visible=True, width=0,
           widthHeight=None, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a new window but leaves it invisible  It is most efficient to add the
    window's elements and then make it visible with the showWindow command  The window can have
    an optional menu bar  Also, the title bar and minimize/maximize buttons can be turned on or
    off  If the title bar is off, then you cannot have minimize or maximize but
    
    :param backgroundColor: (C E) The background color of the window  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type backgroundColor: [float, float, float]
    :param closeCommand: (C E) Script executed after the window is closed
    :type closeCommand: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Attach a tag to the window
    :type docTag: string
    :param dockCorner: (C M) Specifies which docking areas occupied the four different corners
    of the window  By default docking windows on the bottom or top will span the whole
    :type dockCorner: [string, string]
    :param dockStation: (C) When set this flag specifies that this window can contain other
    docked sub-windows
    :type dockStation: boolean
    :param dockingLayout: (C Q E) When queried this flag will return a string holding the
    docking layout information  This string can be set when creating or editing a docking
    station
    :type dockingLayout: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param frontWindow: (Q) Return the name of the front window  Note: you must supply the name
    of any window (the window does not need to exist)  Returns "unknown" if the front
    :type frontWindow: boolean
    :param height: (C Q E) Height of the window excluding any window frame in pixels
    :type height: int
    :param iconName: (C Q E) The window's icon title  By default it is the same as the window's
    title
    :type iconName: string
    :param iconify: (C Q E) Icon state of the window
    :type iconify: boolean
    :param interactivePlacement: (C) Deprecated flag  Recognized but not implemented  This flag
    will be removed in a future version of Maya
    :type interactivePlacement: boolean
    :param leftEdge: (C Q E) Position of the left edge of the window
    :type leftEdge: int
    :param mainMenuBar: (C Q E) If this flag is used then the main menu bar will be enabled
    :type mainMenuBar: boolean
    :param mainWindow: (C Q E) Main window for the application  The main window has an 'Exit'
    item in the Window Manager menu  By default, the first created window becomes the main
    :type mainWindow: boolean
    :param maximizeButton: (C Q E) Turns the window's maximize button on or off
    :type maximizeButton: boolean
    :param menuArray: (Q) Return a string array containing the names of the menus in the
    window's menu bar
    :type menuArray: boolean
    :param menuBar: (C Q) Adds an empty menu bar to the window  The Qt name of the object will
    be m_menubar_nameOfTheWindow
    :type menuBar: boolean
    :param menuBarCornerWidget: (Q E) This flag specifies a widget to add to a corner of the
    parent window  The first argument corresponds to the widget name and the second to the
    positio
    :type menuBarCornerWidget: [string, string]
    :param menuBarResize: (E) This flag should be used with the -mcw/-menuBarCornerWidget flag 
    This is used to resize the menu bar so that the corner widgets are updated
    :type menuBarResize: boolean
    :param menuBarVisible: (C Q E) Visibility of the menu bar (if there is one)
    :type menuBarVisible: boolean
    :param menuIndex: (E) Sets the index of a specified menu
    :type menuIndex: [string, int]
    :param minimizeButton: (C Q E) Turns the window's minimize button on or off
    :type minimizeButton: boolean
    :param minimizeCommand: (C E) Script executed after the window is minimized (iconified)
    :type minimizeCommand: script
    :param nestedDockingEnabled: (C) Controls whether nested docking is enabled or not  Nested
    docking allows for docking windows next to other docked windows for more possible
    arrangeme
    :type nestedDockingEnabled: boolean
    :param numberOfMenus: (Q) Return the number of menus attached to the window's menu bar
    :type numberOfMenus: boolean
    :param parent: (C) Specifies a parent window or layout which the created window is always
    on top of  Note: If the parent is a window the created window is not modal, so
    :type parent: string
    :param resizeToFitChildren: (C Q E) The window will always grow/shrink to just fit the
    controls it contains
    :type resizeToFitChildren: boolean
    :param restoreCommand: (C E) Script executed after the window is restored from it's
    minimized (iconified) state
    :type restoreCommand: script
    :param retain: (C) Retains the window after it has been closed  The default is to delete
    the window when it is closed
    :type retain: boolean
    :param sizeable: (C Q E) Whether or not the window may be interactively resized
    :type sizeable: boolean
    :param state: (C Q E) When queried this flag will return a string holding the window state
    information  This string is a hexadecimal representation of a binary string and
    :type state: string
    :param title: (C Q E) The window's title
    :type title: string
    :param titleBar: (C Q E) Turns the window's title bar on or off
    :type titleBar: boolean
    :param titleBarMenu: (C Q E) Controls whether the title bar menu exists in the window title
    bar  Only valid if -tb/titleBar is true  This Windows only flag is true by default
    :type titleBarMenu: boolean
    :param toolbox: (C Q E) Makes this a toolbox style window  A Windows only flag that makes
    the title bar smaller and uses a slightly different display style
    :type toolbox: boolean
    :param topEdge: (C Q E) Position of the top edge of the window
    :type topEdge: int
    :param topLeftCorner: (C Q E) Position of the window's top left corner
    :type topLeftCorner: [int, int]
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The window's visibility
    :type visible: boolean
    :param width: (C Q E) Width of the window excluding any window frame in pixels
    :type width: int
    :param widthHeight: (C Q E) Window's width and height excluding any window frame in pixels
    :type widthHeight: [int, int]
    
    :returns: Name to the window.
    :rtype: string
    """
    pass


def ModelingPanelUndoViewChange(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_rotateTweakTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def buildSendToBackburnerDialog(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RebuildSurfaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddPondBoatLocatorOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def binMembership(*args, addToBin="", exists="", inheritBinsFromNodes=None, isValidBinName="",
                  listBins=True, makeExclusive="", notifyChanged=True, removeFromBin="", q=True,
                  query=True, **kwargs):
    """
    Command to assign nodes to bins
    
    :param addToBin: (C) Add the nodes in a node list to a bin
    :type addToBin: string
    :param exists: (C) Query if a node exists in a bin  The exists flag can take only one node
    :type exists: string
    :param inheritBinsFromNodes: (C) Let the node in the flag's argument inherit bins from
    nodes in the specified node list  The node list is specified as the object of the command
    :type inheritBinsFromNodes: name
    :param isValidBinName: (C) Query if the specified bin name is valid  If so, return true 
    Otherwise, return false
    :type isValidBinName: string
    :param listBins: (C Q) Query and return a list of bins a list of nodes belong to  If a bin
    contains any of the nodes in the selection list, then it should be included in th
    :type listBins: boolean
    :param makeExclusive: (C) Make the specified nodes belong exclusively in the specified bin
    :type makeExclusive: string
    :param notifyChanged: (C) This flag is used to notify that binMembership has been changed
    :type notifyChanged: boolean
    :param removeFromBin: (C) Remove the nodes in a node list from a bin
    :type removeFromBin: string
    
    :returns: Command result
    :rtype: boolean
    """
    pass


def arnoldRenderView(*args, **kwargs):
    """
    
    """
    pass


def InteractiveBindSkin(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmGrabBrushToolCmd(*args, **kwargs):
    """
    
    """
    pass


def mayaDpiSettingAction(*args, **kwargs):
    """
    
    """
    pass


def NodeEditorPickWalkLeft(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def shelfTabLayout(*args, annotation="", backgroundColor=None, borderStyle="",
                   changeCommand=None, childArray=True, childResizable=True, defineTemplate="",
                   docTag="", doubleClickCommand=None, dragCallback=None, dropCallback=None,
                   enable=True, enableBackground=True, enableKeyboardFocus=True, exists=True,
                   fullPathName=True, height=0, highlightColor=None,
                   horizontalScrollBarThickness=0, image="", imageVisible=True,
                   innerMarginHeight=0, innerMarginWidth=0, isObscured=True, manage=True,
                   minChildWidth=0, moveTab=None, newTabCommand=None, noBackground=True,
                   numberOfChildren=True, numberOfPopupMenus=True, parent="",
                   popupMenuArray=True, preSelectCommand=None, preventOverride=True,
                   scrollable=True, scrollableTabs=True, selectCommand=None, selectTab="",
                   selectTabIndex=0, showNewTab=True, statusBarMessage="", tabLabel=None,
                   tabLabelIndex=None, tabPosition="", tabTooltip=None, tabTooltipIndex=None,
                   tabsClosable=True, tabsVisible=True, useTemplate="",
                   verticalScrollBarThickness=0, visible=True, visibleChangeCommand=None,
                   width=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates/edits/queries a shelf tab group which is essentially a normal
    tabLayout with some drop behaviour in the tab bar  A garbage can icon can appear in the top
    right corner to dispose of buttons dragged to it from shelves
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param borderStyle: (C Q E) Specify the style of the border for tab layout  Valid values
    are: "none", "top", "notop" and "full"  By default, it will use "full" to draw a simple
    :type borderStyle: string
    :param changeCommand: (C E) Command executed when a tab is selected interactively  This
    command is only invoked when the selected tab changes  Re-selecting the current tab will
    :type changeCommand: script
    :param childArray: (Q) Returns a string array of the names of the layout's immediate
    children
    :type childArray: boolean
    :param childResizable: (C Q) Set to true if you want the child of the control layout to be
    as wide as the scroll area  You may also indicate a minimum width for the child using t
    :type childResizable: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param doubleClickCommand: (C E) Command executed when a tab is double clicked on  Note
    that the first click will select the tab and the second click will execute the double click
    co
    :type doubleClickCommand: script
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param horizontalScrollBarThickness: (C E) Thickness of the horizontal scroll bar  Specify
    an integer value greater than or equal to zero  This flag has no effect on Windows systems
    :type horizontalScrollBarThickness: int
    :param image: (C Q E) Image appearing in top right corner of tab layout
    :type image: string
    :param imageVisible: (C Q E) Visibility of tab image
    :type imageVisible: boolean
    :param innerMarginHeight: (C Q) Margin height for all tab children
    :type innerMarginHeight: int
    :param innerMarginWidth: (C Q) Margin width for all tab children
    :type innerMarginWidth: int
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param minChildWidth: (C Q) Specify a positive non-zero integer value indicating the
    minimum width the tab layout's children  This flag only has meaning when the
    -cr/childResiza
    :type minChildWidth: int
    :param moveTab: (C E) Move the tab from the current index to a new index
    :type moveTab: [int, int]
    :param newTabCommand: (C E) Command executed when the 'New Tab' button (on the tab bar) is
    clicked  Note: in order to show the new tab button use the -snt/showNewTab flag  Using
    :type newTabCommand: script
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfChildren: (Q) Returns in an int the number of immediate children of the
    layout
    :type numberOfChildren: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preSelectCommand: (C E) Command executed when a tab is selected but before it's
    contents become visible  Re-selecting the current tab will not invoke this command  Note
    that
    :type preSelectCommand: script
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param scrollable: (C Q) Puts all children of this layout within a scroll area
    :type scrollable: boolean
    :param scrollableTabs: (C Q E) If true, the active tab in the layout can be scrolled
    through with the mouse wheel  Default is true
    :type scrollableTabs: boolean
    :param selectCommand: (C Q E) Command executed when a tab is selected interactively This
    command will be invoked whenever a tab is selected, ie  re-selecting the current tab will
    :type selectCommand: script
    :param selectTab: (C Q E) The name, in short form, of the selected tab  An empty string is
    returned on query if there are no child tabs
    :type selectTab: string
    :param selectTabIndex: (C Q E) Identical to the -st/selectTab flag except this flag takes a
    1-based index to identify the selected tab  A value of 0 is returned on query if there a
    :type selectTabIndex: int
    :param showNewTab: (C Q E) Set to true if you want to have a 'New Tab' button shown at the
    end of the tab bar  Note: use the -ntc/newTabCommand flag to set the command executed
    :type showNewTab: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param tabLabel: (C Q E M) Set a tab label  The first argument is the name of a control
    that must be a child of the tab layout  The second argument is the label for the tab ass
    :type tabLabel: [string, string]
    :param tabLabelIndex: (C Q E M) Identical to the -tl/tabLabel flag except this flag takes a
    1-based index to identify the tab you want to set the label for  If this flag is queried
    :type tabLabelIndex: [int, string]
    :param tabPosition: (C Q E) Changes the tab position  The possible values are: "north",
    "east" and "west"
    :type tabPosition: string
    :param tabTooltip: (C Q E M) Set a tab tooltip  The first argument is the name of a control
    that must be a child of the tab layout  The second argument is the tooltip for the tab
    :type tabTooltip: [string, string]
    :param tabTooltipIndex: (C Q E M) Identical to the -tt/tabTooltip flag except this flag
    takes a 1-based index to identify the tab you want to set the tooltip for  If this flag is
    quer
    :type tabTooltipIndex: [int, string]
    :param tabsClosable: (C Q) Set to true if you want to have a close button icon on all
    created tabs
    :type tabsClosable: boolean
    :param tabsVisible: (C Q E) Visibility of the tab labels
    :type tabsVisible: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param verticalScrollBarThickness: (C E) Thickness of the vertical scroll bar  Specify an
    integer value greater than or equal to zero  This flag has no effect on Windows systems
    :type verticalScrollBarThickness: int
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the shelfTabLayout.
    :rtype: string
    """
    pass


def SelectFacetMask(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SplitPolygonTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def memoryDiag(*args, **kwargs):
    """
    
    """
    pass


def newton(*args, attenuation=0.0, magnitude=0.0, maxDistance=0.0, minDistance=0.0, name="",
           perVertex=True, position=None, torusSectionRadius=0.0, volumeExclusion=True,
           volumeOffset=None, volumeShape="", volumeSweep=0.0, q=True, query=True, e=True,
           edit=True, **kwargs):
    """
    For each listed object, the command creates a new field  The field has a shape which lives
    in the DAG and it has an associated dependency node  The field is added to the list of
    fields owned by the object  Use connectDynamic to cause the field to affect a dynamic
    object  Note that if more than one object is listed, a separate field is created for e
    
    :param attenuation: (Q E) Attentuation rate of field
    :type attenuation: float
    :param magnitude: (Q E) Strength of field
    :type magnitude: float
    :param maxDistance: (Q E) Maximum distance at which field is exerted  -1 indicates that the
    field has no maximum distance
    :type maxDistance: float
    :param minDistance: (Q E) Minimum distance at which field is exerted  Distance is in the
    denominator of the field force equation  Setting md to a small positive number avoids
    :type minDistance: float
    :param name: (Q E) name of field
    :type name: string
    :param perVertex: (Q E) Per-vertex application  If this flag is set true, then each
    individual point (CV, particle, vertex,etc.) of the chosen object exerts an identical cop
    :type perVertex: boolean
    :param position: (Q E M) Position in space (x,y,z) where you want to place a gravity field 
    The gravity then emanates from this position in space rather than from an object
    :type position: [float, float, float]
    :param torusSectionRadius: (Q E) Section radius for a torus volume  Applies only to torus 
    Similar to the section radius in the torus modelling primitive
    :type torusSectionRadius: float
    :param volumeExclusion: (Q E) Volume exclusion of the field  If true, points outside the
    volume (defined by the volume shape attribute) are affected, If false, points inside the v
    :type volumeExclusion: boolean
    :param volumeOffset: (Q E) Volume offset of the field  Volume offset translates the field's
    volume by the specified amount from the actual field location  This is in the field'
    :type volumeOffset: [float, float, float]
    :param volumeShape: (Q E) Volume shape of the field  Sets/edits/queries the field's volume
    shape attribute  If set to any value other than "none", determines a 3-D volume with
    :type volumeShape: string
    :param volumeSweep: (Q E) Volume sweep of the field  Applies only to sphere, cone, cylinder,
    and torus  Similar effect to the sweep attribute in modelling
    :type volumeSweep: float
    
    :returns: Command result
    :rtype: string
    """
    pass


def BakeSimulationOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExtendCurveOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleParticleCount(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def setKeyPath(*args, **kwargs):
    """
    The setKeyPath command either creates or edits the path (a nurbs curve) based on the
    current position of the selected object at the current time
    
    
    :returns: (Names of the created curve node and motionPath node)
    :rtype: string[]
    """
    pass


def SendToUnrealAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExportSelection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AlembicImportOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DisplayUVShaded(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GetHIKNode(*args, **kwargs):
    """
    
    """
    pass


def ToggleAutoSmooth(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorToggleCreateNodePane(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeMoveTabDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NextSkinPaintMode(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyGeoSampler(*args, alphaBlend="", averageColor=True, clampAlphaMax=0.0,
                   clampAlphaMin=0.0, clampRGBMax=None, clampRGBMin=None, colorBlend="",
                   colorDisplayOption=True, computeShadows=True, displaceGeometry=True,
                   flatShading=True, ignoreDoubleSided=True, lightingOnly=True,
                   reuseShadows=True, sampleByFace=True, scaleFactor=0.0, shareUV=True,
                   useLightShadows=True, e=True, edit=True, **kwargs):
    """
    This command performs a render sampling of surface color and transparency for each selected
    vertex or face and stores the sampled data as either the color value, or uses the sampled
    data to displace the affected vertices or faces by a sampled data value  Transparency is
    not used for displacement, and displacement is performed along vertex normals  
    
    :param alphaBlend: (C E) When specified, indicates the type of alpha blend to be applied 
    Options are: "none", "overwrite", "add", "subtract", "multiply", "divide", "average"
    :type alphaBlend: string
    :param averageColor: (C E) When used, will mean to force the storage of shared colors for
    vertex level sampling  By default vertex level sampling stores unshared colors
    :type averageColor: boolean
    :param clampAlphaMax: (C E) When used, will mean to clamp the storage of alpha to a
    maximum
    :type clampAlphaMax: float
    :param clampAlphaMin: (C E) When used, will mean to clamp the storage of alpha to a
    minimum
    :type clampAlphaMin: float
    :param clampRGBMax: (C E) When used, will mean to clamp the storage of RGB color to a
    maximum
    :type clampRGBMax: [float, float, float]
    :param clampRGBMin: (C E) When used, will mean to clamp the storage of RGB color to a
    minimum
    :type clampRGBMin: [float, float, float]
    :param colorBlend: (C E) When specified, indicates the type of color blend to be applied 
    Options are: "none", "overwrite", "add", "subtract", "multiply", "divide", "average"
    :type colorBlend: string
    :param colorDisplayOption: (C E) Change the display options on the mesh to display the
    vertex colors
    :type colorDisplayOption: boolean
    :param computeShadows: (C E) When used, shadow maps will be computed, saved, and reused
    during the sampling process
    :type computeShadows: boolean
    :param displaceGeometry: (C E) When used, geometry will be displaced along the normals at
    the sampling positions, as opposed to storing color values  The default is to store colors
    :type displaceGeometry: boolean
    :param flatShading: (C E) When used, flat shaded sampling will be computed  The default is
    smooth shading
    :type flatShading: boolean
    :param ignoreDoubleSided: (C E) When specified, the double sided flag will be ignored for
    prelighting
    :type ignoreDoubleSided: boolean
    :param lightingOnly: (C E) When used, incoming illumination will be computed as opposed to
    surface color an tranparency
    :type lightingOnly: boolean
    :param reuseShadows: (C E) When used, if shadow maps were previosly computed and saved,
    then they will be reused during the sampling process  The computeShadows option must be
    :type reuseShadows: boolean
    :param sampleByFace: (C E) When used, sample will occur at a per face level versus a per
    vertex level, which is the default behaviour
    :type sampleByFace: boolean
    :param scaleFactor: (C E) When used, will scale the sampled value by the specified amount 
    The default scale factor is 1.0  Negative values are acceptable for displacement, bu
    :type scaleFactor: float
    :param shareUV: (C E) When used, UVs are shared at a vertex when sampled  By default UVs
    are forced to be unshared
    :type shareUV: boolean
    :param useLightShadows: (C E) When used, will use each lights shadow map options  Otherwise
    these options will be overrridden when the computeShadows, and/or reusedShadows option
    :type useLightShadows: boolean
    
    :returns: Success or Failure
    :rtype: boolean
    """
    pass


def ToggleMeshEdges(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def uvSnapshot(*args, antiAliased=True, blueColor=255, entireUVRange=True, fileFormat="",
               greenColor=255, name="", overwrite=True, redColor=255, uMax=0.0, uMin=0.0,
               uvSetName="", vMax=0.0, vMin=0.0, xResolution=512, yResolution=512, **kwargs):
    """
    Builds an image containg the UVs of the selected objects
    
    :param antiAliased: (C) When this flag is set, lines are antialiased
    :type antiAliased: boolean
    :param blueColor: (C) Blue component of line drawing  Default is 255
    :type blueColor: int
    :param entireUVRange: (C) When this flag is set, the generated image will contain the
    entire uv range  Default is UV in 0-1 range
    :type entireUVRange: boolean
    :param fileFormat: (C) Output file format  Any of those keyword: "iff", "sgi", "pic", "tif",
    "als", "gif", "rla", "jpg" Default is iff
    :type fileFormat: string
    :param greenColor: (C) Green component of line drawing  Default is 255
    :type greenColor: int
    :param name: (C) Name of the file to be created
    :type name: string
    :param overwrite: (C) When this flag is set, existing file can be ovewritten
    :type overwrite: boolean
    :param redColor: (C) Red component of line drawing  Default is 255
    :type redColor: int
    :param uMax: (C) Optional User Specified Max value for U  Default value is 1  This will
    take precedence over the "entire range" -euv flag
    :type uMax: float
    :param uMin: (C) Optional User Specified Min value for U  Default value is 0  This will
    take precedence over the "entire range" -euv flag
    :type uMin: float
    :param uvSetName: (C) Name of the uv set to use  Default is the current one
    :type uvSetName: string
    :param vMax: (C) Optional User Specified Max value for V  Default value is 1  This will
    take precedence over the "entire range" -euv flag
    :type vMax: float
    :param vMin: (C) Optional User Specified Min value for V  Default value is 0  This will
    take precedence over the "entire range" -euv flag
    :type vMin: float
    :param xResolution: (C) Horizontal size of the image  Default is 512
    :type xResolution: int
    :param yResolution: (C) Vertical size of the image  Default is 512
    :type yResolution: int
    
    :returns: 
    :rtype: None
    """
    pass


def setFocus(*args, **kwargs):
    """
    Give keyboard focus to a specific control or panel, passed as an argument
    
    
    :returns: 
    :rtype: None
    """
    pass


def HideObjectGeometry(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def formLayout(*args, annotation="", attachControl=None, attachForm=None, attachNone=None,
               attachOppositeControl=None, attachOppositeForm=None, attachPosition=None,
               backgroundColor=None, childArray=True, defineTemplate="", docTag="",
               dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
               enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
               highlightColor=None, isObscured=True, manage=True, noBackground=True,
               numberOfChildren=True, numberOfDivisions=0, numberOfPopupMenus=True, parent="",
               popupMenuArray=True, preventOverride=True, statusBarMessage="", useTemplate="",
               visible=True, visibleChangeCommand=None, width=0, q=True, query=True, e=True,
               edit=True, **kwargs):
    """
    This command creates a form layout control  A form layout allows absolute and relative
    positioning of the controls that are its immediate children   Controls have four edges: top,
    left, bottom and right  There are only two directions that children can be positioned in,
    right-left and up-down  The attach flags take the direction of an attachment fro
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param attachControl: (C E M) Arguments are: control, edge, offset, control Valid edge
    values are: "top" | "bottom" | "left" | "right"  Attach a control to another control
    :type attachControl: [string, string, int, string]
    :param attachForm: (C E M) Arguments are: control, edge, offset  Valid edge values are:
    "top" | "bottom" | "left" | "right"  Attach the specified control to the form, offset by
    :type attachForm: [string, string, int]
    :param attachNone: (C E M) Arguments are: control, edge Valid edge values are: "top" |
    "bottom" | "left" | "right"  Attach a control to nothing
    :type attachNone: [string, string]
    :param attachOppositeControl: (C E M) Arguments are: control, edge, offset, control Valid
    edge values are: "top" | "bottom" | "left" | "right"  Attach a control to the opposite side
    of an
    :type attachOppositeControl: [string, string, int, string]
    :param attachOppositeForm: (C E M) Arguments are: control, edge, offset  Valid edge values
    are: "top" | "bottom" | "left" | "right"  Attach a control to the opposite side of the
    form
    :type attachOppositeForm: [string, string, int]
    :param attachPosition: (C E M) Arguments are: control, edge, offset, position Valid edge
    values are: "top" | "bottom" | "left" | "right"  Attach a control to a position in the
    form
    :type attachPosition: [string, string, int, int]
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param childArray: (Q) Returns a string array of the names of the layout's immediate
    children
    :type childArray: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfChildren: (Q) Returns in an int the number of immediate children of the
    layout
    :type numberOfChildren: boolean
    :param numberOfDivisions: (C Q E) Specify the number of horizontal and vertical divisions
    across the form  Value must be greater than 0
    :type numberOfDivisions: int
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The full name of the control.
    :rtype: string
    """
    pass


def polyIterOnPoly(*args, **kwargs):
    """
    
    """
    pass


def xgmClumpBrushToolCmd(*args, **kwargs):
    """
    
    """
    pass


def FreeTangentWeight(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeUpdatePSDNetworks(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def shaderfx(*args, **kwargs):
    """
    
    """
    pass


def AddFloorContactPlane(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateSubdivPlane(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dirmap(*args, convertDirectory="", enable=True, getAllMappings=True, getMappedDirectory="",
           mapDirectory=None, unmapDirectory="", q=True, query=True, **kwargs):
    """
    Use this command to map a directory to another directory  The first argument is the
    directory to map, and the second is the destination directory to map to   Directories must
    both be absolute paths, and should be separated with forward slashes ('/')  The mapping is
    case-sensitive on all platforms  This command can be useful when moving projects to 
    
    :param convertDirectory: (C) Convert a file or directory  Returns the name of the mapped
    file or directory, if the command is enabled  If the given string contains one of the map
    :type convertDirectory: string
    :param enable: (C Q) Enable directory mapping  Directory mapping is off when you start Maya
     If enabled, when opening Maya scenes, file texture paths (and other file path
    :type enable: boolean
    :param getAllMappings: (C) Get all current mappings  Returns string array of current
    mappings in format: [redirect1, replacement1, ..  redirectN, replacementN]
    :type getAllMappings: boolean
    :param getMappedDirectory: (C) Get the mapped redirected directory  The given argument must
    exactly match the first string used with the -mapDirectory flag
    :type getMappedDirectory: string
    :param mapDirectory: (C) Map a directory - the first argument is mapped to the second 
    Neither directory needs to exist on the local machine at the time of invocation
    :type mapDirectory: [string, string]
    :param unmapDirectory: (C) Unmap a directory  The given argument must exactly match the
    argument used with the -mapDirectory flag
    :type unmapDirectory: string
    
    :returns: when convertDirectory is used
    :rtype: string
    """
    pass


def fluidReplaceFramesOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteAllPoses(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DuplicateEdges(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FlipTriangleEdge(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyAverageVertex(*args, caching=True, constructionHistory=True, iterations=0, name="",
                      nodeState=0, worldSpace=True, q=True, query=True, e=True, edit=True,
                      **kwargs):
    """
    Moves the selected vertices of a polygonal object to round its shape  Translate, move,
    rotate or scale vertices
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param iterations: (C Q E) Number of rounding steps
    :type iterations: int
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def ToggleTimeSlider(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ScaleCurvatureOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyNormalPerVertex(*args, allLocked=True, deformable=True, freezeNormal=True, normalX=0.0,
                        normalXYZ=None, normalY=0.0, normalZ=0.0, relative=True,
                        unFreezeNormal=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Command associates normal(x, y, z) with vertices on polygonal objects  When used with the
    query flag, it returns the normal associated with the specified components  However, when
    queried, the command returns all normals (all vtx-face combinations) on the vertex,
    regardless of whether they are shared or not
    
    :param allLocked: (C Q E) Queries if all normals on the selected vertices are locked
    (frozen) or not
    :type allLocked: boolean
    :param deformable: (C Q E) DEFAULT true OBSOLETE flag  This flag will be removed in the
    next release
    :type deformable: boolean
    :param freezeNormal: (C Q E) Specifies that the normal values be frozen (locked) at the
    current value
    :type freezeNormal: boolean
    :param normalX: (C Q E) Specifies the x value normal
    :type normalX: float
    :param normalXYZ: (C Q E M) Specifies the xyz values normal If this flag is used singly,
    the specified normal xyz values are used for all selected components  If the flag is use
    :type normalXYZ: [float, float, float]
    :param normalY: (C Q E) Specifies the y value normal
    :type normalY: float
    :param normalZ: (C Q E) Specifies the z value normal
    :type normalZ: float
    :param relative: (C Q E) When used, the normal values specified are added relative to the
    current value
    :type relative: boolean
    :param unFreezeNormal: (C Q E) Specifies that the normal values that were frozen at the
    current value be un-frozen (un-locked)
    :type unFreezeNormal: boolean
    
    :returns: Success or Failure.
    :rtype: boolean
    """
    pass


def HypershadeGraphRemoveUpstream(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dbmessage(*args, file="", list=True, monitor=True, type="", **kwargs):
    """
    The dbmessage command is used to install monitors for certain message types, dumping debug
    information as they are sent so that the flow of messages can be examined
    
    :param file: (C) Destination file of the message monitoring information  Use the special
    names stdout and stderr to redirect to your command window  As well, the spec
    :type file: string
    :param list: (C) List all available message types and their current enabled status
    :type list: boolean
    :param monitor: (C) Set the monitoring state of the message type ('on' to enable, 'off' to
    disable)  Returns the list of all message types being monitored after the chan
    :type monitor: boolean
    :param type: (C) Monitor only the messages whose name matches this keyword (default is
    all)
    :type type: string
    
    :returns: 
    :rtype: None
    """
    pass


def NURBSTexturePlacementToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddWire(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def createPolyPlaneCtx(*args, **kwargs):
    """
    
    """
    pass


def HideNCloths(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateImagePlane(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CVCurveToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Tension(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideTexturePlacements(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HIKSelectedMode(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeDisplayAsLargeSwatches(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSplineSelectConvertToFreeze(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExtractSubdivSurfaceVertices(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PreferencesWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_lockSelTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def blendShapePanel(*args, blendShapeEditor=True, control=True, copy="", createString=True,
                    defineTemplate="", docTag="", editString=True, exists=True, init=True,
                    isUnique=True, label="", menuBarRepeatLast=True, menuBarVisible=True,
                    needsInit=True, parent="", popupMenuProcedure=None, replacePanel="",
                    tearOff=True, tearOffCopy="", tearOffRestore=True, unParent=True,
                    useTemplate="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a panel that derives from the base panel class that houses a
    blendShapeEditor
    
    :param blendShapeEditor: (Q) Query only flag that returns the name of an editor to be
    associated with the panel
    :type blendShapeEditor: boolean
    :param control: (Q) Returns the top level control for this panel  Usually used for getting
    a parent to attach popup menus  CAUTION: panels may not have controls at times
    :type control: boolean
    :param copy: (E) Makes this panel a copy of the specified panel  Both panels must be of the
    same type
    :type copy: string
    :param createString: (E) Command string used to create a panel
    :type createString: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Attaches a tag to the Maya panel
    :type docTag: string
    :param editString: (E) Command string used to edit a panel
    :type editString: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param init: (C E) Initializes the panel's default state  This is usually done
    automatically on file -new and file -open
    :type init: boolean
    :param isUnique: (Q) Returns true if only one instance of this panel type is allowed
    :type isUnique: boolean
    :param label: (Q E) Specifies the user readable label for the panel
    :type label: string
    :param menuBarRepeatLast: (C Q E) Controls whether clicking on the menu header with the
    middle mouse button would repeat the last selected menu item
    :type menuBarRepeatLast: boolean
    :param menuBarVisible: (C Q E) Controls whether the menu bar for the panel is displayed
    :type menuBarVisible: boolean
    :param needsInit: (Q E) (Internal) On Edit will mark the panel as requiring initialization 
    Query will return whether the panel is marked for initialization  Used during fil
    :type needsInit: boolean
    :param parent: (C) Specifies the parent layout for this panel
    :type parent: string
    :param popupMenuProcedure: (Q E) Specifies the procedure called for building the panel's
    popup menu(s)  The default value is "buildPanelPopupMenu"  The procedure should take one
    stri
    :type popupMenuProcedure: script
    :param replacePanel: (E) Will replace the specified panel with this panel  If the target
    panel is within the same layout it will perform a swap
    :type replacePanel: string
    :param tearOff: (Q E) Will tear off this panel into a separate window with a paneLayout as
    the parent of the panel  When queried this flag will return if the panel has bee
    :type tearOff: boolean
    :param tearOffCopy: (C) Will create this panel as a torn of copy of the specified source
    panel
    :type tearOffCopy: string
    :param tearOffRestore: (C E) Restores panel if it is torn off and focus is given to it  If
    docked, becomes the active panel in the docked window  This should be the default flag
    :type tearOffRestore: boolean
    :param unParent: (E) Specifies that the panel should be removed from its layout  This
    (obviously) cannot be used with query
    :type unParent: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: The name of the panel
    :rtype: string
    """
    pass


def dR_renderLastTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddKeysTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideStrokePathCurves(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def globalStitch(*args, caching=True, lockSurface=False, maxSeparation=0.1,
                 modificationResistance=1, nodeState=0, sampling=1, stitchCorners=1,
                 stitchEdges=1, stitchPartialEdges=False, stitchSmoothness=0,
                 constructionHistory=True, name="", object=True, q=True, query=True, e=True,
                 edit=True, **kwargs):
    """
    This command computes a globalStitch of NURBS surfaces  There should be at least one NURBS
    surface  The NURBS surface(s) should be untrimmed
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param lockSurface: (C Q E M) Keep the NURBS surface at the specified multi index unchanged
    by the fitting  Default: false
    :type lockSurface: boolean
    :param maxSeparation: (C Q E) Maximum separation that will still be stitched  Default: 0.1
    :type maxSeparation: float
    :param modificationResistance: (C Q E) Modification resistance weight for surface CVs 
    Default: 1e-1
    :type modificationResistance: float
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param sampling: (C Q E) Sampling when stitching edges  Default: 1
    :type sampling: int
    :param stitchCorners: (C Q E) Stitch corners of surfaces  0 - off 1 - closest point 2 -
    closest knot Default: 1
    :type stitchCorners: int
    :param stitchEdges: (C Q E) Stitch edges of surfaces  0 - off 1 - closest point 2 -
    matching params Default: 1
    :type stitchEdges: int
    :param stitchPartialEdges: (C Q E) Toggle on (off) partial edge stitching  Default: false
    :type stitchPartialEdges: boolean
    :param stitchSmoothness: (C Q E) Set type of smoothness of edge join  0 - off 1 - tangent 2
    - normal Default: 0
    :type stitchSmoothness: int
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def HypershadeSetTraversalDepthZero(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SmoothTangent(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def arcLengthDimension(*args, **kwargs):
    """
    This command is used to create an arcLength dimension to display the arcLength of a
    curve/surface at a specified point on the curve/surface
    
    
    :returns: Name of the arcLengthDimension node created
    :rtype: string
    """
    pass


def HypershadeDeleteSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectNone(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def clipEditor(*args, allTrackHeights=0, autoFit="", autoFitTime="", clipDropCmd="",
               clipStyle=2, control=True, defineTemplate="", deleteCmd="", deselectAll=True,
               displayActiveKeyTangents="", displayActiveKeys="", displayInfinities="",
               displayKeys="", displayTangents="", displayValues="", docTag="", exists=True,
               filter="", forceMainConnection="", frameAll=True, frameRange=None,
               highlightConnection="", highlightedBlend=None, highlightedClip=None,
               initialized=True, listAllCharacters=True, listCurrentCharacters=True,
               lockMainConnection=True, lookAt="", mainListConnection="", manageSequencer=True,
               menuContext="", panel="", parent="", selectBlend=None, selectClip=None,
               selectionConnection="", snapTime="", snapValue="", stateString=True,
               unParent=True, unlockMainConnection=True, updateMainConnection=True,
               useTemplate="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    Create a clip editor with the given name
    
    :param allTrackHeights: () OBSOLETE flag  Use clipStyle instead
    :type allTrackHeights: int
    :param autoFit: (Q E) on | off | tgl Auto fit-to-view
    :type autoFit: string
    :param autoFitTime: (Q E) on | off | tgl Auto fit-to-view along the time axis, as well
    :type autoFitTime: string
    :param clipDropCmd: (E) Command executed when clip node is dropped on the TraX editor
    :type clipDropCmd: string
    :param clipStyle: (Q E) Set/return the clip track style in the specified editor  Default is
    2  Valid values are 1-3
    :type clipStyle: int
    :param control: (Q) Query only  Returns the top level control for this editor  Usually used
    for getting a parent to attach popup menus  Caution: It is possible for an ed
    :type control: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param deleteCmd: (E) Command executed when backspace key is pressed
    :type deleteCmd: string
    :param deselectAll: (E) Deselect all clips and blends in the editor
    :type deselectAll: boolean
    :param displayActiveKeyTangents: (E) on | off | tgl Display active key tangents in the
    editor
    :type displayActiveKeyTangents: string
    :param displayActiveKeys: (E) on | off | tgl Display active keys in the editor
    :type displayActiveKeys: string
    :param displayInfinities: (E) on | off | tgl Display infinities in the editor
    :type displayInfinities: string
    :param displayKeys: (E) on | off | tgl Display keyframes in the editor
    :type displayKeys: string
    :param displayTangents: (E) on | off | tgl Display tangents in the editor
    :type displayTangents: string
    :param displayValues: (E) on | off | tgl Display active keys and tangents values in the
    editor
    :type displayValues: string
    :param docTag: (C Q E) Attaches a tag to the editor
    :type docTag: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param filter: (C Q E) Specifies the name of an itemFilter object to be used with this
    editor  This filters the information coming onto the main list of the editor
    :type filter: string
    :param forceMainConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type forceMainConnection: string
    :param frameAll: (E) Frame view around all clips in the editor
    :type frameAll: boolean
    :param frameRange: (Q E) The editor's current frame range
    :type frameRange: [float, float]
    :param highlightConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its highlight list  Not all editors have a highlight list 
    F
    :type highlightConnection: string
    :param highlightedBlend: (Q) Returns the highlighted blend, listed as scheduler and index
    :type highlightedBlend: [string, string]
    :param highlightedClip: (Q) Returns the highlighted clip, listed as scheduler and index
    :type highlightedClip: [string, string]
    :param initialized: (Q) Returns whether the clip editor is fully initialized, and has a
    port to draw through  If not, the -frameRange and -frameAll flags will fail
    :type initialized: boolean
    :param listAllCharacters: (E) List all characters in the editor and outliner
    :type listAllCharacters: boolean
    :param listCurrentCharacters: (E) List only the characters in the editor and outliner
    :type listCurrentCharacters: boolean
    :param lockMainConnection: (C E) Locks the current list of objects within the
    mainConnection, so that only those objects are displayed within the editor  Further changes
    to the origi
    :type lockMainConnection: boolean
    :param lookAt: (E) all | selected | currentTime FitView helpers
    :type lookAt: string
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type mainListConnection: string
    :param manageSequencer: (C Q E) Sets/returns whether the clip editor should manage
    sequencer nodes  If so, animation clips and characters are not represented
    :type manageSequencer: boolean
    :param menuContext: (Q) Returns a string array denoting the type of data object the cursor
    is over  Returned values are: {"timeSlider"} {"nothing"} {"track", "track index",
    :type menuContext: string
    :param panel: (C Q) Specifies the panel for this editor  By default if an editor is created
    in the create callback of a scripted panel it will belong to that panel  If a
    :type panel: string
    :param parent: (C Q E) Specifies the parent layout for this editor  This flag will only
    have an effect if the editor is currently un-parented
    :type parent: string
    :param selectBlend: (Q E) Select the blends specified by the scheduler name and the
    indicies of the two clips used in the blend  When queried, a string containing the
    schedule
    :type selectBlend: [string, string, string]
    :param selectClip: (Q E) Selects the clip specified by the scheduler name and the clip
    index  When queried, a string containing the scheduler and clip index of all of the sel
    :type selectClip: [string, string]
    :param selectionConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its own selection list  As the user selects things in this
    e
    :type selectionConnection: string
    :param snapTime: (Q E) none | integer | keyframe Keyframe move snap in time
    :type snapTime: string
    :param snapValue: (Q E) none | integer | keyframe Keyframe move snap in values
    :type snapValue: string
    :param stateString: (Q) Query only flag  Returns the MEL command that will create an editor
    to match the current editor state  The returned command string uses the string va
    :type stateString: boolean
    :param unParent: (C E) Specifies that the editor should be removed from its layout  This
    cannot be used in query mode
    :type unParent: boolean
    :param unlockMainConnection: (C E) Unlocks the mainConnection, effectively restoring the
    original mainConnection (if it is still available), and dynamic updates
    :type unlockMainConnection: boolean
    :param updateMainConnection: (C E) Causes a locked mainConnection to be updated from the
    orginal mainConnection, but preserves the lock state
    :type updateMainConnection: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: Editor name
    :rtype: string
    """
    pass


def falloffCurve(*args, addControlVertex="", annotation="", asString="", backgroundColor=None,
                 changeCommand=None, currentKey=0, currentKeyValue=None, customCurveWidget=True,
                 defineTemplate="", deleteControlVertex=0, docTag="", dragCallback=None,
                 dropCallback=None, enable=True, enableBackground=True,
                 enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
                 highlightColor=None, isObscured=True, manage=True, noBackground=True,
                 numberOfPopupMenus=True, optionVar="", parent="", popupMenuArray=True,
                 preventOverride=True, readOnly=True, snapToGrid=True, statusBarMessage="",
                 useTemplate="", visible=True, visibleChangeCommand=None, width=0, q=True,
                 query=True, e=True, edit=True, **kwargs):
    """
    This command creates a control for editing a 2D control curve  The control attaches to an
    optionVar used to store and retrieve the encoded control points stored in a string
    
    :param addControlVertex: (E) Used to add a control vertex for the curve
    :type addControlVertex: string
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param asString: (Q E) Used to query and set the value of the curve as a string of comma
    separated values
    :type asString: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (E) Specifies a command to be executed whenever the value of this
    curve is modified  This option should not be used when specifying an optionVar
    :type changeCommand: script
    :param currentKey: (C Q E) Returns the index of the currently selected key
    :type currentKey: int
    :param currentKeyValue: (Q E) Get or set the value of the currently selected key
    :type currentKeyValue: [float, float]
    :param customCurveWidget: (C Q E) Determines whether or not the curve widget is using a
    custom curve  When a custom curve is used, it is stored by a falloff curve in the brush
    tool se
    :type customCurveWidget: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param deleteControlVertex: (E) Used to delete a control vertex of the curve
    :type deleteControlVertex: int
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param optionVar: (C Q E) Specifies the name of the option var used to store and retrieve
    the string value capturing the curve
    :type optionVar: string
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param readOnly: (C Q E) Specifies if the curve is read only or not  If true, the curve
    can't be edited
    :type readOnly: boolean
    :param snapToGrid: (C Q E) Specifies whether or not curve control points snap to grid when
    they are being moved
    :type snapToGrid: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the port created or modified
    :rtype: string
    """
    pass


def ChangeVertexSize(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RotateUVsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSetCombBrushTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SaveCurrentWorkspace(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def unfold(*args, applyToShell=True, areaWeight=0.0, globalBlend=0.0, globalMethodBlend=0.0,
           iterations=0, optimizeAxis=0, pinSelected=True, pinUvBorder=True, scale=0.0,
           stoppingThreshold=0.0, useScale=True, **kwargs):
    """
    None
    
    :param applyToShell: (C) Specifies that the selected components should be only work on
    shells that have something have been selected or pinned
    :type applyToShell: boolean
    :param areaWeight: (C) Surface driven importance  0 treat all faces equal  1 gives more
    importance to large ones
    :type areaWeight: float
    :param globalBlend: (C) This allows the user to blend between a local optimization method
    (globalBlend = 0.0) and a global optimization method (globalBlend = 1.0)  The local
    :type globalBlend: float
    :param globalMethodBlend: (C) The global optimization method uses two functions to compute
    a minimization  The first function controls edge stretch by using edges lengths between
    :type globalMethodBlend: float
    :param iterations: (C) Maximum number of iterations for each connected UV piece
    :type iterations: int
    :param optimizeAxis: (C) Degree of freedom for optimization 0=Optimize freely, 1=Move
    vertically only, 2=Move horzontally only
    :type optimizeAxis: int
    :param pinSelected: (C) Specifies that the selected components should be pinned instead the
    unselected components
    :type pinSelected: boolean
    :param pinUvBorder: (C) Specifies that the UV border should be pinned when doing the solve 
    By default only unselected components are pinned
    :type pinUvBorder: boolean
    :param scale: (C) Ratio between 2d and 3d space
    :type scale: float
    :param stoppingThreshold: (C) Minimum distorsion improvement between two steps in %
    :type stoppingThreshold: float
    :param useScale: (C) Adjust the scale or not
    :type useScale: boolean
    
    :returns: the number of relaxation iterations carried out
    :rtype: int
    """
    pass


def MakeLive(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HIKComputeReference(*args, **kwargs):
    """
    
    """
    pass


def PolyConvertToLoopAndDelete(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectAllTransforms(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleEdgeMetadata(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def fluidMergeCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleContainerCentric(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ReplaceObjects(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateCharacterOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SineOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExtendSurfaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CustomNURBSSmoothness(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HIKSetBodyPartKey(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PoseEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_activeHandleX(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleCurrentFrame(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def aimConstraint(*args, aimVector=None, layer="", maintainOffset=True, name="", offset=None,
                  remove=True, skip="", targetList=True, upVector=None, weight=0.0,
                  weightAliasList=True, worldUpObject=None, worldUpType="", worldUpVector=None,
                  q=True, query=True, e=True, edit=True, **kwargs):
    """
    Constrain an object's orientation to point at a target object or at the average position of
    a number of targets   An aimConstraint takes as input one or more "target" DAG transform
    nodes at which to aim the single "constraint object" DAG transform node  The aimConstraint
    orients the constrained object such that the aimVector (in the object's local 
    
    :param aimVector: (C Q E) Set the aim vector  This is the vector in local coordinates that
    points at the target  If not given at creation time, the default value of (1.0, 0.0,
    :type aimVector: [float, float, float]
    :param layer: (C E) Specify the name of the animation layer where the constraint should be
    added
    :type layer: string
    :param maintainOffset: (C) The offset necessary to preserve the constrained object's
    initial rotation will be calculated and used as the offset
    :type maintainOffset: boolean
    :param name: (C Q E) Sets the name of the constraint node to the specified name  Default
    name is constrainedObjectName_constraintType
    :type name: string
    :param offset: (C Q E) Sets or queries the value of the offset  Default is 0,0,0
    :type offset: [float, float, float]
    :param remove: (E) removes the listed target(s) from the constraint
    :type remove: boolean
    :param skip: (C E M) Specify the axis to be skipped  Valid values are "x", "y", "z" and
    "none"  During creation, "none" is the default
    :type skip: string
    :param targetList: (Q) Return the list of target objects
    :type targetList: boolean
    :param upVector: (C Q E) Set local up vector  This is the vector in local coordinates that
    aligns with the world up vector  If not given at creation time, the default value o
    :type upVector: [float, float, float]
    :param weight: (C Q E) Sets the weight value for the specified target(s)  If not given at
    creation time, the default value of 1.0 is used
    :type weight: float
    :param weightAliasList: (Q) Returns the names of the attributes that control the weight of
    the target objects  Aliases are returned in the same order as the targets are returned
    :type weightAliasList: boolean
    :param worldUpObject: (C Q E) Set the DAG object use for worldUpType "object" and
    "objectrotation"  See worldUpType for greater detail  The default value is no up object,
    which is
    :type worldUpObject: name
    :param worldUpType: (C Q E) Set the type of the world up vector computation  The
    worldUpType can have one of 5 values: "scene", "object", "objectrotation", "vector", or
    "none"
    :type worldUpType: string
    :param worldUpVector: (C Q E) Set world up vector  This is the vector in world coordinates
    that up vector should align with  See -wut/worldUpType (below)for greater detail  If not
    :type worldUpVector: [float, float, float]
    
    :returns: name of the created constraint node
    :rtype: string[]
    """
    pass


def scrollLayout(*args, annotation="", backgroundColor=None, borderVisible=True,
                 childArray=True, childResizable=True, defineTemplate="", docTag="",
                 dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
                 enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
                 highlightColor=None, horizontalScrollBarThickness=0, isObscured=True,
                 manage=True, minChildWidth=0, noBackground=True, numberOfChildren=True,
                 numberOfPopupMenus=True, panEnabled=True, parent="", popupMenuArray=True,
                 preventOverride=True, resizeCommand=None, scrollAreaHeight=True,
                 scrollAreaValue=True, scrollAreaWidth=True, scrollByPixel=None, scrollPage="",
                 statusBarMessage="", useTemplate="", verticalScrollBarAlwaysVisible=True,
                 verticalScrollBarThickness=0, visible=True, visibleChangeCommand=None, width=0,
                 q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a scroll layout  A scroll layout is useful for when you have a number
    of controls which cannot all be visible at a time  This layout will display a horizontal
    and/or vertical scroll bar when necessary to bring into view the hidden controls  Since the
    scroll layout provides no real positioning of children you should use another 
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param borderVisible: (C Q E) Visibility of the border
    :type borderVisible: boolean
    :param childArray: (Q) Returns a string array of the names of the layout's immediate
    children
    :type childArray: boolean
    :param childResizable: (C Q) Set to true if you want the child of the control layout to be
    as wide as the scroll area  You may also indicate a minimum width for the child using t
    :type childResizable: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param horizontalScrollBarThickness: (C E) Thickness of the horizontal scroll bar  Specify
    an integer value of pixels greater than or equal to 0  Other than setting the value to 0 to
    hide the
    :type horizontalScrollBarThickness: int
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param minChildWidth: (C Q) A positive non-zero integer value indicating the minimum width
    the scroll layout's child  This flag only has meaning when the -cr/childResizable flag
    :type minChildWidth: int
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfChildren: (Q) Returns in an int the number of immediate children of the
    layout
    :type numberOfChildren: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param panEnabled: (Q E) Set to true if you want to pan the scroll layout using ALT + MMB 
    On OSX, in one button and two button mode, you could use command+alt+LMB to pan it
    :type panEnabled: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param resizeCommand: (C E) The command invoked when the scroll layout is resized
    :type resizeCommand: script
    :param scrollAreaHeight: (Q) Return the height of the scroll area (in pixels)
    :type scrollAreaHeight: boolean
    :param scrollAreaValue: (Q) Return the vertical and horizontal values of the scroll area
    (in pixels)
    :type scrollAreaValue: boolean
    :param scrollAreaWidth: (Q) Return the width of the scroll area (in pixels)
    :type scrollAreaWidth: boolean
    :param scrollByPixel: (E) Scroll the client area in the direction of the string  The int
    specifies the number of pixels
    :type scrollByPixel: [string, int]
    :param scrollPage: (E) Scroll the client area in the direction of the string  Valid values
    are "up", "down", "left" or "right"
    :type scrollPage: string
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param verticalScrollBarAlwaysVisible: (C) Set to true if you want to always have the
    vertical scroll bar visible
    :type verticalScrollBarAlwaysVisible: boolean
    :param verticalScrollBarThickness: (C E) Thickness of the vertical scroll bar  Specify an
    integer value of pixels greater than or equal to 0  This flag has no effect on Windows
    systems
    :type verticalScrollBarThickness: int
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def GeometryConstraintOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateNSoftBody(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def reverseSurface(*args, caching=True, direction=0, nodeState=0, constructionHistory=True,
                   name="", object=True, replaceOriginal=True, q=True, query=True, e=True,
                   edit=True, **kwargs):
    """
    The reverseSurface command reverses one or both directions of a surface or can be used to
    "swap" the U and V directions (this creates the effect of reversing the surface normal) 
    The name of the newly reversed surface and the name of the resulting dependency node is
    returned  The resulting surface has the same parameter ranges as the original surfa
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param direction: (C Q E) The direction to reverse the surface in: 0 - U, 1 - V, 2 - Both U
    and V, 3 - Swap Default: 0
    :type direction: int
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def SymmetrizeSelection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def directKeyCtx(*args, exists=True, history=True, image1="", image2="", image3="", name="",
                 option="", selectedOnly=True, q=True, query=True, e=True, edit=True,
                 **kwargs):
    """
    This command creates a context which may be used to directly manipulate keyframes within
    the graph editor
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param option: (C Q E) Valid values are "move," "insert," "over," and "segmentOver." When
    you "move" a key, the key will not cross over (in time) any keys before or after i
    :type option: string
    :param selectedOnly: (C Q E) Controls whether only selected curves/keys can be moved, or
    all
    :type selectedOnly: boolean
    
    :returns: Context name
    :rtype: string
    """
    pass


def HideBoundingBox(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def switchTable(*args, annotation="", backgroundColor=None, defineTemplate="", docTag="",
                dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
                enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
                highlightColor=None, isObscured=True, label1="", label2="", manage=True,
                noBackground=True, numberOfPopupMenus=True, parent="", popupMenuArray=True,
                preventOverride=True, selectedRow=True, statusBarMessage="", switchNode=None,
                underPointerRow=True, useTemplate="", visible=True, visibleChangeCommand=None,
                width=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates/edits/queries the switch table control   The optional argument is the
    name of the control
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label1: (E) Set the label of the first column
    :type label1: string
    :param label2: (E) Set the label of the second column
    :type label2: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param selectedRow: (Q) The current row selected
    :type selectedRow: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param switchNode: (Q E) The switch node to be displayed in the control
    :type switchNode: name
    :param underPointerRow: (Q) The row under the pointer
    :type underPointerRow: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the switch table control.
    :rtype: string
    """
    pass


def rehash(*args, **kwargs):
    """
    
    """
    pass


def ModifyUVVectorRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportUpAxis(*args, **kwargs):
    """
    
    """
    pass


def PaintGridOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ParentBaseWireOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetCurrentUVSet(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nClothReplaceFrames(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_showOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def isConnected(*args, ignoreUnitConversion=True, **kwargs):
    """
    The isConnected command is used to check if two plugs are connected in the dependency graph
     The return value is false if they are not and true if they are   The first string
    specifies the source plug to check for connection  The second one specifies the destination
    plug to check for connection
    
    :param ignoreUnitConversion: (C) In looking for connections, skip past unit conversion
    nodes
    :type ignoreUnitConversion: boolean
    
    :returns: Are the two plugs connected?
    :rtype: boolean
    """
    pass


def SelectPreviousObjects3dsMax(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SurfaceBooleanSubtractToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TransformPolygonComponent(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def StitchSurfacePointsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TogglePolygonFaceTriangles(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyQuad(*args, angle=30, caching=True, constructionHistory=True, keepGroupBorder=True,
             keepHardEdges=True, keepTextureBorders=True, name="", nodeState=0, worldSpace=True,
             q=True, query=True, e=True, edit=True, **kwargs):
    """
    Merges selected triangles of a polygonal object into four-sided faces
    
    :param angle: (C Q E) Angle threshold above which two triangles are not merged  C: Default
    is 30 degrees  The range is [0.0, 180.0]  Q: When queried, this flag returns a f
    :type angle: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param keepGroupBorder: (C Q E) Keep facet group border : If "on", the borders of selected
    faces are maintained, otherwise the borders of selected facets may be modified  C: Default
    :type keepGroupBorder: boolean
    :param keepHardEdges: (C Q E) Keep hard edges : If "on", the hard edges of selected faces
    are maintained, otherwise they may be deleted between two triangles  C: Default is "on"
    :type keepHardEdges: boolean
    :param keepTextureBorders: (C Q E) Keep texture border : If "on", the borders of texture
    maps are maintained, otherwise the boreders of texture maps may be modified  C: Default is
    "on"
    :type keepTextureBorders: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def CreatePolygonSphereOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def attachCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def preloadRefEd(*args, control=True, defineTemplate="", docTag="", exists=True, filter="",
                 forceMainConnection="", highlightConnection="", lockMainConnection=True,
                 mainListConnection="", panel="", parent="", selectCommand=None,
                 selectFileNode=True, selectionConnection="", stateString=True, unParent=True,
                 unlockMainConnection=True, updateMainConnection=True, useTemplate="", q=True,
                 query=True, e=True, edit=True, **kwargs):
    """
    This creates an editor for managing which references will be read in (loaded) and which
    deferred (unloaded) upon opening a file
    
    :param control: (Q) Query only  Returns the top level control for this editor  Usually used
    for getting a parent to attach popup menus  Caution: It is possible for an ed
    :type control: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Attaches a tag to the editor
    :type docTag: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param filter: (C Q E) Specifies the name of an itemFilter object to be used with this
    editor  This filters the information coming onto the main list of the editor
    :type filter: string
    :param forceMainConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type forceMainConnection: string
    :param highlightConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its highlight list  Not all editors have a highlight list 
    F
    :type highlightConnection: string
    :param lockMainConnection: (C E) Locks the current list of objects within the
    mainConnection, so that only those objects are displayed within the editor  Further changes
    to the origi
    :type lockMainConnection: boolean
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type mainListConnection: string
    :param panel: (C Q) Specifies the panel for this editor  By default if an editor is created
    in the create callback of a scripted panel it will belong to that panel  If a
    :type panel: string
    :param parent: (C Q E) Specifies the parent layout for this editor  This flag will only
    have an effect if the editor is currently un-parented
    :type parent: string
    :param selectCommand: (C Q E) A script to be executed when an item is selected
    :type selectCommand: script
    :param selectFileNode: (Q) Query the currently selected load setting  Returns the id of the
    currently selected load setting  This id can be used as an argument to the selLoadSe
    :type selectFileNode: boolean
    :param selectionConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its own selection list  As the user selects things in this
    e
    :type selectionConnection: string
    :param stateString: (Q) Query only flag  Returns the MEL command that will create an editor
    to match the current editor state  The returned command string uses the string va
    :type stateString: boolean
    :param unParent: (C E) Specifies that the editor should be removed from its layout  This
    cannot be used in query mode
    :type unParent: boolean
    :param unlockMainConnection: (C E) Unlocks the mainConnection, effectively restoring the
    original mainConnection (if it is still available), and dynamic updates
    :type unlockMainConnection: boolean
    :param updateMainConnection: (C E) Causes a locked mainConnection to be updated from the
    orginal mainConnection, but preserves the lock state
    :type updateMainConnection: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: Name of editor
    :rtype: string
    """
    pass


def FBXImport(*args, **kwargs):
    """
    
    """
    pass


def xgmSplineCache(*args, **kwargs):
    """
    
    """
    pass


def DeformerSetEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorSelectConnected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UVNormalBasedProjectionOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def cacheAppendOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def isTrue(*args, **kwargs):
    """
    This commmand returns the state of the named condition  If the condition is true, it
    returns 1  Otherwise it returns 0
    
    
    :returns: 
    :rtype: None
    """
    pass


def deformerEvaluator(*args, chains=True, meshes=True, q=True, query=True, **kwargs):
    """
    Print debug information about deformer evaluator status  In query mode the debug
    information is returned as a string[], otherwise the information is displayed in the script
    editor
    
    :param chains: (C Q) Print information about all supported deformation chains
    :type chains: boolean
    :param meshes: (C Q) Print information about all meshes
    :type meshes: boolean
    
    :returns: the debug information when query mode is used.
    :rtype: string[]
    """
    pass


def TangentsAuto(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ContourProjection(*args, **kwargs):
    """
    unknown
    """
    pass


def ResetSoftSelectOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_vertLockSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UVSnapTogetherOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyPlanarProjection(*args, projectionHorizontalSweep=0.0, seamCorrect=True, caching=True,
                         constructionHistory=True, createNewMap=True, imageCenter=None,
                         imageCenterX=0.0, imageCenterY=0.0, imageScale=None, imageScaleU=0.0,
                         imageScaleV=0.0, insertBeforeDeformers=True, keepImageRatio=True,
                         mapDirection="", name="", nodeState=0, perInstance=True,
                         projectionCenter=None, projectionCenterX=0.0, projectionCenterY=0.0,
                         projectionCenterZ=0.0, projectionHeight=0.0, projectionScale=None,
                         rotate=None, rotateX=0.0, rotateY=0.0, rotateZ=0.0, rotationAngle=0.0,
                         smartFit=True, worldSpace=True, q=True, query=True, e=True, edit=True,
                         **kwargs):
    """
    TpolyProjCmdBase is a base class for the command to create a mapping on the selected
    polygonal faces  Projects a map onto an object, using an orthogonal projection  The piece
    of the map defined from isu, isv, icx, icy area, is placed at pcx, pcy, pcz location
    
    :param projectionHorizontalSweep: (C Q E) The angle swept horizontally by the projection 
    The range is [0, 360]
    :type projectionHorizontalSweep: float
    :param seamCorrect: (C Q E) This flag specifies to perform a seam correction on the mapped
    faces
    :type seamCorrect: boolean
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param createNewMap: (C Q) This flag when set true will create a new map with a the name
    passed in, if the map does not already exist
    :type createNewMap: boolean
    :param imageCenter: (C Q E) The center point of the 2D model layout  Default: 0.5, 0.5
    :type imageCenter: [float, float]
    :param imageCenterX: (C Q E) Image center X coord
    :type imageCenterX: float
    :param imageCenterY: (C Q E) Image center Y coord
    :type imageCenterY: float
    :param imageScale: (C Q E) Specifies the UV scale : Enlarges or reduces the 2D version of
    the model in U or V space relative to the 2D centerpoint  Default: 1.0, 1.0
    :type imageScale: [float, float]
    :param imageScaleU: (C Q E) The the U scale : Enlarges or reduces the 2D version of the
    model in U space relative to the 2D centerpoint
    :type imageScaleU: float
    :param imageScaleV: (C Q E) The V scale : Enlarges or reduces the 2D version of the model
    in V space relative to the 2D centerpoint
    :type imageScaleV: float
    :param insertBeforeDeformers: (C) This flag specifies if the projection node should be
    inserted before or after deformer nodes already applied to the shape  Inserting the
    projection a
    :type insertBeforeDeformers: boolean
    :param keepImageRatio: (C) True means keep any image ratio
    :type keepImageRatio: boolean
    :param mapDirection: (C) This flag specifies the mapping direction  'x', 'y' and 'z'
    projects the map along the corresponding axis  'c' projects along the current camera view
    :type mapDirection: string
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param perInstance: (C) True if the new map is per-instance, otherwise it is shared
    :type perInstance: boolean
    :param projectionCenter: (C Q E) The point on the object that will be the center of the
    projection  Default: 0.0, 0.0, 0.0
    :type projectionCenter: [float, float, float]
    :param projectionCenterX: (C Q E) Projection center X coord
    :type projectionCenterX: float
    :param projectionCenterY: (C Q E) Projection center Y coord
    :type projectionCenterY: float
    :param projectionCenterZ: (C Q E) Projection center Z coord
    :type projectionCenterZ: float
    :param projectionHeight: (C Q E) The height of the map relative to the 3D projection axis
    :type projectionHeight: float
    :param projectionScale: (C Q E) The width and the height of the map relative to the 3D
    projection axis  Default: 1.0, 1.0
    :type projectionScale: [float, float]
    :param rotate: (C Q E) The mapping rotate angles  Default: 0.0, 0.0, 0.0
    :type rotate: [float, float, float]
    :param rotateX: (C Q E) X mapping rotate angle
    :type rotateX: float
    :param rotateY: (C Q E) Y mapping rotate angle
    :type rotateY: float
    :param rotateZ: (C Q E) Z mapping rotate angle
    :type rotateZ: float
    :param rotationAngle: (C Q E) The angle for the rotation  When the angle is positive, then
    the map rotates counterclockwise on the mapped model; if negative, the map rotates clock
    :type rotationAngle: float
    :param smartFit: (C) True means use the smart fit algorithm
    :type smartFit: boolean
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def DeleteFBIKAllKeys(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddPondDynamicBuoyOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BakeTopologyToTargets(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolyAssignSubdivHole(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExpressionEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ArtPaintAttrTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def loft(*args, autoReverse=True, caching=True, close=False, createCusp=False, degree=3,
         nodeState=0, reverse=False, reverseSurfaceNormals=False, sectionSpans=1, uniform=False,
         constructionHistory=True, name="", object=True, polygon=0, range=True, rebuild=True,
         q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command computes a skinned (lofted) surface passing through a number of NURBS curves 
    There must be at least two curves present  The NURBS curves may be surface isoparms, curve
    on surfaces, trimmed edges or polygon edges
    
    :param autoReverse: (C Q E) If set to true, the direction of the curves for the loft is
    computed automatically  If set to false, the values of the multi-use reverse flag are use
    :type autoReverse: boolean
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param close: (C Q E) If set to true, the resulting surface will be closed (periodic) with
    the start (end) at the first curve  If set to false, the surface will remain ope
    :type close: boolean
    :param createCusp: (C Q E M) Multi-use flag; each occurence of the flag refers to the
    matching curve in the loft operation; if the flag is set the particular profile will have
    a
    :type createCusp: boolean
    :param degree: (C Q E) The degree of the resulting surface Default: 3
    :type degree: int
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param reverse: (C Q E M) Multi-use flag; each occurence of the flag refers to the matching
    curve in the loft operation; if the flag is set the particular curve will be revers
    :type reverse: boolean
    :param reverseSurfaceNormals: (C Q E) If set, the surface normals on the output NURBS
    surface will be reversed  This is accomplished by swapping the U and V parametric
    directions  Default
    :type reverseSurfaceNormals: boolean
    :param sectionSpans: (C Q E) The number of surface spans between consecutive curves in the
    loft  Default: 1
    :type sectionSpans: int
    :param uniform: (C Q E) If set to true, the resulting surface will have uniform
    parameterization in the loft direction  If set to false, the parameterization will be chord
    l
    :type uniform: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param polygon: (C) The value of this argument controls the type of the object created by
    this operation 0: nurbs surface 1: polygon (use nurbsToPolygonsPref to set the
    :type polygon: int
    :param range: (C) Force a curve range on complete input curve
    :type range: boolean
    :param rebuild: (C) Rebuild the input curve(s) before using them in the operation  Use
    nurbsCurveRebuildPref to set the parameters for the conversion
    :type rebuild: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def TimeEditorToggleSnapToClipPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteAllSculptObjects(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyMapCut(*args, caching=True, constructionHistory=True, moveratio=0.0, name="",
               nodeState=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Cut along edges of the texture mapping  The cut edges become map borders
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param moveratio: (Q E) Cut open ratio related to the neighbor edge length of cut edge
    :type moveratio: float
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def greasePencil(*args, **kwargs):
    """
    
    """
    pass


def ReverseCurve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DetachSkin(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def meshReorder(*args, **kwargs):
    """
    
    """
    pass


def curveIntersect(*args, caching=True, constructionHistory=True, direction=None,
                   directionX=0.0, directionY=0.0, directionZ=0.0, nodeState=0, tolerance=0.001,
                   useDirection=False, q=True, query=True, e=True, edit=True, **kwargs):
    """
    You must specify two curves to intersect   This command either returns the parameter values
    at which the given pair of curves intersect, or returns a dependency node that provides the
    intersection information  If you want to find the intersection of the curves in a specific
    direction you must use BOTH the "-useDirection" flag and the "direction" fl
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param direction: (Q E) The direction that the input curves are projected in before
    intersecting  This vector is only used if "useDirection" flag is true
    :type direction: [float, float, float]
    :param directionX: (Q E) The X component of the direction that the input curves are
    projected in before intersecting  This vector is only used if "useDirection" flag is true
    :type directionX: float
    :param directionY: (Q E) The Y component of the direction that the input curves are
    projected in before intersecting  This vector is only used if "useDirection" flag is true
    :type directionY: float
    :param directionZ: (Q E) The Z component of the direction that the input curves are
    projected in before intersecting  This vector is only used if "useDirection" flag is true
    :type directionZ: float
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param tolerance: (Q E) The tolerance that the intersection is calculated with  For example,
    given two curves end-to-end, the ends must be within tolerance for an intersecti
    :type tolerance: float
    :param useDirection: (Q E) If true, use direction flag  The input curves are first
    projected in a specified direction and then intersected  If false, this command will only
    fin
    :type useDirection: boolean
    
    :returns: the parameter values at which two curves intersect.
    :rtype: string
    """
    pass


def runup(*args, cache=True, fromPreviousFrame=True, fromStartFrame=True, maxFrame=None,
          state=True, **kwargs):
    """
    runup plays the scene through a frame of frames, forcing dynamic objects to evaluate as it
    does so  If no max frame is specified, runup runs up to the current time
    
    :param cache: (C) Cache the state after the runup
    :type cache: boolean
    :param fromPreviousFrame: (C) Run up the animation from the previously evaluated frame  If
    no flag is supplied this is the default
    :type fromPreviousFrame: boolean
    :param fromStartFrame: (C) Run up the animation from the start frame  If no flag is
    supplied -fromPreviousFrame is the default
    :type fromStartFrame: boolean
    :param maxFrame: (C) Ending time for runup, in current user time units  The runup will
    always start at the minimum start frame for all dynamic objects
    :type maxFrame: time
    :param state: (C) Turns runup and cache on/off
    :type state: boolean
    
    :returns: Command result
    :rtype: string
    """
    pass


def gradientControlNoAttr(*args, annotation="", asString="", backgroundColor=None,
                          changeCommand=None, currentKey=0, currentKeyChanged=None,
                          currentKeyColorValue=None, currentKeyCurveValue=True,
                          currentKeyInterpValue=0, defineTemplate="", docTag="",
                          dragCallback=None, dragCommand=None, dropCallback=None, enable=True,
                          enableBackground=True, enableKeyboardFocus=True, exists=True,
                          fullPathName=True, height=0, highlightColor=None, isObscured=True,
                          manage=True, noBackground=True, numberOfPopupMenus=True, optionVar="",
                          parent="", popupMenuArray=True, preventOverride=True,
                          rampAsColor=True, statusBarMessage="", useTemplate="",
                          valueAtPoint=0.0, visible=True, visibleChangeCommand=None, width=0,
                          q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a control for editing a ramp (2D control curve)  The control attaches
    to an optionVar used to store and retrieve the encoded gradient control points stored in a
    string
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param asString: (Q E) Used to query and set the value of the ramp as a string of comma
    separated values
    :type asString: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (E) Specifies a command to be executed whenever the value of this
    ramp is modified  This option should not be used when specifying an optionVar
    :type changeCommand: script
    :param currentKey: (C Q E) Returns the index of the currently selected key
    :type currentKey: int
    :param currentKeyChanged: (E) Specifies a command to be executed whenever the selected key
    changes
    :type currentKeyChanged: script
    :param currentKeyColorValue: (Q E) Get or set the color of the currently selected key  Only
    useful if the ramp is set to be a color ramp
    :type currentKeyColorValue: [float, float, float]
    :param currentKeyCurveValue: (Q E) Get or set the value of the currently selected key  Only
    useful if the ramp is set to be a curve ramp
    :type currentKeyCurveValue: boolean
    :param currentKeyInterpValue: (Q E) Get or set the interpolation value for the current key
    :type currentKeyInterpValue: int
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dragCommand: (E) Specifies a command to be executed while the ramp is being
    modified
    :type dragCommand: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param optionVar: (C Q E) Specifies the name of the option var used to store and retrieve
    the string value capturing the curve
    :type optionVar: string
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rampAsColor: (C Q E) Sets whether the ramp should be viewed as a colour ramp or as a
    curve  Default is as a curve
    :type rampAsColor: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param valueAtPoint: (Q) Used during query to specify the point at which to query the curve
     In query mode, this flag needs a value
    :type valueAtPoint: float
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the port created or modified
    :rtype: string
    """
    pass


def SelectTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleUVEditorUVStatisticsHUD(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OutTangentFlat(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sculpt(*args, after=True, afterReference=True, before=True, deformerTools=True,
           dropoffDistance=1.0, dropoffType="", exclusive="", frontOfChain=True, geometry="",
           geometryIndices=True, groupWithLocator=True, ignoreSelected=True,
           includeHiddenSelections=False, insideMode="", maxDisplacement=1.0, mode="", name="",
           objectCentered=True, parallel=True, prune=True, remove=True, sculptTool="",
           split=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates/edits/queries a sculpt object deformer  By default for creation mode
    an implicit sphere will be used as the sculpting object if no sculpt tool is specified  The
    name of the created/edited object is returned
    
    :param after: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type after: boolean
    :param afterReference: (C E) The -afterReference flag is used to specify deformer ordering
    in a hybrid way that choses between -before and -after automatically  If the geometry b
    :type afterReference: boolean
    :param before: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type before: boolean
    :param deformerTools: (Q) Returns the name of the deformer tool objects (if any) as string
    string ..
    :type deformerTools: boolean
    :param dropoffDistance: (C Q E) Specifies the distance from the surface of the sculpt
    object at which the sculpt object produces no deformation effect  Default is 1.0  When
    queried,
    :type dropoffDistance: float
    :param dropoffType: (C Q E) Specifies how the deformation effect drops off from maximum
    effect at the surface of the sculpt object to no effect at dropoff distance limit  Valid
    :type dropoffType: string
    :param exclusive: (C Q) Puts the deformation set in a deform partition
    :type exclusive: string
    :param frontOfChain: (C E) This command is used to specify that the new deformer node
    should be placed ahead (upstream) of existing deformer and skin nodes in the shape's histo
    :type frontOfChain: boolean
    :param geometry: (Q E M) The specified object will be added to the list of objects being
    deformed by this deformer object, unless the -rm flag is also specified  When queried
    :type geometry: string
    :param geometryIndices: (Q) Complements the -geometry flag in query mode  Returns the multi
    index of each geometry
    :type geometryIndices: boolean
    :param groupWithLocator: (C) Groups the sculptor and its locator together under a single
    transform  Default is off
    :type groupWithLocator: boolean
    :param ignoreSelected: (C) Tells the command to not deform objects on the current selection
    list
    :type ignoreSelected: boolean
    :param includeHiddenSelections: (C) Apply the deformer to any visible and hidden objects in
    the selection list  Default is false
    :type includeHiddenSelections: boolean
    :param insideMode: (C Q E) Specifies how the deformation algorithm deals with points that
    are inside the sculpting primitve  The choices are: ring | even  The default is even
    :type insideMode: string
    :param maxDisplacement: (C Q E) Defines the maximum amount the sculpt object may move a
    point on an object which it is deforming  Default is 1.0  When queried, this flag returns a
    f
    :type maxDisplacement: float
    :param mode: (C Q E) Specifies which deformation algorithm the sculpt object should use 
    The choices are: flip | project | stretch  The default is stretch  When queried,
    :type mode: string
    :param name: (C) Used to specify the name of the node being created
    :type name: string
    :param objectCentered: (C) Places the sculpt and locator in the center of the bounding box
    of the selected object(s) or components  Default is off which centers the sculptor an
    :type objectCentered: boolean
    :param parallel: (C E) Inserts the new deformer in a parallel chain to any existing
    deformers in the history of the object  A blendShape is inserted to blend the parallel r
    :type parallel: boolean
    :param prune: (E) Removes any points not being deformed by the deformer in its current
    configuration from the deformer set
    :type prune: boolean
    :param remove: (E M) Specifies that objects listed after the -g flag should be removed from
    this deformer
    :type remove: boolean
    :param sculptTool: (C) Use the specified NURBS object as the sculpt tool instead of the
    default implicit sphere
    :type sculptTool: string
    :param split: (C E) Branches off a new chain in the dependency graph instead of
    inserting/appending the deformer into/onto an existing chain  Works in create mode (and e
    :type split: boolean
    
    :returns: Sculpt algorithm node name, sculpt sphere name, and sculpt stretch origin name
    :rtype: string[]
    """
    pass


def PostInfinityOscillate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXImportAutoAxisEnable(*args, **kwargs):
    """
    
    """
    pass


def NodeEditorHideAttributes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyEditEdgeFlow(*args, adjustEdgeFlow=1.0, caching=True, constructionHistory=True,
                     edgeFlow=True, name="", nodeState=0, q=True, query=True, e=True, edit=True,
                     **kwargs):
    """
    Edit edges of a polygonal object to respect surface curvature
    
    :param adjustEdgeFlow: (C) The weight value of the edge vertices to be positioned  <0:
    Concave 0: Middle point 1: Surface continuity >1: Convex Default is 1.0
    :type adjustEdgeFlow: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param edgeFlow: (C) True to enable edge flow  Otherwise, the edge flow is disabled 
    Default is true
    :type edgeFlow: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def dR_viewLightsTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def air(*args, attenuation=0.0, directionX=0.0, directionY=0.0, directionZ=0.0,
        enableSpread=True, fanSetup=True, inheritRotation=True, inheritVelocity=0.0,
        magnitude=0.0, maxDistance=0.0, name="", perVertex=True, position=None, speed=0.0,
        spread=0.0, torusSectionRadius=0.0, velocityComponentOnly=True, volumeExclusion=True,
        volumeOffset=None, volumeShape="", volumeSweep=0.0, wakeSetup=True, windSetup=True,
        q=True, query=True, e=True, edit=True, **kwargs):
    """
    For each listed object, the command creates a new field  The field has a shape which lives
    in the DAG and it has an associated dependency node  The field is added to the list of
    fields owned by the object  Use connectDynamic to cause the field to affect a dynamic
    object  Note that if more than one object is listed, a separate field is created for e
    
    :param attenuation: (Q E) Attentuation rate of field
    :type attenuation: float
    :param directionX: (Q E) 
    :type directionX: float
    :param directionY: (Q E) 
    :type directionY: float
    :param directionZ: (Q E) Direction that the air will try to match the affected particles'
    velocity to  NOTE: This is not the velocity; this is only the direction  Use the -s
    :type directionZ: float
    :param enableSpread: (Q E) This tells the system whether or not to use the spread angle
    given by '-sp'  If this is 'false' then all connected objectswithin the maximum distance
    :type enableSpread: boolean
    :param fanSetup: (E) Similar to 'windSetup' except that the effects of a fan or a person
    blowing air are approximated  The user can pass the same flags on the command lin
    :type fanSetup: boolean
    :param inheritRotation: (Q E) If this is set to 'true', then the direction vector described
    with -dx, -dy, and -dz will be considered local to the owning object  Therefore, if the
    :type inheritRotation: boolean
    :param inheritVelocity: (Q E) Amount (from 0 to 1) of the field-owner's velocity added to
    the vector determined by the direction and speed flags  The combination of these two vect
    :type inheritVelocity: float
    :param magnitude: (Q E) Strength of field
    :type magnitude: float
    :param maxDistance: (Q E) Maximum distance at which field is exerted  -1 indicates that the
    field has no maximum distance
    :type maxDistance: float
    :param name: (Q E) name of field
    :type name: string
    :param perVertex: (Q E) Per-vertex application  If this flag is set true, then each
    individual point (CV, particle, vertex,etc.) of the chosen object exerts an identical cop
    :type perVertex: boolean
    :param position: (Q E M) Position in space (x,y,z) where you want to place a gravity field 
    The gravity then emanates from this position in space rather than from an object
    :type position: [float, float, float]
    :param speed: (Q E) How fast the affected objects' speed reaches the speed (based on the
    -mag, -dx, -dy, -dz flags) of the air field  This value gets clamped internally
    :type speed: float
    :param spread: (Q E) This represents the angle from the direction vector within which
    objects will be affected  The values are in the range of 0 to 1  A value of 0 will r
    :type spread: float
    :param torusSectionRadius: (Q E) Section radius for a torus volume  Applies only to torus 
    Similar to the section radius in the torus modelling primitive
    :type torusSectionRadius: float
    :param velocityComponentOnly: (Q E) If this is 'false', the air will accelerate or
    decelerate the affected objects so that their velocities will eventually match the TOTAL
    velocity vect
    :type velocityComponentOnly: boolean
    :param volumeExclusion: (Q E) Volume exclusion of the field  If true, points outside the
    volume (defined by the volume shape attribute) are affected, If false, points inside the v
    :type volumeExclusion: boolean
    :param volumeOffset: (Q E) Volume offset of the field  Volume offset translates the field's
    volume by the specified amount from the actual field location  This is in the field'
    :type volumeOffset: [float, float, float]
    :param volumeShape: (Q E) Volume shape of the field  Sets/edits/queries the field's volume
    shape attribute  If set to any value other than "none", determines a 3-D volume with
    :type volumeShape: string
    :param volumeSweep: (Q E) Volume sweep of the field  Applies only to sphere, cone, cylinder,
    and torus  Similar effect to the sweep attribute in modelling
    :type volumeSweep: float
    :param wakeSetup: (E) Like the 'windSetup' and 'fanSetup', 'wakeSetup' sets certain values
    in the field to approximate the movement of air near a moving object, such as a
    :type wakeSetup: boolean
    :param windSetup: (E) This will set some of the values above in a way that approximates the
    effects of a basic wind  This allows the user to then change certain values as
    :type windSetup: boolean
    
    :returns: Command result
    :rtype: string
    """
    pass


def CreatePolygonSVG(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PointOnCurveOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def projectionContext(*args, exists=True, history=True, image1="", image2="", image3="",
                      name="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    Set the context for projection manips
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: Context name.
    :rtype: string
    """
    pass


def IncrementFluidCenter(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_cameraToPoly(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetNormalAngle(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def intSliderGrp(*args, adjustableColumn=0, adjustableColumn2=0, adjustableColumn3=0,
                 adjustableColumn4=0, adjustableColumn5=0, adjustableColumn6=0, annotation="",
                 backgroundColor=None, changeCommand=None, columnAlign=None, columnAlign2=None,
                 columnAlign3=None, columnAlign4=None, columnAlign5=None, columnAlign6=None,
                 columnAttach=None, columnAttach2=None, columnAttach3=None, columnAttach4=None,
                 columnAttach5=None, columnAttach6=None, columnOffset2=None, columnOffset3=None,
                 columnOffset4=None, columnOffset5=None, columnOffset6=None, columnWidth=None,
                 columnWidth1=0, columnWidth2=None, columnWidth3=None, columnWidth4=None,
                 columnWidth5=None, columnWidth6=None, defineTemplate="", docTag="",
                 dragCallback=None, dragCommand=None, dropCallback=None, enable=True,
                 enableBackground=True, enableKeyboardFocus=True, exists=True, extraLabel="",
                 field=True, fieldMaxValue=0, fieldMinValue=0, fieldStep=0, fullPathName=True,
                 height=0, highlightColor=None, isObscured=True, label="", manage=True,
                 maxValue=0, minValue=0, noBackground=True, numberOfPopupMenus=True, parent="",
                 popupMenuArray=True, preventOverride=True, rowAttach=None, sliderStep=0,
                 statusBarMessage="", step=0, useTemplate="", value=0, visible=True,
                 visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
                 **kwargs):
    """
    All of the group commands position their individual controls in columns starting at column
    1  The layout of each control (ie  column) can be customized using the -cw/columnWidth,
    -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumn flags  By
    default, columns are left aligned with no offset and are 100 pixels wide  Only o
    
    :param adjustableColumn: (C E) Specifies which column has an adjustable size that changes
    with the sizing of the layout  The column value is a 1-based index  Passing 0 as argument
    :type adjustableColumn: int
    :param adjustableColumn2: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly two columns
    :type adjustableColumn2: int
    :param adjustableColumn3: (C E) Specifies that the column has an adjustable size that
    changes with the size of the parent layout  Ignored if there are not exactly three columns
    :type adjustableColumn3: int
    :param adjustableColumn4: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly four columns
    :type adjustableColumn4: int
    :param adjustableColumn5: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly five columns
    :type adjustableColumn5: int
    :param adjustableColumn6: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly six columns
    :type adjustableColumn6: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) The command string executed when the value of the slider
    changes  It will be executed only once after a drag of the slider
    :type changeCommand: script
    :param columnAlign: (C E M) Arguments are : column number, alignment type  Possible
    alignments are: left | right | center  Specifies alignment type for the specified column
    :type columnAlign: [int, string]
    :param columnAlign2: (C E) Sets the text alignment of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "center"
    :type columnAlign2: [string, string]
    :param columnAlign3: (C E) Sets the text alignment for all three columns  Ignored if there
    are not exactly three columns  Valid values are "left", "right", and "center"
    :type columnAlign3: [string, string, string]
    :param columnAlign4: (C E) Sets the text alignment for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "center"
    :type columnAlign4: [string, string, string, string]
    :param columnAlign5: (C E) Sets the text alignment for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "center"
    :type columnAlign5: [string, string, string, string, string]
    :param columnAlign6: (C E) Sets the text alignment for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "center"
    :type columnAlign6: [string, string, string, string, string, string]
    :param columnAttach: (C E M) Arguments are : column number, attachment type, and offset 
    Possible attachments are: left | right | both  Specifies column attachment types and offe
    :type columnAttach: [int, string, int]
    :param columnAttach2: (C E) Sets the attachment type of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "both"
    :type columnAttach2: [string, string]
    :param columnAttach3: (C E) Sets the attachment type for all three columns  Ignored if
    there are not exactly three columns  Valid values are "left", "right", and "both"
    :type columnAttach3: [string, string, string]
    :param columnAttach4: (C E) Sets the attachment type for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "both"
    :type columnAttach4: [string, string, string, string]
    :param columnAttach5: (C E) Sets the attachment type for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "both"
    :type columnAttach5: [string, string, string, string, string]
    :param columnAttach6: (C E) Sets the attachment type for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "both"
    :type columnAttach6: [string, string, string, string, string, string]
    :param columnOffset2: (C E) This flag is used in conjunction with the -columnAttach2 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the tw
    :type columnOffset2: [int, int]
    :param columnOffset3: (C E) This flag is used in conjunction with the -columnAttach3 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the th
    :type columnOffset3: [int, int, int]
    :param columnOffset4: (C E) This flag is used in conjunction with the -columnAttach4 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fo
    :type columnOffset4: [int, int, int, int]
    :param columnOffset5: (C E) This flag is used in conjunction with the -columnAttach5 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fi
    :type columnOffset5: [int, int, int, int, int]
    :param columnOffset6: (C E) This flag is used in conjunction with the -columnAttach6 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the si
    :type columnOffset6: [int, int, int, int, int, int]
    :param columnWidth: (C E M) Arguments are : column number, column width  Sets the width of
    the specified column where the first parameter specifies the column (1 based index) an
    :type columnWidth: [int, int]
    :param columnWidth1: (C E) Sets the width of the first column  Ignored if there is not
    exactly one column
    :type columnWidth1: int
    :param columnWidth2: (C E) Sets the column widths of both columns  Ignored if there are not
    exactly two columns
    :type columnWidth2: [int, int]
    :param columnWidth3: (C E) Sets the column widths for all 3 columns  Ignored if there are
    not exactly 3 columns
    :type columnWidth3: [int, int, int]
    :param columnWidth4: (C E) Sets the column widths for all 4 columns  Ignored if there are
    not exactly 4 columns
    :type columnWidth4: [int, int, int, int]
    :param columnWidth5: (C E) Sets the column widths for all 5 columns  Ignored if there are
    not exactly 5 columns
    :type columnWidth5: [int, int, int, int, int]
    :param columnWidth6: (C E) Sets the column widths for all 6 columns  Ignored if there are
    not exactly 6 columns
    :type columnWidth6: [int, int, int, int, int, int]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dragCommand: (C E) The command string executed repeatedly during a drag of the
    slider
    :type dragCommand: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param extraLabel: (C Q E) If present on creation this specifies that there will be an
    extra label appearing after the slider  Sets the string to be the text for the extra labe
    :type extraLabel: string
    :param field: (C) If true on creation the group will have an editable int field present
    that reflects the value of the slider
    :type field: boolean
    :param fieldMaxValue: (C Q E) Maximum value that may be entered in the field  This value
    may be set to any value greater than the -max/maxValue flag  By default, it is equal to th
    :type fieldMaxValue: int
    :param fieldMinValue: (C Q E) Minimum value that may be entered in the field  This value
    may be set to any value less than the -min/minValue flag  By default, it is equal to the -
    :type fieldMinValue: int
    :param fieldStep: (C Q E) Increment for the field
    :type fieldStep: int
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) If present on creation the group will have static text  Returns a
    string on query
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param maxValue: (C Q E) Sets the maximum value for both the slider and the field
    :type maxValue: int
    :param minValue: (C Q E) Sets the minimum value for both the slider and the field
    :type minValue: int
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rowAttach: (C E M) Arguments are : column, attachment type, offset  Possible
    attachments are: top | bottom | both  Specifies attachment types and offsets for the
    entire
    :type rowAttach: [int, string, int]
    :param sliderStep: (C Q E) On Linux the slider step value represents the amount the value
    will increase or decrease when you click either side of the slider
    :type sliderStep: int
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param step: (C Q E) Increment for both the slider and field
    :type step: int
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param value: (C Q E) Value of the group
    :type value: int
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name of the control on creation.
    :rtype: string
    """
    pass


def NodeEditorPinByDefault(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polySoftEdge(*args, angle=30, caching=True, constructionHistory=True, name="", nodeState=0,
                 worldSpace=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Selectively makes edges soft or hard   An edge will be made hard if the angle between two
    owning faces is sharper (larger) than the smoothing angle  An edge wil be made soft if the
    angle between two owning facets is flatter (smaller) than the smoothing angle
    
    :param angle: (C Q E) Smoothing angle  C: Default is 30 degrees  Q: When queried, this flag
    returns a float
    :type angle: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The name of the polySoftEdge node.
    :rtype: string
    """
    pass


def roundCRCtx(*args, **kwargs):
    """
    
    """
    pass


def FBXExportQuickSelectSetAsCache(*args, **kwargs):
    """
    
    """
    pass


def SurfaceBooleanSubtractTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OneClickMenuExecute(*args, **kwargs):
    """
    
    """
    pass


def cylinder(*args, axis=None, caching=True, degree=3, endSweep=2, heightRatio=2.0, nodeState=0,
             pivot=None, radius=1.0, sections=8, spans=1, startSweep=0, tolerance=0.01,
             useTolerance=False, constructionHistory=True, name="", object=True, polygon=0,
             q=True, query=True, e=True, edit=True, **kwargs):
    """
    The cylinder command creates a new cylinder and/or a dependency node that creates one, and
    returns their names
    
    :param axis: (C Q E) The primitive's axis
    :type axis: [float, float, float]
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param degree: (C Q E) The degree of the resulting surface: 1 - linear, 3 - cubic Default:
    3
    :type degree: int
    :param endSweep: (C Q E) The angle at which to end the surface of revolution  Default is
    2Pi radians, or 360 degrees  Default: 6.2831853
    :type endSweep: float
    :param heightRatio: (C Q E) Ratio of "height" to "width" Default: 2.0
    :type heightRatio: float
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param pivot: (C Q E) The primitive's pivot point
    :type pivot: [float, float, float]
    :param radius: (C Q E) The radius of the object Default: 1.0
    :type radius: float
    :param sections: (C Q E) The number of sections determines the resolution of the surface in
    the sweep direction  Used only if useTolerance is false  Default: 8
    :type sections: int
    :param spans: (C Q E) The number of spans determines the resolution of the surface in the
    opposite direction  Default: 1
    :type spans: int
    :param startSweep: (C Q E) The angle at which to start the surface of revolution Default:
    0
    :type startSweep: float
    :param tolerance: (C Q E) The tolerance with which to build the surface  Used only if
    useTolerance is true Default: 0.01
    :type tolerance: float
    :param useTolerance: (C Q E) Use the specified tolerance to determine resolution  Otherwise
    number of sections will be used  Default: false
    :type useTolerance: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param polygon: (C) The value of this argument controls the type of the object created by
    this operation 0: nurbs surface 1: polygon (use nurbsToPolygonsPref to set the
    :type polygon: int
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def MirrorDeformerWeights(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GetHIKEffectorName(*args, **kwargs):
    """
    
    """
    pass


def surfaceShaderList(*args, add=None, remove=None, q=True, query=True, e=True, edit=True,
                      **kwargs):
    """
    Add/Remove a relationship between an object and the current shading group
    
    :param add: (C) add object(s) to shader group list
    :type add: name
    :param remove: (C) remove object(s) to shader group list
    :type remove: name
    
    :returns: 
    :rtype: None
    """
    pass


def defaultLightListCheckBox(*args, annotation="", backgroundColor=None, defineTemplate="",
                             docTag="", dragCallback=None, dropCallback=None, enable=True,
                             enableBackground=True, enableKeyboardFocus=True, exists=True,
                             fullPathName=True, height=0, highlightColor=None, isObscured=True,
                             label="", manage=True, noBackground=True, numberOfPopupMenus=True,
                             parent="", popupMenuArray=True, preventOverride=True,
                             shadingGroup=None, statusBarMessage="", useTemplate="",
                             visible=True, visibleChangeCommand=None, width=0, q=True,
                             query=True, e=True, edit=True, **kwargs):
    """
    This command creates a checkBox that controls whether a shadingGroup is
    connected/disconnected from the defaultLightList
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C E) Value of the checkbox label
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param shadingGroup: (C E) The shading group that is to be connected/disconnected from the
    defaultLightList
    :type shadingGroup: name
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full name to the control
    :rtype: string
    """
    pass


def dR_selectSimilar(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def getFluidAttr(*args, attribute="", lowerFace=True, xIndex=0, xvalue=True, yIndex=0,
                 yvalue=True, zIndex=0, zvalue=True, **kwargs):
    """
    Returns values of built-in fluid attributes such as density, velocity, etc., for individual
    grid cells or for all cells in the grid
    
    :param attribute: (C) Specifies the fluid attribute for which to display values  Valid
    attributes are "force", "velocity", "density", "falloff", "fuel", "color", and "temp
    :type attribute: string
    :param lowerFace: (C) Only valid with "-at velocity"  Since velocity values are stored on
    the edges of each voxel and not at the center, using voxel based indices to set v
    :type lowerFace: boolean
    :param xIndex: (C) Only return values for cells with this X index
    :type xIndex: int
    :param xvalue: () Only get the first component of the vector-valued attribute specified by
    the "-at/attribute" flag
    :type xvalue: boolean
    :param yIndex: (C) Only return values for cells with this Y index
    :type yIndex: int
    :param yvalue: () Only get the second component of the vector-valued attribute specified by
    the "-at/attribute" flag
    :type yvalue: boolean
    :param zIndex: (C) Only return values for cells with this Z index
    :type zIndex: int
    :param zvalue: () Only get the third component of the vector-valued attribute specified by
    the "-at/attribute" flag
    :type zvalue: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def SoloMaterial(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyBevel(*args, angleTolerance=20.0, autoFit=True, caching=True, constructionHistory=True,
              mergeVertexTolerance=0.0, mergeVertices=False, miteringAngle=0.0, name="",
              nodeState=0, offset=0.2, offsetAsFraction=False, roundness=0.5, segments=1,
              smoothingAngle=0.0, subdivideNgons=False, useLegacyBevelAlgorithm=False,
              uvAssignment=0, worldSpace=True, q=True, query=True, e=True, edit=True,
              **kwargs):
    """
    Bevel edges
    
    :param angleTolerance: (C Q E) Angular tolerance for creation of extra triangles Note this
    attribute is for compatability only and should not be modified in Maya 7.0 files Default:
    :type angleTolerance: float
    :param autoFit: (C Q E) If autoFit is on, it computes a smooth roundness : new facets round
    off a smooth angle  Default: true
    :type autoFit: boolean
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param mergeVertexTolerance: (C Q E) Tolerance within which to merge vertices Default: 0.0
    :type mergeVertexTolerance: float
    :param mergeVertices: (C Q E) Merge vertices within a tolerance Default: false
    :type mergeVertices: boolean
    :param miteringAngle: (C Q E) Miter faces that have angles less than this value Default:
    0.0
    :type miteringAngle: float
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param offset: (C Q E) The offset for bevel  Default: 0.2
    :type offset: float
    :param offsetAsFraction: (C Q E) If on, the offset value is treated as a fraction between
    zero and one  Default: false
    :type offsetAsFraction: boolean
    :param roundness: (C Q E) The roundness of bevel, it is taken into account when autoFit is
    off  Default: 0.5
    :type roundness: float
    :param segments: (C Q E) The number of segments used for beveling  Default: 1
    :type segments: int
    :param smoothingAngle: (C Q E) Create new edges as hard edges if the angle between adjacent
    faces exceeds this value Default: 0.0
    :type smoothingAngle: float
    :param subdivideNgons: (C Q E) Subdivide new faces with more than 4 edges Default: false
    :type subdivideNgons: boolean
    :param useLegacyBevelAlgorithm: (C Q E) If on, bevel is done the way maya 2014 did Default:
    false
    :type useLegacyBevelAlgorithm: boolean
    :param uvAssignment: (C Q E) Technique used to compute UVs on new faces 0 computes new UVs
    by projecting along surface normal of original mesh onto new mesh 1 computes new UVs by
    :type uvAssignment: int
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def Loft(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DisplayUVWireframe(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def linearPrecision(*args, q=True, query=True, **kwargs):
    """
    This command controls the display of linear strings in the interface  (See the linearField
    command)  Setting this affects any linear strings displayed afterwards, formatting them so
    they will show at most the specified number of digits after the decimal point  Allowed
    values are 0 through 6
    
    
    :returns: 
    :rtype: None
    """
    pass


def softModCtx(*args, dragSlider="", exists=True, falseColor=True, image1="", image2="",
               image3="", reset=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Controls the softMod context
    
    :param dragSlider: (E) Specify the slider mode for hotkey radius resizing
    :type dragSlider: string
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param falseColor: (E) Enable or disable false color display on the soft mod manipulator
    :type falseColor: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param reset: (Q E) Reset the tool options to their default values
    :type reset: boolean
    
    :returns: - name of the new context created
    :rtype: string
    """
    pass


def DuplicateSpecialOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RotateToolWithSnapMarkingMenuPopDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ConvertSelectionToVertexFaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def mouse(*args, enableScrollWheel=True, mouseButtonTracking=0, mouseButtonTrackingStatus=True,
          scrollWheelStatus=True, **kwargs):
    """
    This command allows to configure mouse
    
    :param enableScrollWheel: (C) Enable or disable scroll wheel support
    :type enableScrollWheel: boolean
    :param mouseButtonTracking: (C) Set the number (1, 2 or 3) of mouse buttons to track  Note:
    this is only supported on Macintosh
    :type mouseButtonTracking: int
    :param mouseButtonTrackingStatus: (C) returns the current number of mouse buttons being
    tracked
    :type mouseButtonTrackingStatus: boolean
    :param scrollWheelStatus: (C) returns the current status of scroll wheel support
    :type scrollWheelStatus: boolean
    
    :returns: When -scrollWheelStatus flag is used, will return 1 if scroll wheel support
    enabled, otherwise 0.
    When -mouseButtonTrackingStatus flag is used, will return the number
    of mouse buttons being tracked.
    :rtype: int
    """
    pass


def webViewCmd(*args, **kwargs):
    """
    
    """
    pass


def colorManagementPrefs(*args, cmConfigFileEnabled=True, cmEnabled=True,
                         colorManageAllNodes=True, colorManagePots=True, colorManagedNodes=True,
                         colorManagementSDKVersion="", configFilePath="",
                         defaultInputSpaceName="", equalsToPolicyFile="", exportPolicy="",
                         inhibitEvents=True, inputSpaceNames=True, loadPolicy="",
                         loadedDefaultInputSpaceName="", loadedOutputTransformName="",
                         loadedRenderingSpaceName="", loadedViewTransformName="",
                         missingColorSpaceNodes=True, ocioRulesEnabled=True, outputTarget="",
                         outputTransformEnabled=True, outputTransformName="",
                         outputTransformNames=True, outputTransformUseColorConversion=True,
                         outputUseViewTransform=True, policyFileName="", popupOnError=True,
                         refresh=True, renderingSpaceName="", renderingSpaceNames=True,
                         restoreDefaults=True, viewTransformName="", viewTransformNames=True,
                         q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command allows querying and editing the color management global data in a scene  It
    also allows for setting the view transform and rendering space which automatically
    configures the color processing in the enabled views
    
    :param cmConfigFileEnabled: (Q E) Turn on or off applying an OCIO configuration file  If
    set, the color management configuration set in the preferences is used
    :type cmConfigFileEnabled: boolean
    :param cmEnabled: (Q E) Turn on or off color management in general  If set, the color
    management configuration set in the preferences is used
    :type cmEnabled: boolean
    :param colorManageAllNodes: (C Q E) Adds color management to all input nodes such as file
    texture nodes
    :type colorManageAllNodes: boolean
    :param colorManagePots: (Q E) Turn on or off color management of color pots in the UI  If
    set, colors in color pots are taken to be in rendering space, and are displayed after bei
    :type colorManagePots: boolean
    :param colorManagedNodes: (Q E) Gets the names of all nodes that apply color management to
    bring pixels from an input color space to the rendering space  Examples include file textu
    :type colorManagedNodes: boolean
    :param colorManagementSDKVersion: (Q E) Obtain the version of the color management SDK used
    by Maya
    :type colorManagementSDKVersion: string
    :param configFilePath: (Q E) The configuration file to be used, if color management is
    enabled
    :type configFilePath: string
    :param defaultInputSpaceName: (Q E) This flag is obsolete  See the colorManagementFileRules
    command for more information
    :type defaultInputSpaceName: string
    :param equalsToPolicyFile: (Q E) Query if the current loaded policy settings is the same
    with the settings described in the policy file which is the argument of the command  In
    query
    :type equalsToPolicyFile: string
    :param exportPolicy: (C Q E) Export the color management parameters to policy file
    :type exportPolicy: string
    :param inhibitEvents: (C Q E) Inhibit client-server notifications and event triggers which
    occur when changing the color management settings
    :type inhibitEvents: boolean
    :param inputSpaceNames: (Q E) Returns the list of available input color spaces  Used to
    populate the input color spaces UI popup
    :type inputSpaceNames: boolean
    :param loadPolicy: (C Q E) Load the color management policy file  This file overides the
    color management settings
    :type loadPolicy: string
    :param loadedDefaultInputSpaceName: (Q E) This flag is obsolete
    :type loadedDefaultInputSpaceName: string
    :param loadedOutputTransformName: (Q E) Gets the loaded output transform  Used by file open,
    import, and reference to check for missing color spaces or transforms
    :type loadedOutputTransformName: string
    :param loadedRenderingSpaceName: (Q E) Gets the loaded rendering space  Used by file open,
    import, and reference to check for missing color spaces or transforms
    :type loadedRenderingSpaceName: string
    :param loadedViewTransformName: (Q E) Gets the loaded view transform  Used by file open,
    import, and reference to check for missing color spaces or transforms
    :type loadedViewTransformName: string
    :param missingColorSpaceNodes: (Q E) Gets the names of the nodes that have color spaces not
    defined in the selected transform collection
    :type missingColorSpaceNodes: boolean
    :param ocioRulesEnabled: (Q E) Turn on or off the use of colorspace assignment rules from
    the OCIO library
    :type ocioRulesEnabled: boolean
    :param outputTarget: (Q E) Indicates to which output the outputTransformEnabled or the
    outputTransformName flags are to be applied  Valid values are "renderer" or "playblast"
    :type outputTarget: string
    :param outputTransformEnabled: (Q E) Turn on or off applying the output transform for out
    of viewport renders  If set, the output transform set in the preferences is used
    :type outputTransformEnabled: boolean
    :param outputTransformName: (Q E) The output transform to be applied for out of viewport
    renders  Disables output use view transform mode
    :type outputTransformName: string
    :param outputTransformNames: (Q E) Returns the list of available output transforms
    :type outputTransformNames: boolean
    :param outputTransformUseColorConversion: (Q E) Turn on or off selecting the color space
    conversion for the output color space of viewport renders  If set, a conversion color space
    is used; otherwi
    :type outputTransformUseColorConversion: boolean
    :param outputUseViewTransform: (Q E) Turns use view transform mode on  In this mode, the
    output transform is set to match the view transform  To turn the mode off, set an output
    transfor
    :type outputUseViewTransform: boolean
    :param policyFileName: (Q E) Set the policy file name
    :type policyFileName: string
    :param popupOnError: (Q E) Turn on or off displaying a modal popup on error (as well as the
    normal script editor reporting of the error), for this invocation of the command  De
    :type popupOnError: boolean
    :param refresh: (C Q E) Refresh the color management
    :type refresh: boolean
    :param renderingSpaceName: (Q E) The color space to be used during rendering  This is the
    source color space to the viewing transform, for color managed viewers and color managed
    UI
    :type renderingSpaceName: string
    :param renderingSpaceNames: (Q E) Returns the list of available rendering spaces  Used to
    populate the color management preference UI popup
    :type renderingSpaceNames: boolean
    :param restoreDefaults: (C Q E) Restore the color management settings to their default
    value
    :type restoreDefaults: boolean
    :param viewTransformName: (Q E) The view transform to be applied by color managed viewers
    and color managed UI controls
    :type viewTransformName: string
    :param viewTransformNames: (Q E) Returns the list of available view transforms  Used to
    populate the color management preference UI popup
    :type viewTransformNames: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def reproInstancer(*args, **kwargs):
    """
    
    """
    pass


def dR_timeConfigTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GlobalStitch(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PaintEffectPanelActivate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def copySkinWeights(*args, destinationSkin="", influenceAssociation="", mirrorInverse=True,
                    mirrorMode="", noBlendWeight=True, noMirror=True, normalize=True,
                    sampleSpace=0, smooth=True, sourceSkin="", surfaceAssociation="",
                    uvSpace=None, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Command to copy or mirror the skinCluster weights accross one of the three major axes  The
    command can be used to mirror weights either from one surface to another or within the same
    surface
    
    :param destinationSkin: (C Q E) Specify the destination skin shape
    :type destinationSkin: string
    :param influenceAssociation: (C Q E M) The influenceAssociation flag controls how the
    influences on the source and target skins are matched up  The flag can be included multiple
    times to s
    :type influenceAssociation: string
    :param mirrorInverse: (C Q E) Values are mirrored from the positive side to the negative 
    If this flag is used then the direction is inverted
    :type mirrorInverse: boolean
    :param mirrorMode: (C Q E) The mirrorMode flag defines the plane of mirroring (XY, YZ, or
    XZ) when the mirror flag is used  The default plane is XY
    :type mirrorMode: string
    :param noBlendWeight: (C Q E) When the no blend flag is used, the blend weights on the skin
    cluster will not be copied across to the destination
    :type noBlendWeight: boolean
    :param noMirror: (C Q E) When the no mirror flag is used, the weights are copied instead of
    mirrored
    :type noMirror: boolean
    :param normalize: (C Q E) Normalize the skin weights
    :type normalize: boolean
    :param sampleSpace: (C Q E) Selects which space the attribute transfer is performed in  0
    is world space, 1 is model space  The default is world space
    :type sampleSpace: int
    :param smooth: (C Q E) When the smooth flag is used, the weights are smoothly interpolated
    between the closest vertices, instead of assigned from the single closest
    :type smooth: boolean
    :param sourceSkin: (C Q E) Specify the source skin shape
    :type sourceSkin: string
    :param surfaceAssociation: (C Q E) The surfaceAssociation flag controls how the weights are
    transferred between the surfaces: "closestPoint", "rayCast", or "closestComponent"  The
    defa
    :type surfaceAssociation: string
    :param uvSpace: (C Q E) The uvSpace flag indicates that the weight transfer should occur in
    UV space, based on the source and destination UV sets specified
    :type uvSpace: [string, string]
    
    :returns: 
    :rtype: None
    """
    pass


def SetMeshRepeatTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_selectTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CycleThroughCameras(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DistributeShellsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SimplifyCurve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SphericalProjection(*args, **kwargs):
    """
    unknown
    """
    pass


def SelectToolOptionsMarkingMenu(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddBifrostChannelField(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgBatchExportArchive(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def poleVectorConstraint(*args, layer="", name="", remove=True, targetList=True, weight=0.0,
                         weightAliasList=True, q=True, query=True, e=True, edit=True,
                         **kwargs):
    """
    Constrains the poleVector of an ikRPsolve handle to point at a target object or at the
    average position of a number of targets   An poleVectorConstraint takes as input one or
    more "target" DAG transform nodes at which to aim pole vector for an IK handle using the
    rotate plane solver  The pole vector is adjust such that the in weighted average of th
    
    :param layer: (C E) Specify the name of the animation layer where the constraint should be
    added
    :type layer: string
    :param name: (C Q E) Sets the name of the constraint node to the specified name  Default
    name is constrainedObjectName_constraintType
    :type name: string
    :param remove: (E) removes the listed target(s) from the constraint
    :type remove: boolean
    :param targetList: (Q) Return the list of target objects
    :type targetList: boolean
    :param weight: (C Q E) Sets the weight value for the specified target(s)  If not given at
    creation time, the default value of 1.0 is used
    :type weight: float
    :param weightAliasList: (Q) Returns the names of the attributes that control the weight of
    the target objects  Aliases are returned in the same order as the targets are returned
    :type weightAliasList: boolean
    
    :returns: name of the created constraint node
    :rtype: string[]
    """
    pass


def dR_loadRecentFile1(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MoveNormalTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_loadRecentFile3(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_loadRecentFile4(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def setAttr(*args, alteredValue=True, caching=True, capacityHint=0, channelBox=True, clamp=True,
            keyable=True, lock=True, size=0, type="", q=True, query=True, e=True, edit=True,
            **kwargs):
    """
    Sets the value of a dependency node attribute  No value for the the attribute is needed
    when the -l/-k/-s flags are used  The -type flag is only required when setting a
    non-numeric attribute   The following chart outlines the syntax of setAttr for non-numeric
    data types:    {TYPE} below means any number of values of type TYPE, separated by a space
    
    
    :param alteredValue: (C) The value is only the current value, which may change in the next
    evalution (if the attribute has an incoming connection)  This flag is only used dur
    :type alteredValue: boolean
    :param caching: (C) Sets the attribute's internal caching on or off  Not all attributes can
    be defined as caching  Only those attributes that are not defined by default
    :type caching: boolean
    :param capacityHint: (C) Used to provide a memory allocation hint to attributes where the
    -size flag cannot provide enough information  This flag is optional and is primarily
    :type capacityHint: int
    :param channelBox: (C) Sets the attribute's display in the channelBox on or off  Keyable
    attributes are always display in the channelBox regardless of the channelBox settti
    :type channelBox: boolean
    :param clamp: (C) For numeric attributes, if the value is outside the range of the
    attribute, clamp it to the min or max instead of failing
    :type clamp: boolean
    :param keyable: (C) Sets the attribute's keyable state on or off
    :type keyable: boolean
    :param lock: (C) Sets the attribute's lock state on or off
    :type lock: boolean
    :param size: (C) Defines the size of a multi-attribute array  This is only a hint, used to
    help allocate memory as efficiently as possible
    :type size: int
    :param type: (C) Identifies the type of data  If the -type flag is not present, a numeric
    type is assumed
    :type type: string
    
    :returns: 
    :rtype: None
    """
    pass


def FBXExportReferencedAssetsContent(*args, **kwargs):
    """
    
    """
    pass


def createNurbsCylinderCtx(*args, **kwargs):
    """
    
    """
    pass


def polySlideEdge(*args, absolute=True, direction=0, edgeDirection=0.0, symmetry=True,
                  **kwargs):
    """
    Moves an edge loop selection along the edges connected to the sides of its vertices
    
    :param absolute: (C) This flag specifies whether or not the command uses absolute mode If
    in absolute then all vertices will move the same distance (the specified percent
    :type absolute: boolean
    :param direction: (C) This flag specifies the direction of the slide edge movement 0: is
    left direction (relative) 1: is right direction (relative) 2: is normal direction
    :type direction: int
    :param edgeDirection: (C) This flag specifies the relative percentage to move along the
    edges on either side of the vertices along the edge loop C: Default is 0.0
    :type edgeDirection: float
    :param symmetry: (C) This flag specifies whether or not the command will do a symmetrical
    slide  Only takes effect when symmetry is enabled  C: Default is off
    :type symmetry: boolean
    
    :returns: Success value
    :rtype: boolean
    """
    pass


def polyTestPop(*args, **kwargs):
    """
    
    """
    pass


def setInfinity(*args, attribute="", controlPoints=False, hierarchy="", postInfinite="",
                preInfinite="", shape=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Set the infinity type before (after) a paramCurve's first (last) keyframe
    
    :param attribute: (C M) List of attributes to select In query mode, this flag needs a
    value
    :type attribute: string
    :param controlPoints: (C) This flag explicitly specifies whether or not to include the
    control points of a shape (see "-s" flag) in the list of attributes  Default: false  (No
    :type controlPoints: boolean
    :param hierarchy: (C) Hierarchy expansion options  Valid values are "above," "below," "both,
    " and "none." (Not valid for "pasteKey" cmd.) In query mode, this flag needs a
    :type hierarchy: string
    :param postInfinite: (C Q) Set the infinity type after a paramCurve's last keyframe  Valid
    values are "constant", "linear", "cycle", "cycleRelative", "oscillate"
    :type postInfinite: string
    :param preInfinite: (C Q) Set the infinity type before a paramCurve's first keyframe  Valid
    values are "constant", "linear", "cycle", "cycleRelative", "oscillate"
    :type preInfinite: string
    :param shape: (C) Consider attributes of shapes below transforms as well, except
    "controlPoints"  Default: true  (Not valid for "pasteKey" cmd.) In query mode, this fl
    :type shape: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def ShareOneBrush(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def journal(*args, **kwargs):
    """
    
    """
    pass


def projectTangent(*args, caching=True, curvature=False, curvatureScale=0.0, ignoreEdges=False,
                   nodeState=0, reverseTangent=False, rotate=0.0, tangentDirection=1,
                   tangentScale=1.0, constructionHistory=True, name="", object=True,
                   replaceOriginal=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The project tangent command is used to align (for tangents) a curve to two other curves or
    a surface  A surface isoparm may be selected to define the direction (U or V) to align to 
    The end of the curve must intersect with these other objects  Curvature continuity may also
    be applied if required   Tangent continuity means the end of the curve is mo
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param curvature: (C Q E) Curvature continuity is on if true and off otherwise  Default:
    false
    :type curvature: boolean
    :param curvatureScale: (C Q E) Curvature scale applied to curvature of curve to align 
    Available if curvature option is true  Default: 0.0
    :type curvatureScale: float
    :param ignoreEdges: (C Q E) If false, use the tangents of the trim edge curves if the
    surface is trimmed  If true, use the tangents of the underlying surface in the U/V
    directio
    :type ignoreEdges: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param reverseTangent: (C Q E) Reverse the tangent direction if true and leave it the way
    it is if false  Default: false
    :type reverseTangent: boolean
    :param rotate: (C Q E) Amount by which the tangent of the curve to align will be rotated 
    Available only if the normal direction (3) is not used for tangentDirection  Defau
    :type rotate: float
    :param tangentDirection: (C Q E) Tangent align direction type legal values: 1=u direction
    (of surface or use first curve), 2=v direction (of surface or use second curve), 3=normal
    di
    :type tangentDirection: int
    :param tangentScale: (C Q E) Tangent scale applied to tangent of curve to align  Default:
    1.0
    :type tangentScale: float
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def UVContourStretchProjection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PixelMoveUp(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowMeshWaxToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectAllCameras(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorShapeMenuStateAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AssignOfflineFileOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SubdivSurfaceMatchTopology(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def pause(*args, seconds=0, **kwargs):
    """
    Pause for a specified number of seconds for canned demos or for test scripts to allow user
    to view results
    
    :param seconds: (C) Pause for the specified number of seconds
    :type seconds: int
    
    :returns: 
    :rtype: None
    """
    pass


def ShowAllUI(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetKeyPath(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def texSculptCacheSync(*args, **kwargs):
    """
    
    """
    pass


def ExtrudeFaceOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddInfluenceOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectMultiComponentMask(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportScaleFactor(*args, **kwargs):
    """
    
    """
    pass


def xgmSetGuideCVCount(*args, **kwargs):
    """
    
    """
    pass


def hudSliderButton(*args, allowOverlap=True, block=0, blockAlignment="", blockSize="",
                    buttonLabel="", buttonLabelFontSize="", buttonPressCommand=None,
                    buttonReleaseCommand=None, buttonShape="", buttonWidth=0,
                    decimalPrecision=0, internalPadding=0, maxValue=0.0, minValue=0.0,
                    padding=0, section=0, sliderDragCommand=None, sliderIncrement=0.0,
                    sliderLabel="", sliderLabelFontSize="", sliderLabelWidth=0, sliderLength=0,
                    sliderPressCommand=None, sliderReleaseCommand=None, type="", value=0.0,
                    valueAlignment="", valueFontSize="", valueWidth=0, visible=True, q=True,
                    query=True, e=True, edit=True, **kwargs):
    """
    This command creates a Heads-up Display (HUD) slider button control which is placed in a 2D
    inactive overlay plane on the 3D viewport  It is to be used to provide hands-on interaction
    designated by a user script  The HUD slider button control is derived from a generic HUD
    object and thus inherits a similar workflow   Although this command provides 
    
    :param allowOverlap: (C Q E) Sets the Heads-Up Display to be visible regardless of
    overlapping section widths/limitations (see -s/section flag description for more details)
    :type allowOverlap: boolean
    :param block: (C Q E) Denotes the individual block that the HUD will reside in, within a
    section  Each section is composed of a single column of blocks  The total number o
    :type block: int
    :param blockAlignment: (C Q E) Specifies the alignment of the block within its respective
    column  Available alignments are: "center", "left" and "right"  The default alignment is "
    :type blockAlignment: string
    :param blockSize: (C Q E) Sets the height of each block  Available heights are: small,
    medium and large  In pixel measurements, each corresponds to a 20, 35 or 50 pixel height
    :type blockSize: string
    :param buttonLabel: (C Q E) Text label of the HUD button
    :type buttonLabel: string
    :param buttonLabelFontSize: (C Q E) Sets the font size of the button label  Available sizes
    are: small and large
    :type buttonLabelFontSize: string
    :param buttonPressCommand: (C Q E) Specifies the procedure or script to run during a button
    mouse click event
    :type buttonPressCommand: script
    :param buttonReleaseCommand: (C Q E) Specifies the procedure or script to run during a
    button mouse release event
    :type buttonReleaseCommand: script
    :param buttonShape: (C Q E) Specifies the shape of the button  Available button shapes are:
    "rectangle" and "roundRectangle"  The first will draw a rectangular button, while the
    :type buttonShape: string
    :param buttonWidth: (C Q E) Specifies the width of the button
    :type buttonWidth: int
    :param decimalPrecision: (C Q E) Sets the decimal precision of any floating point value
    returned by the command  The valid range of precision values are 1 to 8
    :type decimalPrecision: int
    :param internalPadding: (C Q E) Specifies the amount of padding between the internal
    elements of the HUD  For the hudSlider, this represents the padding between the slider bar
    and t
    :type internalPadding: int
    :param maxValue: (C Q E) Specify the maximum value of the slider  Note: Although this flag
    takes in a FLOAT as an argument, if the HUD type is "int", the value will be automa
    :type maxValue: float
    :param minValue: (C Q E) Specify the minimum value of the slider  Note: Although this flag
    takes in a FLOAT as an argument, if the HUD type is "int", the value will be automa
    :type minValue: float
    :param padding: (C Q E) Specifies the width of both the left and right margins of a block 
    Default value is 15 pixels
    :type padding: int
    :param section: (C Q E) Defines the section the HUD will appear in  There are 10 sections
    divided across the screen  Five columns and two rows make up the ten element matrix
    :type section: int
    :param sliderDragCommand: (C Q E) Specifies the procedure or script to run during a slider
    mouse drag event
    :type sliderDragCommand: script
    :param sliderIncrement: (C Q E) Specify the number of increments along the slider  If not
    specified or set to 0 or less, the slider will be linearly even and continuous from
    minValu
    :type sliderIncrement: float
    :param sliderLabel: (C Q E) Text label of the HUD slider
    :type sliderLabel: string
    :param sliderLabelFontSize: (C Q E) Sets the font size of the slider label  Available sizes
    are: small and large
    :type sliderLabelFontSize: string
    :param sliderLabelWidth: (C Q E) Specifies the pixel width of the virtual "textbox" which
    will hold the label  The contents of this "textbox" will be left justified  If the width
    of
    :type sliderLabelWidth: int
    :param sliderLength: (C Q E) Specifies the length of the slider in pixels
    :type sliderLength: int
    :param sliderPressCommand: (C Q E) Specifies the procedure or script to run during a slider
    mouse click event
    :type sliderPressCommand: script
    :param sliderReleaseCommand: (C Q E) Specifies the procedure or script to run during a
    slider mouse release event
    :type sliderReleaseCommand: script
    :param type: (C Q E) Specify the numeric type of the HUD  Available types are: "float" and
    "int"
    :type type: string
    :param value: (C Q E) Set/Return the slider value if the HUD is a valid HUD slider  Note:
    Although this flag takes in a FLOAT as an argument, if the HUD type is "int", the
    :type value: float
    :param valueAlignment: (C Q E) Specifies the alignment of the data blocks and the data text,
    within a HUD block  Available alignments are: "left" and "right"  The default alignment
    :type valueAlignment: string
    :param valueFontSize: (C Q E) Sets the font size of the slider value  Available sizes are:
    small and large
    :type valueFontSize: string
    :param valueWidth: (C Q E) Specifies the pixel width of the virtual "textbox" which will
    hold the slider value  (To see a layout of a block, see the description of the -block f
    :type valueWidth: int
    :param visible: (C Q E) Sets the visibility of the Heads-Up Display on and off
    :type visible: boolean
    
    :returns: ID number of the Heads-Up Display (HUD).
    :rtype: int
    """
    pass


def dR_slideOff(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorToggleAttrFilter(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AssignOfflineFile(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def hyperGraph(*args, addBookmark=True, addDependGraph=None, addDependNode=None,
               animateTransition=True, attributeEditor="", backward=True, bookmarkName=True,
               breakConnectionCommand="", clear=True, collapseContainer=True,
               connectionDrawStyle="center", control=True, currentEdge="", currentNode="",
               debug="", defineTemplate="", deleteBookmark="", dependGraph=True, dependNode="",
               directoryPressCommand="", docTag="", down=True, downstream=True,
               dragAndDropBehaviorCommand="", dropNode="", dropTargetNode="",
               edgeDblClickCommand="", edgeDimmedDblClickCommand="", edgeDropCommand="",
               edgePressCommand="", edgeReleaseCommand="", enableAutomaticLayout=True,
               exists=True, expandContainer=True, feedbackGadget="", feedbackNode="", filter="",
               filterDetail=None, fitImageToHeight=True, fitImageToWidth=True, focusCommand="",
               fold=True, forceMainConnection="", forceRefresh=True, forward=True, frame=True,
               frameBranch=True, frameGraph=True, frameGraphNoRebuild=True, frameHierarchy=True,
               freeform=True, fromAttr="", fromNode="", getNodeList=True, getNodePosition="",
               graphDescription=True, graphLayoutStyle="", graphType="", heatMapDisplay=True,
               highlightConnection="", iconSize="", image="", imageEnabled=True,
               imageForContainer=True, imagePosition=None, imageScale=0.0, initializeScript="",
               isHotkeyTarget=True, layout=True, layoutSelected="", limitGraphTraversal=0,
               lockMainConnection=True, look=None, mainListConnection="", mergeConnections=True,
               navigateHome=True, navup=True, newInputConnection="", newOutputConnection="",
               nextView=True, nodeConnectCommand="", nodeDblClickCommand="", nodeDropCommand="",
               nodeMenuCommand="", nodePressCommand="", nodeReleaseCommand="",
               opaqueContainers=True, orientation="", panView=None, panel="", parent="",
               popupMenuScript="", previousView=True, range=None, rebuild=True, removeNode="",
               rename=True, resetFreeform=True, restoreBookmark="", scrollUpDownNoZoom=True,
               selectionConnection="", setNodePosition=None, showCachedConnections=True,
               showConnectionFromSelected=True, showConnectionToSelected=True,
               showConstraintLabels=True, showConstraints=True, showDeformers=True,
               showExpressions=True, showInvisible=True, showRelationships=True,
               showShapes=True, showUnderworld=True, stateString=True, toAttr="", toNode="",
               transitionFrames=0, unParent=True, unfold=True, unfoldAll=True,
               unfoldAllShapes=True, unfoldHidden=True, unlockMainConnection=True,
               updateMainConnection=True, updateNodeAdded=True, updateSelection=True,
               upstream=True, useDrawOverrideColor=True, useFeedbackList=True, useTemplate="",
               viewOption="", visibility=True, zoom=0.0, q=True, query=True, e=True, edit=True,
               **kwargs):
    """
    The following is an overview of the basic features of the hypergraph  A more detailed
    description is given in the user manuals   The hypergraph provides the user with the
    ability to view and edit the maya scene graph  The hypergraph supports two types of graphs:
    the DAG or scene hierarchy and the dependency graph   The default view of the hypergrap
    
    :param addBookmark: (C E) Create a bookmark for the current hypergraph view
    :type addBookmark: boolean
    :param addDependGraph: (C E) Add a dependency graph starting at the named node to the view
    :type addDependGraph: name
    :param addDependNode: (C E) Add a dependency node to the dependency graph view
    :type addDependNode: name
    :param animateTransition: (C Q E) Turns animate transitions off and on
    :type animateTransition: boolean
    :param attributeEditor: (C E) Launches attribute editor on selected node
    :type attributeEditor: string
    :param backward: (C E) Navigate backward one step
    :type backward: boolean
    :param bookmarkName: (Q) Returns the bookmark name for the most recently created bookmark
    :type bookmarkName: boolean
    :param breakConnectionCommand: (C Q E) Specify the command to call when a connection is
    broken
    :type breakConnectionCommand: string
    :param clear: (C E) Clears the current hypergraph view and deletes the graph UI  (see also
    -rebuild flag)
    :type clear: boolean
    :param collapseContainer: (C E) Collapses containers selected in DG graph
    :type collapseContainer: boolean
    :param connectionDrawStyle: (C E) Specify how connections between nodes should be drawn 
    Valid values are "center" (draws connection lines from the center of one node to the center
    of
    :type connectionDrawStyle: string
    :param control: (Q) Query only  Returns the top level control for this editor  Usually used
    for getting a parent to attach popup menus  Caution: It is possible for an ed
    :type control: boolean
    :param currentEdge: (Q E) Return the current edge name
    :type currentEdge: string
    :param currentNode: (Q E) Return the current node name
    :type currentNode: string
    :param debug: (C E) Run a debug method on the graph
    :type debug: string
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param deleteBookmark: (C E) Delete the bookmark with the corresponding node name
    :type deleteBookmark: string
    :param dependGraph: (C E) Displays dependency graph iterated from specified node
    :type dependGraph: boolean
    :param dependNode: (C E) Displays dependency node in view
    :type dependNode: string
    :param directoryPressCommand: (C E) Specify a command to run when a directory is pressed
    :type directoryPressCommand: string
    :param docTag: (C Q E) Attaches a tag to the editor
    :type docTag: string
    :param down: (C E) Navigate down to the dependency graph containing the current selection 
    Shows upstream and downstream connections
    :type down: boolean
    :param downstream: (C E) Show downstream dependency graph of selected node(s)
    :type downstream: boolean
    :param dragAndDropBehaviorCommand: (C E) Mel proc called when a drag and drop onto a
    hyperGraph node has occurred  Proc signature is procName (string $editor, string
    $sourceNode, string $des
    :type dragAndDropBehaviorCommand: string
    :param dropNode: (Q) Returns the name of the source node in a drag and drop connection,
    when called during processing of a drop
    :type dropNode: string
    :param dropTargetNode: (Q) Returns the name of the destination node in a drag and drop
    connection, when called during processing of a drop
    :type dropTargetNode: string
    :param edgeDblClickCommand: (C E) Mel proc called when an edge is double clicked  Proc
    signature is procName (string $editor, string $edge)
    :type edgeDblClickCommand: string
    :param edgeDimmedDblClickCommand: (C E) Mel proc called when a dimmed edge is double
    clicked  Proc signature is procName (string $editor, string $edge)
    :type edgeDimmedDblClickCommand: string
    :param edgeDropCommand: (C E) Command to execute when an edge drop occurs
    :type edgeDropCommand: string
    :param edgePressCommand: (C E) Command to execute when an edge press occurs
    :type edgePressCommand: string
    :param edgeReleaseCommand: (C E) Command to execute when an edge release occurs
    :type edgeReleaseCommand: string
    :param enableAutomaticLayout: (C E) Rebuild the graph if a node is added or removed from
    the graph via drag and drop or dg messages  Default is true
    :type enableAutomaticLayout: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param expandContainer: (C E) Expands containers selected in DG graph
    :type expandContainer: boolean
    :param feedbackGadget: (Q) Returns the name of the current gadget
    :type feedbackGadget: string
    :param feedbackNode: (Q) Returns the name of the current feedback or highlight node
    :type feedbackNode: string
    :param filter: (C Q E) Specifies the name of an itemFilter object to be used with this
    editor  This filters the information coming onto the main list of the editor
    :type filter: string
    :param filterDetail: (C E) This flag is obsolete  Use the showConstraints, showExpressions,
    showDeformer, showInvisible, showShapes and showUnderworld flags instead
    :type filterDetail: [string, boolean]
    :param fitImageToHeight: (C) Changes position and scale of background image, so its height
    fits current editor view
    :type fitImageToHeight: boolean
    :param fitImageToWidth: (C) Changes position and scale of background image, so its width
    fits current editor view
    :type fitImageToWidth: boolean
    :param focusCommand: (C E) Mel proc to be run when the mouse is clicked in the hyper graph 
    Primarily of use in setting the window focus
    :type focusCommand: string
    :param fold: (C E) Folds (Collapses) selected object
    :type fold: boolean
    :param forceMainConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type forceMainConnection: string
    :param forceRefresh: (C E) Forces the hypergraph to refresh (redraw) its contents
    :type forceRefresh: boolean
    :param forward: (C E) Navigate forward one step
    :type forward: boolean
    :param frame: (C E) Frames the selected objects
    :type frame: boolean
    :param frameBranch: (C E) Frames the the branch from the selected node on downward
    :type frameBranch: boolean
    :param frameGraph: (C E) Frames the entire graph
    :type frameGraph: boolean
    :param frameGraphNoRebuild: (C E) Specify that on zoom out the graph should not rebuild;
    for efficiency
    :type frameGraphNoRebuild: boolean
    :param frameHierarchy: (C E) Frames the hierarchy that contains the selected node
    :type frameHierarchy: boolean
    :param freeform: (C Q E) Enable freeform layout mode
    :type freeform: boolean
    :param fromAttr: (Q) Returns the name of the source attribute in a drag and drop connection,
    when called during processing of a drop
    :type fromAttr: string
    :param fromNode: (Q) Returns the name of the source node in a drag and drop connection,
    when called during processing of a drop
    :type fromNode: string
    :param getNodeList: (Q) Returns a string array that represents a list of all the nodes in
    the graph
    :type getNodeList: boolean
    :param getNodePosition: (Q) Returns the position of a specified node in x,y graph coords 
    This flag and its argument must be passed to the command before the -q flag (see exampl
    :type getNodePosition: string
    :param graphDescription: (C E) When used, return a description of the current graph
    :type graphDescription: boolean
    :param graphLayoutStyle: (C Q E) This flag is obsolete  The only supported graph layout
    style is "hierarchicalLayout"  Use of any other style will trigger a warning
    :type graphLayoutStyle: string
    :param graphType: (Q) Returns the type name of the current graph in the view (either DAG or
    DG)
    :type graphType: string
    :param heatMapDisplay: (Q E) Specify whether the heat map should be shown or not
    :type heatMapDisplay: boolean
    :param highlightConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its highlight list  Not all editors have a highlight list 
    F
    :type highlightConnection: string
    :param iconSize: (C Q E) Set or query the icon size for this hyper graph editor  The
    currently allowed icon sizes are "smallIcons", "mediumIcons", "largeIcons" and "superIcon
    :type iconSize: string
    :param image: (C Q E) Specify background image to be loaded from the project image
    directory
    :type image: string
    :param imageEnabled: (C Q E) Enable display of a loaded background image (Freeform DAG view
    or DG view)
    :type imageEnabled: boolean
    :param imageForContainer: (C Q E) Specify that the following flags work on selected
    containers instead of the whole image: -imageScale,-imagePosition, fitImageToWidth,
    -fitImageToHeig
    :type imageForContainer: boolean
    :param imagePosition: (C Q E) Position of the background image
    :type imagePosition: [float, float]
    :param imageScale: (C Q E) Uniform scale of the background image
    :type imageScale: float
    :param initializeScript: (C E) Script to call when the graph is initialized
    :type initializeScript: string
    :param isHotkeyTarget: (Q) For internal use
    :type isHotkeyTarget: boolean
    :param layout: (C E) Perform an automatic layout on the graph
    :type layout: boolean
    :param layoutSelected: (C E) This flag is obsolete  The only supported graph layout style
    is "hierarchicalLayout"  Use of any other style will trigger a warning
    :type layoutSelected: string
    :param limitGraphTraversal: (C E) Limit the graph traversal to a certain number of levels
    :type limitGraphTraversal: int
    :param lockMainConnection: (C E) Locks the current list of objects within the
    mainConnection, so that only those objects are displayed within the editor  Further changes
    to the origi
    :type lockMainConnection: boolean
    :param look: (C E) Look at a coordinate in the graph view
    :type look: [float, float]
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type mainListConnection: string
    :param mergeConnections: (C Q E) Merge groups of connections into 'fat' connections
    :type mergeConnections: boolean
    :param navigateHome: (C E) Navigate to the home (DAG) view
    :type navigateHome: boolean
    :param navup: (C E) Navigate up to the dependency graph containing the current selection 
    Shows upstream and downstream connections
    :type navup: boolean
    :param newInputConnection: (C E) Specify a new connection, input side
    :type newInputConnection: string
    :param newOutputConnection: (C E) Specify a new connection, output side
    :type newOutputConnection: string
    :param nextView: (C E) Changes the view to the next DAG view
    :type nextView: boolean
    :param nodeConnectCommand: (C E) Command to call when a node is connected
    :type nodeConnectCommand: string
    :param nodeDblClickCommand: (C E) Command to call when a node is double-clicked
    :type nodeDblClickCommand: string
    :param nodeDropCommand: (C E) Set the command to be called when a node is dropped in the
    hypergraph window
    :type nodeDropCommand: string
    :param nodeMenuCommand: (C E) Command to call when a node menu is activated
    :type nodeMenuCommand: string
    :param nodePressCommand: (C E) Set the command to be called when the user presses a mouse
    button while the cursor is over a node in the hypergraph window
    :type nodePressCommand: string
    :param nodeReleaseCommand: (C E) Set the command to be called when the user releases a
    mouse button while the cursor is over a node in the hypergraph window
    :type nodeReleaseCommand: string
    :param opaqueContainers: (Q E) Sets expanded container background opacity
    :type opaqueContainers: boolean
    :param orientation: (C Q E) Selects orientation style of graph: "horiz"|"vert"
    :type orientation: string
    :param panView: (C E) Pan the view to a new center
    :type panView: [float, float]
    :param panel: (C Q) Specifies the panel for this editor  By default if an editor is created
    in the create callback of a scripted panel it will belong to that panel  If a
    :type panel: string
    :param parent: (C Q E) Specifies the parent layout for this editor  This flag will only
    have an effect if the editor is currently un-parented
    :type parent: string
    :param popupMenuScript: (C E) Set the script to be called to register the popup menu with
    the control for this hypergraph  The script will be called with a string argument which g
    :type popupMenuScript: string
    :param previousView: (C E) Changes the view back to the previous DAG view
    :type previousView: boolean
    :param range: (C Q E) Limits the display of nodes to only those within the range  There are
    two float values expected, the first the lower threshold of the range and the s
    :type range: [float, float]
    :param rebuild: (C E) Rebuilds graph
    :type rebuild: boolean
    :param removeNode: (C E) Removes the node identified by string from the graph
    :type removeNode: string
    :param rename: (C E) Pops up text field over selected object for renaming
    :type rename: boolean
    :param resetFreeform: (C E) Resets freeform position on all nodes
    :type resetFreeform: boolean
    :param restoreBookmark: (C E) Restore the view corresponding to the bookmark
    :type restoreBookmark: string
    :param scrollUpDownNoZoom: (C E) Specify if we want to be in the scroll along y only with
    no free zooming mode  By default, hyper graph editor allows user to pan left and right
    :type scrollUpDownNoZoom: boolean
    :param selectionConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its own selection list  As the user selects things in this
    e
    :type selectionConnection: string
    :param setNodePosition: (C E) Sets the node identified by string to the (x,y) position in
    the window specified by the two floats  If the node is not in the graph than it will be a
    :type setNodePosition: [string, float, float]
    :param showCachedConnections: (C E) Specify whether cached connections should be shown
    :type showCachedConnections: boolean
    :param showConnectionFromSelected: (C Q E) Show the connects (constraints, expresions, and
    deformers - see showConstraints for example) leaving from selected nodes  This can be
    combined with s
    :type showConnectionFromSelected: boolean
    :param showConnectionToSelected: (C Q E) Show the connects (constraints, expresions, and
    deformers - see showConstraints for example) arriving at selected nodes  This can be
    combined with sh
    :type showConnectionToSelected: boolean
    :param showConstraintLabels: (C E) Specify whether constraint labels should be shown
    :type showConstraintLabels: boolean
    :param showConstraints: (C Q E) Show constraint relationships in the DAG
    :type showConstraints: boolean
    :param showDeformers: (C Q E) Show deformer or geometry filter relationships in the DAG
    :type showDeformers: boolean
    :param showExpressions: (C Q E) Show expression relationships in the DAG
    :type showExpressions: boolean
    :param showInvisible: (C Q E) Show invisible nodes in the DAG
    :type showInvisible: boolean
    :param showRelationships: (C Q E) Show relationship (message) connections
    :type showRelationships: boolean
    :param showShapes: (C Q E) Show shape nodes in the DAG
    :type showShapes: boolean
    :param showUnderworld: (C Q E) Show underworld graphs in the DAG
    :type showUnderworld: boolean
    :param stateString: (Q) Query only flag  Returns the MEL command that will create an editor
    to match the current editor state  The returned command string uses the string va
    :type stateString: boolean
    :param toAttr: (Q) Returns the name of the destination attribute in a drag and drop
    connection, when called during processing of a drop
    :type toAttr: string
    :param toNode: (Q) Returns the name of the destination node in a drag and drop connection,
    when called during processing of a drop
    :type toNode: string
    :param transitionFrames: (C Q E) Specify te number of transition frames for animate
    transitions
    :type transitionFrames: int
    :param unParent: (C E) Specifies that the editor should be removed from its layout  This
    cannot be used in query mode
    :type unParent: boolean
    :param unfold: (C E) Unfolds (expands) selected object
    :type unfold: boolean
    :param unfoldAll: (C E) Unfolds everything under selected object
    :type unfoldAll: boolean
    :param unfoldAllShapes: (C E) Unfolds all shapes
    :type unfoldAllShapes: boolean
    :param unfoldHidden: (C E) Unfolds all hidden objects
    :type unfoldHidden: boolean
    :param unlockMainConnection: (C E) Unlocks the mainConnection, effectively restoring the
    original mainConnection (if it is still available), and dynamic updates
    :type unlockMainConnection: boolean
    :param updateMainConnection: (C E) Causes a locked mainConnection to be updated from the
    orginal mainConnection, but preserves the lock state
    :type updateMainConnection: boolean
    :param updateNodeAdded: (C Q E) Update graph when a new node is added to the database
    :type updateNodeAdded: boolean
    :param updateSelection: (C Q E) Update selection state in the graph when the selection
    state of database changes
    :type updateSelection: boolean
    :param upstream: (C E) Show upstream dependency graph of selected node(s)
    :type upstream: boolean
    :param useDrawOverrideColor: (C E) Specify whether or not to use draw override coloring
    :type useDrawOverrideColor: boolean
    :param useFeedbackList: (C Q E) Use feedback or highlight list as the target selection when
    processing other hypergraph command-line options
    :type useFeedbackList: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param viewOption: (C Q E) Set or query the view option for this hyper graph editor  The
    currently allowed views are "asIcons" and "asList"
    :type viewOption: string
    :param visibility: (C E) Set the visible state of the selected node(s)
    :type visibility: boolean
    :param zoom: (C E) Specify the zoom factor for animating transitions
    :type zoom: float
    
    :returns: the name of the panel
    :rtype: string
    """
    pass


def setFluidAttr(*args, addValue=True, attribute="", clear=True, floatRandom=0.0,
                 floatValue=0.0, lowerFace=True, reset=True, vectorRandom=None,
                 vectorValue=None, xIndex=0, xvalue=True, yIndex=0, yvalue=True, zIndex=0,
                 zvalue=True, **kwargs):
    """
    Sets values of built-in fluid attributes such as density, velocity, etc., for individual
    grid cells or for all cells in the grid
    
    :param addValue: () Add specified value to attribute
    :type addValue: boolean
    :param attribute: (C) Specifies the fluid attribute for which to set values  Valid
    attributes are "velocity", "density", "fuel", "color", "falloff", and "temperature"
    :type attribute: string
    :param clear: () Set this attribute to 0
    :type clear: boolean
    :param floatRandom: () If this was a scalar (e.g  density) attribute, use a random value in
    +-VALUE If fv is specified, it is used as the base value and combined with the r
    :type floatRandom: float
    :param floatValue: () If this was a scalar (e.g  density) attribute, use this value
    :type floatValue: float
    :param lowerFace: (C) Only valid with "-at velocity"  Since velocity values are stored on
    the edges of each voxel and not at the center, using voxel based indices to set v
    :type lowerFace: boolean
    :param reset: () Set this attribute to default value
    :type reset: boolean
    :param vectorRandom: () If this was a vector (e.g  velocity) attribute, use a random value
    in +-VALUE If vv is specified, it is used as the base value and combined with the
    :type vectorRandom: [float, float, float]
    :param vectorValue: () If this was a vector (e.g  velocity) attribute, use this value
    :type vectorValue: [float, float, float]
    :param xIndex: (C) Only return values for cells with this X index
    :type xIndex: int
    :param xvalue: () Only set the first component of the vector-valued attribute specified by
    the "-at/attribute" flag
    :type xvalue: boolean
    :param yIndex: (C) Only return values for cells with this Y index
    :type yIndex: int
    :param yvalue: () Only set the second component of the vector-valued attribute specified by
    the "-at/attribute" flag
    :type yvalue: boolean
    :param zIndex: (C) Only return values for cells with this Z index
    :type zIndex: int
    :param zvalue: () Only set the third component of the vector-valued attribute specified by
    the "-at/attribute" flag
    :type zvalue: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def xgmCache(*args, **kwargs):
    """
    
    """
    pass


def convertTessellation(*args, allCameras=True, camera=None, **kwargs):
    """
    Command to translate the basic tessellation attributes to advanced  If a camera flag is
    specified the translation will be based on the distance the surface is from the camera  The
    closer the surface is to the camera the more triangles there will be in the tessellation 
    If the "-allCameras" flags is specified, the renderable camera closest to the su
    
    :param allCameras: (C) Specifies that all renderable cameras should be used in calculating
    the screen based tessellation
    :type allCameras: boolean
    :param camera: (C) Specifies the camera which should be used in calculating the screen
    based tessellation
    :type camera: name
    
    :returns: Success or Failure.
    :rtype: boolean
    """
    pass


def LockNormals(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def hwReflectionMap(*args, backTextureName="", bottomTextureName="", cubeMap=False,
                    decalMode=False, enable=False, frontTextureName="", leftTextureName="",
                    rightTextureName="", sphereMapTextureName="", topTextureName="", q=True,
                    query=True, e=True, edit=True, **kwargs):
    """
    This command creates a hwReflectionMap node for having reflection on textured surfaces that
    currently have their boolean attribute displayHWEnvironment set to true
    
    :param backTextureName: (Q) This flag specifies the file texture name for the back side of
    the cube  Default is none When queried, this flag returns a string
    :type backTextureName: string
    :param bottomTextureName: (Q) This flag specifies the file texture name for the bottom side
    of the cube  Default is none When queried, this flag returns a string
    :type bottomTextureName: string
    :param cubeMap: (Q) If on, the reflection of the textures is done using the cube mapping 
    Default is false  The reflection is done using sphere mapping  When queried, th
    :type cubeMap: boolean
    :param decalMode: (Q) If on, the reflection color replaces the surface shading  Default is
    false  The reflection is multiplied to the surface shading  When queried, this f
    :type decalMode: boolean
    :param enable: (Q) If on, enable the corresponding hwReflectionMap node  Default is false 
    When queried, this flag returns a boolean
    :type enable: boolean
    :param frontTextureName: (Q) This flag specifies the file texture name for the front side
    of the cube  Default is none When queried, this flag returns a string
    :type frontTextureName: string
    :param leftTextureName: (Q) This flag specifies the file texture name for the left side of
    the cube  Default is none When queried, this flag returns a string
    :type leftTextureName: string
    :param rightTextureName: (Q) This flag specifies the file texture name for the right side
    of the cube  Default is none When queried, this flag returns a string
    :type rightTextureName: string
    :param sphereMapTextureName: (Q) This flag specifies the file texture name for the sphere
    mapping option  Default is none When queried, this flag returns a string
    :type sphereMapTextureName: string
    :param topTextureName: (Q) This flag specifies the file texture name for the top side of
    the cube  Default is none When queried, this flag returns a string
    :type topTextureName: string
    
    :returns: (name of the created hwReflectionMap node)
    :rtype: string
    """
    pass


def XgmSplineCacheExportOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SwapBlendShape(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def LoadHIKEffectorSetState(*args, **kwargs):
    """
    
    """
    pass


def gravity(*args, attenuation=0.0, directionX=0.0, directionY=0.0, directionZ=0.0,
            magnitude=0.0, maxDistance=0.0, name="", perVertex=True, position=None,
            torusSectionRadius=0.0, volumeExclusion=True, volumeOffset=None, volumeShape="",
            volumeSweep=0.0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    For each listed object, the command creates a new field  The field has a shape which lives
    in the DAG and it has an associated dependency node  The field is added to the list of
    fields owned by the object  Use connectDynamic to cause the field to affect a dynamic
    object  Note that if more than one object is listed, a separate field is created for e
    
    :param attenuation: (Q E) Attentuation rate of field
    :type attenuation: float
    :param directionX: (Q E) X-component of direction
    :type directionX: float
    :param directionY: (Q E) Y-component of direction
    :type directionY: float
    :param directionZ: (Q E) Z-component of direction
    :type directionZ: float
    :param magnitude: (Q E) Strength of field
    :type magnitude: float
    :param maxDistance: (Q E) Maximum distance at which field is exerted  -1 indicates that the
    field has no maximum distance
    :type maxDistance: float
    :param name: (Q E) name of field
    :type name: string
    :param perVertex: (Q E) Per-vertex application  If this flag is set true, then each
    individual point (CV, particle, vertex,etc.) of the chosen object exerts an identical cop
    :type perVertex: boolean
    :param position: (Q E M) Position in space (x,y,z) where you want to place a gravity field 
    The gravity then emanates from this position in space rather than from an object
    :type position: [float, float, float]
    :param torusSectionRadius: (Q E) Section radius for a torus volume  Applies only to torus 
    Similar to the section radius in the torus modelling primitive
    :type torusSectionRadius: float
    :param volumeExclusion: (Q E) Volume exclusion of the field  If true, points outside the
    volume (defined by the volume shape attribute) are affected, If false, points inside the v
    :type volumeExclusion: boolean
    :param volumeOffset: (Q E) Volume offset of the field  Volume offset translates the field's
    volume by the specified amount from the actual field location  This is in the field'
    :type volumeOffset: [float, float, float]
    :param volumeShape: (Q E) Volume shape of the field  Sets/edits/queries the field's volume
    shape attribute  If set to any value other than "none", determines a 3-D volume with
    :type volumeShape: string
    :param volumeSweep: (Q E) Volume sweep of the field  Applies only to sphere, cone, cylinder,
    and torus  Similar effect to the sweep attribute in modelling
    :type volumeSweep: float
    
    :returns: Command result
    :rtype: string
    """
    pass


def NodeEditorSetLargeNodeSwatchSize(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OutlinerToggleConnected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def greasePencilHelper(*args, **kwargs):
    """
    
    """
    pass


def HypershadeCloseActiveTab(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def glRenderEditor(*args, control=True, defineTemplate="", docTag="", exists=True, filter="",
                   forceMainConnection="", highlightConnection="", lockMainConnection=True,
                   lookThru="", mainListConnection="", panel="", parent="",
                   selectionConnection="", stateString=True, unParent=True,
                   unlockMainConnection=True, updateMainConnection=True, useTemplate="",
                   viewCameraName=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Create a glRender view  This is a special view used for hardware rendering  This command is
    used to create and reparent the view as needed to support panels  See the glRender command
    for controlling the specific behavior of the hardware rendering
    
    :param control: (Q) Query only  Returns the top level control for this editor  Usually used
    for getting a parent to attach popup menus  Caution: It is possible for an ed
    :type control: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Attaches a tag to the editor
    :type docTag: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param filter: (C Q E) Specifies the name of an itemFilter object to be used with this
    editor  This filters the information coming onto the main list of the editor
    :type filter: string
    :param forceMainConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type forceMainConnection: string
    :param highlightConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its highlight list  Not all editors have a highlight list 
    F
    :type highlightConnection: string
    :param lockMainConnection: (C E) Locks the current list of objects within the
    mainConnection, so that only those objects are displayed within the editor  Further changes
    to the origi
    :type lockMainConnection: boolean
    :param lookThru: (C Q E) Specify which camera the glRender view should be using
    :type lookThru: string
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type mainListConnection: string
    :param panel: (C Q) Specifies the panel for this editor  By default if an editor is created
    in the create callback of a scripted panel it will belong to that panel  If a
    :type panel: string
    :param parent: (C Q E) Specifies the parent layout for this editor  This flag will only
    have an effect if the editor is currently un-parented
    :type parent: string
    :param selectionConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its own selection list  As the user selects things in this
    e
    :type selectionConnection: string
    :param stateString: (Q) Query only flag  Returns the MEL command that will create an editor
    to match the current editor state  The returned command string uses the string va
    :type stateString: boolean
    :param unParent: (C E) Specifies that the editor should be removed from its layout  This
    cannot be used in query mode
    :type unParent: boolean
    :param unlockMainConnection: (C E) Unlocks the mainConnection, effectively restoring the
    original mainConnection (if it is still available), and dynamic updates
    :type unlockMainConnection: boolean
    :param updateMainConnection: (C E) Causes a locked mainConnection to be updated from the
    orginal mainConnection, but preserves the lock state
    :type updateMainConnection: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param viewCameraName: (Q) Returns the name of the current camera used by the glRenderPanel
     This is a query only flag
    :type viewCameraName: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def loadUI(*args, listTypes=True, uiFile="", uiString="", verbose=True, workingDirectory="",
           **kwargs):
    """
    loadUI command allows loading of a user interface created in Trolltech Qt Designer
    
    :param listTypes: (C) Returns the list of recognized UI types and their associated Maya
    command
    :type listTypes: boolean
    :param uiFile: (C) Full path to a user interface file to load
    :type uiFile: string
    :param uiString: (C) Load UI from a formated string
    :type uiString: string
    :param verbose: (C) Extra information about created controls will be printed
    :type verbose: boolean
    :param workingDirectory: (C) Sets the working directory, the loader looks for resources
    such as icons and resouce files in paths relative to this directory
    :type workingDirectory: string
    
    :returns: Full path name to the root control.
    :rtype: string
    """
    pass


def HotkeyPreferencesWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GraphDelete(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def setInputDeviceMapping(*args, absolute=True, axis="", device="", offset=0.0, relative=True,
                          scale=0.0, view=True, world=True, **kwargs):
    """
    The command sets a scale and offset for all attachments made to a specified device axis 
    Any attachment made to a mapped device axis will have the scale and offset applied to its
    values   The value from the device is multiplied by the scale and the offset is added to
    this product  With an absolute mapping, the attached attribute gets the resulting 
    
    :param absolute: (C) report absolute axis values
    :type absolute: boolean
    :param axis: (C M) specify the axis to map
    :type axis: string
    :param device: (C) specify which device to map
    :type device: string
    :param offset: (C) specify the axis offset value
    :type offset: float
    :param relative: (C) report the change in axis value since the last sample
    :type relative: boolean
    :param scale: (C) specify the axis scale value
    :type scale: float
    :param view: (C) translate the device coordinates into the coordinates of the active
    camera
    :type view: boolean
    :param world: (C) translate the device coordinates into world space coordinates
    :type world: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def FBXGetTakeComment(*args, **kwargs):
    """
    
    """
    pass


def FBIKReachKeyingOptionIK(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectAllNURBSCurves(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TexSewActivateBrushSize(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddCurvesToHairSystem(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportBakeComplexStep(*args, **kwargs):
    """
    
    """
    pass


def XgmSplineCacheEnableSelectedCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def textureWindow(*args, activeSelectionOnTop=True, axesColor=None, backFacingColor=None,
                  capture="", captureSequenceNumber=0, changeCommand=None, checkerColor1=None,
                  checkerColor2=None, checkerColorMode=0, checkerDensity=0,
                  checkerDrawTileLabels=True, checkerGradient1=None, checkerGradient2=None,
                  checkerGradientOverlay=True, checkerTileLabelColor=None, clearImage=True,
                  cmEnabled=True, control=True, defineTemplate="", displayAxes=True,
                  displayCheckered=True, displayDistortion=True, displayDivisionLines=True,
                  displayGridLines=True, displayImage=0, displayIsolateSelectHUD=True,
                  displayLabels=True, displayOverlappingUVCountHUD=True,
                  displayPreselection=True, displayReversedUVCountHUD=True,
                  displaySolidMap=True, displayStyle="", displayTextureBorder=True,
                  displayUVShellCountHUD=True, displayUVStatisticsHUD=True,
                  displayUsedPercentageHUD=True, distortionAlpha=0.0, distortionPerObject=True,
                  divisions=0, docTag="", doubleBuffer=True, drawAxis=True, drawSubregions=True,
                  exists=True, exposure=0.0, filter="", forceMainConnection="",
                  forceRebake=True, frameAll=True, frameSelected=True, frontFacingColor=None,
                  gamma=0.0, gridLinesColor=None, gridNumbersColor=None, highlightConnection="",
                  imageBaseColor=None, imageDim=True, imageDisplay=True, imageNames=True,
                  imageNumber=0, imagePixelSnap=True, imageRatio=True, imageRatioValue=0.0,
                  imageSize=True, imageTileRange=None, imageUnfiltered=True, internalFaces=True,
                  labelPosition="", loadImage="", lockMainConnection=True,
                  mainListConnection="", maxResolution=0, multiColorAlpha=0.0, nbImages=True,
                  nextView=True, numUvSets=True, numberOfImages=0, numberOfTextures=0, panel="",
                  parent="", previousView=True, realSize=True, refresh=True, relatedFaces=True,
                  removeAllImages=True, removeImage=True, rendererString="", reset=True,
                  saveImage=True, scaleBlue=0.0, scaleGreen=0.0, scaleRed=0.0,
                  selectInternalFaces=True, selectRelatedFaces=True, selectionConnection="",
                  setUvSet=0, singleBuffer=True, size=0.0, solidMap3dView=True,
                  solidMapColorSeed=0, solidMapPerShell=True, spacing=0.0, stateString=True,
                  style=0, subdivisionLinesColor=None, textureBorder3dView=True,
                  textureBorderColor=None, textureBorderWidth=0, textureNames=True,
                  textureNumber=0, tileLabels=True, tileLinesColor=None, toggle=True,
                  toggleExposure=True, toggleGamma=True, unParent=True,
                  unlockMainConnection=True, updateMainConnection=True, useFaceGroup=True,
                  useTemplate="", usedPercentageHUDRange=None, uvSets=True, viewPortImage=True,
                  viewTransformName="", wireframeComponentColor=None, wireframeObjectColor=None,
                  writeImage="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command is used to create a UV Editor and to query or edit the texture editor settings
      The UV Editor displays texture mapped polygon objects in 2D texture space  Only active
    objects are visible in this window   The UV Editor has the ability to display two types of
    images  The Texture Image is a visualisation of the current texture and associ
    
    :param activeSelectionOnTop: (C Q E) Display the solid map / distortion of active selection
    on top of others
    :type activeSelectionOnTop: boolean
    :param axesColor: (C Q E) The color of axes, default is 0.0 0.0 1.0
    :type axesColor: [float, float, float]
    :param backFacingColor: (C Q E) Sets or queries the RGBA back facing color
    :type backFacingColor: [float, float, float, float]
    :param capture: (E) Perform an one-time capture of the viewport to the named image file on
    disk
    :type capture: string
    :param captureSequenceNumber: (E) When a number greater or equal to 0 is specified each
    subsequent refresh will save an image file to disk if the capture flag has been enabled 
    The na
    :type captureSequenceNumber: int
    :param changeCommand: (C Q E) Parameters: First string: command Second string: editorName
    Third string: editorCmd Fourth string: updateFunc Call the command when something changes
    :type changeCommand: [string, string, string, string]
    :param checkerColor1: (C Q E) Sets the first color of the checker and identification
    pattern, when color mode is 2-colors
    :type checkerColor1: [float, float, float]
    :param checkerColor2: (C Q E) Sets the second color of the checker and identification
    pattern, when color mode is 2-colors
    :type checkerColor2: [float, float, float]
    :param checkerColorMode: (C Q E) Sets the color mode of the checker and identification
    pattern  0: multi-colors; 1: 2-colors;
    :type checkerColorMode: int
    :param checkerDensity: (C Q E) Sets the density of the checker and identification pattern
    :type checkerDensity: int
    :param checkerDrawTileLabels: (C Q E) Toggles the checker tile label display
    :type checkerDrawTileLabels: boolean
    :param checkerGradient1: (C Q E) Sets the first gradient of the checker and identification
    pattern, when color mode is 2-colors
    :type checkerGradient1: [float, float, float]
    :param checkerGradient2: (C Q E) Sets the second gradient of the checker and identification
    pattern, when color mode is 2-colors
    :type checkerGradient2: [float, float, float]
    :param checkerGradientOverlay: (C Q E) Toggle application of the gradient
    :type checkerGradientOverlay: boolean
    :param checkerTileLabelColor: (C Q E) Sets the checker tile label color
    :type checkerTileLabelColor: [float, float, float]
    :param clearImage: (E) Clears the current Editor Image
    :type clearImage: boolean
    :param cmEnabled: (Q E) Turn on or off applying color management in the editor  If set, the
    color management configuration set in the current editor is used
    :type cmEnabled: boolean
    :param control: (Q) Query only  Returns the top level control for this editor  Usually used
    for getting a parent to attach popup menus  Caution: It is possible for an ed
    :type control: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param displayAxes: (Q E) Specify true to display the grid axes
    :type displayAxes: boolean
    :param displayCheckered: (C Q E) Display a unique checker and identification pattern for
    each UV tiles
    :type displayCheckered: boolean
    :param displayDistortion: (C Q E) Display the layout in shaded colors to indentify areas
    with stretched/squashed UVs
    :type displayDistortion: boolean
    :param displayDivisionLines: (Q E) Specify true to display the subdivision lines between
    grid lines
    :type displayDivisionLines: boolean
    :param displayGridLines: (Q E) Specify true to display the grid lines
    :type displayGridLines: boolean
    :param displayImage: (Q E) Set a particular image in the Editor Image Stack as the current
    Editor Image  Images are added to the Editor Image Stack using the "si/saveImage" fla
    :type displayImage: int
    :param displayIsolateSelectHUD: (C Q E) Show heads-up display of isolate selection
    :type displayIsolateSelectHUD: boolean
    :param displayLabels: (Q E) Specify true to display the grid line numeric labels
    :type displayLabels: boolean
    :param displayOverlappingUVCountHUD: (C Q E) Show heads-up display of overlapping UV count,
    as a part UV Statistics HUD
    :type displayOverlappingUVCountHUD: boolean
    :param displayPreselection: (C Q E) Toggles the pre-selection display
    :type displayPreselection: boolean
    :param displayReversedUVCountHUD: (C Q E) Show heads-up display of UV Shells, as a part UV
    Statistics HUD
    :type displayReversedUVCountHUD: boolean
    :param displaySolidMap: (C Q E) Display a solid overlay for the active texture map
    :type displaySolidMap: boolean
    :param displayStyle: (C Q E) Set the mode to display the image  Valid values are: "color"
    to display the basic RGB image "mask" to display the mask channel "lum" to display the l
    :type displayStyle: string
    :param displayTextureBorder: (C Q E) Toggles the texture borders display
    :type displayTextureBorder: boolean
    :param displayUVShellCountHUD: (C Q E) Show heads-up display of UV Shell count, as a part
    UV Statistics HUD
    :type displayUVShellCountHUD: boolean
    :param displayUVStatisticsHUD: (C Q E) Show heads-up display of UV Statistics
    :type displayUVStatisticsHUD: boolean
    :param displayUsedPercentageHUD: (C Q E) Show heads-up display of used UV space percentage,
    as a part UV Statistics HUD
    :type displayUsedPercentageHUD: boolean
    :param distortionAlpha: (C Q E) Set or query the distortion display alpha
    :type distortionAlpha: float
    :param distortionPerObject: (C Q E) Toggles the per-object distortion display
    :type distortionPerObject: boolean
    :param divisions: (C Q E) Sets the number of subdivisions between main grid lines
    :type divisions: int
    :param docTag: (C Q E) Attaches a tag to the editor
    :type docTag: string
    :param doubleBuffer: (C Q E) Set the display in double buffer mode
    :type doubleBuffer: boolean
    :param drawAxis: (C Q E) Set or query whether the axis will be drawn
    :type drawAxis: boolean
    :param drawSubregions: (C Q E) Toggles the subregion display
    :type drawSubregions: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param exposure: (Q E) The exposure value used by the color management of the current
    editor
    :type exposure: float
    :param filter: (C Q E) Specifies the name of an itemFilter object to be used with this
    editor  This filters the information coming onto the main list of the editor
    :type filter: string
    :param forceMainConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type forceMainConnection: string
    :param forceRebake: (C E) Forces the current cache texture to refresh
    :type forceRebake: boolean
    :param frameAll: (C) This will zoom on the whole scene
    :type frameAll: boolean
    :param frameSelected: (C) This will zoom on the currently selected objects
    :type frameSelected: boolean
    :param frontFacingColor: (C Q E) Sets or queries the RGBA front facing color
    :type frontFacingColor: [float, float, float, float]
    :param gamma: (Q E) The gamma value used by the color management of the current editor
    :type gamma: float
    :param gridLinesColor: (C Q E) The color of grid lines, default is 0.325 0.325 0.325
    :type gridLinesColor: [float, float, float]
    :param gridNumbersColor: (C Q E) The color of grid numbers, default is 0.2 0.2 0.2
    :type gridNumbersColor: [float, float, float]
    :param highlightConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its highlight list  Not all editors have a highlight list 
    F
    :type highlightConnection: string
    :param imageBaseColor: (C Q E) The base color of the image, default is white 1.0 1.0 1.0
    :type imageBaseColor: [float, float, float]
    :param imageDim: (C Q E) Toggles the image dimming
    :type imageDim: boolean
    :param imageDisplay: (Q E) Toggles the Texture Image display
    :type imageDisplay: boolean
    :param imageNames: (Q) List image names for all Texture Images available for display, if
    any
    :type imageNames: boolean
    :param imageNumber: (Q E) Sets the number of Texture Images to display  This depends on the
    number of textures corresponding to the current selection  If there are N textures,
    :type imageNumber: int
    :param imagePixelSnap: (Q E) Sets a mode so that UV transformations in the UV Texture
    Editor will cause UV values to snap to image pixel corners  Which pixels are used depends
    on
    :type imagePixelSnap: boolean
    :param imageRatio: (Q E) Sets the window to draw using the Texture Image's height versus
    width ratio  If the width is greater than the height, then the width is set to be 1 "
    :type imageRatio: boolean
    :param imageRatioValue: (Q) Query current image ratio value in UV Editor
    :type imageRatioValue: float
    :param imageSize: (Q) Returns the size of the Texture Image currently being displayed  The
    values returned are width followed by height  Image size can only be queried
    :type imageSize: boolean
    :param imageTileRange: (Q E) Sets the UV range of the display  The 4 values specify the
    minimum U, V and maximum U, V in that order  When viewing a texture image, these values af
    :type imageTileRange: [float, float, float, float]
    :param imageUnfiltered: (Q E) Sets the Texture Image to draw unfiltered  The image will
    appear "pixelated" when the display resolution is higher than the resolution of the image
    :type imageUnfiltered: boolean
    :param internalFaces: (C Q E) Display contained faces by the selected components
    :type internalFaces: boolean
    :param labelPosition: (Q E) The position of the grid's numeric labels  Valid values are
    "axis" and "edge"
    :type labelPosition: string
    :param loadImage: (E) load an image from disk and set it as the current Editor Image
    :type loadImage: string
    :param lockMainConnection: (C E) Locks the current list of objects within the
    mainConnection, so that only those objects are displayed within the editor  Further changes
    to the origi
    :type lockMainConnection: boolean
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type mainListConnection: string
    :param maxResolution: (C Q E) This flag will set the current cached texture's maximum
    resolution
    :type maxResolution: int
    :param multiColorAlpha: (C Q E) Sets the multi-color alpha of shaded UVs
    :type multiColorAlpha: float
    :param nbImages: (Q) returns the number of images
    :type nbImages: boolean
    :param nextView: (E) Switches to the next view
    :type nextView: boolean
    :param numUvSets: (C Q E) This flag will return the number of UV sets for selected objects
    in the texture window
    :type numUvSets: boolean
    :param numberOfImages: (Q) The number of Texture Images currently available  for display
    :type numberOfImages: int
    :param numberOfTextures: (Q) The number of textures currently available  for display
    :type numberOfTextures: int
    :param panel: (C Q) Specifies the panel for this editor  By default if an editor is created
    in the create callback of a scripted panel it will belong to that panel  If a
    :type panel: string
    :param parent: (C Q E) Specifies the parent layout for this editor  This flag will only
    have an effect if the editor is currently un-parented
    :type parent: string
    :param previousView: (E) Switches to the previous view
    :type previousView: boolean
    :param realSize: (C) This will display the image with the size of the internal buffer 
    Note: This argument no long has any affect on image display
    :type realSize: boolean
    :param refresh: (E) requests a refresh of the current Editor Image
    :type refresh: boolean
    :param relatedFaces: (C Q E) Display connected faces by the selected components
    :type relatedFaces: boolean
    :param removeAllImages: (E) remove all the Editor Images from the Editor Image Stack
    :type removeAllImages: boolean
    :param removeImage: (E) remove the current Editor Image from the Editor Image Stack
    :type removeImage: boolean
    :param rendererString: (C Q E) Set or query the string describing the current renderer
    :type rendererString: string
    :param reset: (C) Resets the ground plane to its default values
    :type reset: boolean
    :param saveImage: (E) save the current Editor Image to memory  Saved Editor Images are
    stored in an Editor Image Stack  The most recently saved image is stored in position
    :type saveImage: boolean
    :param scaleBlue: (C Q E) Define the scaling factor for the blue component in the View  The
    default value is 1 and can be between -1000 to +1000
    :type scaleBlue: float
    :param scaleGreen: (C Q E) Define the scaling factor for the green component in the View 
    The default value is 1 and can be between -1000 to +1000
    :type scaleGreen: float
    :param scaleRed: (C Q E) Define the scaling factor for the red component in the View  The
    default value is 1 and can be between -1000 to +1000
    :type scaleRed: float
    :param selectInternalFaces: (C Q E) Add to selectionList the faces which are contained by
    (internal to) selected components
    :type selectInternalFaces: boolean
    :param selectRelatedFaces: (C) Add to selectionList the faces which are connected to
    (non-internally related to) selected components
    :type selectRelatedFaces: boolean
    :param selectionConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its own selection list  As the user selects things in this
    e
    :type selectionConnection: string
    :param setUvSet: (C E) This flag will set the current UV set on one given selected object
    within the texture window
    :type setUvSet: int
    :param singleBuffer: (C Q E) Set the display in single buffer mode
    :type singleBuffer: boolean
    :param size: (C Q E) Sets the size of the grid
    :type size: float
    :param solidMap3dView: (C Q E) Display a solid overlay for the active texture map in 3D
    viewport
    :type solidMap3dView: boolean
    :param solidMapColorSeed: (C Q E) Sets the multi-color seed of shaded UVs
    :type solidMapColorSeed: int
    :param solidMapPerShell: (C Q E) Display a solid overlay with a random color per shell
    :type solidMapPerShell: boolean
    :param spacing: (C) Sets the spacing between main grid lines
    :type spacing: float
    :param stateString: (Q) Query only flag  Returns the MEL command that will create an editor
    to match the current editor state  The returned command string uses the string va
    :type stateString: boolean
    :param style: (Q E) This flag is obsolete and should not be used
    :type style: int
    :param subdivisionLinesColor: (C Q E) The color of subdivision lines, default is 0.25 0.25
    0.25
    :type subdivisionLinesColor: [float, float, float]
    :param textureBorder3dView: (C Q E) Toggles the texture borders display in 3d viewport
    :type textureBorder3dView: boolean
    :param textureBorderColor: (C Q E) Sets the display color of texture border
    :type textureBorderColor: [float, float, float]
    :param textureBorderWidth: (C Q E) Set the display edge width of texture border
    :type textureBorderWidth: int
    :param textureNames: (Q) Texture names for all Texture Images available for display, if
    any
    :type textureNames: boolean
    :param textureNumber: (Q E) Sets the number of textures to display This depends on the
    number of textures corresponding to the current selection  If there are N textures, then t
    :type textureNumber: int
    :param tileLabels: (C Q E) Toggles the texture tile label display
    :type tileLabels: boolean
    :param tileLinesColor: (C Q E) The color of tile lines, default is 0.0 0.0 0.0
    :type tileLinesColor: [float, float, float]
    :param toggle: (C Q E) Toggles the ground plane display
    :type toggle: boolean
    :param toggleExposure: (E) Toggles between the current and the default exposure value of
    the editor
    :type toggleExposure: boolean
    :param toggleGamma: (E) Toggles between the current and the default gamma value of the
    editor
    :type toggleGamma: boolean
    :param unParent: (C E) Specifies that the editor should be removed from its layout  This
    cannot be used in query mode
    :type unParent: boolean
    :param unlockMainConnection: (C E) Unlocks the mainConnection, effectively restoring the
    original mainConnection (if it is still available), and dynamic updates
    :type unlockMainConnection: boolean
    :param updateMainConnection: (C E) Causes a locked mainConnection to be updated from the
    orginal mainConnection, but preserves the lock state
    :type updateMainConnection: boolean
    :param useFaceGroup: (C Q E) Display faces that are associated with the groupId that is set
    on the mesh node that is drawn  (The attribute "displayFacesWithGroupId")
    :type useFaceGroup: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param usedPercentageHUDRange: (C Q E) Sets the range when calculating used UV space
    percentage  The 4 values specify the minimum U, V and maximum U, V in that order., default
    is 0 0 1 1
    :type usedPercentageHUDRange: [float, float, float, float]
    :param uvSets: (C Q E) This flag will return strings containing UV set and object name
    pairs for selected objects in the texture window  The syntax of each pair is "objectN
    :type uvSets: boolean
    :param viewPortImage: (C E) Toggles the view port/ caching Texture Images
    :type viewPortImage: boolean
    :param viewTransformName: (Q E) Sets the view pipeline to be applied if color management is
    enabled in the current editor
    :type viewTransformName: string
    :param wireframeComponentColor: (C Q E) Sets or queries the RGBA component wireframe color
    :type wireframeComponentColor: [float, float, float, float]
    :param wireframeObjectColor: (C Q E) Sets or queries the RGBA object wireframe color
    :type wireframeObjectColor: [float, float, float, float]
    :param writeImage: (E) write the current Editor Image to disk
    :type writeImage: string
    
    :returns: The name of the texture window
    :rtype: string
    """
    pass


def getMetadata(*args, dataType=True, listChannelNames=True, listMemberNames=True,
                listStreamNames=True, memberName="", channelName="", channelType="",
                endIndex="", index="", indexType="", scene=True, startIndex="", streamName="",
                **kwargs):
    """
    This command is used to retrieve the values of metadata elements from a node or scene  It
    is restricted to returning a single structure member at a time  For convenience the detail
    required is only enough to find a single Member of a single Structure on a single metadata
    Channel   In the simplest case if there is a single Stream on one metadata Cha
    
    :param dataType: (C) Used with the flag 'streamName' and 'memberName' to query the dataType
    of the specfied member
    :type dataType: boolean
    :param listChannelNames: (C) Query the channel names on the shape  This flag can be used
    with some flags to filter the results  It can be used with the flag 'streamName' to get t
    :type listChannelNames: boolean
    :param listMemberNames: (C) Query the member names on the shape  This flag can be used with
    some flags to filter the results  It can be used with 'streamName' to get the member
    :type listMemberNames: boolean
    :param listStreamNames: (C) Query the stream names on the shape  This flag can be used with
    some flags to filter the results  It can be used with the flag 'channelName' to get t
    :type listStreamNames: boolean
    :param memberName: (C) Name of the Structure member being retrieved  The names of the
    members are set up in the Structure definition, either through the description passed
    :type memberName: string
    :param channelName: (C Q) Filter the metadata selection to only recognize metadata
    belonging to the specified named Channel (e.g  "vertex")  This flag is ignored if the
    compon
    :type channelName: string
    :param channelType: (C Q) Obsolete - use the 'channelName' flag instead  In query mode,
    this flag can accept a value
    :type channelType: string
    :param endIndex: (C) The metadata is stored in a Stream, which is an indexed list  If you
    have mesh components selected then the metadata indices are implicit in the list
    :type endIndex: string
    :param index: (C Q M) In the typical case metadata is indexed using a simple integer value 
    Certain types of data may use other index types  e.g  a "vertexFace" component
    :type index: string
    :param indexType: (C Q) Name of the index type the new Channel should be using  If not
    specified this defaults to a simple integer index  Of the native types only a mesh "ve
    :type indexType: string
    :param scene: (C Q) Use this flag when you want to add metadata to the scene as a whole
    rather than to any individual nodes  If you use this flag and have nodes selected
    :type scene: boolean
    :param startIndex: (C) The metadata is stored in a Stream, which is an indexed list  If you
    have mesh components selected then the metadata indices are implicit in the list
    :type startIndex: string
    :param streamName: (C Q) Name of the metadata Stream  Depending on context it could be the
    name of a Stream to be created, or the name of the Stream to pass through the filte
    :type streamName: string
    
    :returns: List of integer values from the metadata member
    :rtype: int[]
    """
    pass


def ShowLastHidden(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dragAttrContext(*args, connectTo=None, exists=True, history=True, image1="", image2="",
                    image3="", name="", reset=True, q=True, query=True, e=True, edit=True,
                    **kwargs):
    """
    The dragAttrContext allows a user to manipulate the attributes of an object by using a
    virtual slider within the viewport  The virtual slider is used by dragging in a viewport
    with the middle mouse button  The speed at which the attributes are changed can be
    controlled by holding down the Ctrl key to slow it down and the Shift key to speed it up
    
    :param connectTo: (C Q E M) Specifies an attribute to which to connect the context  This is
    a multi-use flag, but all attributes used must be from one object
    :type connectTo: name
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param reset: (C E) Resets the list of attributes to which the context is connected
    :type reset: boolean
    
    :returns: The name of the context created
    :rtype: string
    """
    pass


def findType(*args, deep=True, exact=True, forward=True, type="", **kwargs):
    """
    The findType command is used to search through a dependency subgraph on a certain node to
    find all nodes of the given type  The search can go either upstream (input connections) or
    downstream (output connections)  The plug/attribute dependencies are not taken into account
    when searching for matching nodes, only the connections
    
    :param deep: (C) Find all nodes of the given type instead of just the first
    :type deep: boolean
    :param exact: (C) Match node types exactly instead of any in a node hierarchy
    :type exact: boolean
    :param forward: (C) Look forwards (downstream) through the graph rather than backwards
    (upstream) for matching nodes
    :type forward: boolean
    :param type: (C) Type of node to look for (e.g  "transform")  This flag is mandatory
    :type type: string
    
    :returns: The list of node(s) of the requested type connected to the given node(s)
    :rtype: string[]
    """
    pass


def DuplicateCurve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def bezierAnchorState(*args, even=True, smooth=True, **kwargs):
    """
    The bezierAnchorState command provides an easy interface to modify anchor states:  -
    Smooth/Broken anchor tangents - Even/Uneven weighted anchor tangents
    
    :param even: (C) Sets selected anchors (or attached tangent handles) to even weighting when
    true, uneven otherwise
    :type even: boolean
    :param smooth: (C) Sets selected anchors (or attached tangent handles) to smooth when true,
    broken otherwise
    :type smooth: boolean
    
    :returns: (number of modified anchors)
    :rtype: int
    """
    pass


def dR_connectPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def helpLine(*args, annotation="", backgroundColor=None, defineTemplate="", docTag="",
             dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
             enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
             highlightColor=None, isObscured=True, manage=True, noBackground=True,
             numberOfPopupMenus=True, parent="", popupMenuArray=True, preventOverride=True,
             statusBarMessage="", useTemplate="", visible=True, visibleChangeCommand=None,
             width=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a help line where tool help/hints are shown
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name of control.
    :rtype: string
    """
    pass


def CopyMeshAttributes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorAddOnNodeCreate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteHistory(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateCameraAimUpOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeTestTextureOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def removeMultiInstance(*args, allChildren=True, b=True, **kwargs):
    """
    Removes a particular instance of a multiElement  This is only useful for input attributes
    since outputs will get regenerated the next time the node gets executed  This command will
    remove the instance and optionally break all incoming and outgoing connections to that
    instance  If the connections are not broken (with the -b true) flag, then the comm
    
    :param allChildren: (C) If the argument is true, remove all children of the multi parent
    :type allChildren: boolean
    :param b: (C) If the argument is true, all connections to the attribute will be broken
    before the element is removed  If false, then the command will fail if the e
    :type b: boolean
    
    :returns: (true if the instance was removed, false if something went wrong,
    like the
    attribute is connected but -b true was not specified)
    :rtype: boolean
    """
    pass


def dR_alwaysOnTopTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CutUVs3D(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorCreateAudioTracksAtEnd(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def callbacks(*args, addCallback=None, clearAllCallbacks=True, clearCallbacks=True,
              describeHooks=True, dumpCallbacks=True, executeCallbacks=True, hook="",
              listCallbacks=True, owner="", removeCallback=None, **kwargs):
    """
    This command allows you to add callbacks at key times during UI creation so that the Maya
    UI can be extended  The list of standard Maya hooks, as well as the arguments which will be
    passed to the callback based on the context are enumerated in the describeHooks section
    below  Custom hooks can also be added if third parties want to add UI extensibil
    
    :param addCallback: (C) Add a callback for the specified hook  The owner must also be
    specified when adding callbacks
    :type addCallback: script
    :param clearAllCallbacks: (C) Clear all the callbacks for all hooks and owners  This is
    generally only used during plugin development and testing as it affects all callbacks
    regis
    :type clearAllCallbacks: boolean
    :param clearCallbacks: (C) Clear all the callbacks for the specified owner  If a hook is
    specified, only the callbacks for that hook and owner will be cleared
    :type clearCallbacks: boolean
    :param describeHooks: (C) List the standard Maya hooks  Below is a list of the hooks and
    their associated arguments and return values  Custom hooks added by third parties are
    :type describeHooks: boolean
    :param dumpCallbacks: (C) Gives a list of all the registered callbacks for all hooks and
    owners  Can be useful for debugging
    :type dumpCallbacks: boolean
    :param executeCallbacks: (C) Execute the callbacks for the specified hook, passing the
    extra arguments to each callback when it is executed  Returns an array (MEL) or list
    (Pytho
    :type executeCallbacks: boolean
    :param hook: (C) The name of the hook for which the callback should be registered
    :type hook: string
    :param listCallbacks: (C) Get the list of callbacks for the specified hook name  If the
    owner is specified, only callbacks for the specified hook and owner will be listed
    :type listCallbacks: boolean
    :param owner: (C) The name of the owner registering the callback  This is typically a
    plugin name
    :type owner: string
    :param removeCallback: (C) Remove an existing callback for the specified hook name  The
    owner must also be specified when removing a callback
    :type removeCallback: script
    
    :returns: Command result
    :rtype: string[]
    """
    pass


def PointOnCurve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorExportSelectionOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Turbulence(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PasteKeys(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyProjectCurve(*args, addUnderTransform=True, caching=True, direction=None,
                     directionX=0.0, directionY=0.0, directionZ=0.0, nodeState=0, tolerance=0.0,
                     q=True, query=True, e=True, edit=True, **kwargs):
    """
    The polyProjectCurve command creates curves by projecting a selected curve onto a selected
    poly mesh  The direction of projection will be the current view direction unless the
    direction vector is specified with the -direction/-d flag
    
    :param addUnderTransform: (C) True if the resulting curve should be added under the source
    transform
    :type addUnderTransform: boolean
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param direction: (C Q E) Direction of projection
    :type direction: [float, float, float]
    :param directionX: (C Q E) X direction of projection
    :type directionX: float
    :param directionY: (C Q E) Y direction of projection
    :type directionY: float
    :param directionZ: (C Q E) Z direction of projection
    :type directionZ: float
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param tolerance: (C Q E) Tolerance to fit to
    :type tolerance: float
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def PaintEffectPanelDeactivate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def moveVertexAlongDirection(*args, direction=None, magnitude=0.0, normalDirection=0.0,
                             uDirection=0.0, uvNormalDirection=None, vDirection=0.0, **kwargs):
    """
    The command moves the selected vertex ( control vertex ) in the specified unit direction by
    the given magnitude  The vertex(ices) may also be moved in the direction of unit normal (
    -n flag )  For NURBS surface vertices the direction of movement could also be either in
    tangent along U or tangent along V  The flags -n, -u, -v and -d are mutually exc
    
    :param direction: (C M) move the vertex along the direction as specified  The direction is
    normalized
    :type direction: [float, float, float]
    :param magnitude: (C M) move by the specified magnitude in the direction vector
    :type magnitude: float
    :param normalDirection: (C M) move components in the direction of normal by the given
    magnitude at the respective components  The normal is 'normalized'
    :type normalDirection: float
    :param uDirection: (C M) move components in the direction of tangent along U at the
    respective components where appropriate  The flag is ignored for polygons, NURBS curves  T
    :type uDirection: float
    :param uvNormalDirection: (C M) move in the triad space [u,v,n] at the respective
    components by the specified displacements  The flag is ignored for polygons, NURBS curves
    :type uvNormalDirection: [float, float, float]
    :param vDirection: (C M) move components in the direction of tangent along V at the
    respective components where appropriate  The flag is ignored for polygons, NURBS curves
    :type vDirection: float
    
    :returns: 
    :rtype: None
    """
    pass


def XgmSetPlaceBrushToolOption(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def flushUndo(*args, **kwargs):
    """
    Removes everything from the undo queue, freeing up memory
    
    
    :returns: 
    :rtype: None
    """
    pass


def XgGuideTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def subdToBlind(*args, absolutePosition=True, includeCreases=False, includeZeroOffsets=False,
                **kwargs):
    """
    The subdivision surface hierarchical edits will get copied into blind data on the given
    polygon  The polygon face count and topology must match the subdivision surface base mesh
    face count and topology  If they don't, the blind data will still appear, but is not
    guaranteed to produce the same result when converted back to a subdivision surface
    
    :param absolutePosition: (C) If set to true, the hierarchical edits are represented as the
    point positions, not the point offsets  Most of the time, this is not desirable, but if
    :type absolutePosition: boolean
    :param includeCreases: (C) If set, the creases get transfered as well  With it false, the
    subdivision surface created from the blind data + polygon will have lost all the craes
    :type includeCreases: boolean
    :param includeZeroOffsets: (C) If set, the zero offset will get included in the blind data 
    This will greatly increase the size of the blind data, but will also let you keep all cr
    :type includeZeroOffsets: boolean
    
    :returns: Command result
    :rtype: boolean
    """
    pass


def extendFluid(*args, **kwargs):
    """
    
    """
    pass


def ShowMeshGrabToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def VortexOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MergeEdgeTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PickWalkLeftSelect(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_viewJointsTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmCreateInteractiveGroomSplines(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CoarserSubdivLevel(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorFbxExportAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def intFieldGrp(*args, adjustableColumn=0, adjustableColumn2=0, adjustableColumn3=0,
                adjustableColumn4=0, adjustableColumn5=0, adjustableColumn6=0, annotation="",
                backgroundColor=None, changeCommand=None, columnAlign=None, columnAlign2=None,
                columnAlign3=None, columnAlign4=None, columnAlign5=None, columnAlign6=None,
                columnAttach=None, columnAttach2=None, columnAttach3=None, columnAttach4=None,
                columnAttach5=None, columnAttach6=None, columnOffset2=None, columnOffset3=None,
                columnOffset4=None, columnOffset5=None, columnOffset6=None, columnWidth=None,
                columnWidth1=0, columnWidth2=None, columnWidth3=None, columnWidth4=None,
                columnWidth5=None, columnWidth6=None, defineTemplate="", docTag="",
                dragCallback=None, dragCommand=None, dropCallback=None, enable=True,
                enable1=True, enable2=True, enable3=True, enable4=True, enableBackground=True,
                enableKeyboardFocus=True, exists=True, extraLabel="", fullPathName=True,
                height=0, highlightColor=None, isObscured=True, label="", manage=True,
                noBackground=True, numberOfFields=0, numberOfPopupMenus=True, parent="",
                popupMenuArray=True, preventOverride=True, rowAttach=None, statusBarMessage="",
                useTemplate="", value=None, value1=0, value2=0, value3=0, value4=0,
                visible=True, visibleChangeCommand=None, width=0, q=True, query=True, e=True,
                edit=True, **kwargs):
    """
    All of the group commands position their individual controls in columns starting at column
    1  The layout of each control (ie  column) can be customized using the -cw/columnWidth,
    -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumn flags  By
    default, columns are left aligned with no offset and are 100 pixels wide  Only o
    
    :param adjustableColumn: (C E) Specifies which column has an adjustable size that changes
    with the sizing of the layout  The column value is a 1-based index  Passing 0 as argument
    :type adjustableColumn: int
    :param adjustableColumn2: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly two columns
    :type adjustableColumn2: int
    :param adjustableColumn3: (C E) Specifies that the column has an adjustable size that
    changes with the size of the parent layout  Ignored if there are not exactly three columns
    :type adjustableColumn3: int
    :param adjustableColumn4: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly four columns
    :type adjustableColumn4: int
    :param adjustableColumn5: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly five columns
    :type adjustableColumn5: int
    :param adjustableColumn6: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly six columns
    :type adjustableColumn6: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Command string executed when the value of any of the fields
    changes
    :type changeCommand: script
    :param columnAlign: (C E M) Arguments are : column number, alignment type  Possible
    alignments are: left | right | center  Specifies alignment type for the specified column
    :type columnAlign: [int, string]
    :param columnAlign2: (C E) Sets the text alignment of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "center"
    :type columnAlign2: [string, string]
    :param columnAlign3: (C E) Sets the text alignment for all three columns  Ignored if there
    are not exactly three columns  Valid values are "left", "right", and "center"
    :type columnAlign3: [string, string, string]
    :param columnAlign4: (C E) Sets the text alignment for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "center"
    :type columnAlign4: [string, string, string, string]
    :param columnAlign5: (C E) Sets the text alignment for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "center"
    :type columnAlign5: [string, string, string, string, string]
    :param columnAlign6: (C E) Sets the text alignment for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "center"
    :type columnAlign6: [string, string, string, string, string, string]
    :param columnAttach: (C E M) Arguments are : column number, attachment type, and offset 
    Possible attachments are: left | right | both  Specifies column attachment types and offe
    :type columnAttach: [int, string, int]
    :param columnAttach2: (C E) Sets the attachment type of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "both"
    :type columnAttach2: [string, string]
    :param columnAttach3: (C E) Sets the attachment type for all three columns  Ignored if
    there are not exactly three columns  Valid values are "left", "right", and "both"
    :type columnAttach3: [string, string, string]
    :param columnAttach4: (C E) Sets the attachment type for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "both"
    :type columnAttach4: [string, string, string, string]
    :param columnAttach5: (C E) Sets the attachment type for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "both"
    :type columnAttach5: [string, string, string, string, string]
    :param columnAttach6: (C E) Sets the attachment type for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "both"
    :type columnAttach6: [string, string, string, string, string, string]
    :param columnOffset2: (C E) This flag is used in conjunction with the -columnAttach2 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the tw
    :type columnOffset2: [int, int]
    :param columnOffset3: (C E) This flag is used in conjunction with the -columnAttach3 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the th
    :type columnOffset3: [int, int, int]
    :param columnOffset4: (C E) This flag is used in conjunction with the -columnAttach4 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fo
    :type columnOffset4: [int, int, int, int]
    :param columnOffset5: (C E) This flag is used in conjunction with the -columnAttach5 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fi
    :type columnOffset5: [int, int, int, int, int]
    :param columnOffset6: (C E) This flag is used in conjunction with the -columnAttach6 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the si
    :type columnOffset6: [int, int, int, int, int, int]
    :param columnWidth: (C E M) Arguments are : column number, column width  Sets the width of
    the specified column where the first parameter specifies the column (1 based index) an
    :type columnWidth: [int, int]
    :param columnWidth1: (C E) Sets the width of the first column  Ignored if there is not
    exactly one column
    :type columnWidth1: int
    :param columnWidth2: (C E) Sets the column widths of both columns  Ignored if there are not
    exactly two columns
    :type columnWidth2: [int, int]
    :param columnWidth3: (C E) Sets the column widths for all 3 columns  Ignored if there are
    not exactly 3 columns
    :type columnWidth3: [int, int, int]
    :param columnWidth4: (C E) Sets the column widths for all 4 columns  Ignored if there are
    not exactly 4 columns
    :type columnWidth4: [int, int, int, int]
    :param columnWidth5: (C E) Sets the column widths for all 5 columns  Ignored if there are
    not exactly 5 columns
    :type columnWidth5: [int, int, int, int, int]
    :param columnWidth6: (C E) Sets the column widths for all 6 columns  Ignored if there are
    not exactly 6 columns
    :type columnWidth6: [int, int, int, int, int, int]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dragCommand: (C E) Command string executed when dragging the invisible slider in any
    of the fields
    :type dragCommand: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enable1: (C Q E) 
    :type enable1: boolean
    :param enable2: (C Q E) 
    :type enable2: boolean
    :param enable3: (C Q E) 
    :type enable3: boolean
    :param enable4: (C Q E) Enable state for the respective field
    :type enable4: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param extraLabel: (C Q E) If present on creation this specifies that there will be an
    extra label in the group  Sets the string to be label text to the right of fields
    :type extraLabel: string
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) If present on creation this specifies that there will be a label to
    the left of the fields  Sets the string to be the label text
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfFields: (C) Set the number of fields on creation  One to four fields are
    available  The default is one field
    :type numberOfFields: int
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rowAttach: (C E M) Arguments are : column, attachment type, offset  Possible
    attachments are: top | bottom | both  Specifies attachment types and offsets for the
    entire
    :type rowAttach: [int, string, int]
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param value: (C Q E) Values for all fields
    :type value: [int, int, int, int]
    :param value1: (C Q E) 
    :type value1: int
    :param value2: (C Q E) 
    :type value2: int
    :param value3: (C Q E) 
    :type value3: int
    :param value4: (C Q E) Value for the respective field
    :type value4: int
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def pluginDisplayFilter(*args, classification="", deregister=True, exists=True, label="",
                        listFilters=True, register=True, q=True, query=True, **kwargs):
    """
    Register, deregister or query a plugin display filter  Plug-ins can use this command to
    register their own display filters which will appear in the 'Show' menus on Maya's model
    panels
    
    :param classification: (C Q) The classification used to filter objects in Viewport 2.0 
    This classification is the same as MFnPlugin::registerNode()  If the node was registered w
    :type classification: string
    :param deregister: (C) Deregister a plugin display filter
    :type deregister: boolean
    :param exists: (C) Returns true if the specified filter exists, false otherwise  Other
    flags are ignored
    :type exists: boolean
    :param label: (C Q) The string to be displayed for this filter in the UI  E.g  in the
    'Show' menu of a model panel  The default value of this flag is the same as the plu
    :type label: string
    :param listFilters: (Q) Returns an array of all plugin display filters
    :type listFilters: boolean
    :param register: (C) Register a plugin display filter  The -register is implied if both
    -register and -deregister flags are missing in create mode  You are responsible fo
    :type register: boolean
    
    :returns: string[]
    :rtype: string
    """
    pass


def FBXLoadImportPresetFile(*args, **kwargs):
    """
    
    """
    pass


def TemplateObject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def JointToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CombinePolygonsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def paramLocator(*args, position=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The command creates a locator in the underworld of a NURBS curve or NURBS surface at the
    specified parameter value  If no object is specified, then a locator will be created on the
    first valid selected item (either a curve point or a surface point)
    
    :param position: (C) Whether to set the locator position in normalized space
    :type position: boolean
    
    :returns: Name for the new locator in the underworld of NURBS shape.
    :rtype: string
    """
    pass


def sbs_GetSubstanceBuildVersion(*args, **kwargs):
    """
    
    """
    pass


def MakeMotorBoatsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CircularFilletOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleAutoActivateBodyPart(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def affectedNet(*args, name="", type="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command gets the list of attributes on a node or node type and creates nodes of type
    TdnAffect, one for each attribute, that are connected iff the source node's attribute
    affects the destination node's attribute
    
    :param name: (C Q E) Name to use for this command
    :type name: string
    :param type: (C) Get information from the given node type instead of one node
    :type type: string
    
    :returns: 
    :rtype: None
    """
    pass


def fluidDeleteCacheOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polySetVertices(*args, **kwargs):
    """
    
    """
    pass


def OutlinerToggleDAGOnly(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShareUVInstances(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nexQuadDrawContext(*args, **kwargs):
    """
    
    """
    pass


def polyWarpImage(*args, **kwargs):
    """
    
    """
    pass


def curveEditorCtx(*args, direction=0, exists=True, history=True, image1="", image2="",
                   image3="", name="", relativeTangentSize=4, title="", q=True, query=True,
                   e=True, edit=True, **kwargs):
    """
    The curveEditorCtx command creates a new NURBS editor context, which is used to edit a
    NURBS curve or surface
    
    :param direction: (Q) Query the current direction of the tangent control  Always zero for
    the curve case  In the surface case, its 0 for the normal direction, 1 for U dire
    :type direction: int
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param relativeTangentSize: (C Q E) Relative size of the tangent manipulator handle  Helps
    to adjust as the surface parameterization controls the size of the tangent, even if the
    shape
    :type relativeTangentSize: float
    :param title: (Q E) The title for the tool
    :type title: string
    
    :returns: (name of the new context)
    :rtype: string
    """
    pass


def HypershadeMoveTabLeft(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExtractFace(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateNURBSPlaneOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sbs_GetGraphsNamesFromSubstanceNode(*args, **kwargs):
    """
    
    """
    pass


def EnableDynamicConstraints(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CVCurveTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteAllFluids(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nodePreset(*args, attributes="", custom="", delete=None, exists=None, isValidName="",
               list=None, load=None, save=None, **kwargs):
    """
    Command to save and load preset settings for a node  This command allows you to take a
    snapshot of the values of all attributes of a node and save it to disk as a preset with
    user specified name  Later the saved preset can be loaded and applied onto a different node
    of the same type  The end result is that the node to which the preset is applied ta
    
    :param attributes: (C) A white space separated string of the named attributes to save to
    the preset file  If not specified, all attributes will be stored
    :type attributes: string
    :param custom: (C) Specifies a MEL script for custom handling of node attributes that are
    not handled by the general save preset mechanism (ie  multis, dynamic attribut
    :type custom: string
    :param delete: (C) Deletes the existing preset for the node specified by the first argument
    with the name specified by the second argument
    :type delete: [name, string]
    :param exists: (C) Returns true if the node specified by the first argument already has a
    preset with a name specified by the second argument  This flag can be used to
    :type exists: [name, string]
    :param isValidName: (C) Returns true if the name consists entirely of valid characters for
    a preset name  Returns false if not  Because the preset name will become part of a
    :type isValidName: string
    :param list: (C) Lists the names of all presets which can be loaded onto the specified
    node
    :type list: name
    :param load: (C) Sets the settings of the node specified by the first argument according to
    the preset specified by the second argument  Any attributes on the node wh
    :type load: [name, string]
    :param save: (C) Saves the current settings of the node specified by the first argument to
    a preset of the name specified by the second argument  If a preset for that
    :type save: [name, string]
    
    :returns: if isValidName or exists is used.
    :rtype: boolean
    """
    pass


def animDisplay(*args, modelUpdate="", refAnimCurvesEditable=True, timeCode="",
                timeCodeOffset="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command changes certain display options used by animation windows
    
    :param modelUpdate: (C Q E) Controls how changes to animCurves are propagated through the
    dependency graph  Valid modes are "none", "interactive" or "delayed"  If modelUpdate is
    :type modelUpdate: string
    :param refAnimCurvesEditable: (C Q E) Specify if animation curves from referenced files are
    editable
    :type refAnimCurvesEditable: boolean
    :param timeCode: (C Q E) Controls how time value are display  Valid values are "frame",
    "timecode", "fulltimecode"  If the value is "frame" maya will display time in frame ev
    :type timeCode: string
    :param timeCodeOffset: (C Q E) This flag has now been deprecated  It still exists to not
    break legacy scripts, but it will now do nothing  See the new timeCode command to set and
    q
    :type timeCodeOffset: string
    
    :returns: 
    :rtype: None
    """
    pass


def HideLights(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def clipSchedulerOutliner(*args, annotation="", backgroundColor=None, clipScheduler="",
                          defineTemplate="", docTag="", dragCallback=None, dropCallback=None,
                          enable=True, enableBackground=True, enableKeyboardFocus=True,
                          exists=True, fullPathName=True, height=0, highlightColor=None,
                          isObscured=True, manage=True, noBackground=True,
                          numberOfPopupMenus=True, parent="", popupMenuArray=True,
                          preventOverride=True, statusBarMessage="", useTemplate="",
                          visible=True, visibleChangeCommand=None, width=0, q=True, query=True,
                          e=True, edit=True, **kwargs):
    """
    This command creates/edits/queries a clip scheduler outliner control
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param clipScheduler: (E) Name of the clip scheduler for which to display information
    :type clipScheduler: string
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the outliner control.
    :rtype: string
    """
    pass


def dgfootprint(*args, **kwargs):
    """
    
    """
    pass


def BakeChannelOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExportSkinWeightMapsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleOutliner(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def cMuscleCompIndex(*args, **kwargs):
    """
    
    """
    pass


def nurbsSquare(*args, caching=True, center=None, centerX=0, centerY=0, centerZ=0, degree=3,
                nodeState=0, normal=None, normalX=0, normalY=0, normalZ=1, sideLength1=1.0,
                sideLength2=1.0, spansPerSide=1, constructionHistory=True, name="", object=True,
                q=True, query=True, e=True, edit=True, **kwargs):
    """
    The nurbsSquare command creates a square
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param center: (C Q E) The center point of the square
    :type center: [float, float, float]
    :param centerX: (C Q E) X of the center point  Default: 0
    :type centerX: float
    :param centerY: (C Q E) Y of the center point  Default: 0
    :type centerY: float
    :param centerZ: (C Q E) Z of the center point  Default: 0
    :type centerZ: float
    :param degree: (C Q E) The degree of the resulting circle: 1 - linear, 2 - quadratic, 3 -
    cubic, 5 - quintic, 7 - heptic Default: 3
    :type degree: int
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param normal: (C Q E) The normal of the plane in which the square will lie
    :type normal: [float, float, float]
    :param normalX: (C Q E) X of the normal direction  Default: 0
    :type normalX: float
    :param normalY: (C Q E) Y of the normal direction  Default: 0
    :type normalY: float
    :param normalZ: (C Q E) Z of the normal direction  Default: 1
    :type normalZ: float
    :param sideLength1: (C Q E) The length of a side on the square  Default: 1.0
    :type sideLength1: float
    :param sideLength2: (C Q E) The length of an adjacent side on the square  Default: 1.0
    :type sideLength2: float
    :param spansPerSide: (C Q E) The number of spans per side determines the resolution of the
    square  Default: 1
    :type spansPerSide: int
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def TimeEditorToggleTimeCursorRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nClothCreateOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadePerspLayout(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddInfluence(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PreviousKey(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def muMessageAdd(*args, **kwargs):
    """
    
    """
    pass


def PaintGeomCacheToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UVSphericalProjection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyDelFacet(*args, caching=True, constructionHistory=True, name="", nodeState=0, q=True,
                 query=True, e=True, edit=True, **kwargs):
    """
    Deletes faces  If the result is split into disconnected pieces, the pieces (so-called
    shells) are still considered to be one object
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def ToggleTextureBorder(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Flare(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def pointOnPolyConstraint(*args, layer="", maintainOffset=True, name="", offset=None,
                          remove=True, skip="", targetList=True, weight=0.0,
                          weightAliasList=True, q=True, query=True, e=True, edit=True,
                          **kwargs):
    """
    Constrain an object's position to the position of the target object or to the average
    position of a number of targets   A pointOnPolyConstraint takes as input one or more
    "target" DAG transform nodes at which to position the single "constraint object" DAG
    transform node  The pointOnPolyConstraint positions the constrained object at the weighted
    ave
    
    :param layer: (C E) Specify the name of the animation layer where the constraint should be
    added
    :type layer: string
    :param maintainOffset: (C) The offset necessary to preserve the constrained object's
    initial position will be calculated and used as the offset
    :type maintainOffset: boolean
    :param name: (C Q E) Sets the name of the constraint node to the specified name  Default
    name is constrainedObjectName_constraintType
    :type name: string
    :param offset: (C Q E) Sets or queries the value of the offset  Default is 0,0,0
    :type offset: [float, float, float]
    :param remove: (E) removes the listed target(s) from the constraint
    :type remove: boolean
    :param skip: (C E M) Specify the axis to be skipped  Valid values are "x", "y", "z" and
    "none"  During creation, "none" is the default  This flag is multi-use
    :type skip: string
    :param targetList: (Q) Return the list of target objects
    :type targetList: boolean
    :param weight: (C Q E) Sets the weight value for the specified target(s)  If not given at
    creation time, the default value of 1.0 is used
    :type weight: float
    :param weightAliasList: (Q) Returns the names of the attributes that control the weight of
    the target objects  Aliases are returned in the same order as the targets are returned
    :type weightAliasList: boolean
    
    :returns: Name of the created constraint node
    :rtype: string[]
    """
    pass


def RemoveInbetween(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def reroot(*args, **kwargs):
    """
    This command will reroot a skeleton  The selected joint or the given joint at the command
    line will be the new root of the skeleton  All ikHandles passing through the selected joint
    or above it will be deleted   The given(or selected) joint should not have skin attached 
    The command works on the given or selected joint  No options or flags are nece
    
    
    :returns: 
    :rtype: None
    """
    pass


def displayString(*args, delete=True, exists=True, keys=True, replace=True, value="", q=True,
                  query=True, **kwargs):
    """
    Assign a string value to a string identifier  Allows you define a string in one location
    and then refer to it by its identifier in many other locations  Formatted strings are also
    supported (NOTE however, this functionality is now provided in a more general fashion by
    the format command, use of format is recommended)  You may embed up to 3 special 
    
    :param delete: (C) This flag is used to remove an identifer string  The command will fail
    if the identifier does not exist
    :type delete: boolean
    :param exists: (C) Returns true or false depending upon whether the specified identifier
    exists
    :type exists: boolean
    :param keys: (C Q) List all displayString keys that match the identifier string  The
    identifier string may be a whole or partial key string  The command will return a l
    :type keys: boolean
    :param replace: (C Q) Since a displayString command will fail if it tries to assign a new
    value to an existing identifer, this flag is required to allow updates to the val
    :type replace: boolean
    :param value: (C Q) The display string\'s value  If you do not specify this flag when
    creating a display string then the value will be the same as the identifier
    :type value: string
    
    :returns: 
    :rtype: None
    """
    pass


def selectPref(*args, affectsActive=True, allowHiliteSelection=True, autoSelectContainer=True,
               autoUseDepth=True, clickBoxSize=0, clickDrag=True,
               containerCentricSelection=True, disableComponentPopups=True,
               expandPopupList=True, ignoreSelectionPriority=True, manipClickBoxSize=0,
               paintSelect=True, paintSelectWithDepth=True, popupMenuSelection=True,
               preSelectBackfacing=True, preSelectClosest=True, preSelectDeadSpace=0,
               preSelectHilite=True, preSelectHiliteSize=0.0, preSelectTweakDeadSpace=0,
               selectTypeChangeAffectsActive=True, selectionChildHighlightMode=0,
               singleBoxSelection=True, straightLineDistance=True, trackSelectionOrder=True,
               useDepth=True, xformNoSelect=True, q=True, query=True, **kwargs):
    """
    This command controls state variables used to selection UI behavior
    
    :param affectsActive: (C Q) Set affects-active toggle which when on causes the active list
    to be affected when changing between object and component selection mode
    :type affectsActive: boolean
    :param allowHiliteSelection: (C Q) When in component selection mode, allow selection of
    objects for editing  If an object is selected for editing, it appears in the hilite color
    and it
    :type allowHiliteSelection: boolean
    :param autoSelectContainer: (Q) When enabled, with container centric selection also on,
    whenever the root transform is selected in the viewport, the container node will
    automaticall
    :type autoSelectContainer: boolean
    :param autoUseDepth: (Q) When enabled, useDepth and paintSelectWithDepth will be
    automatically enabled in shaded display mode and disabled in wireframe display mode
    :type autoUseDepth: boolean
    :param clickBoxSize: (C Q) When click selecting, this value defines the size of square
    picking region surrounding the cursor  The size of the square is twice the specified valu
    :type clickBoxSize: int
    :param clickDrag: (C Q) Set click/drag selection interaction on/off
    :type clickDrag: boolean
    :param containerCentricSelection: (Q) When enabled, selecting any DAG node in a container
    in the viewport will select the container's root transform if there is one  If there is no
    root t
    :type containerCentricSelection: boolean
    :param disableComponentPopups: (C Q) A separate preference to allow users to disable popup
    menus when selecting components  This pref is only meaningful if the popupMenuSelection
    pref is
    :type disableComponentPopups: boolean
    :param expandPopupList: (C Q) When in popup selection mode, if this is set then all
    selection items that contain multiple objects or components will be be expanded such that
    each
    :type expandPopupList: boolean
    :param ignoreSelectionPriority: (C Q) If this is set, selection priority will be ignored
    when performing selection
    :type ignoreSelectionPriority: boolean
    :param manipClickBoxSize: (C Q) When selecting a manipulator, this value defines the size
    of square picking region surrounding the cursor  The size of the square is twice the
    specif
    :type manipClickBoxSize: int
    :param paintSelect: (Q) When enabled, the select tool will use drag selection instead of
    marquee selection
    :type paintSelect: boolean
    :param paintSelectWithDepth: (Q) When enabled, paint selection will not select components
    that are behind the surface in the current camera view
    :type paintSelectWithDepth: boolean
    :param popupMenuSelection: (C Q) If this is set, a popup menu will be displayed and used to
    determine the object to select  The menu lists the current user box (marquee) of selected
    :type popupMenuSelection: boolean
    :param preSelectBackfacing: (Q) When enabled preselection will highlight backfacing
    components whose normals face away from the camera
    :type preSelectBackfacing: boolean
    :param preSelectClosest: (Q) When enabled and the cursor is over a surface, preselection
    highlighting will try to preselect the closest component to the cursor regardless of dist
    :type preSelectClosest: boolean
    :param preSelectDeadSpace: (Q) This value defines the size of the region around the cursor
    used for preselection highlighting when the cursor is outside the surface
    :type preSelectDeadSpace: int
    :param preSelectHilite: (Q) When enabled, the closest component under the cursor will be
    highlighted to indicate that clicking will select that component
    :type preSelectHilite: boolean
    :param preSelectHiliteSize: (Q) This value defines the size of the region around the cursor
    used for preselection highlighting  Within this region the closest component to the curso
    :type preSelectHiliteSize: float
    :param preSelectTweakDeadSpace: (Q) This value defines the size of the region around the
    cursor used for preselection highlighting when the cursor is outside the surface in tweak
    mode
    :type preSelectTweakDeadSpace: int
    :param selectTypeChangeAffectsActive: (Q) If true then the active list will be updated
    according to the new selection preferences
    :type selectTypeChangeAffectsActive: boolean
    :param selectionChildHighlightMode: (C Q) Controls the highlighting of the children of a
    selected object  Valid modes are: 0: Always highlight children 1: Never highlight children
    2: Use per-
    :type selectionChildHighlightMode: int
    :param singleBoxSelection: (C Q) Set single box selection on/off  This flag indicates
    whether just single object will be selected when the user box (marquee) selects several
    objects
    :type singleBoxSelection: boolean
    :param straightLineDistance: (Q) If true then use straight line distances for selection
    proximity
    :type straightLineDistance: boolean
    :param trackSelectionOrder: (Q) When enabled, the order of selected objects and components
    will be tracked  The 'ls' command will be able to return the active list in the order of s
    :type trackSelectionOrder: boolean
    :param useDepth: (Q) When enabled, marquee selection will not select components that are
    behind the surface in the current camera view
    :type useDepth: boolean
    :param xformNoSelect: (C Q) Disable selection in xform tools
    :type xformNoSelect: boolean
    
    :returns: in the query mode.
    :rtype: boolean
    """
    pass


def FBXGetTakeIndex(*args, **kwargs):
    """
    
    """
    pass


def cone(*args, axis=None, caching=True, degree=3, endSweep=2, heightRatio=2.0, nodeState=0,
         pivot=None, radius=1.0, sections=8, spans=1, startSweep=0, tolerance=0.01,
         useOldInitBehaviour=False, useTolerance=False, constructionHistory=True, name="",
         object=True, polygon=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The cone command creates a new cone and/or a dependency node that creates one, and returns
    their names
    
    :param axis: (C Q E) The primitive's axis
    :type axis: [float, float, float]
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param degree: (C Q E) The degree of the resulting surface: 1 - linear, 3 - cubic Default:
    3
    :type degree: int
    :param endSweep: (C Q E) The angle at which to end the surface of revolution  Default is
    2Pi radians, or 360 degrees  Default: 6.2831853
    :type endSweep: float
    :param heightRatio: (C Q E) Ratio of "height" to "width" Default: 2.0
    :type heightRatio: float
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param pivot: (C Q E) The primitive's pivot point
    :type pivot: [float, float, float]
    :param radius: (C Q E) The radius of the object Default: 1.0
    :type radius: float
    :param sections: (C Q E) The number of sections determines the resolution of the surface in
    the sweep direction  Used only if useTolerance is false  Default: 8
    :type sections: int
    :param spans: (C Q E) The number of spans determines the resolution of the surface in the
    opposite direction  Default: 1
    :type spans: int
    :param startSweep: (C Q E) The angle at which to start the surface of revolution Default:
    0
    :type startSweep: float
    :param tolerance: (C Q E) The tolerance with which to build the surface  Used only if
    useTolerance is true Default: 0.01
    :type tolerance: float
    :param useOldInitBehaviour: (C Q E) Create the cone with base on the origin as in Maya V8.0
    and below Otherwise create cone centred at origin Default: false
    :type useOldInitBehaviour: boolean
    :param useTolerance: (C Q E) Use the specified tolerance to determine resolution  Otherwise
    number of sections will be used  Default: false
    :type useTolerance: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param polygon: (C) The value of this argument controls the type of the object created by
    this operation 0: nurbs surface 1: polygon (use nurbsToPolygonsPref to set the
    :type polygon: int
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def SelectAllWires(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def vnnConnect(*args, **kwargs):
    """
    
    """
    pass


def AddSelectionAsTargetShape(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def menuItem(*args, allowOptionBoxes=True, annotation="", boldFont=False, checkBox=True,
             collection="", command=None, data=0, defineTemplate="", divider=True,
             dividerLabel="", docTag="", dragDoubleClickCommand=None, dragMenuCommand=None,
             echoCommand=True, enable=True, enableCommandRepeat=True, exists=True,
             familyImage="", image="", imageOverlayLabel="", insertAfter="", isCheckBox=True,
             isOptionBox=True, isRadioButton=True, italicized=False, label="", longDivider=True,
             ltVersion="", optionBox=True, optionBoxIcon="", parent="", postMenuCommand=None,
             postMenuCommandOnce=True, radialPosition="", radioButton=True, runTimeCommand="",
             sourceType="", subMenu=True, tearOff=True, useTemplate="", version="",
             visible=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates/edits/queries menu items
    
    :param allowOptionBoxes: (C Q) Deprecated  All menus and menu items always allow option
    boxes  In the case of submenu items this flag specifies whether the submenu will be able
    to
    :type allowOptionBoxes: boolean
    :param annotation: (C Q E) Annotate the menu item with an extra string value
    :type annotation: string
    :param boldFont: (C Q) Specify if text should be bold  Only supported in menus which use
    the marking menu implementation  Default is false for Windows, and true for all oth
    :type boldFont: boolean
    :param checkBox: (C Q E) Creates a check box menu item  Argument specifies the check box
    value
    :type checkBox: boolean
    :param collection: (C Q) To explicitly add a radio menu item to a radioMenuItemCollection
    :type collection: string
    :param command: (C Q E) Attaches a command/script that will be executed when the item is
    selected  Note this command is not executed when the menu item is in an optionMenu c
    :type command: script
    :param data: (C Q E) Attaches a piece of user-defined data to the menu item
    :type data: int
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param divider: (C Q) Creates a divider menu item
    :type divider: boolean
    :param dividerLabel: (C Q E) Adds a label to a divider menu item
    :type dividerLabel: string
    :param docTag: (C Q E) Attaches a tag to the menu item
    :type docTag: string
    :param dragDoubleClickCommand: (C Q E) If the menu item is put on the shelf then this
    command will be invoked when the corresponding shelf object is double clicked
    :type dragDoubleClickCommand: script
    :param dragMenuCommand: (C Q E) If the menu item is put on the shelf then this command will
    be invoked when the corresponding shelf object is clicked
    :type dragMenuCommand: script
    :param echoCommand: (C Q E) Specify whether the action attached with the c/command flag
    should echo to the command output areas when invoked  This flag is false by default and m
    :type echoCommand: boolean
    :param enable: (C Q E) Enable state for the menu item  A disabled menu item is dimmed and
    unresponsive  An enabled menu item is selectable and has normal appearance
    :type enable: boolean
    :param enableCommandRepeat: (C Q E) This flag only affects menu items to which a command
    can be attached  Specify true and the command may be repeated by executing the command
    repeatLas
    :type enableCommandRepeat: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param familyImage: (Q) Get the filename of the family icon associated with the menu  The
    family icon will be used for the shelf unless an icon is specified with the image f
    :type familyImage: string
    :param image: (C Q E) The filename of the icon associated with the menu item  If the menu
    containing the menu item is being edited with a menuEditor widget, then the menuE
    :type image: string
    :param imageOverlayLabel: (C Q E) Specify a short (5 character) text string to be overlayed
    on top of the icon associated with the menu item  This is primarily a mechanism for
    differe
    :type imageOverlayLabel: string
    :param insertAfter: (C) Specify After which item the new one will be placed  If this flag
    is not specified, item is added at the end of the menu  Use the empty string "" to
    :type insertAfter: string
    :param isCheckBox: (Q) Returns true if the item is a check box item
    :type isCheckBox: boolean
    :param isOptionBox: (Q) Returns true if the item is an option box item
    :type isOptionBox: boolean
    :param isRadioButton: (Q) Returns true if the item is a radio button item
    :type isRadioButton: boolean
    :param italicized: (C Q) Specify if text should be italicized  Only supported in menus
    which use the marking menu implementation  Default is false
    :type italicized: boolean
    :param label: (C Q E) The text that appears in the item
    :type label: string
    :param longDivider: (C Q E) Indicate whether the divider is long or short  Has no effect if
    divider label is set  Default is true
    :type longDivider: boolean
    :param ltVersion: (C Q E) This flag is used to specify the Maya LT version that this
    control feature was introduced, if the version flag is not specified, or if the version fl
    :type ltVersion: string
    :param optionBox: (C Q) Indicates that the menu item will be an option box item  This item
    will appear to the right of the preceeding menu item
    :type optionBox: boolean
    :param optionBoxIcon: (C Q E) The filename of an icon to be used instead of the usual
    option box icon  The icon is searched for in the folder specified by the XBMLANGPATH
    environm
    :type optionBoxIcon: string
    :param parent: (C) Specify the menu that the item will appear in
    :type parent: string
    :param postMenuCommand: (C Q E) Specify a script to be executed when the submenu is about
    to be shown
    :type postMenuCommand: script
    :param postMenuCommandOnce: (C Q E) Indicate the pmc/postMenuCommand should only be invoked
    once  Default value is false, ie  the pmc/postMenuCommand is invoked everytime the sub menu
    i
    :type postMenuCommandOnce: boolean
    :param radialPosition: (C Q E) The radial position of the menu item if it is in a Marking
    Menu  Radial positions are given in the form of a cardinal direction, and may be "N", "NW"
    :type radialPosition: string
    :param radioButton: (C Q E) Creates a radio button menu item  Argument specifies the radio
    button value
    :type radioButton: boolean
    :param runTimeCommand: (C E) A shortcut flag to link the menu item with a runTimeCommand 
    The value is the name of the runTimeCommand (unique)  It copies the following fields fro
    :type runTimeCommand: string
    :param sourceType: (C Q E) Set the language type for a command script  Can only be used in
    conjunction with a command flag  Without this flag, commands are assumed to be the sa
    :type sourceType: string
    :param subMenu: (C Q) Indicates that the item will have a submenu  Subsequent menuItems
    will be added to the submenu until setParent -menu is called  Note that a submenu i
    :type subMenu: boolean
    :param tearOff: (C Q) For the case where the menu item is a sub menu this flag will make
    the sub menu tear-off-able  Note that this flag has no effect on the other menu it
    :type tearOff: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param version: (C Q E) Specify the version that this menu item feature was introduced  The
    argument should be given as a string of the version number (e.g  "2013", "2014")
    :type version: string
    :param visible: (C Q E) The visible state of the menu item  A menu item is created visible
    by default  Note that a menu item's actual appearance is also dependent on the vis
    :type visible: boolean
    
    :returns: Full path name to the menu item.
    :rtype: string
    """
    pass


def DistanceTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleIsolateSelect(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyCloseBorder(*args, caching=True, constructionHistory=True, name="", nodeState=0, q=True,
                    query=True, e=True, edit=True, **kwargs):
    """
    Closes open borders of objects  For each border edge given, a face is created to fill the
    hole the edge lies on
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def AutoProjectionOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MakeHoleTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FrameSelectedInAllViews(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def grid(*args, default=True, displayAxes=True, displayAxesBold=True, displayDivisionLines=True,
         displayGridLines=True, displayOrthographicLabels=True, displayPerspectiveLabels=True,
         divisions=5, orthographicLabelPosition="", perspectiveLabelPosition="", reset=True,
         size=12, spacing=5, style=0, toggle=True, q=True, query=True, **kwargs):
    """
    This command changes the size and spacing of lines on the ground plane displayed in the
    perspective and orthographic views   This command lets you reset the ground plane, change
    its size and grid line spacing, grid subdivisions and display options
    
    :param default: (Q) Used to specify/query default values
    :type default: boolean
    :param displayAxes: (Q) Specify true to display the grid axes
    :type displayAxes: boolean
    :param displayAxesBold: (Q) Specify true to accent the grid axes by drawing them with a
    thicker line
    :type displayAxesBold: boolean
    :param displayDivisionLines: (Q) Specify true to display the subdivision lines between grid
    lines
    :type displayDivisionLines: boolean
    :param displayGridLines: (Q) Specify true to display the grid lines
    :type displayGridLines: boolean
    :param displayOrthographicLabels: (Q) Specify true to display the grid line numeric labels
    in the orthographic views
    :type displayOrthographicLabels: boolean
    :param displayPerspectiveLabels: (Q) Specify true to display the grid line numeric labels
    in the perspective view
    :type displayPerspectiveLabels: boolean
    :param divisions: (Q) Sets the number of subdivisions between major grid lines  The default
    is 5  If the spacing is 5 units, setting divisions to 5 will cause division lin
    :type divisions: int
    :param orthographicLabelPosition: (Q) The position of the grid's numeric labels in
    orthographic views  Valid values are "axis" and "edge"
    :type orthographicLabelPosition: string
    :param perspectiveLabelPosition: (Q) The position of the grid's numeric labels in
    perspective views  Valid values are "axis" and "edge"
    :type perspectiveLabelPosition: string
    :param reset: () Resets the ground plane to its default values
    :type reset: boolean
    :param size: (Q) Sets the size of the grid in linear units  The default is 12 units
    :type size: float
    :param spacing: (Q) Sets the spacing between major grid lines in linear units  The default
    is 5 units
    :type spacing: float
    :param style: (Q) This flag is obsolete and should not be used
    :type style: int
    :param toggle: (Q) Turns the ground plane display off in all windows, including
    orthographic windows  Default is true
    :type toggle: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def ToggleCapsLockDisplay(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSetDirectionBrushToolOption(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteTextureReferenceObject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeShowDirectoriesOnly(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def attachGeometryCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RemoveInfluence(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectUVFrontFacingComponents(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectAllNParticles(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectLinesMask(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sculptMeshCacheCtx(*args, adjustSize=True, adjustStrength=True, affectAllLayers=True,
                       brushDirection=0, brushSize=0.0, brushStrength=0.0, buildUpRate=0.0,
                       cloneHideSource=True, cloneMethod=0, cloneShapeSource="",
                       cloneTargetSource="", constrainToSurface=True, direction=0,
                       displayFrozen=True, displayMask=True, displayWireframe=True,
                       falloffType=0, flood=0.0, floodFreeze=0.0, frame=True,
                       freezeSelection=True, grabFollowPath=True, grabSilhouette=True,
                       grabTwist=True, inverted=True, lastMode="", lockShellBorder=True,
                       makeStroke=None, minSize=0.0, minStrength=0.0, mirror=0, mode="",
                       orientToSurface=True, recordStroke=True, sculptFalloffCurve="", size=0.0,
                       stampDistance=0.0, stampFile="", stampFlipX=True, stampFlipY=True,
                       stampOrientToStroke=True, stampPlacement=0, stampRandomization=True,
                       stampRandomizationSeed=0, stampRandomizeFlipX=True,
                       stampRandomizeFlipY=True, stampRandomizePosX=0.0, stampRandomizePosY=0.0,
                       stampRandomizeRotation=0.0, stampRandomizeScale=0.0,
                       stampRandomizeStrength=0.0, stampRotation=0.0, steadyStrokeDistance=0.0,
                       strength=0.0, updatePlane=True, useGlobalSize=True, useScreenSpace=True,
                       useStampDistance=True, useStampImage=True, useSteadyStroke=True,
                       wholeStroke=True, wireframeAlpha=0.0, wireframeColor=None, q=True,
                       query=True, e=True, edit=True, **kwargs):
    """
    This is a tool context command for mesh cache sculpting tool
    
    :param adjustSize: (E) If true, puts the tool into the mode where dragging the mouse will
    edit the brush size  If false, puts the tool back into the previous sculpt mode
    :type adjustSize: boolean
    :param adjustStrength: (E) If true, puts the tool into the mode where dragging the mouse
    will edit the brush strength  If false, puts the tool back into the previous sculpt mod
    :type adjustStrength: boolean
    :param affectAllLayers: (C Q E) If true, the brush affects all layers at once
    :type affectAllLayers: boolean
    :param brushDirection: (Q E) Specifies the direction of the named brush
    :type brushDirection: int
    :param brushSize: (Q E) Specifies the world-space size of the named brush
    :type brushSize: float
    :param brushStrength: (Q E) Specifies the world-space strength of the named brush
    :type brushStrength: float
    :param buildUpRate: (Q E) Specifies the brush strength increasing along the stroke
    :type buildUpRate: float
    :param cloneHideSource: (C Q E) True if the cloned source should be hidden
    :type cloneHideSource: boolean
    :param cloneMethod: (C Q E) Controls how the source delta vectors should change the target 
    0=copy 1=add
    :type cloneMethod: int
    :param cloneShapeSource: (C Q E) Name of the shape source to clone
    :type cloneShapeSource: string
    :param cloneTargetSource: (C Q E) Name of the target source of the clone
    :type cloneTargetSource: string
    :param constrainToSurface: (C Q E) If true, the modification keeps the surface curvature
    :type constrainToSurface: boolean
    :param direction: (Q E) Specifies the direction in which the vertices are moved
    :type direction: int
    :param displayFrozen: (C Q E) If false, turns off the display of frozen area on the object
    :type displayFrozen: boolean
    :param displayMask: (C Q E) If false, turns off the display of masked area on the object
    :type displayMask: boolean
    :param displayWireframe: (C Q E) If false, turns off the wireframe display of the object
    :type displayWireframe: boolean
    :param falloffType: (Q E) Specifies how the brush determines which vertices to affect
    :type falloffType: int
    :param flood: (C E) Sets the brush effect for each vertex to the given value
    :type flood: float
    :param floodFreeze: (C E) Sets the freeze value for each vertex to the given value
    :type floodFreeze: float
    :param frame: (C E) Frames on the sculpted area
    :type frame: boolean
    :param freezeSelection: (C E) Freezes selected components
    :type freezeSelection: boolean
    :param grabFollowPath: (C Q E) If true, the grab brush effect follows mouse movement
    :type grabFollowPath: boolean
    :param grabSilhouette: (C Q E) If true, the grab brush uses paint-through mode
    :type grabSilhouette: boolean
    :param grabTwist: (C Q E) If true, the grab brush twists the vertices
    :type grabTwist: boolean
    :param inverted: (C Q E) If true, inverts the effect of the brush
    :type inverted: boolean
    :param lastMode: (Q E) Specifies the type of the last active sculpting brush
    :type lastMode: string
    :param lockShellBorder: (C Q E) Lock the shell borders so that they won't be moved by a UV
    texture brush
    :type lockShellBorder: boolean
    :param makeStroke: (E M) Specify a surface point patch for a brush stroke  Multiple patches
    can be specified to form a brush stroke  The first argument is the mesh index  The
    :type makeStroke: [int, int, int, float, float]
    :param minSize: (Q E) Specifies the minimum size percentage of the current brush
    :type minSize: float
    :param minStrength: (Q E) Specifies the minimum strength percentage of the current brush
    :type minStrength: float
    :param mirror: (Q E) Specifies the mirror mode of the brush
    :type mirror: int
    :param mode: (Q E) Specifies the type of sculpting effect the brush will perform
    :type mode: string
    :param orientToSurface: (C Q E) If true, aligns the brush display to the surface of the
    mesh
    :type orientToSurface: boolean
    :param recordStroke: (Q E) Set this flag to true to enable stroke recording that can be
    later played back with the makeStroke flag
    :type recordStroke: boolean
    :param sculptFalloffCurve: (Q E) Specifies the falloff curve of sculpting effect the brush
    will perform
    :type sculptFalloffCurve: string
    :param size: (Q E) Specifies the world-space size of the current brush
    :type size: float
    :param stampDistance: (Q E) Specifies the stamping distance of the brush
    :type stampDistance: float
    :param stampFile: (Q E) Specifies an image file to use as stamp
    :type stampFile: string
    :param stampFlipX: (C Q E) Specifies if the brush stamp is flipped on the X axis
    :type stampFlipX: boolean
    :param stampFlipY: (C Q E) Specifies if the brush stamp is flipped on the Y axis
    :type stampFlipY: boolean
    :param stampOrientToStroke: (C Q E) Specifies if the brush stamp is aligned to the stroke
    direction
    :type stampOrientToStroke: boolean
    :param stampPlacement: (Q E) Specifies the placement mode of the stamp image
    :type stampPlacement: int
    :param stampRandomization: (C Q E) Specifies if the brush stamp is randomized
    :type stampRandomization: boolean
    :param stampRandomizationSeed: (E) Specifies the stamp randomization seed value  Use a
    value of 0 to generate a random seed value
    :type stampRandomizationSeed: int
    :param stampRandomizeFlipX: (C Q E) Specifies if the brush stamp flipping is randomized on
    the X axis
    :type stampRandomizeFlipX: boolean
    :param stampRandomizeFlipY: (C Q E) Specifies if the brush stamp flipping is randomized on
    the Y axis
    :type stampRandomizeFlipY: boolean
    :param stampRandomizePosX: (Q E) Specifies the stamp X position value is randomized
    :type stampRandomizePosX: float
    :param stampRandomizePosY: (Q E) Specifies the stamp Y position value is randomized
    :type stampRandomizePosY: float
    :param stampRandomizeRotation: (Q E) Specifies the stamp rotation value is randomized
    :type stampRandomizeRotation: float
    :param stampRandomizeScale: (Q E) Specifies the stamp scale value is randomized
    :type stampRandomizeScale: float
    :param stampRandomizeStrength: (Q E) Specifies the stamp strength value is randomized
    :type stampRandomizeStrength: float
    :param stampRotation: (Q E) Specifies the rotation value of the stamp image
    :type stampRotation: float
    :param steadyStrokeDistance: (Q E) Specifies the distance for the steady stroke
    :type steadyStrokeDistance: float
    :param strength: (Q E) Specifies the world-space strength of the current brush
    :type strength: float
    :param updatePlane: (C Q E) Recalculates the underlying tool plane for each stamp in a
    stroke
    :type updatePlane: boolean
    :param useGlobalSize: (C Q E) If true, all the brushes have a shared size property;
    otherwise size is local
    :type useGlobalSize: boolean
    :param useScreenSpace: (C Q E) If true, the brush size is in screen space pixels
    :type useScreenSpace: boolean
    :param useStampDistance: (C Q E) Force the stamps to be spread out along the stroke, rather
    than building up continually
    :type useStampDistance: boolean
    :param useStampImage: (C Q E) Specifies if the brush uses a stamp image
    :type useStampImage: boolean
    :param useSteadyStroke: (C Q E) Turns using steady stroke on/off
    :type useSteadyStroke: boolean
    :param wholeStroke: (C Q E) Continuously recalculates the underlying tool plane from all
    the vertices affected during the stroke
    :type wholeStroke: boolean
    :param wireframeAlpha: (C Q E) Sets the alpha value of the wireframe for the object that is
    being sculpted
    :type wireframeAlpha: float
    :param wireframeColor: (C Q E) Sets the color of the wireframe for the object that is being
    sculpted  Values should be 0-1 RGB
    :type wireframeColor: [float, float, float]
    
    :returns: 
    :rtype: None
    """
    pass


def subgraph(*args, **kwargs):
    """
    
    """
    pass


def SymmetrizeUV(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddBifrostKillplane(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectedAnimLayer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SnapPointToPoint(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SmoothPolygonOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateSoftBodyOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UIModeMarkingMenu(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideWrapInfluences(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExtendFluid(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PlaybackForward(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def hikCustomRigToolWidget(*args, **kwargs):
    """
    
    """
    pass


def TimeEditorClipTrimEnd(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def iconTextCheckBox(*args, align="", annotation="", backgroundColor=None, changeCommand=None,
                     defineTemplate="", disabledImage="", docTag="", dragCallback=None,
                     dropCallback=None, enable=True, enableBackground=True,
                     enableKeyboardFocus=True, exists=True, flat=True, flipX=True, flipY=True,
                     font="", fullPathName=True, height=0, highlightColor=None,
                     highlightImage="", image="", image1="", image2="", image3="",
                     imageOverlayLabel="", isObscured=True, label="", labelOffset=0,
                     ltVersion="", manage=True, marginHeight=0, marginWidth=0,
                     noBackground=True, numberOfPopupMenus=True, offCommand=None,
                     onCommand=None, overlayLabelBackColor=None, overlayLabelColor=None,
                     parent="", popupMenuArray=True, preventOverride=True, rotation=0.0,
                     selectionHighlightImage="", selectionImage="", statusBarMessage="",
                     style="", useAlpha=True, useTemplate="", value=True, version="",
                     visible=True, visibleChangeCommand=None, width=0, q=True, query=True,
                     e=True, edit=True, **kwargs):
    """
    This control supports up to 3 icon images and 4 different display styles  The icon image
    displayed is the one that best fits the current size of the control given its current style
      This command creates an iconTextCheckBox
    
    :param align: (C Q E) The label alignment  Alignment values are "left", "right", and
    "center"  By default, the label is aligned "center"  Currently only available when -st
    :type align: string
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C Q E) Command executed when the control's state is changed  Note
    that this flag should not be used in conjunction with onCommand and offCommand  That is, o
    :type changeCommand: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param disabledImage: (C Q E) Image used when the button is disabled  Image size must be
    the same as the image specified with the i/image flag  This is a Windows only flag
    :type disabledImage: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param flat: (C Q E) Sets whether the control will be a flat button (0 false, 1 true)
    :type flat: boolean
    :param flipX: (C Q E) Is the image flipped horizontally?
    :type flipX: boolean
    :param flipY: (C Q E) Is the image flipped vertically?
    :type flipY: boolean
    :param font: (C Q E) The font for the text  Valid values are "boldLabelFont",
    "smallBoldLabelFont", "tinyBoldLabelFont", "plainLabelFont", "smallPlainLabelFont",
    "oblique
    :type font: string
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param highlightImage: (C Q E) Highlight image displayed while the cursor is over the
    control  Image size must be the same as the image specified with the -i/image flag  This is
    a
    :type highlightImage: string
    :param image: (C Q E) If you are not providing images with different sizes then you may use
    this flag for the control's image  If the "iconOnly" style is set, the icon wil
    :type image: string
    :param image1: (C Q E) First of three possible icons  The icon that best fits the current
    size of the control will be displayed
    :type image1: string
    :param image2: (C Q E) Second of three possible icons  The icon that best fits the current
    size of the control will be displayed
    :type image2: string
    :param image3: (C Q E) Third of three possible icons  The icon that best fits the current
    size of the control will be displayed
    :type image3: string
    :param imageOverlayLabel: (C Q E) A short string, up to 6 characters, representing a label
    that will be displayed on top of the image
    :type imageOverlayLabel: string
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) The text that appears in the control
    :type label: string
    :param labelOffset: (C Q E) The label offset  Default is 0  Currently only available when
    -st/style is set to "iconAndTextCentered"
    :type labelOffset: int
    :param ltVersion: (C Q E) This flag is used to specify the Maya LT version that this
    control feature was introduced, if the version flag is not specified, or if the version fl
    :type ltVersion: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param marginHeight: (C Q E) The number of pixels above and below the control content  The
    default value is 1 pixel
    :type marginHeight: int
    :param marginWidth: (C Q E) The number of pixels on either side of the control content  The
    default value is 1 pixel
    :type marginWidth: int
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param offCommand: (C Q E) Command executed when the control is turned off
    :type offCommand: script
    :param onCommand: (C Q E) Command executed when the control is turned on
    :type onCommand: script
    :param overlayLabelBackColor: (C Q E) The RGBA color of the shadow behind the label defined
    by imageOverlayLabel  Default is 50% transparent black: 0 0 0 .5
    :type overlayLabelBackColor: [float, float, float, float]
    :param overlayLabelColor: (C Q E) The RGB color of the label defined by imageOverlayLabel 
    Default is a light grey: .8 .8 .8
    :type overlayLabelColor: [float, float, float]
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rotation: (C Q E) The rotation value of the image in radians
    :type rotation: float
    :param selectionHighlightImage: (C Q E) Image displayed while the control is selected and
    the cursor is over the control  Image size must be the same as the image specified with the
    -i/imag
    :type selectionHighlightImage: string
    :param selectionImage: (C Q E) Image displayed while the control is selected  Image size
    must be the same as the image specified with the -i/image flag  This is a Windows only
    flag
    :type selectionImage: string
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param style: (C Q E) The draw style of the control  Valid styles are "iconOnly",
    "textOnly", "iconAndTextHorizontal", "iconAndTextVertical", and "iconAndTextCentered"  (N
    :type style: string
    :param useAlpha: (C Q E) Is the image using alpha channel?
    :type useAlpha: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param value: (C Q E) Sets or returns the state of the control
    :type value: boolean
    :param version: (C Q E) Specify the version that this control feature was introduced  The
    argument should be given as a string of the version number (e.g  "2013", "2014")  C
    :type version: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def MatchPivots(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyColorSet(*args, allColorSets=True, clamped=True, colorSet="", copy=True, create=True,
                 currentColorSet=True, currentPerInstanceSet=True, delete=True, newColorSet="",
                 perInstance=True, rename=True, representation="", shareInstances=True,
                 unshared=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Command to do the following to color sets: - delete an existing color set  - rename an
    existing color set  - create a new empty color set  - set the current color set to a
    pre-existing color set  - modify sharing between instances of per-instance color sets -
    query the current color set  - query the names of all color sets  - query the name(s) alon
    
    :param allColorSets: (C Q E) This flag when used in a query will return a list of all of
    the color set names
    :type allColorSets: boolean
    :param clamped: (C Q E) This flag specifies if the color set will truncate any value that
    is outside 0 to 1 range
    :type clamped: boolean
    :param colorSet: (C Q E) Specifies the name of the color set that this command needs to
    work on  This flag has to be specified for this command to do anything meaningful othe
    :type colorSet: string
    :param copy: (C Q E) This flag when used will result in the copying of the color set
    corresponding to name specified with the colorSet flag to the colorSet corresponding
    :type copy: boolean
    :param create: (C Q E) This flag when used will result in the creation of an empty color
    set corresponding to the name specified with the colorSet flag  If a color set with
    :type create: boolean
    :param currentColorSet: (C Q E) This flag when used will set the current color set that the
    object needs to work on, to be the color set corresponding to the name specified with the
    :type currentColorSet: boolean
    :param currentPerInstanceSet: (Q E) This is a query-only flag for use when the current
    color set is a per-instance color set family  This returns the member of the set family
    that corre
    :type currentPerInstanceSet: boolean
    :param delete: (C Q E) This flag when used will result in the deletion of the color set
    corresponding to the name specified with the colorSet flag
    :type delete: boolean
    :param newColorSet: (C Q E) Specifies the name that the color set corresponding to the name
    specified with the colorSet flag, needs to be renamed to
    :type newColorSet: string
    :param perInstance: (C Q E) This flag can be used in conjunction with the create flag to
    indicate whether or not the color set is per-instance  When you create a per-instance co
    :type perInstance: boolean
    :param rename: (C Q E) This flag when used will result in the renaming of the color set
    corresponding to the name specified with the colorSet flag to the name specified usi
    :type rename: boolean
    :param representation: (C Q E) This flag corresponds to the color channels to used, for
    example A(alpha only), RGB, and RGBA
    :type representation: string
    :param shareInstances: (C Q E) This flag is used to modify the sharing of per-instance
    color sets within a given color set family so that all selected instances share the
    specified
    :type shareInstances: boolean
    :param unshared: (C Q E) This flag can be used in conjunction with the create and
    perInstance flags to indicate that the newly created per-instance set should be created
    with
    :type unshared: boolean
    
    :returns: Success or Failure.
    :rtype: boolean
    """
    pass


def SetIKFKKeyframe(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def falloffCurveAttr(*args, addControlVertex="", annotation="", asString="", attribute=None,
                     backgroundColor=None, changeCommand=None, currentKey=0,
                     currentKeyValue=None, customCurveWidget=0, defineTemplate="",
                     deleteControlVertex=0, docTag="", dragCallback=None, dropCallback=None,
                     enable=True, enableBackground=True, enableKeyboardFocus=True, exists=True,
                     fullPathName=True, height=0, highlightColor=None, isObscured=True,
                     manage=True, noBackground=True, numberOfPopupMenus=True, parent="",
                     popupMenuArray=True, preventOverride=True, readOnly=0,
                     selectedPositionControl="", selectedValueControl="", snapToGrid=0,
                     statusBarMessage="", useTemplate="", visible=True,
                     visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
                     **kwargs):
    """
    This command creates a control for editing a 2D control curve  This control attaches to a
    curve attribute, which must be a multi attribute where each entry is a compound composed
    of:  A single float for control point position A single float for control point value  The
    MEL command AEaddCurveControl should be used to attach this control to an attrib
    
    :param addControlVertex: (E) Used to add a control vertex for the curve
    :type addControlVertex: string
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param asString: (Q E) Used to query and set the value of the curve as a string of comma
    separated values
    :type asString: string
    :param attribute: (C) Specifies the name of the curve attribute to control
    :type attribute: name
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (E) Specifies a command to be executed whenever the value of this
    curve is modified
    :type changeCommand: script
    :param currentKey: (C Q E) Returns the index of the currently selected key
    :type currentKey: int
    :param currentKeyValue: (Q E) Get or set the value of the currently selected key
    :type currentKeyValue: [float, float]
    :param customCurveWidget: (C Q E) Determines whether or not the curve widget is using a
    custom curve  When a custom curve is used, it is stored by a falloff curve in the brush
    tool se
    :type customCurveWidget: int
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param deleteControlVertex: (E) Used to delete a control vertex of the curve
    :type deleteControlVertex: int
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param readOnly: (C Q E) Specifies if the curve is read only or not  If true, the curve
    can't be edited
    :type readOnly: int
    :param selectedPositionControl: (C E) Specifies the name of a float slider to edit the
    selected key position
    :type selectedPositionControl: string
    :param selectedValueControl: (C E) Specifies the name of a float slider to edit the
    selected key value
    :type selectedValueControl: string
    :param snapToGrid: (C Q E) Specifies whether or not curve control points snap to grid when
    they are being moved
    :type snapToGrid: int
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the port created or modified
    :rtype: string
    """
    pass


def DeltaMushOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def reverseCurve(*args, caching=True, nodeState=0, constructionHistory=True,
                 curveOnSurface=True, name="", object=True, range=True, replaceOriginal=True,
                 q=True, query=True, e=True, edit=True, **kwargs):
    """
    The reverseCurve command reverses the direction of a curve or curve-on-surface  A string is
    returned containing the pathname of the newly reversed curve and the name of the resulting
    dependency node  The reversed curve has the same parameter range as the original curve
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param curveOnSurface: (C) If possible, create 2D curve as a result
    :type curveOnSurface: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param range: (C) Force a curve range on complete input curve
    :type range: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    
    :returns: (object name and node name)
    :rtype: string[]
    """
    pass


def ShowObjectGeometry(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PencilCurveTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DecrementFluidCenter(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OpenCloseCurve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmSplineBaseDensityScaleChangeCmd(*args, **kwargs):
    """
    
    """
    pass


def pointOnCurve(*args, caching=True, constructionHistory=True, curvatureCenter=True,
                 curvatureRadius=True, nodeState=0, normal=True, normalizedNormal=True,
                 normalizedTangent=True, parameter=0.0, position=True, tangent=True,
                 turnOnPercentage=False, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command returns information for a point on a NURBS curve  If no flag is specified, it
    assumes p/position by default
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param curvatureCenter: (C) Returns the (x,y,z) center of curvature of the specified point
    on the curve
    :type curvatureCenter: boolean
    :param curvatureRadius: (C) Returns the radius of curvature of the specified point on the
    curve
    :type curvatureRadius: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param normal: (C) Returns the (x,y,z) normal of the specified point on the curve
    :type normal: boolean
    :param normalizedNormal: (C) Returns the (x,y,z) normalized normal of the specified point
    on the curve
    :type normalizedNormal: boolean
    :param normalizedTangent: (C) Returns the (x,y,z) normalized tangent of the specified point
    on the curve
    :type normalizedTangent: boolean
    :param parameter: (Q E) The parameter value on curve Default: 0.0
    :type parameter: float
    :param position: (C) Returns the (x,y,z) position of the specified point on the curve
    :type position: boolean
    :param tangent: (C) Returns the (x,y,z) tangent of the specified point on the curve
    :type tangent: boolean
    :param turnOnPercentage: (Q E) Whether the parameter is normalized (0,1) or not Default:
    false
    :type turnOnPercentage: boolean
    
    :returns: Vector query result
    :rtype: float[3]
    """
    pass


def CameraSetEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BreakShadowLinks(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetPreferredAngle(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def U3DBrushSizeOff(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ls(*args, absoluteName=True, allPaths=True, assemblies=True, cameras=True, containerType="",
       containers=True, dagObjects=True, defaultNodes=True, dependencyNodes=True, exactType="",
       excludeType="", flatten=True, geometry=True, ghost=True, head=0, hilite=True,
       intermediateObjects=True, invisible=True, leaf=True, lights=True, live=True,
       lockedNodes=True, long=True, materials=True, modified=True, noIntermediate=True,
       nodeTypes=True, objectsOnly=True, orderedSelection=True, partitions=True,
       persistentNodes=True, planes=True, preSelectHilite=True, readOnly=True, recursive=True,
       referencedNodes=True, references=True, renderGlobals=True, renderQualities=True,
       renderResolutions=True, renderSetups=True, selection=True, sets=True, shapes=True,
       shortNames=True, showNamespace=True, showType=True, tail=0, templated=True,
       textures=True, transforms=True, type="", undeletable=True, untemplated=True, uuid=True,
       visible=True, **kwargs):
    """
    The ls command returns the names (and optionally the type names) of objects in the scene  
    The most common use of ls is to filter or match objects based on their name (using
    wildcards) or based on their type  By default ls will match any object in the scene but it
    can also be used to filter or list the selected objects when used in conjunction with
    
    :param absoluteName: (C) This flag can be used in conjunction with the showNamespace flag
    to specify that the namespace(s) returned by the command be in absolute namespace fo
    :type absoluteName: boolean
    :param allPaths: (C) List all paths to nodes in DAG  This flag only works if -dag is also
    specified or if an object name is supplied
    :type allPaths: boolean
    :param assemblies: (C) List top level transform Dag objects
    :type assemblies: boolean
    :param cameras: (C) List camera shapes
    :type cameras: boolean
    :param containerType: (C M) List containers with the specified user-defined type  This flag
    cannot be used in conjunction with the type or exactType flag
    :type containerType: string
    :param containers: (C) List containers  Includes both standard containers as well as other
    types of containers such as dagContainers
    :type containers: boolean
    :param dagObjects: (C) List Dag objects of any type  If object name arguments are passed to
    the command then this flag will list all Dag objects below the specified object(
    :type dagObjects: boolean
    :param defaultNodes: (C) Returns default nodes  A default node is one that Maya creates
    automatically and does not get saved out with the scene, although some of its attribut
    :type defaultNodes: boolean
    :param dependencyNodes: (C) List dependency nodes  (including Dag objects)
    :type dependencyNodes: boolean
    :param exactType: (C M) List all objects of the specified type, but not objects that are
    descendents of that type  This flag can appear multiple times on the command line  N
    :type exactType: string
    :param excludeType: (C M) List all objects that are not of the specified type  This flag
    can appear multiple times on the command line  Note: the type passed to this flag is t
    :type excludeType: string
    :param flatten: (C) Flattens the returned list of objects so that each component is
    identified individually
    :type flatten: boolean
    :param geometry: (C) List geometric Dag objects
    :type geometry: boolean
    :param ghost: (C) List ghosting objects
    :type ghost: boolean
    :param head: (C) This flag specifies the maximum number of elements to be returned from the
    beginning of the list of items  Note: each type flag will return at most t
    :type head: int
    :param hilite: (C) List objects that are currently hilited for component selection
    :type hilite: boolean
    :param intermediateObjects: (C) List only intermediate dag nodes
    :type intermediateObjects: boolean
    :param invisible: (C) List only invisible dag nodes
    :type invisible: boolean
    :param leaf: (C) List all leaf nodes in Dag  This flag is a modifier and must be used in
    conjunction with the -dag flag
    :type leaf: boolean
    :param lights: (C) List light shapes
    :type lights: boolean
    :param live: (C) List objects that are currently live
    :type live: boolean
    :param lockedNodes: (C) Returns locked nodes, which cannot be deleted or renamed  However,
    their status may change
    :type lockedNodes: boolean
    :param long: (C) Return full path names for Dag objects  By default the shortest unique
    name is returned
    :type long: boolean
    :param materials: (C) List materials or shading groups
    :type materials: boolean
    :param modified: (C) When this flag is set, only nodes modified since the last save will be
    returned
    :type modified: boolean
    :param noIntermediate: (C) List only non intermediate dag nodes
    :type noIntermediate: boolean
    :param nodeTypes: (C) Lists all registered node types
    :type nodeTypes: boolean
    :param objectsOnly: (C) When this flag is set only object names will be returned and
    components/attributes will be ignored
    :type objectsOnly: boolean
    :param orderedSelection: (C) List objects and components that are currently selected in
    their order of selection  This flag depends on the value of the -tso/trackSelectionOrder f
    :type orderedSelection: boolean
    :param partitions: (C) List partitions
    :type partitions: boolean
    :param persistentNodes: (C) Returns persistent nodes, which are nodes that stay in the Maya
    session after a file > new  These are a special class of default nodes that do not ge
    :type persistentNodes: boolean
    :param planes: (C) List construction plane shapes
    :type planes: boolean
    :param preSelectHilite: (C) List components that are currently hilited for pre-selection
    :type preSelectHilite: boolean
    :param readOnly: (C) Returns referenced nodes  Referenced nodes are read only  NOTE:
    Obsolete  Please use "-referencedNodes"
    :type readOnly: boolean
    :param recursive: (C) When set to true, this command will look for name matches in all
    namespaces  When set to false, this command will only look for matches in namespaces
    :type recursive: boolean
    :param referencedNodes: (C) Returns referenced nodes  Referenced nodes are read only
    :type referencedNodes: boolean
    :param references: (C) List references associated with files  Excludes special reference
    nodes such as the sharedReferenceNode and unknown reference nodes
    :type references: boolean
    :param renderGlobals: (C) List render globals
    :type renderGlobals: boolean
    :param renderQualities: (C) List named render qualities
    :type renderQualities: boolean
    :param renderResolutions: (C) List render resolutions
    :type renderResolutions: boolean
    :param renderSetups: (C) Alias for -renderGlobals
    :type renderSetups: boolean
    :param selection: (C) List objects that are currently selected
    :type selection: boolean
    :param sets: (C) List sets
    :type sets: boolean
    :param shapes: (C) List shape objects
    :type shapes: boolean
    :param shortNames: (C) Return short attribute names  By default long attribute names are
    returned
    :type shortNames: boolean
    :param showNamespace: (C) Show the namespace of each object after the object name  This
    flag cannot be used in conjunction with the showType flag
    :type showNamespace: boolean
    :param showType: (C) List the type of each object after its name
    :type showType: boolean
    :param tail: (C) This flag specifies the maximum number of elements to be returned from the
    end of the list of items  Note: each type flag will return at most this ma
    :type tail: int
    :param templated: (C) List only templated dag nodes
    :type templated: boolean
    :param textures: (C) List textures
    :type textures: boolean
    :param transforms: (C) List transform objects
    :type transforms: boolean
    :param type: (C M) List all objects of the specified type  This flag can appear multiple
    times on the command line  Note: the type passed to this flag is the same type
    :type type: string
    :param undeletable: (C) Returns nodes that cannot be deleted (which includes locked nodes) 
    These nodes also cannot be renamed
    :type undeletable: boolean
    :param untemplated: (C) List only un-templated dag nodes
    :type untemplated: boolean
    :param uuid: (C) Return node UUIDs instead of names  Note that there are no "UUID paths" -
    combining this flag with e.g  the -long flag will not result in a path form
    :type uuid: boolean
    :param visible: (C) List only visible dag nodes
    :type visible: boolean
    
    :returns: Command result
    :rtype: string[]
    """
    pass


def symmetricModelling(*args, about="", allowPartial=True, axis="", preserveSeam=0, reset=True,
                       seamFalloffCurve="", seamTolerance=0.0, symmetry=0, tolerance=0.0,
                       topoSymmetry=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command allows you to change the symmetric modelling options   Symmetric modelling is
    an option that allows for reflection of basic manipulator actions such as move, rotate, and
    scale
    
    :param about: (C Q E) Set the space in which symmetry should be calculated (object or world
    or topo)  When queried, returns a string which is the current space being used
    :type about: string
    :param allowPartial: (C Q E) Specifies whether partial symmetry should be allowed when
    enabling topological symmetry
    :type allowPartial: boolean
    :param axis: (C Q E) Set the current axis to be reflected over  When queried, returns a
    string which is the current axis
    :type axis: string
    :param preserveSeam: (C Q E) Controls whether selection or symmetry should take priority on
    the plane of symmetry  When queried, returns an int for the option
    :type preserveSeam: int
    :param reset: (C E) Reset the redo information before starting
    :type reset: boolean
    :param seamFalloffCurve: (C Q E) Set the seam's falloff curve, used to control the seam
    strength within the seam tolerance  The string is a comma separated list of sets of 3
    values f
    :type seamFalloffCurve: string
    :param seamTolerance: (C Q E) Set the seam tolerance used for reflection  When preserveSeam
    is enabled, this tolerance controls the width of the enforced seam  When queried, retur
    :type seamTolerance: float
    :param symmetry: (C Q E) Set the symmetry option on or off  When queried, returns an int
    for the option
    :type symmetry: int
    :param tolerance: (C Q E) Set the tolerance of reflection  When queried, returns a float of
    the tolerance
    :type tolerance: float
    :param topoSymmetry: (C Q E) Enable/disable topological symmetry  When enabled, the
    supplied component/active list will be used to define the topological symmetry seam  When
    quer
    :type topoSymmetry: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def SetShrinkWrapInnerObject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorClipLoopToggle(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def editor(*args, control=True, defineTemplate="", docTag="", exists=True, filter="",
           forceMainConnection="", highlightConnection="", lockMainConnection=True,
           mainListConnection="", panel="", parent="", selectionConnection="", stateString=True,
           unParent=True, unlockMainConnection=True, updateMainConnection=True, useTemplate="",
           q=True, query=True, e=True, edit=True, **kwargs):
    """
    Edit the characteristic of an editor
    
    :param control: (Q) Query only  Returns the top level control for this editor  Usually used
    for getting a parent to attach popup menus  Caution: It is possible for an ed
    :type control: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Attaches a tag to the editor
    :type docTag: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param filter: (C Q E) Specifies the name of an itemFilter object to be used with this
    editor  This filters the information coming onto the main list of the editor
    :type filter: string
    :param forceMainConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type forceMainConnection: string
    :param highlightConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its highlight list  Not all editors have a highlight list 
    F
    :type highlightConnection: string
    :param lockMainConnection: (C E) Locks the current list of objects within the
    mainConnection, so that only those objects are displayed within the editor  Further changes
    to the origi
    :type lockMainConnection: boolean
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type mainListConnection: string
    :param panel: (C Q) Specifies the panel for this editor  By default if an editor is created
    in the create callback of a scripted panel it will belong to that panel  If a
    :type panel: string
    :param parent: (C Q E) Specifies the parent layout for this editor  This flag will only
    have an effect if the editor is currently un-parented
    :type parent: string
    :param selectionConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its own selection list  As the user selects things in this
    e
    :type selectionConnection: string
    :param stateString: (Q) Query only flag  Returns the MEL command that will create an editor
    to match the current editor state  The returned command string uses the string va
    :type stateString: boolean
    :param unParent: (C E) Specifies that the editor should be removed from its layout  This
    cannot be used in query mode
    :type unParent: boolean
    :param unlockMainConnection: (C E) Unlocks the mainConnection, effectively restoring the
    original mainConnection (if it is still available), and dynamic updates
    :type unlockMainConnection: boolean
    :param updateMainConnection: (C E) Causes a locked mainConnection to be updated from the
    orginal mainConnection, but preserves the lock state
    :type updateMainConnection: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: Name of the editor
    :rtype: string
    """
    pass


def RenderSetupWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def spring(*args, addSprings=True, allPoints=False, count=True, damping=0.2, dampingPS=0.2,
           endForceWeight=1.0, exclusive=False, length=0.0, maxDistance=0.0, minDistance=0.0,
           minMax=False, name="", noDuplicate=False, restLength=0.0, restLengthPS=0.0,
           startForceWeight=1.0, stiffness=1.0, stiffnessPS=1.0, useDampingPS=False,
           useRestLengthPS=False, useStiffnessPS=False, walkLength=0, wireframe=False, q=True,
           query=True, e=True, edit=True, **kwargs):
    """
    The spring command can do any of the following: * create a new spring object (shape plus
    transform)  The shape contains springs between the points (particles, cvs, etc.) of the
    objects selected or listed on the command line. * create new springs and add them to an
    existing spring object * edit or query certain attributes of an existing spring objec
    
    :param addSprings: (C) If specified, springs will be added to the existing selected set of
    springs  (Default is to create a new spring object.)
    :type addSprings: boolean
    :param allPoints: (C E) If True, sets the mode of spring application to All  This will add
    springs between all points selected  (Default is False.)
    :type allPoints: boolean
    :param count: (Q) Return the number of springs in the shape  Query-only  We maintain this
    flag only for compatibility with earlier versions of Maya  To get the count o
    :type count: boolean
    :param damping: (C Q E) Damping factor for the springs created in the spring object 
    (Default = 0.2 )
    :type damping: float
    :param dampingPS: (C Q E) Damping factor for the springs created in the spring object  This
    will initialize all the entries in dampingPS to the specified value  In both the fl
    :type dampingPS: float
    :param endForceWeight: (C Q E) Amount of the force of the spring that gets applied to the
    point to which the spring ends  Valid range is from 0.0 to 1.0  (Default = 1.0 )
    :type endForceWeight: float
    :param exclusive: (C) If true, tells the command to create springs only between pairs of
    points which are not in the same object  (Default is False.)
    :type exclusive: boolean
    :param length: (C Q E) Vestigial form of "restLength." Please use "restLength" instead
    :type length: float
    :param maxDistance: (C E) Maximum distance between two points that a spring would be
    considered
    :type maxDistance: float
    :param minDistance: (C) Minimum distance between two points that a spring would be
    considered  (Default = 0.0  See Defaults for more information on this flag's default.)
    :type minDistance: float
    :param minMax: (C) If True, sets the mode of the spring application to Min/Max  This will
    add springs between all points from the specified point groups that are betwee
    :type minMax: boolean
    :param name: (C Q) Name of spring object
    :type name: string
    :param noDuplicate: (C) Check for existing springs and don't add a new spring between two
    points already connected by a spring in the same object  Only the object the comman
    :type noDuplicate: boolean
    :param restLength: (C Q E) Per-object rest length for the new springs  Springs can use
    either their per-object or per-spring rest length  See the -lPS and -ulp flags
    :type restLength: float
    :param restLengthPS: (C Q E) Per-spring rest length for the new springs  This will
    initialize all the entries in restLengthPS to the specified value  If this flag is not
    thrown,
    :type restLengthPS: float
    :param startForceWeight: (C Q E) Amount of the force of the spring that gets applied to the
    point from which the spring starts  Valid range is from 0.0 to 1.0  (Default = 1.0 )
    :type startForceWeight: float
    :param stiffness: (C Q E) Stiffness of the springs created in the spring object  (Default =
    1.0 ) -damp float Vestigial form of "damping." Please use "damping" instead
    :type stiffness: float
    :param stiffnessPS: (C Q E) Stiffness of the springs created in the spring object  This
    will initialize all the entries in stiffnessPS to the specified value  In both the flag a
    :type stiffnessPS: float
    :param useDampingPS: (C Q E) Specifies whether to use dampingPS (per spring damping)  If
    set to false, the per object damping attribute value will be used  This flag simply sets
    :type useDampingPS: boolean
    :param useRestLengthPS: (C Q E) Specifies whether to use restLengthPS (per spring
    restLength)  If set to false, the per object restLength attribute value will be used  This
    flag sim
    :type useRestLengthPS: boolean
    :param useStiffnessPS: (C Q E) Specifies whether to use stiffnessPS (per spring stiffness) 
    If set to false, the per object stiffness attribute value will be used  This flag simply
    :type useStiffnessPS: boolean
    :param walkLength: (C) This flag is valid only when doing wireframe creation  It will
    create springs between pairs of points connected by the specified number of edges  For
    :type walkLength: int
    :param wireframe: (C) If True, sets the mode of the spring application to Wireframe  This
    is valid only for springs created on a soft body  It will add springs along all e
    :type wireframe: boolean
    
    :returns: Command result
    :rtype: string
    """
    pass


def transformCompare(*args, root=True, **kwargs):
    """
    Compares two transforms passed as arguments  If they are the same, returns 0  If they are
    different, returns 1  If no transforms are specified in the command line, then the
    transforms from the active list are used
    
    :param root: (C) Compare the root only, rather than the entire hierarchy below the roots
    :type root: boolean
    
    :returns: 0 if successful, 1 if transform1 and transform2 are not determined to be equal.
    :rtype: int
    """
    pass


def InteractiveSplitToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PreviousManipulatorHandle(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CopyKeys(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowMeshRepeatToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polySplit(*args, adjustEdgeFlow=0.0, detachEdges=True, edgepoint=None, facepoint=None,
              insertWithEdgeFlow=True, insertpoint=None, projectedCurve=None,
              projectedCurveTolerance=0.0, smoothingangle=0.0, subdivision=1,
              constructionHistory=True, name="", q=True, query=True, e=True, edit=True,
              **kwargs):
    """
    Split facets/edges of a polygonal object   The first and last arguments must be edges 
    Intermediate points may lie on either a shared face or an edge which neighbors the previous
    point
    
    :param adjustEdgeFlow: (C Q E) The weight value of the edge vertices to be positioned
    :type adjustEdgeFlow: float
    :param detachEdges: (C) Value of the detachEdges attribute for the resulting poly split
    node
    :type detachEdges: boolean
    :param edgepoint: (C M) The given edge is split into two new edges by inserting a new
    vertex located the given percentage along the edge  Note: This flag is not recommended
    :type edgepoint: [int, float]
    :param facepoint: (C M) A new vertex is inserted, lying at the given coordinates inside the
    given face  Coordinates are given in the local object space  Note: This flag is n
    :type facepoint: [int, float, float, float]
    :param insertWithEdgeFlow: (C Q E) True to enable edge flow  Otherwise, the edge flow is
    disabled
    :type insertWithEdgeFlow: boolean
    :param insertpoint: (C M) This flag allows the caller to insert a new vertex into an edge
    or a face  To insert a new vertex in an edge, pass the index of the edge and a percen
    :type insertpoint: [int, float, [, float, float, ]]
    :param projectedCurve: (C M) Curves to be projected
    :type projectedCurve: name
    :param projectedCurveTolerance: (C) Tolerance for curve projection
    :type projectedCurveTolerance: float
    :param smoothingangle: (C) Subdivide new edges will be soft if less then this angle  C:
    Default is 0.0
    :type smoothingangle: float
    :param subdivision: (C Q E) Subdivide new edges into the given number of sections  Edges
    involving free points won't be subdivided  C: Default is 1 (no subdivision)  Q: When que
    :type subdivision: int
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    
    :returns: The node name.
    :rtype: string
    """
    pass


def SetFluidAttrFromCurveOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MoveRotateScaleToolToggleSnapRelativeMode(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CurveEditTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def keyframeRegionDollyCtx(*args, exists=True, history=True, image1="", image2="", image3="",
                           name="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command can be used to create a dolly context for the dope sheet editor
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: Context name
    :rtype: string
    """
    pass


def BrushPresetBlendShapeOff(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyColorBlindData(*args, aboveMaxColorBlue=0.0, aboveMaxColorGreen=0.0,
                       aboveMaxColorRed=0.0, attrName="", belowMinColorBlue=0.0,
                       belowMinColorGreen=0.0, belowMinColorRed=0.0, clashColorBlue=0.0,
                       clashColorGreen=0.0, clashColorRed=0.0, colorBlue=0.0, colorGreen=0.0,
                       colorRed=0.0, dataType="", enableFalseColor=True, maxColorBlue=0.0,
                       maxColorGreen=0.0, maxColorRed=0.0, maxValue=0.0, minColorBlue=0.0,
                       minColorGreen=0.0, minColorRed=0.0, minValue=0.0, mode=0,
                       noColorBlue=0.0, noColorGreen=0.0, noColorRed=0.0, numIdTypes=0,
                       queryMode=True, typeId=0, useMax=True, useMin=True, value="", **kwargs):
    """
    This command applies false color to the selected polygonal components and objects,
    depending on whether or not blind data exists for the selected components (or, in the case
    of poly objects, dynamic attributes), and, depending on the color mode indicated, what the
    values are  It is possible to color objects based on whether or not the data exists, 
    
    :param aboveMaxColorBlue: (C M) Specifies blue component of color to use for data that is
    above max
    :type aboveMaxColorBlue: float
    :param aboveMaxColorGreen: (C M) Specifies green component of color to use for data that is
    above max
    :type aboveMaxColorGreen: float
    :param aboveMaxColorRed: (C M) Specifies red component of color to use for data that is
    above max
    :type aboveMaxColorRed: float
    :param attrName: (C M) Specifies the name of the data that is being examined by this
    command
    :type attrName: string
    :param belowMinColorBlue: (C M) Specifies blue component of color to use for data that is
    below min
    :type belowMinColorBlue: float
    :param belowMinColorGreen: (C M) Specifies green component of color to use for data that is
    below min
    :type belowMinColorGreen: float
    :param belowMinColorRed: (C M) Specifies red component of color to use for data that is
    below min
    :type belowMinColorRed: float
    :param clashColorBlue: (C) Specifies blue component color to use for data which clashes
    :type clashColorBlue: float
    :param clashColorGreen: (C) Specifies green component color to use for data which clashes
    :type clashColorGreen: float
    :param clashColorRed: (C) Specifies red component color to use for data which clashes
    :type clashColorRed: float
    :param colorBlue: (C M) Specifies blue component of color to use for given data
    :type colorBlue: float
    :param colorGreen: (C M) Specifies green component of color to use for given data
    :type colorGreen: float
    :param colorRed: (C M) Specifies red component of color to use for given data
    :type colorRed: float
    :param dataType: (C M) Specifies the type for this id
    :type dataType: string
    :param enableFalseColor: (C) Turns false coloring on or off for all poly objects in the
    scene
    :type enableFalseColor: boolean
    :param maxColorBlue: (C M) Specifies blue component of color to use for max value for
    grayscale
    :type maxColorBlue: float
    :param maxColorGreen: (C M) Specifies green component of color to use for max value for
    grayscale
    :type maxColorGreen: float
    :param maxColorRed: (C M) Specifies red component of color to use for max value for
    grayscale
    :type maxColorRed: float
    :param maxValue: (C M) Specifies the max value for grayscale or discrete range data
    :type maxValue: float
    :param minColorBlue: (C M) Specifies blue component of color to use for min value for
    grayscale
    :type minColorBlue: float
    :param minColorGreen: (C M) Specifies green component of color to use for min value for
    grayscale
    :type minColorGreen: float
    :param minColorRed: (C M) Specifies red component of color to use for min value for
    grayscale
    :type minColorRed: float
    :param minValue: (C M) Specifies the min value for grayscale or discrete range data
    :type minValue: float
    :param mode: (C M) Specifies the mode: 0 : binary - only components and objects that have
    the data will be colored 1 : discrete value - a value is specified  Data that
    :type mode: int
    :param noColorBlue: (C) Specifies blue component of color to use for no data assigned
    :type noColorBlue: float
    :param noColorGreen: (C) Specifies green component of color to use for no data assigned
    :type noColorGreen: float
    :param noColorRed: (C) Specifies red component of color to use for no data assigned
    :type noColorRed: float
    :param numIdTypes: (C M) Specifies how many attrs are in this id type
    :type numIdTypes: int
    :param queryMode: (C) If on, do not color and return selection as string array instead  Any
    data that would be colored normally (except for 'no color' and out of range col
    :type queryMode: boolean
    :param typeId: (C M) Specifies the typeId of the BlindData type being created
    :type typeId: int
    :param useMax: (C M) Specifies whether the max should be used for discrete ranges
    :type useMax: boolean
    :param useMin: (C M) Specifies whether the min should be used for discrete ranges
    :type useMin: boolean
    :param value: (C M) The value of the data
    :type value: string
    
    :returns: Command result
    :rtype: string[]
    """
    pass


def RelaxInitialState(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetKeyVertexColor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CancelBatchRender(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportColladaTriangulate(*args, **kwargs):
    """
    
    """
    pass


def dR_modeMulti(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeRevertSelectedSwatches(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_viewXrayTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_selConstraintOff(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExportSkinWeightMaps(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyMoveEdge(*args, caching=True, constructionHistory=True, gain=1.0, localCenter=0,
                 localDirection=None, localDirectionX=0.0, localDirectionY=0.0,
                 localDirectionZ=0.0, localRotate=None, localRotateX=0.0, localRotateY=0.0,
                 localRotateZ=0.0, localScale=None, localScaleX=0.0, localScaleY=0.0,
                 localScaleZ=0.0, localTranslate=None, localTranslateX=0.0, localTranslateY=0.0,
                 localTranslateZ=0.0, name="", nodeState=0, pivot=None, pivotX=0.0, pivotY=0.0,
                 pivotZ=0.0, random=0.0, rotate=None, rotateX=0.0, rotateY=0.0, rotateZ=0.0,
                 scale=None, scaleX=0.0, scaleY=0.0, scaleZ=0.0, translate=None, translateX=0.0,
                 translateY=0.0, translateZ=0.0, worldSpace=True, q=True, query=True, e=True,
                 edit=True, **kwargs):
    """
    Modifies edges of a polygonal object  Translate, move, rotate or scale edges
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param gain: (C Q E M) Gain factor per component  Can be painted using Artisan  Default:
    1.0
    :type gain: float
    :param localCenter: (C Q E) Local center on the edge : 0=Middle point, 1=Start point, 2=End
    point  Default: 0
    :type localCenter: int
    :param localDirection: (C Q E) Direction to determine X axis for local space  Default: 1.0,
    0.0, 0.0
    :type localDirection: [float, float, float]
    :param localDirectionX: (C Q E) X coord of the X axis
    :type localDirectionX: float
    :param localDirectionY: (C Q E) Y coord of the X axis
    :type localDirectionY: float
    :param localDirectionZ: (C Q E) Z coord of the X axis
    :type localDirectionZ: float
    :param localRotate: (C Q E) The local rotations  Default: 0.0, 0.0, 0.0
    :type localRotate: [float, float, float]
    :param localRotateX: (C Q E) Local rotate X coord  The range is [0, 360]
    :type localRotateX: float
    :param localRotateY: (C Q E) Local rotate Y coord  The range is [0, 360]
    :type localRotateY: float
    :param localRotateZ: (C Q E) Local rotate Z coord : Rotation along the normal  The range is
    [0, 360]
    :type localRotateZ: float
    :param localScale: (C Q E) Local Scale  Default: 1.0, 1.0, 1.0
    :type localScale: [float, float, float]
    :param localScaleX: (C Q E) Scale X coord
    :type localScaleX: float
    :param localScaleY: (C Q E) Scale Y coord
    :type localScaleY: float
    :param localScaleZ: (C Q E) Scale Z coord
    :type localScaleZ: float
    :param localTranslate: (C Q E) Local translate  Default: 0.0, 0.0, 0.0
    :type localTranslate: [float, float, float]
    :param localTranslateX: (C Q E) Local translation X coord
    :type localTranslateX: float
    :param localTranslateY: (C Q E) Local translation Y coord
    :type localTranslateY: float
    :param localTranslateZ: (C Q E) Local translation Z coord : Move along the normal
    :type localTranslateZ: float
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param pivot: (C Q E) The pivot for scaling and rotation  Default: 0.0, 0.0, 0.0
    :type pivot: [float, float, float]
    :param pivotX: (C Q E) Pivot X coord
    :type pivotX: float
    :param pivotY: (C Q E) Pivot Y coord
    :type pivotY: float
    :param pivotZ: (C Q E) Pivot Z coord
    :type pivotZ: float
    :param random: (C Q E) Random value for all parameters  Default: 0.0
    :type random: float
    :param rotate: (C Q E) Rotation angles around X, Y, Z  Default: 0.0, 0.0, 0.0
    :type rotate: [float, float, float]
    :param rotateX: (C Q E) Rotation angle around X
    :type rotateX: float
    :param rotateY: (C Q E) Rotation angle around Y
    :type rotateY: float
    :param rotateZ: (C Q E) Rotation angle around Z
    :type rotateZ: float
    :param scale: (C Q E) Scaling vector  Default: 1.0, 1.0, 1.0
    :type scale: [float, float, float]
    :param scaleX: (C Q E) Scale X coord
    :type scaleX: float
    :param scaleY: (C Q E) Scale Y coord
    :type scaleY: float
    :param scaleZ: (C Q E) Scale Z coord
    :type scaleZ: float
    :param translate: (C Q E) Translation vector  Default: 0.0, 0.0, 0.0
    :type translate: [float, float, float]
    :param translateX: (C Q E) Translation X coord
    :type translateX: float
    :param translateY: (C Q E) Translation Y coord
    :type translateY: float
    :param translateZ: (C Q E) Translation Z coord
    :type translateZ: float
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def lightList(*args, add=None, remove=None, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Add/Remove a relationship between an object and the current light  Soon to be replaced by
    the connect-attribute command
    
    :param add: (C) add object(s) to light list
    :type add: name
    :param remove: (C) remove object(s) to light list
    :type remove: name
    
    :returns: 
    :rtype: None
    """
    pass


def distanceDimension(*args, endPoint=None, startPoint=None, **kwargs):
    """
    This command is used to create a distance dimension to display the distance between two
    specified points
    
    :param endPoint: (C) Specifies the point to measure distance to, from the startPoint
    :type endPoint: [float, float, float]
    :param startPoint: (C) Specifies the point to start measuring distance from
    :type startPoint: [float, float, float]
    
    :returns: - the shape name of the DAG node created.
    :rtype: string
    """
    pass


def CreateShrinkWrap(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetMeshSmoothTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeGraphUpstream(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgPreRendering(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ArtPaintSelectToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetAsCombinationTarget(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def makebot(*args, checkdepends=True, checkres=0, input="", nooverwrite=True, output="",
            verbose=True, **kwargs):
    """
    The makebot command takes an image file and produces a block ordered texture (BOT) file, to
    be used for texture caching  If a relative pathname is specified for the input image file,
    project management rules apply  If a relative pathname is specified for the output BOT file,
    project management rules apply and gets put into the sourceImages director
    
    :param checkdepends: (C) the BOT file should only be generated if it doesn't already exists,
    or if it is older than the source file
    :type checkdepends: boolean
    :param checkres: (C) the BOT file should only be generated if its resolution (maximum of
    width and height) is larger than the minimum value specified by the argument
    :type checkres: int
    :param input: (C) input image file
    :type input: string
    :param nooverwrite: (C) If -c and/or -r indicate that the BOT file should be generated but
    if already exists, then this flag will prevent the file from being overwritten
    :type nooverwrite: boolean
    :param output: (C) output BOT file
    :type output: string
    :param verbose: (C) Makebot will provide feedback if this flag is specified
    :type verbose: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def RefineSelectedComponents(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_targetWeldRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectAllDynamicConstraints(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def resourceManager(*args, nameFilter="", saveAs=None, **kwargs):
    """
    List resources matching certain properties
    
    :param nameFilter: (C) List only resources matching the name  Argument may contain ? and *
    characters
    :type nameFilter: string
    :param saveAs: (C) Saves a copy of the resource (first parameter) as a separate file
    (second parameter)
    :type saveAs: [string, string]
    
    :returns: 
    :rtype: None
    """
    pass


def FBXLoadExportPresetFile(*args, **kwargs):
    """
    
    """
    pass


def HypershadeDeleteAllUtilities(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddToCurrentSceneMotionBuilder(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def EnterEditMode(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AttachSubdivSurfaceOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_setRelaxAffectsAuto(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def artAttrTool(*args, exists="", remove="", q=True, query=True, **kwargs):
    """
    The artAttrTool command manages the list of tool types which are used for attribute
    painting  This command supports querying the list contents as well as adding new tools to
    the list  Note that there is a set of built-in tools  The list of built-ins can be queried
    by starting Maya and doing an "artAttrTool -q"   The tools which are managed by this
    
    
    :param exists: (C Q) Checks if the named tool exists, returning true if found, and false
    otherwise
    :type exists: string
    :param remove: (C) Removes the named tool from the internal list of tools
    :type remove: string
    
    :returns: 
    :rtype: None
    """
    pass


def PaintOperationMarkingMenuRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def emit(*args, attribute="", floatValue=0.0, object="", position=None, vectorValue=None,
         **kwargs):
    """
    The emit action allows users to add particles to an existing particle object without the
    use of an emitter  At the same time, it allows them to set any per-particle attribute for
    the particles that are created with the action. The particles created do not become a part
    of the initial state for the particle object, and will disappear when the scene 
    
    :param attribute: (C M) Specifies the attribute on the particle object that any value flags
    following it and before the next -attribute flag will be associated with  The sam
    :type attribute: string
    :param floatValue: (C M) Sets the float value to be used for the "current" attribute of the
    "current" particle  By current attribute, it is meant the attribute specified by t
    :type floatValue: float
    :param object: (C) This flag takes the name of a particleShape or the transform directly
    above it in the DAG as its parent  It specifies which object to add the particl
    :type object: string
    :param position: (C M) Specifies the positions in the particle object's space (usually
    world space) where the particles are to be created  One particle is created for each
    :type position: [float, float, float]
    :param vectorValue: (C M) Sets the vector value to be used for the "current" attribute of
    the "current" particle  By current attribute, it is meant the attribute specified by
    :type vectorValue: [float, float, float]
    
    :returns: Integer array containing the list of the particleId attribute values
    for the
    created particles in the same order that the position flags
    were passed.
    :rtype: int[]
    """
    pass


def SmoothProxy(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def trim(*args, caching=True, locatorU=0.5, locatorV=0.5, nodeState=0, selected=0, shrink=False,
         tolerance=0.001, constructionHistory=True, name="", object=True, q=True, query=True,
         e=True, edit=True, **kwargs):
    """
    This command trims a surface to its curves on surface by first splitting the surface and
    then selecting which regions to keep or discard
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param locatorU: (C Q E M) u parameter value to position a locator on the surface  Default:
    0.5
    :type locatorU: float
    :param locatorV: (C Q E M) v parameter value to position a locator on the surface  Default:
    0.5
    :type locatorV: float
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param selected: (C Q E) Specify whether to keep or discard selected regions  Default: 0
    :type selected: int
    :param shrink: (C Q E) If true, shrink underlying surface to outer boundaries of trimmed
    surface  Default: false
    :type shrink: boolean
    :param tolerance: (C Q E) The tolerance with which to trim  Default: 0.001
    :type tolerance: float
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    
    :returns: Object name and node name.
    :rtype: string[]
    """
    pass


def loadModule(*args, allModules=True, load="", scan=True, **kwargs):
    """
    Maya plug-ins may be installed individually within one of Maya's standard plug-in
    directories, or they may be packaged up with other resources in a "module"  Each module
    resides in its own directory and provides a module definition file to make Maya aware of
    the plug-ins it provides  When Maya starts up it loads all of the module files it finds,
    ma
    
    :param allModules: (C) Load all new modules not yet loaded in Maya  New modules are the one
    returned by the -scan option
    :type allModules: boolean
    :param load: (C) Load the module specified by the module definition file
    :type load: string
    :param scan: (C) Rescan module presence  Returns the list of module definition files found
    and not yet loaded into Maya  Does not load any of these newly found module
    :type scan: boolean
    
    :returns: Command result
    :rtype: string[]
    """
    pass


def ExportDeformerWeights(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def graphSelectContext(*args, exists=True, image1="", image2="", image3="", q=True, query=True,
                       e=True, edit=True, **kwargs):
    """
    This command can be used to create a selection context for the hypergraph editor
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    
    :returns: Command result
    :rtype: string
    """
    pass


def Create3DContainerEmitterOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MergeCharacterSet(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorGraphClearGraph(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyMapSewMove(*args, caching=True, constructionHistory=True, limitPieceSize=True, name="",
                   nodeState=0, numberFaces=0, uvSetName="", worldSpace=True, q=True,
                   query=True, e=True, edit=True, **kwargs):
    """
    This command can be used to Move and Sew together separate UV pieces along geometric edges 
    UV pieces that correspond to the same geometric edge, are merged together by moving the
    smaller piece to the larger one.
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param limitPieceSize: (C Q E) When on, this flag specifies that the face number limit
    described above should be used
    :type limitPieceSize: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param numberFaces: (C Q E) Maximum number of faces in a UV piece  When trying to combine
    two UV pieces into a single one, the merge operation is rejected if the smaller piece h
    :type numberFaces: int
    :param uvSetName: (C) Name of the UV set to be created
    :type uvSetName: string
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def BrushPresetReplaceShading(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def viewClipPlane(*args, autoClipPlane=True, farClipPlane=0.0, nearClipPlane=0.0,
                  surfacesOnly=True, q=True, query=True, **kwargs):
    """
    The viewClipPlane command can be used to query or set a camera's clip planes  If a camera
    is not specified, the camera in the active view will be used  The near and far clip plane
    flags may be used in conjunction with the auto clip plane flag
    
    :param autoClipPlane: (C Q) Compute the clip planes such that all object's in the camera's
    viewing frustum will be visible
    :type autoClipPlane: boolean
    :param farClipPlane: (C Q) Set or query the far clip plane
    :type farClipPlane: float
    :param nearClipPlane: (C Q) Set or query the near clip plane
    :type nearClipPlane: float
    :param surfacesOnly: (C) This flag is to be used in conjunction with the auto clip plane
    flag  Only the bounding boxes of surfaces will be used to compute the camera's clippi
    :type surfacesOnly: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def ChamferVertexOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def InsertKeysTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetKeyTranslate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateSoftBody(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeOpenUVEditorWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def iconTextButton(*args, align="", annotation="", backgroundColor=None, command=None,
                   commandRepeatable=True, defineTemplate="", disabledImage="", docTag="",
                   doubleClickCommand=None, dragCallback=None, dropCallback=None, enable=True,
                   enableBackground=True, enableKeyboardFocus=True, exists=True, flat=True,
                   flipX=True, flipY=True, font="", fullPathName=True,
                   handleNodeDropCallback=None, height=0, highlightColor=None,
                   highlightImage="", image="", image1="", image2="", image3="",
                   imageOverlayLabel="", isObscured=True, label="", labelEditingCallback=None,
                   labelOffset=0, ltVersion="", manage=True, marginHeight=0, marginWidth=0,
                   noBackground=True, numberOfPopupMenus=True, overlayLabelBackColor=None,
                   overlayLabelColor=None, parent="", popupMenuArray=True, preventOverride=True,
                   rotation=0.0, scaleIcon=True, selectionImage="", sourceType="",
                   statusBarMessage="", style="", useAlpha=True, useTemplate="", version="",
                   visible=True, visibleChangeCommand=None, width=0, q=True, query=True, e=True,
                   edit=True, **kwargs):
    """
    This control supports up to 3 icon images and 4 different display styles  The icon image
    displayed is the one that best fits the current size of the control given its current style
      This command creates an iconTextButton that can be displayed with different icons, with
    or without accompanying text label  When an argument is passed, it is used to g
    
    :param align: (C Q E) The label alignment  Alignment values are "left", "right", and
    "center"  By default, the label is aligned "center"  Currently only available when -st
    :type align: string
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param command: (C Q E) Command executed when the control is pressed
    :type command: script
    :param commandRepeatable: (C Q E) Set if the MEL command specified in the command flag
    should be repeatable or not  The "g" key, by default, is the shortcut to repeat the last
    execute
    :type commandRepeatable: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param disabledImage: (C Q E) Image used when the button is disabled  Image size must be
    the same as the image specified with the i/image flag  This is a Windows only flag
    :type disabledImage: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param doubleClickCommand: (C Q E) Command executed when the control is double clicked
    :type doubleClickCommand: script
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param flat: (C Q E) Sets whether the control will be a flat button (0 false, 1 true)
    :type flat: boolean
    :param flipX: (C Q E) Is the image flipped horizontally?
    :type flipX: boolean
    :param flipY: (C Q E) Is the image flipped vertically?
    :type flipY: boolean
    :param font: (C Q E) The font for the text  Valid values are "boldLabelFont",
    "smallBoldLabelFont", "tinyBoldLabelFont", "plainLabelFont", "smallPlainLabelFont",
    "oblique
    :type font: string
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param handleNodeDropCallback: (C E) Specify a script callback which is called when a node
    is dropped on the control  The name of the node being dropped will be passed to the
    function (p
    :type handleNodeDropCallback: script
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param highlightImage: (C Q E) Highlight image displayed while the cursor is over the
    control  Image size must be the same as the image specified with the -i/image flag  This is
    a
    :type highlightImage: string
    :param image: (C Q E) If you are not providing images with different sizes then you may use
    this flag for the control's image  If the "iconOnly" style is set, the icon wil
    :type image: string
    :param image1: (C Q E) First of three possible icons  The icon that best fits the current
    size of the control will be displayed
    :type image1: string
    :param image2: (C Q E) Second of three possible icons  The icon that best fits the current
    size of the control will be displayed
    :type image2: string
    :param image3: (C Q E) Third of three possible icons  The icon that best fits the current
    size of the control will be displayed
    :type image3: string
    :param imageOverlayLabel: (C Q E) A short string, up to 6 characters, representing a label
    that will be displayed on top of the image
    :type imageOverlayLabel: string
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) The text that appears in the control
    :type label: string
    :param labelEditingCallback: (C E) Specify a callback which is called after the user double
    clicks the label of the control to give it a new label  The new label string will be
    passed
    :type labelEditingCallback: script
    :param labelOffset: (C Q E) The label offset  Default is 0  Currently only available when
    -st/style is set to "iconAndTextCentered"
    :type labelOffset: int
    :param ltVersion: (C Q E) This flag is used to specify the Maya LT version that this
    control feature was introduced, if the version flag is not specified, or if the version fl
    :type ltVersion: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param marginHeight: (C Q E) The number of pixels above and below the control content  The
    default value is 1 pixel
    :type marginHeight: int
    :param marginWidth: (C Q E) The number of pixels on either side of the control content  The
    default value is 1 pixel
    :type marginWidth: int
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param overlayLabelBackColor: (C Q E) The RGBA color of the shadow behind the label defined
    by imageOverlayLabel  Default is 50% transparent black: 0 0 0 .5
    :type overlayLabelBackColor: [float, float, float, float]
    :param overlayLabelColor: (C Q E) The RGB color of the label defined by imageOverlayLabel 
    Default is a light grey: .8 .8 .8
    :type overlayLabelColor: [float, float, float]
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rotation: (C Q E) The rotation value of the image in radians
    :type rotation: float
    :param scaleIcon: (C E) For "textOnly" and "iconOnly" style, this flag has no effect  For
    other styles, if the flag is specified, the icon will be scaled to the size of the
    :type scaleIcon: boolean
    :param selectionImage: (C Q E) Image displayed while the control is selected  Image size
    must be the same as the image specified with the -i/image flag  This is a Windows only
    flag
    :type selectionImage: string
    :param sourceType: (C Q E) Sets the language type for the command script  Can only be used
    in conjunction with the c/command or dcc/doubleClickCommand flags  Valid values are "
    :type sourceType: string
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param style: (C Q E) The draw style of the control  Valid styles are "iconOnly",
    "textOnly", "iconAndTextHorizontal", "iconAndTextVertical", and "iconAndTextCentered"  (N
    :type style: string
    :param useAlpha: (C Q E) Is the image using alpha channel?
    :type useAlpha: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param version: (C Q E) Specify the version that this control feature was introduced  The
    argument should be given as a string of the version number (e.g  "2013", "2014")  C
    :type version: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the iconTextButton.
    :rtype: string
    """
    pass


def polyPlatonicSolid(*args, axis=None, caching=True, constructionHistory=True, createUVs=4,
                      name="", nodeState=0, object=True, radius=1.0, sideLength=1.0,
                      solidType=0, texture=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The polyPlatonicSolid command creates a new polygonal platonic solid
    
    :param axis: (C Q E) This flag specifies the primitive axis used to build the platonic
    solid  Q: When queried, this flag returns a float[3]
    :type axis: [float, float, float]
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param createUVs: (C) This flag alows a specific UV mechanism to be selected, while
    creating  The valid values are 0, 1, 2 ,3 or 4  0 implies that no UVs will be generated
    :type createUVs: int
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param object: (C) Create the result, or just the dependency node (where applicable)
    :type object: boolean
    :param radius: (C Q E) This flag specifies the radius of the platonic solid  C: Default is
    1.0  Q: When queried, this flag returns a float
    :type radius: float
    :param sideLength: (C Q E) This flag specifies the side length of platonic solid  C:
    Default is 1.0  Q: When queried, this flag returns a float
    :type sideLength: float
    :param solidType: (C) This flag allows a specific platonic solid to be selected for
    creation of mesh, The valid values are 0, 1, 2 and 3  0 implies dodecahedron to be crea
    :type solidType: int
    :param texture: (C) This flag is obsolete and will be removed in the next release  The
    -cuv/createUVs flag should be used instead
    :type texture: int
    
    :returns: Object name and node name.
    :rtype: string[]
    """
    pass


def insertJoint(*args, **kwargs):
    """
    This command will insert a new joint under the given or selected joint  If the given joint
    has child joints, they will be reparented under the new inserted joint   The given joint(or
    selected joint) should not have skin attached  The command works on the selected joint  No
    options or flags are necessary
    
    
    :returns: The name of the new inserted joint
    :rtype: string
    """
    pass


def changeSubdivComponentDisplayLevel(*args, level=0, relative=True, q=True, query=True,
                                      **kwargs):
    """
    Explicitly forces the subdivision surface to display components at a particular level of
    refinement
    
    :param level: (C Q) Specifies the display level of components
    :type level: int
    :param relative: (C Q) If set, level refers to the relative display level
    :type relative: boolean
    
    :returns: Command result
    :rtype: int
    """
    pass


def SculptMeshDeactivateBrushStrength(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nodeEditor(*args, activeTab=0, addNewNodes=True, addNode="", additiveGraphingMode=True,
               allAttributes=True, allNodes=True, allowNewTabs=True, allowTabTearoff=True,
               autoSizeNodes=True, beginCreateNode=True, beginNewConnection="",
               breakSelectedConnections=True, closeAllTabs=True, closeTab=0,
               connectSelectedNodes=True, connectionMinSegment=0.0, connectionOffset=0.0,
               connectionRoundness=0.0, connectionStyle="", connectionTension=0,
               consistentNameSize=True, contentsChangedCommand=None, control=True,
               createInfo="", createNodeCommand=None, createTab=None,
               crosshairOnEdgeDragging=True, customAttributeListEdit=None, cycleHUD=True,
               defaultPinnedState=True, defineTemplate="", deleteSelected=True, docTag="",
               dotFormat="", downstream=True, duplicateTab=None, enableOpenGL=True, exists=True,
               extendToShapes=True, feedbackConnection=True, feedbackNode=True,
               feedbackPlug=True, feedbackTabIndex=True, feedbackType=True, filter="",
               filterCreateNodeTypes=None, focusCommand=None, forceMainConnection="",
               frameAll=True, frameModelSelection=True, frameSelected=True, getNodeList=True,
               graphSelectedConnections=True, graphSelection=True, gridSnap=True,
               gridVisibility=True, hasWatchpoint=True, highlightConnection="",
               highlightConnections=None, hudMessage=None, ignoreAssets=True, island=True,
               keyPressCommand=None, keyReleaseCommand=None, layout=True, layoutCommand=None,
               lockMainConnection=True, mainListConnection="", nodeSwatchSize="",
               nodeTitleMode="", nodeViewMode="", overrideNodeDropPosition=None, panView=None,
               panel="", parent="", pinSelectedNodes=True, popupMenuScript=None, primary=True,
               redockTab=True, removeDownstream=True, removeNode="", removeUnselected=True,
               removeUpstream=True, renameNode="", renameTab=None, restoreInfo="",
               restoreLastClosedTab=True, rootNode="", rootsFromSelection=True, scaleView=0.0,
               selectAll=True, selectConnectionNodes=True, selectDownstream=True,
               selectFeedbackConnection=True, selectNode="", selectUpstream=True,
               selectionConnection="", setWatchpoint=True, settingsChangedCallback=None,
               shaderNetworks=True, showAllNodeAttributes="", showNamespace=True,
               showSGShapes=True, showShapes=True, showTabs=True, showTransforms=True,
               stateString=True, syncedSelection=True, tabChangeCommand=None,
               toggleAttrFilter=True, toggleSelectedPins=True, toggleSwatchSize="",
               toolTipCommand=None, traversalDepthLimit=0, unParent=True,
               unlockMainConnection=True, updateMainConnection=True, upstream=True,
               useAssets=True, useTemplate="", q=True, query=True, e=True, edit=True,
               **kwargs):
    """
    This command creates/edits/queries a nodeEditor editor  The optional argument is the name
    of the control
    
    :param activeTab: (Q E) Gets/sets the index of the tab widget's (active) visible tab  Note:
    the index is zero-based
    :type activeTab: int
    :param addNewNodes: (C Q E) New nodes should be added to the graph, default is on
    :type addNewNodes: boolean
    :param addNode: (E M) Adds a specified node to the graph  Passing an empty string means the
    current model selection will be added to the graph
    :type addNode: string
    :param additiveGraphingMode: (C Q E) When enabled, the graphing will add node networks to
    the existing graph instead of replacing it
    :type additiveGraphingMode: boolean
    :param allAttributes: (C Q E) Attributes should not be filtered out of the graph, default
    is off
    :type allAttributes: boolean
    :param allNodes: (C Q E) Nodes should not be filtered out of the graph, default is off
    :type allNodes: boolean
    :param allowNewTabs: (Q) Query only  Returns whether this Node Editor is allowed to have
    new tabs added, either by creating a new tab or duplicating an existing one
    :type allowNewTabs: boolean
    :param allowTabTearoff: (C E) Control whether or not the tabs can be torn off and floated 
    Defaults to true
    :type allowTabTearoff: boolean
    :param autoSizeNodes: (C Q E) When enabled, default node widths will be dynamically
    determined by the node name length, default is on
    :type autoSizeNodes: boolean
    :param beginCreateNode: (E) Begin interactive node-creation at the mouse position  This
    will create a control which allows quick creation of a node in the editor  The actual cre
    :type beginCreateNode: boolean
    :param beginNewConnection: (E) Begin a new interactive connection at the given attribute
    :type beginNewConnection: string
    :param breakSelectedConnections: (E) Break the selected attribute connections
    :type breakSelectedConnections: boolean
    :param closeAllTabs: (E) Close all tabs on the tab widget
    :type closeAllTabs: boolean
    :param closeTab: (E) Closes the tab on the tab widget at the specified index  Note: using
    this flag on a torn-off tab will close the node editor since there can be only a
    :type closeTab: int
    :param connectSelectedNodes: (E) Creates a connection between all selected nodes in the
    editor  The default output port of one node is connected to the default input port of the
    next
    :type connectSelectedNodes: boolean
    :param connectionMinSegment: (Q E) Sets the minimum segment length ratio of the connection
    leaving an output port  Applies to "straight", "corner" and "s-shape" connection styles 
    Valu
    :type connectionMinSegment: float
    :param connectionOffset: (Q E) Sets the offset length for each connection edges  Applies to
    "corner" and "s-shape" connection styles  Value must be between 0.0 and 1.0
    :type connectionOffset: float
    :param connectionRoundness: (Q E) Sets the roundness factor for each connection edges 
    Applies only to "s-shape" connection style  Value must be between 0.5 and 1.0
    :type connectionRoundness: float
    :param connectionStyle: (Q E) Sets how the connection between nodes are drawn  Mode values
    are: "bezier", "straight", "corner" and "s-shape"  In query mode, returns current connec
    :type connectionStyle: string
    :param connectionTension: (Q E) Sets where the vertical line should be drawn on connection
    edge, 0 being in the middle  Applies to "corner" and "s-shape" connection styles  Value mu
    :type connectionTension: int
    :param consistentNameSize: (C Q E) When enabled, the size of the node name will
    consistently match the current zoom level  When disabled, the node name size will remain
    the same after
    :type consistentNameSize: boolean
    :param contentsChangedCommand: (C Q E) Specifies a function to be called whenever the
    contents of the node editor changes
    :type contentsChangedCommand: script
    :param control: (Q) Query only  Returns the top level control for this editor  Usually used
    for getting a parent to attach popup menus  Caution: It is possible for an ed
    :type control: boolean
    :param createInfo: (C E) Creates or modifies a hyperGraphInfo network to save the state of
    the editor
    :type createInfo: string
    :param createNodeCommand: (C Q E) Specifies a function to be used to create nodes through
    the editor  The function will be passed the name of the chosen node type  This is used by
    the
    :type createNodeCommand: script
    :param createTab: (C E) Create a new tab inserting it into the tab widget at the specified
    index  If index is out of range (such as -1), the tab is simply appended  You can
    :type createTab: [int, [, string, ]]
    :param crosshairOnEdgeDragging: (C Q E) Toggle crosshair cursor during edge dragging
    on/off
    :type crosshairOnEdgeDragging: boolean
    :param customAttributeListEdit: (Q E) Create/Edit the custom attribute list for the given
    node by entering a special "Edit Mode" for the node  Note: only one node in the node editor
    can b
    :type customAttributeListEdit: [string, [, string, ]]
    :param cycleHUD: (C E) Change the HUD to the next state
    :type cycleHUD: boolean
    :param defaultPinnedState: (C Q E) Sets default pinned state of all nodes, 1 for pinned, 0
    for unpinned  default value 0
    :type defaultPinnedState: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param deleteSelected: (E) Delete the selected nodes and break the selected connections
    :type deleteSelected: boolean
    :param docTag: (C Q E) Attaches a tag to the editor
    :type docTag: string
    :param dotFormat: (Q E) In query mode: Get the graph information in DOT format  The flag
    argument specifies a file path to write to  If "-" is supplied, the data is returned
    :type dotFormat: string
    :param downstream: (C E) Include nodes that are downstream of the root nodes
    :type downstream: boolean
    :param duplicateTab: (C E) Duplicates the tab at the specified index, placing it at the
    second optional (Python only) specified index  To place duplicated tab at the end use -1
    :type duplicateTab: [int, [, int, ]]
    :param enableOpenGL: (C Q E) Specifies if OpenGL should be used to render the node editor
    view  When enabled this will greatly improve performance but is still a work in progress
    :type enableOpenGL: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param extendToShapes: (C Q E) Include child shapes for each selected transform
    :type extendToShapes: boolean
    :param feedbackConnection: (Q) Returns a description of the connection(s) at the current
    mouse position in the editor view, if any  The connection(s) will be returned as a list of
    :type feedbackConnection: boolean
    :param feedbackNode: (Q) Returns the name of the node at the current mouse position in the
    editor view, if any
    :type feedbackNode: boolean
    :param feedbackPlug: (Q) Returns the name of the plug (attribute) at the current mouse
    position in the editor view, if any
    :type feedbackPlug: boolean
    :param feedbackTabIndex: (Q) Returns the index of the tab at the current mouse position in
    the editor view, if any
    :type feedbackTabIndex: boolean
    :param feedbackType: (Q) Returns the most specific type of the feedback item (item at the
    current mouse position) in the editor view, if any  Will be one of "plug", "node", "
    :type feedbackType: boolean
    :param filter: (C Q E) Specifies the name of an itemFilter object to be used with this
    editor  This filters the information coming onto the main list of the editor
    :type filter: string
    :param filterCreateNodeTypes: (C Q E) Specifies a function to be used to filter the list of
    node types which appear in the inline-creation menu (tab key)  The function should accept
    one s
    :type filterCreateNodeTypes: script
    :param focusCommand: (C Q E) Specifies a function to be called whenever focus changes for
    the node editor
    :type focusCommand: script
    :param forceMainConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type forceMainConnection: string
    :param frameAll: (E) Frame all the contents of the node editor
    :type frameAll: boolean
    :param frameModelSelection: (E) Frame the current model selection
    :type frameModelSelection: boolean
    :param frameSelected: (E) Frame the selected contents of the node editor
    :type frameSelected: boolean
    :param getNodeList: (Q) Returns a list of all nodes displayed in the editor
    :type getNodeList: boolean
    :param graphSelectedConnections: (E) Graph the nodes connected by the selected attribute
    connections
    :type graphSelectedConnections: boolean
    :param graphSelection: (E) Graph the nodes that are currently selected
    :type graphSelection: boolean
    :param gridSnap: (C Q E) Toggle grid snapping on/off
    :type gridSnap: boolean
    :param gridVisibility: (C Q E) Toggle grid visiblity on/off
    :type gridVisibility: boolean
    :param hasWatchpoint: (Q) Returns if the selected connection has a watchpoint set
    :type hasWatchpoint: boolean
    :param highlightConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its highlight list  Not all editors have a highlight list 
    F
    :type highlightConnection: string
    :param highlightConnections: (C Q E M) Sets if selecting a node should highlight its
    connections for the specified editor, which can be "regular" or "bifrost"
    :type highlightConnections: [string, boolean]
    :param hudMessage: (E) Display the given message on the editor HUD  The flag arguments are
    (message, type, duration), where type is: upper-left corner  top center  upper-ri
    :type hudMessage: [string, int, float]
    :param ignoreAssets: (C Q E) Deprecated  Do not use in scripts
    :type ignoreAssets: boolean
    :param island: (Q E) Deprecated  Do not use in scripts
    :type island: boolean
    :param keyPressCommand: (C Q E) Specifies a function to be called when a key is pressed and
    the editor has focus  The function will be passed the name of the editor and an (uppercas
    :type keyPressCommand: script
    :param keyReleaseCommand: (C Q E) Specifies a function to be called when a key is released
    and the editor has focus  The function will be passed the name of the editor and an
    (upperca
    :type keyReleaseCommand: script
    :param layout: (E) Perform an automatic layout of the graph
    :type layout: boolean
    :param layoutCommand: (C Q E) Specifies a function to override the default action when a
    graph layout is required  The function will be passed the name of editor  The function sho
    :type layoutCommand: script
    :param lockMainConnection: (C E) Locks the current list of objects within the
    mainConnection, so that only those objects are displayed within the editor  Further changes
    to the origi
    :type lockMainConnection: boolean
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type mainListConnection: string
    :param nodeSwatchSize: (E) Sets the icon swatch size of selected nodes in the active scene
    (all nodes if none are selected)  Size values are "small" and "large"
    :type nodeSwatchSize: string
    :param nodeTitleMode: (C Q E) Gets/sets the node title display mode of the current scene 
    Mode values are: "name" (Display node names), "type" (Display node types), "none" (Do not
    :type nodeTitleMode: string
    :param nodeViewMode: (E) Sets the attribute view mode of selected nodes in the active scene
    (all nodes if none are selected)  Mode values are: "simple" (no attributes display
    :type nodeViewMode: string
    :param overrideNodeDropPosition: (E) Specifies the override position for new node  Values
    are respectively the width and height ratio; 0.0, 0.0 corresponds to the top left corner of
    the
    :type overrideNodeDropPosition: [float, float]
    :param panView: (E) Pan the view by the given amount  Arguments of 0 0 will reset the view
    translation
    :type panView: [float, float]
    :param panel: (C Q) Specifies the panel for this editor  By default if an editor is created
    in the create callback of a scripted panel it will belong to that panel  If a
    :type panel: string
    :param parent: (C Q E) Specifies the parent layout for this editor  This flag will only
    have an effect if the editor is currently un-parented
    :type parent: string
    :param pinSelectedNodes: (E) Pins or unpins the selected nodes  If no nodes are selected,
    this will apply to all displayed nodes
    :type pinSelectedNodes: boolean
    :param popupMenuScript: (C Q E) Set the script to be called to register the popup menu with
    the control for this editor  The script will be called with a string argument which gives
    :type popupMenuScript: script
    :param primary: (Q) Query only  Returns whether this node editor is the primary one  The
    primary editor is the only one that will show and allow tabs
    :type primary: boolean
    :param redockTab: (Q E) If this tab was torn-off from the primary node editor, then the tab
    and all its data will be re-docked back into the primary editor and this node edi
    :type redockTab: boolean
    :param removeDownstream: (E) Removes all items downstream to the currently active
    selection
    :type removeDownstream: boolean
    :param removeNode: (E M) Removes a node from the graph  An empty string indicates that
    currently selected nodes should be removed
    :type removeNode: string
    :param removeUnselected: (E) Removes unselected nodes from graph
    :type removeUnselected: boolean
    :param removeUpstream: (E) Removes all items upstream to the currently active selection
    :type removeUpstream: boolean
    :param renameNode: (E) Rename a node in the graph  Depending on the zoom level of the view,
    an edit field will either appear on the node item or in a popup dialog to allow
    :type renameNode: string
    :param renameTab: (E) Renames the tab at the specified index with the (optional) name  If
    no name is specified (Python only) or an empty string ("") is used then an inline
    :type renameTab: [int, [, string, ]]
    :param restoreInfo: (C E) Restores the editor state corresponding to supplied
    hyperGraphInfo node
    :type restoreInfo: string
    :param restoreLastClosedTab: (Q E) If this node editor is the primary one, then restore the
    last closed tab (if any)  In query mode returns whether there is a tab available to
    restore
    :type restoreLastClosedTab: boolean
    :param rootNode: (C E M) Add a node name as a root node of the graph  Passing an empty
    string clears the current root node list  When queried, returns the list of current roo
    :type rootNode: string
    :param rootsFromSelection: (C E) Specify that the root nodes for the graph should taken
    from the currently active selection
    :type rootsFromSelection: boolean
    :param scaleView: (E) Scales the graph view by the given factor  An argument of zero means
    reset to default
    :type scaleView: float
    :param selectAll: (E) Select all items in the graph
    :type selectAll: boolean
    :param selectConnectionNodes: (E) Select the nodes connected by the selected attribute
    connections
    :type selectConnectionNodes: boolean
    :param selectDownstream: (E) Select all items downstream to the currently active selection
    :type selectDownstream: boolean
    :param selectFeedbackConnection: (E) Select the feedback connection(s) in the editor view,
    if any
    :type selectFeedbackConnection: boolean
    :param selectNode: (Q E M) Select a node in the graph  Passing an empty string clears the
    current selection  When queried, returns the list of currently selected nodes
    :type selectNode: string
    :param selectUpstream: (E) Select all items upstream to the currently active selection
    :type selectUpstream: boolean
    :param selectionConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its own selection list  As the user selects things in this
    e
    :type selectionConnection: string
    :param setWatchpoint: (C E) Adds or removes the watchpoint on the selected connections
    :type setWatchpoint: boolean
    :param settingsChangedCallback: (C Q E) Specifies a function to be called whenever settings
    for the node editor get changed
    :type settingsChangedCallback: script
    :param shaderNetworks: (E) Graph the shader network for all the objects on the selection
    list that have shaders
    :type shaderNetworks: boolean
    :param showAllNodeAttributes: (E) Display all attributes for the given node, not just
    primary attributes  Passing an empty string will apply this to all currently selected nodes
     If n
    :type showAllNodeAttributes: string
    :param showNamespace: (C Q E) Specifies whether nodes will have their namespace displayed
    if they are not in the root namespace
    :type showNamespace: boolean
    :param showSGShapes: (C Q E) Show shapes that are connected to the network through a
    shading group
    :type showSGShapes: boolean
    :param showShapes: (C Q E) Show shape nodes
    :type showShapes: boolean
    :param showTabs: (C) Creation time flag to explicitly control the visibility of the tabs 
    If this is set to true or false the tabs visibility will respect that setting  I
    :type showTabs: boolean
    :param showTransforms: (C Q E) Show transforms
    :type showTransforms: boolean
    :param stateString: (Q) Query only flag  Returns the MEL command that will create an editor
    to match the current editor state  The returned command string uses the string va
    :type stateString: boolean
    :param syncedSelection: (C Q E) Keep the graph selection in sync with the model selection
    :type syncedSelection: boolean
    :param tabChangeCommand: (C E) Command executed when the current (active) tab is changed 
    Re-selecting the current tab will not invoke this command  NOTE: This command will also be
    :type tabChangeCommand: script
    :param toggleAttrFilter: (E) Toggles the display of the attribute filter field on selected
    nodes  If any of the selected nodes have the field displayed, this operation will hide
    :type toggleAttrFilter: boolean
    :param toggleSelectedPins: (E) Toggles pinned state on selected nodes  If any selected
    nodes are unpinned, this operation will choose to pin all nodes  If no nodes are selected,
    th
    :type toggleSelectedPins: boolean
    :param toggleSwatchSize: (E) Toggles the swatch size of the given node between small and
    large  If supplied node name was empty, this will be applied to selection, and if no node
    :type toggleSwatchSize: string
    :param toolTipCommand: (C Q E) Specifies a function to override the tooltip that is
    displayed for a node  The function will be passed the name of the node under the cursor,
    and sho
    :type toolTipCommand: script
    :param traversalDepthLimit: (C Q E) Specify the maximum number of edges which will be
    followed from any root node when building the graph  A negative value means unlimited 
    Default is u
    :type traversalDepthLimit: int
    :param unParent: (C E) Specifies that the editor should be removed from its layout  This
    cannot be used in query mode
    :type unParent: boolean
    :param unlockMainConnection: (C E) Unlocks the mainConnection, effectively restoring the
    original mainConnection (if it is still available), and dynamic updates
    :type unlockMainConnection: boolean
    :param updateMainConnection: (C E) Causes a locked mainConnection to be updated from the
    orginal mainConnection, but preserves the lock state
    :type updateMainConnection: boolean
    :param upstream: (C E) Include nodes that are upstream of the root nodes
    :type upstream: boolean
    :param useAssets: (C Q E) Use assets and published attributes instead of contents and
    actual attributes
    :type useAssets: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: The name of the created control.
    :rtype: string
    """
    pass


def CreateNURBSCylinderOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def LevelOfDetailGroup(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PostInfinityCycleOffset(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowMeshGrabUVToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PasteVertexSkinWeights(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def artAttrCtx(*args, accopacity=False, activeListChangedProc="", afterStrokeCmd="",
               alphaclamp="none", alphaclamplower=0.0, alphaclampupper=1.0, attrSelected="",
               beforeStrokeCmd="", brushalignment=True, brushfeedback=True, clamp="none",
               clamplower=0.0, clampupper=1.0, clear=True, colorAlphaValue=0.0,
               colorRGBAValue=None, colorRGBValue=None, colorRamp="", colorfeedback=False,
               colorfeedbackOverride=False, colorrangelower=0.0, colorrangeupper=1.0,
               dataTypeIndex=0, disablelighting=False, dragSlider="", duringStrokeCmd="",
               dynclonemode=True, exists=True, expandfilename=True, exportaspectratio=0.0,
               exportfilemode="luminance/rgb", exportfilesave="", exportfilesizex=0,
               exportfilesizey=0, exportfiletype="", filterNodes=True, history=True, image1="",
               image2="", image3="", importfileload="", importfilemode="alpha",
               importreassign=False, interactiveUpdate=True, lastRecorderCmd="",
               lastStampName="", lowerradius=0.0, makeStroke=0, mappressure="none",
               maxvalue=1.0, minvalue=0.0, name="", objattrArray="", opacity=1.0, outline=True,
               outwhilepaint=False, paintNodeArray="", paintattrselected="", paintmode="screen",
               paintoperationtype="Paint", pickColor=True, pickValue=True, playbackCursor=None,
               playbackPressure=0.0, preserveclonesource=True, profileShapeFile="",
               projective=False, radius=1.0, rampMaxColor=None, rampMinColor=None, record=True,
               reflection=False, reflectionaboutorigin=True, reflectionaxis="x",
               screenRadius=0.0, selectclonesource=True, selectedattroper="absolute",
               showactive=True, stampDepth=0.0, stampProfile="", stampSpacing=1.0,
               strokesmooth="", surfaceConformedBrushVertices=True, tablet=True,
               tangentOutline=True, toolOffProc="", toolOnProc="", useColorRamp=True,
               useMaxMinColor=True, usepressure=False, value=0.0, whichTool="", worldRadius=0.0,
               q=True, query=True, e=True, edit=True, **kwargs):
    """
    This is a context command to set the flags on the artAttrContext, which is the base context
    for attribute painting operations  All commands require the name of the context as the last
    argument as this provides the name of the context to create, edit or query   This is a
    context command to set the flags on the Attribute Paint Tool context
    
    :param accopacity: (C Q E) Sets opacity accumulation on/off  C: Default is false (Except
    for sculpt tool for which it is true by default)  Q: When queried, it returns a boolean
    :type accopacity: boolean
    :param activeListChangedProc: (C Q E) Accepts a string that contains a MEL command that is
    invoked whenever the active list changes  There may be some situations where the UI, for
    example
    :type activeListChangedProc: string
    :param afterStrokeCmd: (C Q E) The passed string is executed as a MEL command immediately
    after the end of a stroke  C: Default is no command  Q: When queried, it returns the curre
    :type afterStrokeCmd: string
    :param alphaclamp: (C Q E) Specifies if the weight value should be alpha clamped to the
    lower and upper bounds  There are four options here: "none" - no clamping is performed,
    :type alphaclamp: string
    :param alphaclamplower: (C Q E) Specifies the lower bound for the alpha values  C: Default
    is 0.0  Q: When queried, it returns a float
    :type alphaclamplower: float
    :param alphaclampupper: (C Q E) Specifies the upper bound for the alpha values  C: Default
    is 1.0  Q: When queried, it returns a float
    :type alphaclampupper: float
    :param attrSelected: (Q) Returns a name of the currently selected attribute  Q: When
    queried, it returns a string
    :type attrSelected: string
    :param beforeStrokeCmd: (C Q E) The passed string is executed as a MEL command immediately
    before the start of a stroke  C: Default is no command  Q: When queried, it returns the cu
    :type beforeStrokeCmd: string
    :param brushalignment: (C Q E) Specifies the path brush alignemnt  If true, the brush will
    align to stroke path, otherwise it will align to up vector  C: Default is true  Q: When q
    :type brushalignment: boolean
    :param brushfeedback: (C Q E) Specifies if the brush additional feedback should be drawn 
    C: Default is TRUE  Q: When queried, it returns a boolean
    :type brushfeedback: boolean
    :param clamp: (C Q E) Specifies if the weight value should be clamped to the lower and
    upper bounds  There are four options here: "none" - no clamping is performed, "lower
    :type clamp: string
    :param clamplower: (C Q E) Specifies the lower bound for the values  C: Default is 0.0  Q:
    When queried, it returns a float
    :type clamplower: float
    :param clampupper: (C Q E) Specifies the upper bound for the values  C: Default is 1.0  Q:
    When queried, it returns a float
    :type clampupper: float
    :param clear: (C E) Floods all cvs/vertices to the current value
    :type clear: boolean
    :param colorAlphaValue: (C Q E) The Alpha value of the color
    :type colorAlphaValue: float
    :param colorRGBAValue: (C Q E) The RGBA value of the color
    :type colorRGBAValue: [float, float, float, float]
    :param colorRGBValue: (C Q E) The RGB value of the color
    :type colorRGBValue: [float, float, float]
    :param colorRamp: (C Q E) Allows a user defined color ramp to be used to map values to
    colors
    :type colorRamp: string
    :param colorfeedback: (C Q E) Sets on/off the color feedback display  C: Default is FALSE 
    Q: When queried, it returns a boolean
    :type colorfeedback: boolean
    :param colorfeedbackOverride: (C Q E) Sets on/off the color feedback override  C: Default
    is FALSE  Q: When queried, it returns a boolean
    :type colorfeedbackOverride: boolean
    :param colorrangelower: (C Q E) Specifies the value that maps to black when color feedback
    mode is on  C: Default is 0.0  Q: When queried, it returns a float
    :type colorrangelower: float
    :param colorrangeupper: (C Q E) Specifies the value that maps to the maximum color when
    color feedback mode is on  C: Default is 1.0  Q: When queried, it returns a float
    :type colorrangeupper: float
    :param dataTypeIndex: (Q E) When the selected paintable attribute is a vectorArray, it
    specifies which field to paint on
    :type dataTypeIndex: int
    :param disablelighting: (C Q E) If color feedback is on, this flag determines whether
    lighting is disabled or not for the surfaces that are affected  C: Default is FALSE  Q:
    When qu
    :type disablelighting: boolean
    :param dragSlider: (C E) Sets the current brush drag state for resizing or offsetting the
    brush (like the 'b' and 'm' default hotkeys)  The string argument is one of: "radius
    :type dragSlider: string
    :param duringStrokeCmd: (C Q E) The passed string is executed as a MEL command during the
    stroke, each time the mouse is dragged  C: Default is no command  Q: When queried, it
    retur
    :type duringStrokeCmd: string
    :param dynclonemode: (C Q E) Enable or disable dynamic clone mode
    :type dynclonemode: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param expandfilename: (C E) If true, it will expand the name of the export file and
    concatenate it with the surface name  Otherwise it will take the name as it is  C: Default
    is
    :type expandfilename: boolean
    :param exportaspectratio: (C Q E) Value of aspect ratio for export
    :type exportaspectratio: float
    :param exportfilemode: (C Q E) Specifies the export channel.The valid entries here are:
    "alpha", "luminance", "rgb", "rgba"  C: Default is "luminance/rgb"  Q: When queried, it
    retu
    :type exportfilemode: string
    :param exportfilesave: (E) Exports the attribute map and saves to a specified file
    :type exportfilesave: string
    :param exportfilesizex: (C Q E) Specifies the width of the attribute map to export  C:
    Default width is 256  Q: When queried, it returns an integer
    :type exportfilesizex: int
    :param exportfilesizey: (C Q E) Specifies the width of the attribute map to export  C:
    Default width is 256  Q: When queried, it returns an integer
    :type exportfilesizey: int
    :param exportfiletype: (C Q E) Specifies the image file format  It can be one of the
    following: "iff", "tiff", "jpeg", "alias", "rgb", "fit" "postScriptEPS", "softimage",
    "wavefron
    :type exportfiletype: string
    :param filterNodes: (E) Sets the node filter
    :type filterNodes: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param importfileload: (E) Load the attribute map a specified file
    :type importfileload: string
    :param importfilemode: (C Q E) Specifies the channel to import  The valid entries here are:
    "alpha", "luminance", "red", "green", "blue", and "rgb" C: Default is "alpha"  Q: When q
    :type importfilemode: string
    :param importreassign: (C Q E) Specifies if the multiply atrribute maps are to be
    reassigned while importing  Only maps previously exported from within Artisan can be
    reassigned  C
    :type importreassign: boolean
    :param interactiveUpdate: (C Q E) Specifies how often to transfer the painted values into
    the attribute  TRUE: transfer them "continuously" (many times per stroke) FALSE: transfer
    the
    :type interactiveUpdate: boolean
    :param lastRecorderCmd: (C Q E) Value of last recorded command
    :type lastRecorderCmd: string
    :param lastStampName: (C Q E) Value of the last stamp name
    :type lastStampName: string
    :param lowerradius: (C Q E) Sets the lower size of the brush (only apply on tablet)
    :type lowerradius: float
    :param makeStroke: (C Q E M) Stroke point values
    :type makeStroke: int
    :param mappressure: (C Q E) Sets the tablet pressure mapping when the table is used  There
    are four options: "none" - the pressure has no effect, "opacity" - the pressure is map
    :type mappressure: string
    :param maxvalue: (C Q E) Specifies the maximum value for each attribute  C: Default is 1.0 
    Q: When queried, it returns a float
    :type maxvalue: float
    :param minvalue: (C Q E) Specifies the minimum value for each attribute  C: Default is 0.0 
    Q: When queried, it returns a float
    :type minvalue: float
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param objattrArray: (Q) An array of all paintable attributes  Each element of the array is
    a string with the following information: NodeType.NodeName.AttributeName.MenuType
    :type objattrArray: string
    :param opacity: (C Q E) Sets the brush opacity  C: Default is 1.0  Q: When queried, it
    returns a float
    :type opacity: float
    :param outline: (C Q E) Specifies if the brush should be drawn  C: Default is TRUE  Q: When
    queried, it returns a boolean
    :type outline: boolean
    :param outwhilepaint: (C Q E) Specifies if the brush outline should be drawn while painting
     C: Default is FALSE  Q: When queried, it returns a boolean
    :type outwhilepaint: boolean
    :param paintNodeArray: (Q) An array of paintable nodes  Q: When queried, it returns a
    string
    :type paintNodeArray: string
    :param paintattrselected: (E) An array of selected paintable attributes  Each element of
    the array is a string with the following information: NodeType.NodeName.AttributeName
    :type paintattrselected: string
    :param paintmode: (C Q E) Specifies the paint mode  There are two possibilities: "screen"
    and "tangent"  C: Default is "screen"  Q: When queried, it returns a string
    :type paintmode: string
    :param paintoperationtype: (C Q E) Specifies the operation type used by the Paint Tool 
    Currently, we support the following paint modes: "Paint", "Smear", "Blur", "Erase" and
    "Clone"
    :type paintoperationtype: string
    :param pickColor: (C Q E) Set pick color mode on or off
    :type pickColor: boolean
    :param pickValue: (C Q E) Toggle for picking
    :type pickValue: boolean
    :param playbackCursor: (C Q E M) Values for the playback cursor
    :type playbackCursor: [float, float]
    :param playbackPressure: (C Q E M) Valus for the playback pressure
    :type playbackPressure: float
    :param preserveclonesource: (C Q E) Whether or not to preserve a clone source
    :type preserveclonesource: boolean
    :param profileShapeFile: (Q E) Passes a name of the image file for the stamp shape profile
    :type profileShapeFile: string
    :param projective: (C Q E) Specifies the projective paint mode  C: Default is 'false'  Q:
    When queried, it returns a boolean
    :type projective: boolean
    :param radius: (C Q E) Sets the size of the brush  C: Default is 1.0 cm  Q: When queried,
    it returns a float
    :type radius: float
    :param rampMaxColor: (C Q E) Defines a special color to be used when the value is greater
    than or equal to the maximum value
    :type rampMaxColor: [float, float, float]
    :param rampMinColor: (C Q E) Defines a special color to be used when the value is less than
    or equal to the minimum value
    :type rampMinColor: [float, float, float]
    :param record: (C Q E) Toggle on for recording
    :type record: boolean
    :param reflection: (C Q E) Specifies the reflection mode  C: Default is 'false'  Q: When
    queried, it returns a boolean
    :type reflection: boolean
    :param reflectionaboutorigin: (C Q E) Toggle on to reflect about the origin
    :type reflectionaboutorigin: boolean
    :param reflectionaxis: (C Q E) Specifies the reflection axis  There are three
    possibilities: "x", "y" and "z"  C: Default is "x"  Q: When queried, it returns a string
    :type reflectionaxis: string
    :param screenRadius: (C Q E) Brush radius on the screen
    :type screenRadius: float
    :param selectclonesource: (C Q E) Toggle on to select the clone source
    :type selectclonesource: boolean
    :param selectedattroper: (C Q E) Sets the edit weight operation  Four edit weights
    operations are provided : "absolute" - the value of the weight is replaced by the current
    one, "add
    :type selectedattroper: string
    :param showactive: (C Q E) Sets on/off the display of the surface isoparms  C: Default is
    TRUE  Q: When queried, it returns a boolean
    :type showactive: boolean
    :param stampDepth: (C Q E) Depth of the stamps
    :type stampDepth: float
    :param stampProfile: (C Q E) Sets the brush profile of the current stamp  Currently, the
    following profiles are supported: "gaussian", "poly", "solid" and "square"  C: Default is
    :type stampProfile: string
    :param stampSpacing: (C Q E) Specifies the stamp spacing  Default is 1.0
    :type stampSpacing: float
    :param strokesmooth: (C Q E) Stroke smoothing type name
    :type strokesmooth: string
    :param surfaceConformedBrushVertices: (C Q E) Enables/disables the the display of the
    effective brush area as affected vertices
    :type surfaceConformedBrushVertices: boolean
    :param tablet: (Q) Returns true if the tablet device is present, false if it is absent
    :type tablet: boolean
    :param tangentOutline: (C Q E) Enables/disables the display of the brush circle tangent to
    the surface
    :type tangentOutline: boolean
    :param toolOffProc: (C Q E) Accepts a strings describing the name of a MEL procedure that
    is invoked whenever the tool is turned off  For example, cloth invokes "clothPaintToolO
    :type toolOffProc: string
    :param toolOnProc: (C Q E) Accepts a strings describing the name of a MEL procedure that is
    invoked whenever the tool is turned on  For example, cloth invokes "clothPaintToolOn
    :type toolOnProc: string
    :param useColorRamp: (C Q E) Specifies whether the user defined color ramp should be used
    to map values from to colors  If this is turned off, the default greyscale feedback will
    :type useColorRamp: boolean
    :param useMaxMinColor: (C Q E) Specifies whether the out of range colors should be used 
    See rampMinColor and rampMaxColor flags for further details
    :type useMaxMinColor: boolean
    :param usepressure: (C Q E) Sets the tablet pressure on/off  C: Default is false  Q: When
    queried, it returns a boolean
    :type usepressure: boolean
    :param value: (C Q E) Specifies the value for each attribute  C: Default is 0.0  Q: When
    queried, it returns a float
    :type value: float
    :param whichTool: (C Q E) The string defines the name of the tool to be used for the
    Artisan context  An example is "artClothPaint"  In query mode, the tool name for the given
    :type whichTool: string
    :param worldRadius: (C Q E) Radius in worldspace
    :type worldRadius: float
    
    :returns: The name of the context created.
    :rtype: string
    """
    pass


def snapshot(*args, constructionHistory=True, endTime=None, increment=None, motionTrail=False,
             name="", startTime=None, update="always", q=True, query=True, e=True, edit=True,
             **kwargs):
    """
    This command can be used to create either a series of surfaces evaluated at the times
    specified by the command flags, or a motion trail displaying the trajectory of the object's
    pivot point at the times specified.  If the constructionHistory flag is true, the output
    shapes or motion trail will re-update when modifications are made to the animation 
    
    :param constructionHistory: (C Q) update with changes to original geometry
    :type constructionHistory: boolean
    :param endTime: (C Q E) time to stop copying target geometry Default: 10.0
    :type endTime: time
    :param increment: (C Q E) time increment between copies Default: 1.0
    :type increment: time
    :param motionTrail: (C) Rather than create a series of surfaces, create a motion trail
    displaying the location of the object's pivot point at the specified time steps  Defau
    :type motionTrail: boolean
    :param name: (C Q E) the name of the snapshot node  Query returns string
    :type name: string
    :param startTime: (C Q E) time to begin copying target geometry Default: 1.0
    :type startTime: time
    :param update: (C Q E) This flag can only be used if the snapshot has constructionHistory 
    It sets the snapshot node's update value  The update value controls whether the s
    :type update: string
    
    :returns: names of nodes created or edited: transform-name [snapshot-node-name]
    :rtype: string[]
    """
    pass


def Create3DContainer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AttachToPath(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorClipScaleEnd(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def setAttrMapping(*args, absolute=True, attribute="", axis="", clutch="", device="",
                   offset=0.0, relative=True, scale=0.0, selection=True, q=True, query=True,
                   **kwargs):
    """
    This command applies an offset and scale to a specified device attachment  This command is
    different than the setInputDeviceMapping command, which applies a mapping to a device axis 
     The value from the device is multiplied by the scale and the offset is added to this
    product  With an absolute mapping, the attached attribute gets the resulting valu
    
    :param absolute: (C) Make the mapping absolute
    :type absolute: boolean
    :param attribute: (C M) The attribute used in the attachment
    :type attribute: string
    :param axis: (C) The axis on the device used in the attachment
    :type axis: string
    :param clutch: (C) The clutch button used in the attachment
    :type clutch: string
    :param device: (C) The device used in the attachment
    :type device: string
    :param offset: (C) Specify the offset value
    :type offset: float
    :param relative: (C) Make the mapping relative
    :type relative: boolean
    :param scale: (C) Specify the scale value
    :type scale: float
    :param selection: (C) This flag specifies the mapping should be on the selected objects
    :type selection: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def pairBlend(*args, attribute="", input1=True, input2=True, node="", q=True, query=True,
              e=True, edit=True, **kwargs):
    """
    The pairBlend node allows a weighted combinations of 2 inputs to be blended together  It is
    created automatically when keying or constraining an attribute which is already connected.
    Alternatively, the pairBlend command can be used to connect a pairBlend node to connected
    attributes of a node  The previously existing connections are rewired to inpu
    
    :param attribute: (C M) The name of the attribute(s) which the blend will drive  This flag
    is required when creating the blend
    :type attribute: string
    :param input1: (Q) Returns a string array of the node(s) connected to input 1
    :type input1: boolean
    :param input2: (Q) Returns a string array of the node(s) connected to input 2
    :type input2: boolean
    :param node: (C) The name of the node which the blend will drive  This flag is required
    when creating the blend
    :type node: string
    
    :returns: name of pairBlend node
    :rtype: string
    """
    pass


def inViewMessage(*args, alpha=0.0, assistMessage="", backColor=0, clear="", clickKill=True,
                  dragKill=True, fade=True, fadeInTime=0, fadeOutTime=0, fadeStayTime=0,
                  font="", fontSize=0, frameOffset=0, hide=True, message="", minimize=True,
                  position="", restore=True, show=True, statusMessage="", textAlpha=0.0,
                  textOffset=0, uvEditor=True, **kwargs):
    """
    Used for displaying in-view messages   Note: On Linux, the alpha and textAlpha flags for
    inViewMessage are only supported when running a window manager that supports compositing
    (transparency and opacity)  Otherwise, they are ignored  In addition, the flags for message
    fading: -fade, -fadeInTime, -fadeStay and -fadeOutTime are supported, but the me
    
    :param alpha: (C) Sets the maximum alpha transparency for the message box
    :type alpha: float
    :param assistMessage: (C) The user assistance message to be displayed, can be html format
    :type assistMessage: string
    :param backColor: (C) Sets the background color for the message using the format 0xAARRGGBB,
    alpha is not taken into account
    :type backColor: int
    :param clear: (C) Use this flag to clear the message at a specified position  The supported
    positions are the same as for the -pos/position flag
    :type clear: string
    :param clickKill: (C) Use this flag if the message needs to be deleted on mouse click
    :type clickKill: boolean
    :param dragKill: (C) Use this flag if the message needs to be deleted on mouse drag
    :type dragKill: boolean
    :param fade: (C) Whether the message will fade after a time interval or not
    :type fade: boolean
    :param fadeInTime: (C) Sets how long it takes for the image to fade in (milliseconds)
    :type fadeInTime: int
    :param fadeOutTime: (C) Sets how long it takes for the image to fade out (milliseconds)
    :type fadeOutTime: int
    :param fadeStayTime: (C) Sets how long the image stays at max opacity (milliseconds)
    :type fadeStayTime: int
    :param font: (C) Sets the message to a font (eg  "Arial")
    :type font: string
    :param fontSize: (C) Sets the message font size
    :type fontSize: int
    :param frameOffset: (C) Sets how far the message appears from the edge of the viewport in
    pixels
    :type frameOffset: int
    :param hide: (C) Hides all messages
    :type hide: boolean
    :param message: (C) The message to be displayed, can be html format  General message,
    inherited by -amg/assistMessage and -smg/statusMessage
    :type message: string
    :param minimize: (C) Minimize all messages
    :type minimize: boolean
    :param position: (C) The position that the message will appear at relative to the active
    viewport  The supported positions are: "topLeft" "topCenter" "topRight" "midLeft"
    :type position: string
    :param restore: (C) Restore all messages
    :type restore: boolean
    :param show: (C) Shows all messages
    :type show: boolean
    :param statusMessage: (C) The status info message to be displayed, can be html format
    :type statusMessage: string
    :param textAlpha: (C) Sets the maximum alpha transparency for the message text
    :type textAlpha: float
    :param textOffset: (C) Sets how far the text appears from the edge of the message box in
    pixels
    :type textOffset: int
    :param uvEditor: (C) Show the message in the active UV editor view
    :type uvEditor: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def SelectAllJoints(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeEditPSDFile(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RebuildCurveOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideGeometry(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExportProxyContainer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def fileDialog(*args, application=True, defaultFileName="", directoryMask="", mode=0, title="",
               **kwargs):
    """
    The fileBrowserDialog and fileDialog commands have now been deprecated  Both commands are
    still callable, but it is recommended that the fileDialog2 command be used instead  To
    maintain some backwards compatibility, both fileBrowserDialog and fileDialog will convert
    the flags/values passed to them into the appropriate flags/values that the fileDial
    
    :param application: (C) This is a "Mac" only flag  This brings up the dialog which selects
    only the application bundle
    :type application: boolean
    :param defaultFileName: (C) Set default file name  This flag is available under "write"
    mode
    :type defaultFileName: string
    :param directoryMask: (C) This can be used to specify what directory and file names will be
    displayed in the dialog  If not specified, the current directory will be used, with
    :type directoryMask: string
    :param mode: (C) Defines the mode in which to run the file dialog: 0 for read 1 for write
    Write mode can not be used in conjunction with the -application flag
    :type mode: int
    :param title: (C) Set title text  The default value under "write" mode is "Save As"  The
    default value under "read" mode is "Open"
    :type title: string
    
    :returns: Name of dialog
    :rtype: string
    """
    pass


def invertShape(*args, **kwargs):
    """
    
    """
    pass


def SelectToolMarkingMenu(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MoveRotateScaleToolToggleSnapMode(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PlaybackStop(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_safeFrameTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleEdgeIDs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TangentsPlateau(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def selectKeyframe(*args, **kwargs):
    """
    
    """
    pass


def HypershadeOpenCreateWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def combinationShape(*args, addDriver=True, allDrivers=True, blendShape="",
                     combinationTargetIndex=0, combinationTargetName="", combineMethod=0,
                     driverTargetIndex=0, driverTargetName="", exist=True, removeDriver=True,
                     q=True, query=True, e=True, edit=True, **kwargs):
    """
    Command to create or edit drive relationship of blend shape targets
    
    :param addDriver: () Add drivers to the combination shape
    :type addDriver: boolean
    :param allDrivers: (Q) All drivers of the combination shape
    :type allDrivers: boolean
    :param blendShape: (C) Associated blend shape node of the combination shape In query mode,
    this flag can accept a value
    :type blendShape: string
    :param combinationTargetIndex: (C) Driven blend shape target index of the combination shape
    In query mode, this flag can accept a value
    :type combinationTargetIndex: int
    :param combinationTargetName: (C) Driven blend shape target name of the combination shape
    In query mode, this flag can accept a value
    :type combinationTargetName: string
    :param combineMethod: (C Q E) Combine method of the combination shape: 0 : Multiplication 1
    : Lowest Weighting 2 : Lowest Weighting (Smooth)
    :type combineMethod: int
    :param driverTargetIndex: (C M) Driver blend shape target index of the combination shape
    :type driverTargetIndex: int
    :param driverTargetName: (C M) Driver blend shape target name of the combination shape
    :type driverTargetName: string
    :param exist: (Q) If the combination shape exist
    :type exist: boolean
    :param removeDriver: () Remove drivers from the combination shape
    :type removeDriver: boolean
    
    :returns: In edit mode, return the newly created combination shape node name.
    :rtype: Int
    """
    pass


def sbs_GetBakeFormat(*args, **kwargs):
    """
    
    """
    pass


def melOptions(*args, duplicateVariableWarnings=True, q=True, query=True, **kwargs):
    """
    Set and query options that affect the behavior of Maya's Embedded Language (MEL)
    
    :param duplicateVariableWarnings: (C Q) When turned on, this option will cause a warning to
    be generated whenever a MEL variable is declared within the same scope as another variable
    with t
    :type duplicateVariableWarnings: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def xgmExport(*args, **kwargs):
    """
    
    """
    pass


def polySphericalProjection(*args, imageCenter=None, imageCenterX=0.5, imageCenterY=0.5,
                            imageScale=None, imageScaleU=1.0, imageScaleV=1.0,
                            projectionCenter=None, projectionCenterX=0.0, projectionCenterY=0.0,
                            projectionCenterZ=0.0, projectionHorizontalSweep=0.0,
                            projectionScale=None, projectionScaleU=180.0, projectionScaleV=90.0,
                            radius=0.0, rotate=None, rotateX=0.0, rotateY=0.0, rotateZ=0.0,
                            rotationAngle=10.0, seamCorrect=True, caching=True,
                            constructionHistory=True, createNewMap=True,
                            insertBeforeDeformers=True, keepImageRatio=True, mapDirection="",
                            name="", nodeState=0, perInstance=True, smartFit=True,
                            worldSpace=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    TpolyProjCmdBase is a base class for the command to create a mapping on the selected
    polygonal faces  Projects a spherical map onto an object
    
    :param imageCenter: (C Q E) This flag specifies the center point of the 2D model layout  C:
    Default is 0.5 0.5  Q: When queried, this flag returns a float[2]
    :type imageCenter: [float, float]
    :param imageCenterX: (C Q E) This flag specifies X for the center point of the 2D model
    layout  C: Default is 0.5  Q: When queried, this flag returns a float
    :type imageCenterX: float
    :param imageCenterY: (C Q E) This flag specifies Y for the center point of the 2D model
    layout  C: Default is 0.5  Q: When queried, this flag returns a float
    :type imageCenterY: float
    :param imageScale: (C Q E) This flag specifies the UV scale : Enlarges or reduces the 2D
    version of the model in U or V space relative to the 2D centerpoint  C: Default is 1.0
    :type imageScale: [float, float]
    :param imageScaleU: (C Q E) This flag specifies the U scale : Enlarges or reduces the 2D
    version of the model in U space relative to the 2D centerpoint  C: Default is 1.0  Q: Wh
    :type imageScaleU: float
    :param imageScaleV: (C Q E) This flag specifies the V scale : Enlarges or reduces the 2D
    version of the model in V space relative to the 2D centerpoint  C: Default is 1.0  Q: Wh
    :type imageScaleV: float
    :param projectionCenter: (C Q E) This flag specifies the origin point from which the map is
    projected  C: Default is 0.0 0.0 0.0  Q: When queried, this flag returns a float[3]
    :type projectionCenter: [float, float, float]
    :param projectionCenterX: (C Q E) This flag specifies X for the origin point from which the
    map is projected  C: Default is 0.0  Q: When queried, this flag returns a float
    :type projectionCenterX: float
    :param projectionCenterY: (C Q E) This flag specifies Y for the origin point from which the
    map is projected  C: Default is 0.0  Q: When queried, this flag returns a float
    :type projectionCenterY: float
    :param projectionCenterZ: (C Q E) This flag specifies Z for the origin point from which the
    map is projected  C: Default is 0.0  Q: When queried, this flag returns a float
    :type projectionCenterZ: float
    :param projectionHorizontalSweep: (C Q E) The angle swept horizontally by the projection 
    The range is [0, 360]
    :type projectionHorizontalSweep: float
    :param projectionScale: (C Q E) This flag specifies the width and the height of the map
    relative to the 3D projection axis  C: Default is 180.0 90.0  Q: When queried, this flag
    retu
    :type projectionScale: [float, float]
    :param projectionScaleU: (C Q E) This flag specifies the width of the map relative to the
    3D projection axis : the scale aperture  The range is [0, 360]  C: Default is 180.0  Q:
    When
    :type projectionScaleU: float
    :param projectionScaleV: (C Q E) This flag specifies the height of the map relative to the
    3D projection axis : the scale height  C: Default is 90.0  Q: When queried, this flag
    retur
    :type projectionScaleV: float
    :param radius: (C Q E) Used by the UI : Manipulator
    :type radius: float
    :param rotate: (C Q E) This flag specifies the mapping rotate angles  C: Default is 0.0 0.0
    0.0  Q: When queried, this flag returns a float[3]
    :type rotate: [float, float, float]
    :param rotateX: (C Q E) This flag specifies X mapping rotate angle  C: Default is 0.0  Q:
    When queried, this flag returns a float[3]
    :type rotateX: float
    :param rotateY: (C Q E) This flag specifies Y mapping rotate angle  C: Default is 0.0  Q:
    When queried, this flag returns a float
    :type rotateY: float
    :param rotateZ: (C Q E) This flag specifies Z mapping rotate angle  C: Default is 0.0  Q:
    When queried, this flag returns a float
    :type rotateZ: float
    :param rotationAngle: (C Q E) This flag specifies the rotation angle in the mapping space 
    When the angle is positive, then the map rotates counterclockwise on the mapped model, w
    :type rotationAngle: float
    :param seamCorrect: (C Q E) This flag specifies to perform a seam correction on the mapped
    faces
    :type seamCorrect: boolean
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param createNewMap: (C Q) This flag when set true will create a new map with a the name
    passed in, if the map does not already exist
    :type createNewMap: boolean
    :param insertBeforeDeformers: (C) This flag specifies if the projection node should be
    inserted before or after deformer nodes already applied to the shape  Inserting the
    projection a
    :type insertBeforeDeformers: boolean
    :param keepImageRatio: (C) True means keep any image ratio
    :type keepImageRatio: boolean
    :param mapDirection: (C) This flag specifies the mapping direction  'x', 'y' and 'z'
    projects the map along the corresponding axis  'c' projects along the current camera view
    :type mapDirection: string
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param perInstance: (C) True if the new map is per-instance, otherwise it is shared
    :type perInstance: boolean
    :param smartFit: (C) True means use the smart fit algorithm
    :type smartFit: boolean
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def objExists(*args, **kwargs):
    """
    This command simply returns true or false depending on whether an object with the given
    name exists
    
    
    :returns: Command result
    :rtype: boolean
    """
    pass


def currentTime(*args, update=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    When given a time argument (with or without the -edit flag) this command sets the current
    global time  The model updates and displays at the new time, unless "-update off" is
    present on the command line
    
    :param update: (C) change the current time, but do not update the world  Default value is
    true
    :type update: boolean
    
    :returns: Command result
    :rtype: time
    """
    pass


def xgmSplineGeometryConvert(*args, **kwargs):
    """
    
    """
    pass


def dpBirailCtx(*args, **kwargs):
    """
    
    """
    pass


def connectJoint(*args, connectMode=True, parentMode=True, **kwargs):
    """
    This command will connect two skeletons based on the two selected joints  The first
    selected joint can be made a child of the parent of the second selected joint or a child of
    the second selected joint, depending on the flags used   Note1: The first selected joint
    must be the root of a skeleton  The second selected joint must have a parent   Note2:
    
    :param connectMode: (C) The first selected joint will be parented under the parent of the
    second selected joint
    :type connectMode: boolean
    :param parentMode: (C) The first selected joint will be parented under the second selected
    joint  Both joints will be in the active list(selection list)
    :type parentMode: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def shadingConnection(*args, connectionState=True, q=True, query=True, e=True, edit=True,
                      **kwargs):
    """
    Sets the connection state of a connection between nodes that are used in shading  Specify
    the destination attribute of the connection
    
    :param connectionState: (C Q E) Specifies the state of the connection  On/True/1 means the
    connection is still active  Off/False/0 means the connection is inactive
    :type connectionState: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def hikRigSync(*args, **kwargs):
    """
    
    """
    pass


def stitchSurface(*args, bias=1.0, caching=True, cvIthIndex=1, cvJthIndex=1, fixBoundary=False,
                  nodeState=0, parameterU=10000, parameterV=10000, positionalContinuity=True,
                  stepCount=20, tangentialContinuity=False, togglePointNormals=False,
                  togglePointPosition=True, toggleTolerance=False, tolerance=0.1, cascade=False,
                  constructionHistory=True, keepG0Continuity=True, keepG1Continuity=False,
                  name="", numberOfSamples=20, object=True, replaceOriginal=True, weight0=0.5,
                  weight1=0.5, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The stitchSurface command aligns two surfaces together to be G(0) and/or G(1) continuous by
    ajusting only the Control Vertices of the surfaces  The two surfaces can be stitched by
    specifying the two isoparm boundary edges that are to stitched together  The edge to which
    the two surfaces are stitched together is obtained by doing a weighted average 
    
    :param bias: (C Q E) Blend CVs in between input surface and result from stitch  A value of
    0.0 returns the input surface  Default: 1.0
    :type bias: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param cvIthIndex: (C Q E M) The ith boundary CV index on the input surface  Default: -1
    :type cvIthIndex: int
    :param cvJthIndex: (C Q E M) The jth boundary CV index on the input surface  Default: -1
    :type cvJthIndex: int
    :param fixBoundary: (C Q E) Fix Boundary CVs while solving for any G1 constraints  Default:
    false
    :type fixBoundary: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param parameterU: (C Q E M) The U parameter value on surface for a point constraint 
    Default: -10000
    :type parameterU: float
    :param parameterV: (C Q E M) The V parameter value on surface for a point constraint 
    Default: -10000
    :type parameterV: float
    :param positionalContinuity: (C Q E M) Toggle on (off) G0 continuity at edge corresponding
    to multi index  Default: true
    :type positionalContinuity: boolean
    :param stepCount: (C Q E M) Step count for the number of discretizations  Default: 20
    :type stepCount: int
    :param tangentialContinuity: (C Q E M) Toggle on (off) G1 continuity across edge
    corresponding to multi index  Default: false
    :type tangentialContinuity: boolean
    :param togglePointNormals: (C Q E) Toggle on (off) normal point constraints on the surface 
    Default: false
    :type togglePointNormals: boolean
    :param togglePointPosition: (C Q E) Toggle on (off) position point constraints on the
    surface  Default: true
    :type togglePointPosition: boolean
    :param toggleTolerance: (C Q E M) Toggle on (off) so as to use Tolerance or specified steps
    for discretization  Default: false
    :type toggleTolerance: boolean
    :param tolerance: (C Q E M) Tolerance to use while discretizing the edge  Default: 0.1
    :type tolerance: float
    :param cascade: (C) Cascade the created stitch node  (Only if the surface has a stitch
    history) Default is 'false'
    :type cascade: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param keepG0Continuity: (C) Stitch together with positional continuity  Default is 'true'
    :type keepG0Continuity: boolean
    :param keepG1Continuity: (C) Stitch together with tangent continuity  Default is 'false'
    :type keepG1Continuity: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param numberOfSamples: (C) The number of samples on the edge  Default is 20
    :type numberOfSamples: int
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    :param weight0: (C) The weighting factor for the first edge  Default is 0.5
    :type weight0: float
    :param weight1: (C) The weighting factor for the second edge  Default is 0.5
    :type weight1: float
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def CreateShrinkWrapOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def attributeQuery(*args, affectsAppearance=True, affectsWorldspace=True, attributeType=True,
                   cachedInternally=True, categories=True, channelBox=True, connectable=True,
                   enum=True, exists=True, hidden=True, indeterminant=True, indexMatters=True,
                   internal=True, internalGet=True, internalSet=True, keyable=True,
                   listChildren=True, listDefault=True, listEnum=True, listParent=True,
                   listSiblings=True, longName=True, maxExists=True, maximum=True, message=True,
                   minExists=True, minimum=True, multi=True, niceName=True, node=None,
                   numberOfChildren=True, range=True, rangeExists=True, readable=True,
                   renderSource=True, shortName=True, softMax=True, softMaxExists=True,
                   softMin=True, softMinExists=True, softRange=True, softRangeExists=True,
                   storable=True, type="", typeExact="", usedAsColor=True, usedAsFilename=True,
                   usesMultiBuilder=True, worldspace=True, writable=True, **kwargs):
    """
    attributeQuery returns information about the configuration of an attribute  It handles both
    boolean flags, returning true or false, as well as other return values  Specifying more
    than one boolean flag will return the logical "and" of all the specified boolean flags  You
    may not specify any two flags when both do not provide a boolean return type  
    
    :param affectsAppearance: (C) Return true if the attribute affects the appearance of the
    node
    :type affectsAppearance: boolean
    :param affectsWorldspace: (C) Return the status of the attribute flag marking attributes
    affecting worldspace
    :type affectsWorldspace: boolean
    :param attributeType: (C) Return the name of the attribute type (will be the same type
    names as described in the addAttr and addExtension commands)
    :type attributeType: boolean
    :param cachedInternally: (C) Return whether the attribute is cached within the node as well
    as in the datablock
    :type cachedInternally: boolean
    :param categories: (C) Return the categories to which the attribute belongs or an empty
    list if it does not belong to any
    :type categories: boolean
    :param channelBox: (C) Return whether the attribute should show up in the channelBox or
    not
    :type channelBox: boolean
    :param connectable: (C) Return the connectable status of the attribute
    :type connectable: boolean
    :param enum: (C) Return true if the attribute is a enum attribute
    :type enum: boolean
    :param exists: (C) Return true if the attribute exists
    :type exists: boolean
    :param hidden: (C) Return the hidden status of the attribute
    :type hidden: boolean
    :param indeterminant: (C) Return true if this attribute might be used in evaluation but
    it's not known for sure until evaluation time
    :type indeterminant: boolean
    :param indexMatters: (C) Return the indexMatters status of the attribute
    :type indexMatters: boolean
    :param internal: (C) Return true if the attribute is either internalSet or internalGet
    :type internal: boolean
    :param internalGet: (C) Return true if the attribute come from getCachedValue
    :type internalGet: boolean
    :param internalSet: (C) Return true if the attribute must be set through setCachedValue
    :type internalSet: boolean
    :param keyable: (C) Return the keyable status of the attribute
    :type keyable: boolean
    :param listChildren: (C) Return the list of children attributes of the given attribute
    :type listChildren: boolean
    :param listDefault: (C) Return the default values of numeric and compound numeric
    attributes
    :type listDefault: boolean
    :param listEnum: (C) Return the list of enum strings for the given attribute
    :type listEnum: boolean
    :param listParent: (C) Return the parent of the given attribute
    :type listParent: boolean
    :param listSiblings: (C) Return the list of sibling attributes of the given attribute
    :type listSiblings: boolean
    :param longName: (C) Return the long name of the attribute
    :type longName: boolean
    :param maxExists: (C) Return true if the attribute has a hard maximum  A min does not have
    to be present
    :type maxExists: boolean
    :param maximum: (C) Return the hard maximum of the attribute's value
    :type maximum: boolean
    :param message: (C) Return true if the attribute is a message attribute
    :type message: boolean
    :param minExists: (C) Return true if the attribute has a hard minimum  A max does not have
    to be present
    :type minExists: boolean
    :param minimum: (C) Return the hard minimum of the attribute's value
    :type minimum: boolean
    :param multi: (C) Return true if the attribute is a multi-attribute
    :type multi: boolean
    :param niceName: (C) Return the nice name (or "UI name") of the attribute
    :type niceName: boolean
    :param node: (C) Use all attributes from node named NAME
    :type node: name
    :param numberOfChildren: (C) Return the number of children the attribute has
    :type numberOfChildren: boolean
    :param range: (C) Return the hard range of the attribute's value
    :type range: boolean
    :param rangeExists: (C) Return true if the attribute has a hard range  Both min and max
    must be present
    :type rangeExists: boolean
    :param readable: (C) Return the readable status of the attribute
    :type readable: boolean
    :param renderSource: (C) Return whether this attribute is marked as a render source or not
    :type renderSource: boolean
    :param shortName: (C) Return the short name of the attribute
    :type shortName: boolean
    :param softMax: (C) Return the soft max (slider range) of the attribute's value
    :type softMax: boolean
    :param softMaxExists: (C) Return true if the attribute has a soft maximum  A min does not
    have to be present
    :type softMaxExists: boolean
    :param softMin: (C) Return the soft min (slider range) of the attribute's value
    :type softMin: boolean
    :param softMinExists: (C) Return true if the attribute has a soft minimum  A max does not
    have to be present
    :type softMinExists: boolean
    :param softRange: (C) Return the soft range (slider range) of the attribute's value
    :type softRange: boolean
    :param softRangeExists: (C) Return true if the attribute has a soft range  Both min and max
    must be present
    :type softRangeExists: boolean
    :param storable: (C) Return true if the attribute is storable
    :type storable: boolean
    :param type: (C) Use static attributes from nodes of type TYPE  Includes attributes
    inherited from parent class nodes
    :type type: string
    :param typeExact: (C) Use static attributes only from nodes of type TYPE  Does not included
    inherited attributes
    :type typeExact: string
    :param usedAsColor: (C) Return true if the attribute should bring up a color picker
    :type usedAsColor: boolean
    :param usedAsFilename: (C) Return true if the attribute should bring up a file browser
    :type usedAsFilename: boolean
    :param usesMultiBuilder: (C) Return true if the attribute is a multi-attribute and it uses
    the multi-builder to handle its data
    :type usesMultiBuilder: boolean
    :param worldspace: (C) Return the status of the attribute flag marking worldspace
    attribute
    :type worldspace: boolean
    :param writable: (C) Return the writable status of the attribute
    :type writable: boolean
    
    :returns: when querying ranges or default values
    :rtype: float[]
    """
    pass


def text(*args, align="", annotation="", backgroundColor=None, defineTemplate="", docTag="",
         dragCallback=None, dropCallback=None, dropRectCallback=None, enable=True,
         enableBackground=True, enableKeyboardFocus=True, exists=True, font="",
         fullPathName=True, height=0, highlightColor=None, hyperlink=True, isObscured=True,
         label="", manage=True, noBackground=True, numberOfPopupMenus=True, parent="",
         popupMenuArray=True, preventOverride=True, recomputeSize=True, statusBarMessage="",
         useTemplate="", visible=True, visibleChangeCommand=None, width=0, wordWrap=True,
         q=True, query=True, e=True, edit=True, **kwargs):
    """
    Create a simple text label control
    
    :param align: (C Q E) The label alignment  Alignment values are "left", "right", and
    "center"  Note that the alignment will only be noticable if the control is wider than
    :type align: string
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param dropRectCallback: (E) Adds a callback that is called when a drag and drop operation
    is hovering above the drop site  It returns the shape of the rectangle to be drawn to h
    :type dropRectCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param font: (C Q E) The font for the text  Valid values are "boldLabelFont",
    "smallBoldLabelFont", "tinyBoldLabelFont", "plainLabelFont", "smallPlainLabelFont",
    "oblique
    :type font: string
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param hyperlink: (C Q E) Sets the label text to be a hyperlink if the argument is true 
    The label text must be a proper HTML link  In MEL, double quotes in the link will most
    :type hyperlink: boolean
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) The label text  The default label is the name of the control
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param recomputeSize: (C Q E) If true then the control will recompute it's size to just fit
    the size of the label  If false then the control size will remain fixed as you change t
    :type recomputeSize: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    :param wordWrap: (C Q) If true then label text is wrapped where necessary at word-breaks 
    If false, it is not wrapped at all  The default value of this flag is false
    :type wordWrap: boolean
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def nParticle(*args, attribute="", cache=True, conserve=0.0, count=True, deleteCache=True,
              dynamicAttrList=True, floatValue=0.0, gridSpacing=0.0, inherit=0.0,
              jitterBasePoint=None, jitterRadius=0.0, lowerLeft=None, name="", numJitters=0,
              order=0, particleId=0, perParticleDouble=True, perParticleVector=True,
              position=None, shapeName="", upperRight=None, vectorValue=None, q=True,
              query=True, e=True, edit=True, **kwargs):
    """
    The nParticle command creates a new nParticle object from a list of world space points  If
    an nParticle object is created, the command returns the names of the new particle shape and
    its associated particle object dependency node  If an object was queried, the results of
    the query are returned  Per particle attributes can be queried using the parti
    
    :param attribute: (Q E) Used in per particle attribute query and edit  Specifies the name
    of the attribute being queried or edited  In query mode, this flag needs a value
    :type attribute: string
    :param cache: (C Q E) Turns caching on/off for the particle shape
    :type cache: boolean
    :param conserve: (Q E) Conservation of momentum control (between 0 and 1)  Specifies the
    fraction of the particle shape's existing momentum which is conserved from frame to
    :type conserve: float
    :param count: (Q) Returns the number of particles in the object
    :type count: boolean
    :param deleteCache: (C) Deletes the particle shapes cache  This command is not undoable
    :type deleteCache: boolean
    :param dynamicAttrList: (Q) Returns a list of the dynamic attributes in the object
    :type dynamicAttrList: boolean
    :param floatValue: (E) Used only in per particle attribute edit  Specifies that the edit is
    of a float attribute and must be followed by the new float value
    :type floatValue: float
    :param gridSpacing: (C Q M) Spacing between particles in the grid
    :type gridSpacing: float
    :param inherit: (Q E) Inherit this fraction (0-1) of emitting object's velocity
    :type inherit: float
    :param jitterBasePoint: (C Q M) Base point (center point) for jitters  The command will
    create one swatch of jitters for each base point  It will pair up other flags with base
    point
    :type jitterBasePoint: [float, float, float]
    :param jitterRadius: (C Q M) Max radius from the center to place the particle instances
    :type jitterRadius: float
    :param lowerLeft: (C Q M) Lower left point of grid
    :type lowerLeft: [float, float, float]
    :param name: (Q E) name of particle object
    :type name: string
    :param numJitters: (C Q M) Number of jitters (instances) per particle
    :type numJitters: int
    :param order: (Q E) Used in per particle attribute query and edit  Specifies the zero-based
    order (index) of the particle whose attribute is being queried or edited in t
    :type order: int
    :param particleId: (Q E) Used in per particle attribute query and edit  Specifies the id of
    the particle whose attribute is being queried or edited  Querying the value of a p
    :type particleId: int
    :param perParticleDouble: (Q) Returns a list of the per-particle double attributes,
    excluding initial-state, cache, and information-only attributes
    :type perParticleDouble: boolean
    :param perParticleVector: (Q) Returns a list of the per-particle vector attributes,
    excluding initial-state, cache, and information-only attributes
    :type perParticleVector: boolean
    :param position: (M) World-space position of each particle
    :type position: [float, float, float]
    :param shapeName: (Q E) Specify the shape name used for geometry instancing  DO not confuse
    this with the -n flag which names the particle object
    :type shapeName: string
    :param upperRight: (C Q M) Upper right point of grid
    :type upperRight: [float, float, float]
    :param vectorValue: (E) Used only in per particle attribute edit  Specifies that the edit
    is of a vector attribute and must be followed by all three float values for the vec
    :type vectorValue: [float, float, float]
    
    :returns: The name of the nParticle object created
    :rtype: string
    """
    pass


def PaintEffectsToPolyOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeCreateContainerOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SculptPolygonsTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def toolBar(*args, allowedArea="all", annotation="", area="", backgroundColor=None, content="",
            defineTemplate="", docTag="", dragCallback=None, dropCallback=None, enable=True,
            enableBackground=True, enableKeyboardFocus=True, exists=True, fullPathName=True,
            height=0, highlightColor=None, isObscured=True, label="", manage=True,
            noBackground=True, numberOfPopupMenus=True, parent="", popupMenuArray=True,
            preventOverride=True, statusBarMessage="", useTemplate="", visible=True,
            visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
            **kwargs):
    """
    Create a toolbar  Tool bars are movable panel that contains a set of controls  They are
    placed in the tool bar area around the central control in a main window  Tool bars can be
    moved inside their current area, moved into new areas and floated
    
    :param allowedArea: (C Q E M) Areas where the dock control may be placed  Valid values are
    "top", "left", "bottom", "right" and "all"  The default is "all"
    :type allowedArea: string
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param area: (C Q E) The initial dock area for this dock control  Valid values are "top",
    "left", "bottom" and "right"  This is a required flag
    :type area: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param content: (C Q) The name of the control that is a content of this dock control  This
    is a required flag
    :type content: string
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) The label text  The default label is the name of the control
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def nexConnectCtx(*args, **kwargs):
    """
    
    """
    pass


def TimeEditorUnsoloAllTracks(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def saveShelf(*args, **kwargs):
    """
    This command saves the specified shelf (first argument) to the specified file (second
    argument)   Note that this command doesn't work well with controls that have mixed mel and
    python command callbacks  Also, because it saves the state to a mel file, it does not work
    with callbacks that are python callable objects
    
    
    :returns: True if successful.
    :rtype: boolean
    """
    pass


def CurveUtilitiesMarkingMenu(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyMirrorFace(*args, axis=0, axisDirection=1, caching=True, constructionHistory=True,
                   direction=0, mergeMode=1, mergeThreshold=0.001, mergeThresholdType=0,
                   mirrorAxis=2, mirrorPosition=0.0, name="", nodeState=0, pivot=None,
                   pivotX=0.0, pivotY=0.0, pivotZ=0.0, worldSpace=True, q=True, query=True,
                   e=True, edit=True, **kwargs):
    """
    Mirror all the faces of the selected object
    
    :param axis: (C Q E) Axis to mirror the object along Default: 0
    :type axis: int
    :param axisDirection: (C Q E) Direction to mirror the object along Default: 1
    :type axisDirection: int
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param direction: (C Q E) Direction to mirror the object along Default: 0
    :type direction: int
    :param mergeMode: (C Q E) Merge mode to apply Default: 1
    :type mergeMode: int
    :param mergeThreshold: (C Q E) Tolerance to determine whether vertices should be merged 
    Default: 0.001
    :type mergeThreshold: float
    :param mergeThresholdType: (C Q E) Merge mode to apply Default: 0
    :type mergeThresholdType: int
    :param mirrorAxis: (C Q E) Mirror axis type selection Default: 2
    :type mirrorAxis: int
    :param mirrorPosition: (C Q E) Custom mirror axis position Default: 0.0
    :type mirrorPosition: float
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param pivot: (C Q E) Pivot point of the mirror plane  Default: 0.0, 0.0, 0.0
    :type pivot: [float, float, float]
    :param pivotX: (C Q E) Translation X coord
    :type pivotX: float
    :param pivotY: (C Q E) Translation Y coord
    :type pivotY: float
    :param pivotZ: (C Q E) Translation Z coord
    :type pivotZ: float
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def PolyExtrudeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SendToUnrealSetProject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nodeOutliner(*args, addCommand=None, addObject=None, annotation="", attrAlphaOrder="",
                 backgroundColor=None, connectivity=None, currentSelection=True,
                 defineTemplate="", docTag="", dragCallback=None, dropCallback=None,
                 enable=True, enableBackground=True, enableKeyboardFocus=True, exists=True,
                 fullPathName=True, height=0, highlightColor=None, isObscured=True,
                 lastClickedNode=True, lastMenuChoice="", longNames=True, manage=True,
                 menuCommand=None, menuMultiOption=True, multiSelect=True, niceNames=True,
                 noBackground=True, noConnectivity=True, nodesDisplayed=True,
                 numberOfPopupMenus=True, parent="", popupMenuArray=True,
                 pressHighlightsUnconnected=True, preventOverride=True, redraw=True,
                 redrawRow=True, remove="", removeAll=True, replace=None, selectCommand=None,
                 showConnectedOnly=True, showHidden=True, showInputs=True,
                 showNonConnectable=True, showNonKeyable=True, showOutputs=True,
                 showPublished=True, showReadOnly=True, statusBarMessage="", useTemplate="",
                 visible=True, visibleChangeCommand=None, width=0, q=True, query=True, e=True,
                 edit=True, **kwargs):
    """
    The nodeOutliner command creates, edits and queries an outline control that shows
    dependency nodes and their attributes  Compound attributes are further expandable to show
    their children  Additional configure flags allow multi selection, customizable commands to
    issue upon selection, and showing connections (and connectability) to a single input
    at
    
    :param addCommand: (C Q E) Command executed when the node outliner adds something  String
    commands use substitution of the term %node for whatever is added, eg, if you want to
    :type addCommand: script
    :param addObject: (E) add the given object to the display
    :type addObject: name
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param attrAlphaOrder: (C Q E) Specify how attributes are to be sorted  Current recognised
    values are "default" for no sorting and "ascend" to sort attributes from 'a' to ''z' and
    :type attrAlphaOrder: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param connectivity: (Q E) Takes an attribute argument ("nodeName.attributeName"), dims any
    attributes that can't connect to the given, and highlights any attributes already co
    :type connectivity: name
    :param currentSelection: (Q) Retruns a string array containing what is currently selected
    :type currentSelection: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param lastClickedNode: (Q) Returns a string with the last clicked node
    :type lastClickedNode: boolean
    :param lastMenuChoice: (Q) Returns the text of the most recent menu selection
    :type lastMenuChoice: string
    :param longNames: (Q E) Controls whether long or short attribute names will be used in the
    interface  Note that this flag is ignored if the niceNames flag is set  Default is
    :type longNames: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param menuCommand: (E) Attaches the given command to each item in the popup menu
    :type menuCommand: script
    :param menuMultiOption: (Q E) Sets whether a menu option labelled "next available" will
    appear as the first option on any multi-attribute's right mouse button menu  Defaults to
    Tr
    :type menuMultiOption: boolean
    :param multiSelect: (Q E) Allow multiSelect; more than one thing to be selected at a time
    :type multiSelect: boolean
    :param niceNames: (Q E) Controls whether the attribute names will be displayed in a more
    user-friendly, readable way  When this is on, the longNames flag is ignored  When th
    :type niceNames: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param noConnectivity: (E) Reset the node outliner to not show any connectivity, ie, redraw
    all rows normally
    :type noConnectivity: boolean
    :param nodesDisplayed: (Q) Returns a string array containing the list of nodes showing in
    the node Outliner
    :type nodesDisplayed: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param pressHighlightsUnconnected: (Q E) Sets whether clicking on an unconnected plug will
    select it or not  Default is True
    :type pressHighlightsUnconnected: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param redraw: (E) Redraws the displayed space
    :type redraw: boolean
    :param redrawRow: (E) Redraws the given row
    :type redrawRow: boolean
    :param remove: (E M) remove the given object from the display
    :type remove: string
    :param removeAll: (E) remove all objects from the display
    :type removeAll: boolean
    :param replace: (Q E) replace what's displayed with the given objects
    :type replace: name
    :param selectCommand: (Q E) Command issued by selecting  Different from the c flag in that
    this command will only be issued if something is selected
    :type selectCommand: script
    :param showConnectedOnly: (Q E) show (true) or hide (false) only attributes that are
    connected matching input/output criteria
    :type showConnectedOnly: boolean
    :param showHidden: (Q E) show (true) or hide (false) UI invisible attributes that match the
    input/output criteria
    :type showHidden: boolean
    :param showInputs: (Q E) show only UI visible attributes that can be connected to
    :type showInputs: boolean
    :param showNonConnectable: (Q E) show (true) or hide (false) non connectable attributes
    that match the input/output criteria
    :type showNonConnectable: boolean
    :param showNonKeyable: (Q E) show (true) or hide (false) non keyframeable (animatable)
    attributes that match the input/output criteria
    :type showNonKeyable: boolean
    :param showOutputs: (Q E) show only UI visible attributes that can be connected from
    :type showOutputs: boolean
    :param showPublished: (Q E) Show only published attributes for an asset or a member of an
    asset  This flag is ignored on nodes not related to assets
    :type showPublished: boolean
    :param showReadOnly: (Q E) show only read only attributes attributes that can be connected
    from
    :type showReadOnly: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: 
    :rtype: None
    """
    pass


def createPolySoccerBallCtx(*args, **kwargs):
    """
    
    """
    pass


def extendCurve(*args, caching=True, distance=1, extendMethod=0, extensionType=0,
                inputPoint=None, join=True, nodeState=0, pointX=0, pointY=0, pointZ=0,
                removeMultipleKnots=False, start=1, constructionHistory=True,
                curveOnSurface=True, name="", noChanges=True, object=True, range=True,
                replaceOriginal=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command extends a curve or creates a new curve as an extension
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param distance: (C Q E) The distance to extend Used only for extendMethod is byDistance 
    Default: 1
    :type distance: float
    :param extendMethod: (C Q E) The method with which to extend: 0 - based on distance, 2 - to
    a 3D point Default: 0
    :type extendMethod: int
    :param extensionType: (C Q E) The type of extension: 0 - linear, 1 - circular, 2 -
    extrapolate Default: 0
    :type extensionType: int
    :param inputPoint: (C Q E) The point to extend to (optional)
    :type inputPoint: [float, float, float]
    :param join: (C Q E) If true, join the extension to original curve Default: true
    :type join: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param pointX: (C Q E) X of the point to extend to Default: 0
    :type pointX: float
    :param pointY: (C Q E) Y of the point to extend to Default: 0
    :type pointY: float
    :param pointZ: (C Q E) Z of the point to extend to Default: 0
    :type pointZ: float
    :param removeMultipleKnots: (C Q E) If true remove multiple knots at join Used only if join
    is true  Default: false
    :type removeMultipleKnots: boolean
    :param start: (C Q E) Which end of the curve to extend  0 - end, 1 - start, 2 - both
    Default: 1
    :type start: int
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param curveOnSurface: (C) If possible, create 2D curve as a result
    :type curveOnSurface: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param noChanges: (C Q E) If set then the operation node will be automatically put into
    pass-through mode
    :type noChanges: boolean
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param range: (C) Force a curve range on complete input curve
    :type range: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def ToggleViewCube(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def fluidDeleteCacheFramesOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AnimationTurntable(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polySplitRing(*args, adjustEdgeFlow=1.0, caching=True, constructionHistory=True,
                  direction=True, divisions=2, enableProfileCurve=True, fixQuads=False,
                  insertWithEdgeFlow=False, name="", nodeState=0, profileCurveInputOffset=0.0,
                  profileCurveInputScale=1.0, profileCurve_FloatValue=0.0,
                  profileCurve_Interp=0, profileCurve_Position=0.0, rootEdge=1,
                  smoothingAngle=0.0, splitType=0, useEqualMultiplier=True,
                  useFaceNormalsAtEnds=True, weight=0.5, worldSpace=True, q=True, query=True,
                  e=True, edit=True, **kwargs):
    """
    Splits a series of ring edges of connected quads and inserts connecting edges between them
    
    :param adjustEdgeFlow: (C Q E) The weight value of the edge vertices to be positioned 
    Default: 1.0f
    :type adjustEdgeFlow: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param direction: (C Q E) This attribute is used when doing an absolute split  If true then
    the distance is taken from the start vertex of the root edge  If false the distance
    :type direction: boolean
    :param divisions: (C Q E) Number of divisions  Default: 2
    :type divisions: int
    :param enableProfileCurve: (C Q E) Enables the use of the profile curve  Default: true
    :type enableProfileCurve: boolean
    :param fixQuads: (C Q E) Fixes splits which go across a quad face leaving a 5 and 3 sided
    faces by splitting from the middle of the new edge to the vertex accross from the ed
    :type fixQuads: boolean
    :param insertWithEdgeFlow: (C Q E) True to enable edge flow  Otherwise, the edge flow is
    disabled  Default: false
    :type insertWithEdgeFlow: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param profileCurveInputOffset: (C Q E) Changes the offset to the multisplit profile curve 
    eg  if the profile curve values go between 0 and 1 and this value is set to -1 then the
    profile c
    :type profileCurveInputOffset: float
    :param profileCurveInputScale: (C Q E) Changes the range of values that the profile curve
    represents  eg  if the profile curve values go between 0 and 1 and this value is set to 2
    then the
    :type profileCurveInputScale: float
    :param profileCurve_FloatValue: (C Q E) ?????
    :type profileCurve_FloatValue: float
    :param profileCurve_Interp: (C Q E) ????? Default: 0
    :type profileCurve_Interp: int
    :param profileCurve_Position: (C Q E) ?????
    :type profileCurve_Position: float
    :param rootEdge: (C Q E) The weight attribute uses the start vertex of this edge to
    determine where the new split occurs  Default: -1
    :type rootEdge: int
    :param smoothingAngle: (C Q E) Angle below which new edges will be smoothed Default: kPi
    :type smoothingAngle: float
    :param splitType: (C Q E) Format: 0 - Absolute, 1 - Relative, 2 - Multi Default:
    TdnpolySplitRing::Relative
    :type splitType: int
    :param useEqualMultiplier: (C Q E) Changes how the profile curve effects the offset when
    doing a multisplit  If true then the verts will be offset the same distance based on the
    shorte
    :type useEqualMultiplier: boolean
    :param useFaceNormalsAtEnds: (C Q E) When doing a multisplit on a set of non-closed edge
    ring this will toggle the normals at the ends of the split to be calculated as the edge
    normal or
    :type useFaceNormalsAtEnds: boolean
    :param weight: (C Q E) Weight value controlling the relative positioning of the new points
    on existing edges  Range is [0.0, 1.0]  Value of 0.1 indicates the new edges will
    :type weight: float
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def SculptMeshActivateBrushStrength(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def inheritTransform(*args, off=True, on=True, preserve=True, toggle=True, q=True, query=True,
                     **kwargs):
    """
    This command toggles the inherit state of an object  If this flag is off the object will
    not inherit transformations from its parent  In other words transformations applied to the
    parent node will not affect the object and it will act as though it is under the world   If
    the -p flag is specified then the object's transformation will be modified to 
    
    :param off: (C Q) turn off inherit state for the given object(s)
    :type off: boolean
    :param on: (C Q) turn on inherit state for the given object(s)
    :type on: boolean
    :param preserve: (C Q) preserve the objects world-space position by modifying the object(s)
    transformation matrix
    :type preserve: boolean
    :param toggle: (C Q) toggle the inherit state for the given object(s) (default if no flags
    are given) -on turn on inherit state for the given object(s) -off turn off inhe
    :type toggle: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def manipMoveContext(*args, activeHandle=0, activeHandleNormal=3, alignAlong=None,
                     constrainAlongNormal=True, currentActiveHandle=0, editPivotMode=True,
                     editPivotPosition=True, exists=True, image1="", image2="", image3="",
                     interactiveUpdate=True, lastMode=0, manipVisible=True, mode=3,
                     orientAxes=None, orientJoint="", orientJointEnabled=True, orientObject="",
                     orientTowards=None, pinPivot=True, pivotOriHandle=True, position=True,
                     postCommand=None, postDragCommand=None, preCommand=None,
                     preDragCommand=None, preserveChildPosition=False, preserveUV=True,
                     reflection=True, reflectionAbout=0, reflectionAxis=0,
                     reflectionTolerance=0.0, secondaryAxisOrient="", snap=True,
                     snapComponentsRelative=True, snapLiveFaceCenter=True, snapLivePoint=True,
                     snapPivotOri=True, snapPivotPos=True, snapRelative=True, snapValue=0.0,
                     translate=None, tweakMode=True, xformConstraint="", q=True, query=True,
                     e=True, edit=True, **kwargs):
    """
    This command can be used to create, edit, or query a move manip context  Note that the
    flags -s, -sv, -sr, -scr, -slp, -slf control the global behaviour of all move manip context
     Changing one context independently is not allowed  Changing a context's behaviour using
    the above flags, will change all existing move manip context
    
    :param activeHandle: (Q E) Sets the default active handle for the manip  That is, the
    handle which should be initially active when the tool is activated  Values can be: 0 - X a
    :type activeHandle: int
    :param activeHandleNormal: (Q E) 0 - U axis handle is active 1 - V axis handle is active 2
    - N axis handle is active ( default ) 3 - Center handle (all 3 axes) is active applicable
    o
    :type activeHandleNormal: int
    :param alignAlong: (C E) Aligns active handle along vector
    :type alignAlong: [float, float, float]
    :param constrainAlongNormal: (Q E) When true, transform constraints are applied along the
    vertex normal first and only use the closest point when no intersection is found along the
    nor
    :type constrainAlongNormal: boolean
    :param currentActiveHandle: (Q E) Sets the active handle for the manip  Values can be: 0 -
    X axis handle is active 1 - Y axis handle is active 2 - Z axis handle is active 3 - Center
    h
    :type currentActiveHandle: int
    :param editPivotMode: (Q) Returns true manipulator is in edit pivot mode
    :type editPivotMode: boolean
    :param editPivotPosition: (Q) Returns the current position of the edit pivot manipulator
    :type editPivotPosition: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param interactiveUpdate: (Q E) Value can be : true or false  This flag value is valid only
    if the mode is 3 i.e  move vertex normal
    :type interactiveUpdate: boolean
    :param lastMode: (Q) Returns the previous translation mode
    :type lastMode: int
    :param manipVisible: (Q) Returns true if the main translate manipulator is visible
    :type manipVisible: boolean
    :param mode: (Q E) Translate mode: 0 - Object Space 1 - Local Space 2 - World Space
    (default) 3 - Move Along Vertex Normal 4 - Move Along Rotation Axis 5 - Move Along L
    :type mode: int
    :param orientAxes: (Q E) Orients manipulator rotating around axes by specified angles
    :type orientAxes: [float, float, float]
    :param orientJoint: (Q E) Specifies the type of orientation for joint orientation  Valid
    options are: none, xyz, xzy, yxz, yzx, zxy, zyx
    :type orientJoint: string
    :param orientJointEnabled: (Q E) Specifies if joints should be reoriented when moved
    :type orientJointEnabled: boolean
    :param orientObject: (C E) Orients manipulator to the passed in object/component
    :type orientObject: string
    :param orientTowards: (C E) Orients active handle towards world point
    :type orientTowards: [float, float, float]
    :param pinPivot: (Q E) Pin component pivot  When the component pivot is set and pinned
    selection changes will not reset the pivot position and orientation
    :type pinPivot: boolean
    :param pivotOriHandle: (Q E) When true, the pivot manipulator will show the orientation
    handle during editing  Default is true
    :type pivotOriHandle: boolean
    :param position: (Q) Returns the current position of the manipulator
    :type position: boolean
    :param postCommand: (C E) Specifies a command to be executed when the tool is exited
    :type postCommand: script
    :param postDragCommand: (C E) Specifies a command and a node type  The command will be
    executed at the end of a drag when a node of the specified type is in the selection
    :type postDragCommand: [script, string]
    :param preCommand: (C E) Specifies a command to be executed when the tool is entered
    :type preCommand: script
    :param preDragCommand: (C E) Specifies a command and a node type  The command will be
    executed at the start of a drag when a node of the specified type is in the selection
    :type preDragCommand: [script, string]
    :param preserveChildPosition: (Q E) When false, the children objects move when their parent
    is moved  When true, the worldspace position of the children will be maintained as the
    parent
    :type preserveChildPosition: boolean
    :param preserveUV: (Q E) When false, the uvs are not changes to match the vertex edit  When
    true, the uvs are edited to project to new values to stop texture swimming as vert
    :type preserveUV: boolean
    :param reflection: () This flag is obsolete  Reflection is now managed as part of selection
    itself using the symmetricModeling command
    :type reflection: boolean
    :param reflectionAbout: () This flag is obsolete  Reflection is now managed as part of
    selection itself using the symmetricModeling command
    :type reflectionAbout: int
    :param reflectionAxis: () This flag is obsolete  Reflection is now managed as part of
    selection itself using the symmetricModeling command
    :type reflectionAxis: int
    :param reflectionTolerance: () This flag is obsolete  Reflection is now managed as part of
    selection itself using the symmetricModeling command
    :type reflectionTolerance: float
    :param secondaryAxisOrient: (Q E) Specifies the global axis (in world coordinates) that
    should be used to should be used to align the second axis of the orientJointType triple 
    Valid
    :type secondaryAxisOrient: string
    :param snap: (Q E) Value can be : true or false  Enable/Disable the discrete move  If set
    to true, the move manipulator of all the move contexts would snap at discrete
    :type snap: boolean
    :param snapComponentsRelative: (Q E) Value can be : true or false  If true, while snapping
    a group of CVs/Vertices, the relative spacing between them will be preserved  If false, all
    the
    :type snapComponentsRelative: boolean
    :param snapLiveFaceCenter: (Q E) Value can be : true or false  If true, while moving on the
    live polygon object, the move manipulator will snap to the face centers of the object
    :type snapLiveFaceCenter: boolean
    :param snapLivePoint: (Q E) Value can be : true or false  If true, while moving on the live
    polygon object, the move manipulator will snap to the vertices of the object
    :type snapLivePoint: boolean
    :param snapPivotOri: (Q E) Snap pivot orientation  Modify pivot orientation when snapping
    the pivot to a component
    :type snapPivotOri: boolean
    :param snapPivotPos: (Q E) Snap pivot position  Modify pivot position when snapping the
    pivot to a component
    :type snapPivotPos: boolean
    :param snapRelative: (Q E) Value can be : true or false  Applicable only when the snap is
    enabled  If true, the snapValue is treated relative to the original position before mo
    :type snapRelative: boolean
    :param snapValue: (Q E) Applicable only when the snap is enabled  The manipulator of all
    move contexts would move in steps of 'snapValue'
    :type snapValue: float
    :param translate: (Q E) Returns the translation of the manipulator for its current
    orientation/mode
    :type translate: [float, float, float]
    :param tweakMode: (Q E) When true, the manipulator is hidden and highlighted components can
    be selected and moved in one step using a click-drag interaction
    :type tweakMode: boolean
    :param xformConstraint: (Q E) none - no transform constraint edge - edge transform
    constraint surface - surface transform constraint
    :type xformConstraint: string
    
    :returns: The name of the new context
    :rtype: string
    """
    pass


def constructionHistory(*args, toggle=True, q=True, query=True, **kwargs):
    """
    This command turns construction history on or off
    
    :param toggle: (C Q) Turns construction history on or off
    :type toggle: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def ConformPolygonNormals(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ScaleToolWithSnapMarkingMenuPopDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyAppend(*args, append=None, constructionHistory=True, edge=0, hole=True, name="",
               point=None, subdivision=1, texture=0, q=True, query=True, e=True, edit=True,
               **kwargs):
    """
    Appends a new face to the selected polygonal object  The first argument must be a border
    edge  The new face will be automatically closed
    
    :param append: (C M) Appends to the given polygon object  The append flag should be used
    multiple times to specify the edges, points, and holes that make up the new face
    :type append: [[, float, float, float, ]]
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param edge: (C M) Adds the given edge of the selected object to the new face  This edge
    must be a border, which will be then shared by the new face and the neighboring
    :type edge: int
    :param hole: (C M) Add a hole  The following points and edges will define a hole  Note that
    this flag should be avoided in Python  You may use the "append" flag instead
    :type hole: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param point: (C M) Adds a new point to the new face  Coordinates of free points are given
    in the local object reference  Note that this flag should be avoided in Python
    :type point: [float, float, float]
    :param subdivision: (C Q E) This flag specifies the level of subdivisions  Automatically
    subdivides new edges into the given number of edges  Existing edges cannot be subdivided
    :type subdivision: int
    :param texture: (C Q E) Specifies how new faces are mapped  0 - None; 1 - Normalize; 2 -
    Unitize C: Default is 0 (no mapping)  Q: When queried, this flag returns an int
    :type texture: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def XgmSetSelectBrushToolOption(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateFBIKOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CopyVertexSkinWeights(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddBifrostEmissionRegion(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def disconnectAttr(*args, nextAvailable=True, **kwargs):
    """
    Disconnects two connected attributes  First argument is the source attribute, second is the
    destination
    
    :param nextAvailable: (C) If the destination multi-attribute has set the indexMatters to be
    false, the command will disconnect the first matching connection  No index needs to
    :type nextAvailable: boolean
    
    :returns: A phrase containing the names of the disconnected attributes.
    :rtype: string
    """
    pass


def manipMoveLimitsCtx(*args, exists=True, history=True, image1="", image2="", image3="",
                       name="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    Create a context for the translate limits manipulator
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: Name of newly created context
    :rtype: string
    """
    pass


def ArchiveSceneOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeviceEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleFaceNormalDisplay(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OutlinerToggleShowMuteInformation(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorOpenContentBrowser(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def toggleAxis(*args, origin=True, view=True, q=True, query=True, **kwargs):
    """
    Toggles the state of the display axis   Note: the display of the axis in the bottom left
    corner has been rendered obsolete by the headsUpDisplay command
    
    :param origin: (C Q) Turns display of the axis at the origin of the ground plane on or off
    :type origin: boolean
    :param view: (C Q) Turns display of the axis at the bottom left of each view on or off 
    (Obsolete - refer to the headsUpDisplay command)
    :type view: boolean
    
    :returns: if in the query mode, otherwise none.
    :rtype: boolean
    """
    pass


def HideFur(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSetNoiseBrushTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadePinByDefault(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteHair(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_modeEdge(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorCreateAudioClip(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorCreateForEachCompound(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetDrivenKeyOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreatePartition(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def performanceOptions(*args, clusterResolution=0.0, disableStitch="",
                       disableTrimBoundaryDisplay="", disableTrimDisplay="",
                       latticeResolution=0.0, passThroughBindSkinAndFlexors="",
                       passThroughBlendShape="", passThroughCluster="", passThroughDeltaMush="",
                       passThroughFlexors="", passThroughLattice="", passThroughPaintEffects="",
                       passThroughSculpt="", passThroughWire="", skipHierarchyTraversal=True,
                       useClusterResolution="", useLatticeResolution="", q=True, query=True,
                       **kwargs):
    """
    Sets the global performance options for the application  The options allow the disabling of
    features such as stitch surfaces or deformers to cut down on computation time in the scene 
     Performance options that are in effect may be on all the time, or they can be turned on
    only for interaction  In the latter case, the options will only take effect d
    
    :param clusterResolution: (Q) Sets the global cluster resolution  This value may range
    between 0.0 (exact calculation) and 10.0 (rough approximation)
    :type clusterResolution: float
    :param disableStitch: (Q) Sets the state of stitch surface disablement  Setting this to
    "on" suppresses the generation of stitch surfaces  Valid values are "on", "off", "inter
    :type disableStitch: string
    :param disableTrimBoundaryDisplay: (Q) Sets the state of trim boundary drawing disablement 
    Setting this to "on" suppresses the drawing of surface trim boundaries  Valid values are
    "on", "
    :type disableTrimBoundaryDisplay: string
    :param disableTrimDisplay: (Q) Sets the state of trim drawing disablement  Setting this to
    "on" suppresses the drawing of surface trims  Valid values are "on", "off", "interactive"
    :type disableTrimDisplay: string
    :param latticeResolution: (Q) Sets the global lattice resolution  This value may range
    between 0.0 (exact calculation) and 1.0 (rough approximation)
    :type latticeResolution: float
    :param passThroughBindSkinAndFlexors: (Q) Sets the state of bind skin and all flexors pass
    through  Valid values are "on", "off", "interactive"
    :type passThroughBindSkinAndFlexors: string
    :param passThroughBlendShape: (Q) Sets the state of blend shape deformer pass through 
    Valid values are "on", "off", "interactive"
    :type passThroughBlendShape: string
    :param passThroughCluster: (Q) Sets the state of cluster deformer pass through  Valid
    values are "on", "off", "interactive"
    :type passThroughCluster: string
    :param passThroughDeltaMush: (Q) Sets the state of delta mush deformer pass through  Valid
    values are "on", "off", "interactive"
    :type passThroughDeltaMush: string
    :param passThroughFlexors: (Q) Sets the state of flexor pass through  Valid values are "on",
    "off", "interactive"
    :type passThroughFlexors: string
    :param passThroughLattice: (Q) Sets the state of lattice deformer pass through  Valid
    values are "on", "off", "interactive"
    :type passThroughLattice: string
    :param passThroughPaintEffects: (Q) Sets the state of paint effects pass through  Valid
    values are "on", "off", "interactive"
    :type passThroughPaintEffects: string
    :param passThroughSculpt: (Q) Sets the state of sculpt deformer pass through  Valid values
    are "on", "off", "interactive"
    :type passThroughSculpt: string
    :param passThroughWire: (Q) Sets the state of wire deformer pass through  Valid values are
    "on", "off", "interactive"
    :type passThroughWire: string
    :param skipHierarchyTraversal: (Q) When enabled, hierarchy traversal of invisible objects
    in the scene will be disabled in order to increase performance however this has a side
    effect
    :type skipHierarchyTraversal: boolean
    :param useClusterResolution: (Q) Sets the state of cluster deformer global resolution  This
    allows clusters to be calculated at a lower resolution  Valid values are "on", "off", "int
    :type useClusterResolution: string
    :param useLatticeResolution: (Q) Sets the state of lattice deformer global resolution  This
    allows lattices to be calculated at a lower resolution  Valid values are "on", "off", "int
    :type useLatticeResolution: string
    
    :returns: One of "on", "off", or "interactive" giving the state of the option
    :rtype: string
    """
    pass


def HIKSetSelectionKey(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def IntersectSurfacesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleFaceNormals(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PaintEffectsToNurbs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DoUnghostOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TangentsStepped(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def manipScaleContext(*args, activeHandle=0, alignAlong=None, constrainAlongNormal=True,
                      currentActiveHandle=0, editPivotMode=True, editPivotPosition=True,
                      exists=True, image1="", image2="", image3="", lastMode=0,
                      manipVisible=True, mode=3, orientAxes=None, orientObject="",
                      orientTowards=None, pinPivot=True, pivotOriHandle=True, position=True,
                      postCommand=None, postDragCommand=None, preCommand=None,
                      preDragCommand=None, preserveChildPosition=False, preserveUV=True,
                      preventNegativeScale=True, reflection=True, reflectionAbout=0,
                      reflectionAxis=0, reflectionTolerance=0.0, scale=None, snap=True,
                      snapPivotOri=True, snapPivotPos=True, snapRelative=True, snapValue=0.0,
                      tweakMode=True, useManipPivot=True, useObjectPivot=True,
                      xformConstraint="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command can be used to create, edit, or query a scale manip context
    
    :param activeHandle: (Q E) Sets the default active handle for the manip  That is, the
    handle which should be initially active when the tool is activated  Values can be: 0 - X a
    :type activeHandle: int
    :param alignAlong: (C E) Aligns active handle along vector
    :type alignAlong: [float, float, float]
    :param constrainAlongNormal: (Q E) When true, transform constraints are applied along the
    vertex normal first and only use the closest point when no intersection is found along the
    nor
    :type constrainAlongNormal: boolean
    :param currentActiveHandle: (Q E) Sets the active handle for the manip  Values can be: 0 -
    X axis handle is active 1 - Y axis handle is active 2 - Z axis handle is active 3 - Center
    h
    :type currentActiveHandle: int
    :param editPivotMode: (Q) Returns true manipulator is in edit pivot mode
    :type editPivotMode: boolean
    :param editPivotPosition: (Q) Returns the current position of the edit pivot manipulator
    :type editPivotPosition: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param lastMode: (Q) Returns the previous scaling mode
    :type lastMode: int
    :param manipVisible: (Q) Returns true if the scale manipulator is visible
    :type manipVisible: boolean
    :param mode: (Q E) Scale mode: 0 - Object Space 1 - Local Space 2 - World Space (default) 3
    - Scale Along Vertex Normal 4 - Scale Along Rotation Axis 5 - Scale Along Li
    :type mode: int
    :param orientAxes: (Q E) Orients manipulator rotating around axes by specified angles
    :type orientAxes: [float, float, float]
    :param orientObject: (C E) Orients manipulator to the passed in object/component
    :type orientObject: string
    :param orientTowards: (C E) Orients active handle towards world point
    :type orientTowards: [float, float, float]
    :param pinPivot: (Q E) Pin component pivot  When the component pivot is set and pinned
    selection changes will not reset the pivot position and orientation
    :type pinPivot: boolean
    :param pivotOriHandle: (Q E) When true, the pivot manipulator will show the orientation
    handle during editing  Default is true
    :type pivotOriHandle: boolean
    :param position: (Q) Returns the current position of the manipulator
    :type position: boolean
    :param postCommand: (C E) Specifies a command to be executed when the tool is exited
    :type postCommand: script
    :param postDragCommand: (C E) Specifies a command and a node type  The command will be
    executed at the end of a drag when a node of the specified type is in the selection
    :type postDragCommand: [script, string]
    :param preCommand: (C E) Specifies a command to be executed when the tool is entered
    :type preCommand: script
    :param preDragCommand: (C E) Specifies a command and a node type  The command will be
    executed at the start of a drag when a node of the specified type is in the selection
    :type preDragCommand: [script, string]
    :param preserveChildPosition: (Q E) When false, the children objects move when their parent
    is rotated  When true, the worldspace position of the children will be maintained as the
    pare
    :type preserveChildPosition: boolean
    :param preserveUV: (Q E) When false, the uvs are not changes to match the vertex edit  When
    true, the uvs are edited to project to new values to stop texture swimming as vert
    :type preserveUV: boolean
    :param preventNegativeScale: (Q) When this is true, negative scale is not allowed
    :type preventNegativeScale: boolean
    :param reflection: () This flag is obsolete  Reflection is now managed as part of selection
    itself using the symmetricModeling command
    :type reflection: boolean
    :param reflectionAbout: () This flag is obsolete  Reflection is now managed as part of
    selection itself using the symmetricModeling command
    :type reflectionAbout: int
    :param reflectionAxis: () This flag is obsolete  Reflection is now managed as part of
    selection itself using the symmetricModeling command
    :type reflectionAxis: int
    :param reflectionTolerance: () This flag is obsolete  Reflection is now managed as part of
    selection itself using the symmetricModeling command
    :type reflectionTolerance: float
    :param scale: (Q E) Returns the scale of the manipulator for its current orientation/mode
    :type scale: [float, float, float]
    :param snap: (C Q E) Specify that the manipulation is to use absolute snap
    :type snap: boolean
    :param snapPivotOri: (Q E) Snap pivot orientation  Modify pivot orientation when snapping
    the pivot to a component
    :type snapPivotOri: boolean
    :param snapPivotPos: (Q E) Snap pivot position  Modify pivot position when snapping the
    pivot to a component
    :type snapPivotPos: boolean
    :param snapRelative: (C Q E) Specify that the manipulation is to use relative snap
    :type snapRelative: boolean
    :param snapValue: (C Q E) Specify the snapping value
    :type snapValue: float
    :param tweakMode: (Q E) When true, the manipulator is hidden and highlighted components can
    be selected and scaled in one step using a click-drag interaction
    :type tweakMode: boolean
    :param useManipPivot: (C Q E) Specify whether to pivot on the manip
    :type useManipPivot: boolean
    :param useObjectPivot: (C Q E) Specify whether to pivot on the object
    :type useObjectPivot: boolean
    :param xformConstraint: (Q E) none - no transform constraint edge - edge transform
    constraint surface - surface transform constraint
    :type xformConstraint: string
    
    :returns: (name of the new context)
    :rtype: string
    """
    pass


def DeleteConstraints(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ResampleCurveOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleNormals(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_nexCmd(*args, **kwargs):
    """
    
    """
    pass


def TimeEditorToggleMuteSelectedTracks(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nBase(*args, clearCachedTextureMap="", clearStart=True, stuffStart=True, textureToVertex="",
          q=True, query=True, e=True, edit=True, **kwargs):
    """
    Edits one or more nBase objects  Note that nBase objects include nCloth, nRigid and
    nParticle objects, but the options on this command do not currently apply to nParticle
    objects
    
    :param clearCachedTextureMap: (C E) Clear the cached texture map for the specified
    attribute from the nBase
    :type clearCachedTextureMap: string
    :param clearStart: (C E) Indicates that start state should be cleared
    :type clearStart: boolean
    :param stuffStart: (C E) Indicates that current state should be stuffed into the start
    state
    :type stuffStart: boolean
    :param textureToVertex: (C E) Transfer the texture map data for the specified attribute
    into the related per-vertex attribute
    :type textureToVertex: string
    
    :returns: Command result
    :rtype: boolean
    """
    pass


def PreInfinityLinear(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SphericalProjectionOptions(*args, **kwargs):
    """
    unknown
    """
    pass


def ConvertSelectionToEdges(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def toggleWindowVisibility(*args, **kwargs):
    """
    Toggle the visibility of a window  If no window is specified then the current window (most
    recently created) is used  See also the window command's vis/visible flag
    
    
    :returns: 
    :rtype: None
    """
    pass


def filterExpand(*args, expand=True, fullPath=False, selectionMask=0, symActive=True,
                 symNegative=True, symPositive=True, symSeam=True, **kwargs):
    """
    Based on selected components (or components specified on the command line), the command
    filters and/or expands the list given the options  Returns a string array containing all
    matching selection items  Selection masks are as follows:  Object Type Mask Handle 0 Nurbs
    Curves 9 Nurbs Surfaces 10 Nurbs Curves On Surface 11 Polygon 12 Locator XYZ 22 Or
    
    :param expand: (C) Each item is a single entity if this is true  Default is true
    :type expand: boolean
    :param fullPath: (C) If this is true and the selection item is a DAG object, return its
    full selection path, instead of the name of the object only when this value is fal
    :type fullPath: boolean
    :param selectionMask: (C M) Specify the selection mask
    :type selectionMask: int
    :param symActive: (C) If symmetry is enabled only return the components on the active
    symmetry side of the object  This flag has no effect if symmetry is not active
    :type symActive: boolean
    :param symNegative: (C) If symmetry is enabled only return the components on the negative
    side of the object relative to the current symmetry plane  This flag has no effect
    :type symNegative: boolean
    :param symPositive: (C) If symmetry is enabled only return the components on the positive
    side of the object relative to the current symmetry plane  This flag has no effect
    :type symPositive: boolean
    :param symSeam: (C) If symmetry is enabled only return the components that lie equally on
    both sides of the object relative to the current symmetry plane  This flag has
    :type symSeam: boolean
    
    :returns: Command result
    :rtype: string[]
    """
    pass


def TagAsControllerParent(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TemplateBrushSettings(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ReorderVertex(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ctxAbort(*args, **kwargs):
    """
    This command tells the current context to reset itself, losing what has been done so far 
    If a escape context has been set it then makes that context current
    
    
    :returns: 
    :rtype: None
    """
    pass


def AddDivisionsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def colorManagementCatalog(*args, addTransform="", editUserTransformPath="",
                           listSupportedExtensions=True, listTransformConnections=True, path="",
                           queryUserTransformPath=True, removeTransform="",
                           transformConnection="", type="", **kwargs):
    """
    This non-undoable action performs additions and removals of custom color transforms from
    the Autodesk native color transform catalog  Once a custom color transform has been added
    to the catalog, it can be used in the same way as the builtin Autodesk native color
    transforms
    
    :param addTransform: (C) Add transform to collection
    :type addTransform: string
    :param editUserTransformPath: (C) Edit the user transform directory  By changing the
    directory, all custom transforms currently added could be changed, and new ones could
    appear
    :type editUserTransformPath: string
    :param listSupportedExtensions: (C) List the file extensions that are supported by add
    transform  This list is valid for all transform types, and therefore this flag does not
    require us
    :type listSupportedExtensions: boolean
    :param listTransformConnections: (C) List the transforms that can be used as source (for
    "view" and "output" types) or destination (for "input" and "rendering space" types) to
    connect a
    :type listTransformConnections: boolean
    :param path: (C) In addTransform mode, the path to the transform data file
    :type path: string
    :param queryUserTransformPath: (C) Query the user transform directory
    :type queryUserTransformPath: boolean
    :param removeTransform: (C) Remove transform from collection
    :type removeTransform: string
    :param transformConnection: (C) In addTransform mode, an existing transform to which the
    added transform will be connected  For an input transform or rendering space transform,
    this
    :type transformConnection: string
    :param type: (C) The type of transform added, removed, or whose transform connections are
    to be listed  Must be one of "view", "rendering space", "input", or "output"
    :type type: string
    
    :returns: 
    :rtype: None
    """
    pass


def FBXExportConvertUnitString(*args, **kwargs):
    """
    
    """
    pass


def NodeEditorExtendToShapes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def U3DBrushSizeOn(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyCut(*args, caching=True, constructionHistory=True, cutPlaneCenter=None,
            cutPlaneCenterX=0.0, cutPlaneCenterY=0.0, cutPlaneCenterZ=0.0, cutPlaneHeight=0.0,
            cutPlaneRotate=None, cutPlaneRotateX=0.0, cutPlaneRotateY=0.0, cutPlaneRotateZ=0.0,
            cutPlaneSize=None, cutPlaneWidth=0.0, cuttingDirection="", deleteFaces=False,
            extractFaces=False, extractOffset=None, extractOffsetX=0.0, extractOffsetY=0.0,
            extractOffsetZ=0.0, name="", nodeState=0, onObject=True, worldSpace=True, q=True,
            query=True, e=True, edit=True, **kwargs):
    """
    This command splits a mesh, or a set of poly faces, along a plane  The position and
    orientation of the plane can be adjusted using the appropriate flags listed above  In
    addition, the cut operation can also delete the faces lying on one side of the cutting
    plane, or extract those faces by an offset amount
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param cutPlaneCenter: (C Q E) The position of the cutting plane  Default: 0.0, 0.0, 0.0
    :type cutPlaneCenter: [float, float, float]
    :param cutPlaneCenterX: (C Q E) Cutting plane center X coord
    :type cutPlaneCenterX: float
    :param cutPlaneCenterY: (C Q E) Cutting plane center Y coord
    :type cutPlaneCenterY: float
    :param cutPlaneCenterZ: (C Q E) Cutting plane center Z coord
    :type cutPlaneCenterZ: float
    :param cutPlaneHeight: (C Q E) The height of the cutting plane
    :type cutPlaneHeight: float
    :param cutPlaneRotate: (C Q E) The orientation of the cutting plane  Default: 0.0, 0.0,
    0.0
    :type cutPlaneRotate: [float, float, float]
    :param cutPlaneRotateX: (C Q E) cutting plane X rotate angle
    :type cutPlaneRotateX: float
    :param cutPlaneRotateY: (C Q E) cutting plane Y rotate angle
    :type cutPlaneRotateY: float
    :param cutPlaneRotateZ: (C Q E) cutting plane Z rotate angle
    :type cutPlaneRotateZ: float
    :param cutPlaneSize: (C Q E) The width and the height of the cutting plane Default: 1.0,
    1.0
    :type cutPlaneSize: [float, float]
    :param cutPlaneWidth: (C Q E) The width of the cutting plane
    :type cutPlaneWidth: float
    :param cuttingDirection: (C) This flag specifies the direction of the cutting plane  Valid
    values are "x", "y", "z" A value of "x" will cut the object along the YZ plane cutting
    :type cuttingDirection: string
    :param deleteFaces: (C Q E) whether to delete the one-half of the cut-faces of the poly  If
    true, they are deleted  Default: false
    :type deleteFaces: boolean
    :param extractFaces: (C Q E) whether to extract the cut-faces of the poly into a separate
    shell  If true, they are extracted  Default: false
    :type extractFaces: boolean
    :param extractOffset: (C Q E) The displacement offset of the cut faces  Default: 0.5, 0.5,
    0.5
    :type extractOffset: [float, float, float]
    :param extractOffsetX: (C Q E) The X-displacement offset of the cut faces
    :type extractOffsetX: float
    :param extractOffsetY: (C Q E) The Y-displacement offset of the cut faces
    :type extractOffsetY: float
    :param extractOffsetZ: (C Q E) The Z-displacement offset of the cut faces
    :type extractOffsetZ: float
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param onObject: (C Q E) whether to act on the entire polyObject or its selected face
    components Default: true
    :type onObject: boolean
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def vnnPaste(*args, **kwargs):
    """
    
    """
    pass


def retimeKeyCtx(*args, exists=True, history=True, image1="", image2="", image3="",
                 moveByFrame=0, name="", snapOnFrame=True, q=True, query=True, e=True,
                 edit=True, **kwargs):
    """
    This command creates a context which may be used to scale keyframes within the graph editor
    using the retime tool
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param moveByFrame: (E) Move the selected retime bar by the specified number of frames
    :type moveByFrame: int
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param snapOnFrame: (Q E) When set, the retime markers will snap on frames as they are
    moved
    :type snapOnFrame: boolean
    
    :returns: Query value from the snapOnFame setting.
    :rtype: boolean
    """
    pass


def CreateNURBSSphereOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeImport(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def listAttr(*args, array=True, caching=True, category="", changedSinceFileOpen=True,
             channelBox=True, connectable=True, extension=True, fromPlugin=True, hasData=True,
             hasNullData=True, inUse=True, keyable=True, leaf=True, locked=True, multi=True,
             output=True, ramp=True, read=True, readOnly=True, scalar=True, scalarAndArray=True,
             settable=True, shortNames=True, string="", unlocked=True, usedAsFilename=True,
             userDefined=True, visible=True, write=True, **kwargs):
    """
    This command lists the attributes of a node  If no flags are specified all attributes are
    listed
    
    :param array: (C) only list array (not multi) attributes
    :type array: boolean
    :param caching: (C) only show attributes that are cached internally
    :type caching: boolean
    :param category: (C M) only show attributes belonging to the given category  Category
    string can be a regular expression
    :type category: string
    :param changedSinceFileOpen: (C) Only list the attributes that have been changed since the
    file they came from was opened  Typically useful only for objects/attributes coming from
    re
    :type changedSinceFileOpen: boolean
    :param channelBox: (C) only show non-keyable attributes that appear in the channelbox
    :type channelBox: boolean
    :param connectable: (C) only show connectable attributes
    :type connectable: boolean
    :param extension: (C) list user-defined attributes for all nodes of this type (extension
    attributes)
    :type extension: boolean
    :param fromPlugin: (C) only show attributes that were created by a plugin
    :type fromPlugin: boolean
    :param hasData: (C) list only attributes that have data (all attributes except for message
    attributes)
    :type hasData: boolean
    :param hasNullData: (C) list only attributes that have null data  This will list all
    attributes that have data (see hasData flag) but the data value is uninitialized  A comm
    :type hasNullData: boolean
    :param inUse: (C) only show attributes that are currently marked as in use  This flag
    indicates that an attribute affects the scene data in some way  For example it ha
    :type inUse: boolean
    :param keyable: (C) only show attributes that can be keyframed
    :type keyable: boolean
    :param leaf: (C) Only list the leaf-level name of the attribute  controlPoints[44].xValue
    would be listed as "xValue"
    :type leaf: boolean
    :param locked: (C) list only attributes which are locked
    :type locked: boolean
    :param multi: (C) list each currently existing element of a multi-attribute
    :type multi: boolean
    :param output: (C) List only the attributes which are numeric or which are compounds of
    numeric attributes
    :type output: boolean
    :param ramp: (C) list only attributes which are ramps
    :type ramp: boolean
    :param read: (C) list only attributes which are readable
    :type read: boolean
    :param readOnly: (C) List only the attributes which are readable and not writable
    :type readOnly: boolean
    :param scalar: (C) only list scalar numerical attributes
    :type scalar: boolean
    :param scalarAndArray: (C) only list scalar and array attributes
    :type scalarAndArray: boolean
    :param settable: (C) list attribute which are settable
    :type settable: boolean
    :param shortNames: (C) list short attribute names (default is to list long names)
    :type shortNames: boolean
    :param string: (C M) List only the attributes that match the other criteria AND match the
    string(s) passed from this flag  String can be a regular expression
    :type string: string
    :param unlocked: (C) list only attributes which are unlocked
    :type unlocked: boolean
    :param usedAsFilename: (C) list only attributes which are designated to be treated as
    filenames
    :type usedAsFilename: boolean
    :param userDefined: (C) list user-defined (dynamic) attributes
    :type userDefined: boolean
    :param visible: (C) only show visible or non-hidden attributes
    :type visible: boolean
    :param write: (C) list only attributes which are writable
    :type write: boolean
    
    :returns: : List of attributes matching criteria
    :rtype: string[]
    """
    pass


def OutlinerToggleNamespace(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateFluidCacheOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetMeshGrabTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Gravity(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleDisplacement(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowModelingUI(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetMeshFoamyTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetFocusToNumericInputLine(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OneClickExecute(*args, **kwargs):
    """
    
    """
    pass


def bifSaveFrame(*args, **kwargs):
    """
    
    """
    pass


def HypershadeOpenRenderViewWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def curveRGBColor(*args, hueSaturationValue=True, list=True, listNames=True, remove=True,
                  resetToFactory=True, resetToSaved=True, q=True, query=True, **kwargs):
    """
    This command creates, changes or removes custom curve colors, which are used to draw the
    curves in the Graph Editor  The custom curve names may contain the wildcards "?", which
    marches a single character, and "*", which matches any number of characters  These colors
    are part of the UI and not part of the saved data for a model  This command is not 
    
    :param hueSaturationValue: (C Q) Indicates that rgb values are really hsv values
    :type hueSaturationValue: boolean
    :param list: (C) Writes out a list of all curve color names and their values
    :type list: boolean
    :param listNames: (C) Returns an array of all curve color names
    :type listNames: boolean
    :param remove: (C) Removes the named curve color
    :type remove: boolean
    :param resetToFactory: (C) Resets all the curve colors to their factory defaults
    :type resetToFactory: boolean
    :param resetToSaved: (C) Resets all the curve colors to their saved values
    :type resetToSaved: boolean
    
    :returns: HSV values from querying the hsv flag
    :rtype: float[]
    """
    pass


def symbolButton(*args, annotation="", backgroundColor=None, command=None, defineTemplate="",
                 docTag="", dragCallback=None, dropCallback=None, enable=True,
                 enableBackground=True, enableKeyboardFocus=True, exists=True,
                 fullPathName=True, height=0, highlightColor=None, image="", isObscured=True,
                 manage=True, noBackground=True, numberOfPopupMenus=True, parent="",
                 popupMenuArray=True, preventOverride=True, statusBarMessage="", useTemplate="",
                 visible=True, visibleChangeCommand=None, width=0, q=True, query=True, e=True,
                 edit=True, **kwargs):
    """
    This command creates a symbol button  A symbol button behaves like a regular button, the
    only difference is a symbol button displays an image rather that a text label  A command
    may be attached to the button which will be executed when the button is pressed
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param command: (C Q E) Command executed when the symbol button is pressed
    :type command: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param image: (C Q E) Image for the button
    :type image: string
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def dgdirty(*args, allPlugs=True, clean=True, implicit=True, list="", propagation=True,
            showTiming=True, verbose=True, q=True, query=True, **kwargs):
    """
    The dgdirty command is used to force a dependency graph dirty message on a node or plug 
    Used for debugging to find evaluation problems  If no nodes are specified then the current
    selection list is used  If the list flag is used it will return the list of things
    currently marked as dirty (or clean if the clean flag was also used)  The returned valu
    
    :param allPlugs: (C Q) Ignore the selected or specified objects and dirty (or clean) all
    plugs
    :type allPlugs: boolean
    :param clean: (C Q) If this flag is set then the attributes are cleaned  Otherwise they are
    set to dirty
    :type clean: boolean
    :param implicit: (C Q) If this flag is set then allow the implicit or default nodes to be
    processed as well  Otherwise they will be skipped for efficiency
    :type implicit: boolean
    :param list: (C Q) When this flag is specified then instead of sending out dirty/clean
    messages the list of currently dirty/clean objects will be returned  The allPlugs
    :type list: string
    :param propagation: (C Q) If this flag is set then the ability of dirty messages to flow
    through the graph is left enabled
    :type propagation: boolean
    :param showTiming: (C Q) If this flag is used then show how long the dirty messages took to
    propagate
    :type showTiming: boolean
    :param verbose: (C Q) Prints out all of the plugs being set dirty on stdout
    :type verbose: boolean
    
    :returns: List of dirty/clean plugs in list plug mode.
    :rtype: string[]
    """
    pass


def ConvertSelectionToUVShellBorder(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OneClickDisconnect(*args, **kwargs):
    """
    
    """
    pass


def iGroom(*args, **kwargs):
    """
    
    """
    pass


def BestPlaneTexturingTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmWidthBrushToolCmd(*args, **kwargs):
    """
    
    """
    pass


def SetFluidAttrFromCurve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def subdMatchTopology(*args, frontOfChain=True, **kwargs):
    """
    Command matches topology across multiple subdiv surfaces - at all levels
    
    :param frontOfChain: (C) This command is used to specify that the new addTopology node
    should be placed ahead (upstream) of existing deformer and skin nodes in the shape's hi
    :type frontOfChain: boolean
    
    :returns: Success or Failure.
    :rtype: boolean
    """
    pass


def XgExportArchive(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def uniform(*args, attenuation=0.0, directionX=0.0, directionY=0.0, directionZ=0.0,
            magnitude=0.0, maxDistance=0.0, name="", perVertex=True, position=None,
            torusSectionRadius=0.0, volumeExclusion=True, volumeOffset=None, volumeShape="",
            volumeSweep=0.0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    For each listed object, the command creates a new field  The field has a shape which lives
    in the DAG and it has an associated dependency node  The field is added to the list of
    fields owned by the object  Use connectDynamic to cause the field to affect a dynamic
    object  Note that if more than one object is listed, a separate field is created for e
    
    :param attenuation: (Q E) Attentuation rate of field
    :type attenuation: float
    :param directionX: (Q E) X-component of direction
    :type directionX: float
    :param directionY: (Q E) Y-component of direction
    :type directionY: float
    :param directionZ: (Q E) Z-component of direction
    :type directionZ: float
    :param magnitude: (Q E) Strength of field
    :type magnitude: float
    :param maxDistance: (Q E) Maximum distance at which field is exerted  -1 indicates that the
    field has no maximum distance
    :type maxDistance: float
    :param name: (Q E) name of field
    :type name: string
    :param perVertex: (Q E) Per-vertex application  If this flag is set true, then each
    individual point (CV, particle, vertex,etc.) of the chosen object exerts an identical cop
    :type perVertex: boolean
    :param position: (Q E M) Position in space (x,y,z) where you want to place a gravity field 
    The gravity then emanates from this position in space rather than from an object
    :type position: [float, float, float]
    :param torusSectionRadius: (Q E) Section radius for a torus volume  Applies only to torus 
    Similar to the section radius in the torus modelling primitive
    :type torusSectionRadius: float
    :param volumeExclusion: (Q E) Volume exclusion of the field  If true, points outside the
    volume (defined by the volume shape attribute) are affected, If false, points inside the v
    :type volumeExclusion: boolean
    :param volumeOffset: (Q E) Volume offset of the field  Volume offset translates the field's
    volume by the specified amount from the actual field location  This is in the field'
    :type volumeOffset: [float, float, float]
    :param volumeShape: (Q E) Volume shape of the field  Sets/edits/queries the field's volume
    shape attribute  If set to any value other than "none", determines a 3-D volume with
    :type volumeShape: string
    :param volumeSweep: (Q E) Volume sweep of the field  Applies only to sphere, cone, cylinder,
    and torus  Similar effect to the sweep attribute in modelling
    :type volumeSweep: float
    
    :returns: Command result
    :rtype: string
    """
    pass


def ViewAlongAxisNegativeZ(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ViewAlongAxisNegativeX(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeSelectConnected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorCreateAnimTracksAtEnd(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeOpenBinsWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sbs_SetBakeFormat(*args, **kwargs):
    """
    
    """
    pass


def SelectPolygonToolMarkingMenuPopDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def blend2(*args, autoAnchor=True, autoNormal=True, caching=True, flipLeftNormal=False,
           flipRightNormal=False, leftAnchor=0.0, leftEnd=1.0, leftStart=0.0,
           multipleKnots=True, nodeState=0, positionTolerance=0.1, reverseLeft=False,
           reverseRight=False, rightAnchor=0.0, rightEnd=1.0, rightStart=0.0,
           tangentTolerance=0.1, constructionHistory=True, crvsInFirstRail=0, name="",
           object=True, polygon=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a surface by blending between given curves  This is an enhancement
    (more user control) compared to blend which is now obsolete
    
    :param autoAnchor: (C Q E) If true and both paths are closed, automatically determine the
    value on the right rail so that they match Default: true
    :type autoAnchor: boolean
    :param autoNormal: (C Q E) If true, the direction of each starting tangent is computed
    based on given geometry  Default: true
    :type autoNormal: boolean
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param flipLeftNormal: (C Q E) If true, flip the starting tangent off the left boundary 
    Default: false
    :type flipLeftNormal: boolean
    :param flipRightNormal: (C Q E) If true, flip the starting tangent off the right boundary 
    Default: false
    :type flipRightNormal: boolean
    :param leftAnchor: (C Q E) The reference parameter on the left boundary where the blend
    surface starts in the case of the closed rail  Default: 0.0
    :type leftAnchor: float
    :param leftEnd: (C Q E) The reference parameter on the left boundary where the blend
    surface ends  Default: 1.0
    :type leftEnd: float
    :param leftStart: (C Q E) The reference parameter on the left boundary where the blend
    surface starts  Default: 0.0
    :type leftStart: float
    :param multipleKnots: (C Q E) If true, use the new blend which produces fully multiple
    interior knots Default: true
    :type multipleKnots: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param positionTolerance: (C Q E) The positional C(0) tolerance of the blend surface to the
    adjacent surfaces  Default: 0.1
    :type positionTolerance: float
    :param reverseLeft: (C Q E) If true, reverse the direction off the left boundary 
    autoDirection must be false for this value to be considered  Default: false
    :type reverseLeft: boolean
    :param reverseRight: (C Q E) If true, reverse the direction of the right boundary 
    autoDirection must be false for this value to be considered  Default: false
    :type reverseRight: boolean
    :param rightAnchor: (C Q E) The reference parameter on the right boundary where the blend
    surface starts in the case of the closed rail  Default: 0.0
    :type rightAnchor: float
    :param rightEnd: (C Q E) The reference parameter on the right boundary where the blend
    surface ends  Default: 1.0
    :type rightEnd: float
    :param rightStart: (C Q E) The reference parameter on the right boundary where the blend
    surface starts  Default: 0.0
    :type rightStart: float
    :param tangentTolerance: (C Q E) The tangent G(1) continuity tolerance of the blend surface
    to the adjacent surfaces  Default: 0.1
    :type tangentTolerance: float
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param crvsInFirstRail: (C Q E) Number of curves in the first rail of the blend
    :type crvsInFirstRail: int
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param polygon: (C) The value of this argument controls the type of the object created by
    this operation 0: nurbs surface 1: polygon (use nurbsToPolygonsPref to set the
    :type polygon: int
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def HypershadeAddOnNodeCreate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def pose(*args, allPoses=True, apply=True, name="", q=True, query=True, e=True, edit=True,
         **kwargs):
    """
    This command is used to create character poses
    
    :param allPoses: (Q) This flag is used to query all the poses in the scene
    :type allPoses: boolean
    :param apply: (C) This flag is used in conjunction with the name flag to specify a pose
    should be applied to the character
    :type apply: boolean
    :param name: (C Q) In create mode, specify the pose name  In query mode, return a list of
    all the poses for the character  In apply mode, specify the pose to be applied
    :type name: string
    
    :returns: Pose name
    :rtype: string
    """
    pass


def AddToCharacterSet(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TwoPointArcTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def WedgePolygonOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def setStartupMessage(*args, **kwargs):
    """
    Update the startup window message  Also know as the 'Splash Screen', this is the window
    that appears while the application is starting up
    
    
    :returns: 
    :rtype: None
    """
    pass


def PrelightPolygonOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeDuplicateShadingNetwork(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowLattices(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UVSphericalProjectionOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HIKPinTranslate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddFaceDivisionsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def keyframeOutliner(*args, animCurve="", annotation="", backgroundColor=None,
                     defineTemplate="", display="", docTag="", dragCallback=None,
                     dropCallback=None, enable=True, enableBackground=True,
                     enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
                     highlightColor=None, isObscured=True, manage=True, noBackground=True,
                     numberOfPopupMenus=True, parent="", popupMenuArray=True,
                     preventOverride=True, statusBarMessage="", useTemplate="", visible=True,
                     visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
                     **kwargs):
    """
    This command creates/edits/queries a keyframe outliner control
    
    :param animCurve: (E) Name of the animation curve for which to display keyframes
    :type animCurve: string
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param display: (Q E) narrow | wide What columns to display  When "narrow", time and value
    will be displayed, when "wide" tangent information will be displayed as well
    :type display: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the outliner control.
    :rtype: string
    """
    pass


def shelfLayout(*args, alignment="", annotation="", backgroundColor=None, cellHeight=0,
                cellWidth=0, cellWidthHeight=None, childArray=True, defineTemplate="",
                docTag="", dragCallback=None, dropCallback=None, enable=True,
                enableBackground=True, enableKeyboardFocus=True, exists=True, fullPathName=True,
                height=0, highlightColor=None, horizontal=True, isObscured=True, ltVersion="",
                manage=True, noBackground=True, numberOfChildren=True, numberOfPopupMenus=True,
                parent="", popupMenuArray=True, position=None, preventOverride=True, spacing=0,
                statusBarMessage="", style="", useTemplate="", version="", visible=True,
                visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
                **kwargs):
    """
    This command creates a new empty shelf layout  The shelf layout can accept drops of
    commands scripts  Use the addNewShelfTab MEL command to add a shelf to the top level
    shelves
    
    :param alignment: (C Q E) Sets the alignment of the buttons in the layout  When horizontal
    is true, valid options are "left" and "right"  When horizontal is false, valid optio
    :type alignment: string
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param cellHeight: (C Q E) Set or query the height of the items in the shelf
    :type cellHeight: int
    :param cellWidth: (C Q E) Set or query the width of the items in the shelf
    :type cellWidth: int
    :param cellWidthHeight: (C Q E) Set the width and height of the items in the shelf
    :type cellWidthHeight: [int, int]
    :param childArray: (Q) Returns a string array of the names of the layout's immediate
    children
    :type childArray: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param horizontal: (C Q E) Orientation of the layout  This flag is true by default, which
    corresponds to a horizontally laid out shelf
    :type horizontal: boolean
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param ltVersion: (C Q E) This flag is used to specify the Maya LT version that this
    control feature was introduced, if the version flag is not specified, or if the version fl
    :type ltVersion: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfChildren: (Q) Returns in an int the number of immediate children of the
    layout
    :type numberOfChildren: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param position: (C E M) Specify the name of a child control in the grid layout along with
    a 1-based integer value indicating the desired position of the child  Positions inc
    :type position: [string, int]
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param spacing: (C Q E) Sets the space between children
    :type spacing: int
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param style: (C Q E) Set or query the current style of the items in the shelf  Valid
    styles are "iconOnly", "textOnly", "iconAndTextHorizontal" and "iconAndTextVertical"
    :type style: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param version: (C Q E) Specify the version that this feature was introduced  The argument
    should be given as a string of the version number (e.g  "2014", "2015")  Currently
    :type version: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the layout.
    :rtype: string
    """
    pass


def CreateWrap(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GraphEditorStackedView(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_selectRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmFreezeBrushContext(*args, **kwargs):
    """
    
    """
    pass


def HypershadeTransferAttributeValuesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BrushPresetBlendOff(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def targetWeldCtx(*args, exists=True, image1="", image2="", image3="", mergeToCenter=True,
                  q=True, query=True, e=True, edit=True, **kwargs):
    """
    Create a new context to weld vertices together on a poly object
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param mergeToCenter: (C Q E) If mergeToCenter is set to true then the source and target
    vertices's will be moved to the center before doing the merge  If set to false the source
    :type mergeToCenter: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def PolygonBooleanIntersection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyHole(*args, assignHole=True, createHistory=True, q=True, query=True, e=True, edit=True,
             **kwargs):
    """
    Command to set and clear holes on given faces
    
    :param assignHole: (C Q E) Assign the selected faces to be hole or unassign the hole faces
    to be non-hole  By default, the command will assign faces to be hole
    :type assignHole: boolean
    :param createHistory: (C Q E) For objects that have no construction history, this flag can
    be used to force the creation of construction history for hole  By default, history is n
    :type createHistory: boolean
    
    :returns: Success or Failure.
    :rtype: boolean
    """
    pass


def SpreadSheetEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXRead(*args, **kwargs):
    """
    
    """
    pass


def commandPort(*args, bufferSize=0, close=True, echoOutput=True, listPorts=True, name="",
                noreturn=True, pickleOutput=True, prefix="", returnNumCommands=True,
                securityWarning=True, sourceType="", q=True, query=True, **kwargs):
    """
    Opens or closes the Maya command port  The command port comprises a socket to which a
    client program may connect  An example command port client "mcp" is included in the Motion
    Capture developers kit   It supports multi-byte commands and uses utf-8 as its transform
    format  It will receive utf8 command string and decode it to Maya native coding  The
    
    :param bufferSize: (C) Commands and results are each subject to size limits  This option
    allows the user to specify the size of the buffer used to communicate with Maya  If
    :type bufferSize: int
    :param close: (C) Closes the commandPort, deletes the pipes
    :type close: boolean
    :param echoOutput: (C) Sends a copy of all command output to the command port  Typically
    only the result is transmitted  This option provides a copy of all output
    :type echoOutput: boolean
    :param listPorts: (C) Returns the available ports
    :type listPorts: boolean
    :param name: (C) Specifies the name of the command port which this command creates 
    CommandPort names of the form name create a UNIX domain socket on the localhost co
    :type name: string
    :param noreturn: (C) Do not write the results from executed commands back to the command
    port socket  Instead, the results from executed commands are written to the scrip
    :type noreturn: boolean
    :param pickleOutput: (C) Python output will be pickled
    :type pickleOutput: boolean
    :param prefix: (C) The string argument is the name of a Maya command taking one string
    argument  This command is called each time data is sent to the command port  The
    :type prefix: string
    :param returnNumCommands: (C) Ignore the result of the command, but return the number of
    commands that have been read and executed in this call  This is a simple way to track buff
    :type returnNumCommands: boolean
    :param securityWarning: (C) Enables security warning on command port input
    :type securityWarning: boolean
    :param sourceType: (C) The string argument is used to indicate which source type would be
    passed to the commandPort, like "mel", "python"  The default source type is "mel"
    :type sourceType: string
    
    :returns: - in query mode
    :rtype: boolean
    """
    pass


def PublishConnections(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_rotatePress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RandomizeShellsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_pointSnapRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ArtPaintBlendShapeWeightsToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def muMessageDelete(*args, **kwargs):
    """
    
    """
    pass


def PartitionEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorClipHoldToggle(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def geometryReplaceCacheOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeCloseAllTabs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def panelConfiguration(*args, addPanel=None, configString="", createStrings=True,
                       defaultImage="", defineTemplate="", editStrings=True, exists=True,
                       image="", isFixedState=True, label="", labelStrings=True,
                       numberOfPanels=True, removeAllPanels=True, removeLastPanel=True,
                       replaceCreateString=None, replaceEditString=None, replaceFixedState=None,
                       replaceLabel=None, replacePanel=None, replaceTypeString=None,
                       sceneConfig=True, typeStrings=True, useTemplate="", userCreated=True,
                       q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a panel configuration object  Typically you would not call this method
    command directly  Instead use the Panel Editor   Once a panel configuration is created you
    can make it appear in the main Maya window by selecting it from any panel's "Panels->Saved
    Layouts" menu
    
    :param addPanel: (C E M) Adds the specified panel to the configuration  Arguments are:
    isFixed, label string, type string, create string, edit string
    :type addPanel: [boolean, string, string, string, string]
    :param configString: (C Q E) Specifies the string that arranges the panels
    :type configString: string
    :param createStrings: (Q) Returns an string array of the panel creation strings
    :type createStrings: boolean
    :param defaultImage: (C Q) The default image for this configuration  Once the default image
    is set it may not be changed  If an image is set with the -i/image flag then it's va
    :type defaultImage: string
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param editStrings: (Q) Returns an string array of the panel edit strings
    :type editStrings: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param image: (C Q E) The user specified image for this configuration  Use this flag to
    override the default image
    :type image: string
    :param isFixedState: (Q) Returns an integer array of whether the panels have fixed states
    or not
    :type isFixedState: boolean
    :param label: (C Q E) Configuration label
    :type label: string
    :param labelStrings: (Q) Returns an string array of the panel labels
    :type labelStrings: boolean
    :param numberOfPanels: (Q) Returns the number of panels in the configuration
    :type numberOfPanels: boolean
    :param removeAllPanels: (E) Removes the last panel in the config
    :type removeAllPanels: boolean
    :param removeLastPanel: (E) Removes the last panel in the config
    :type removeLastPanel: boolean
    :param replaceCreateString: (E) Replaces the specified create string  The index is 1 based
    :type replaceCreateString: [int, string]
    :param replaceEditString: (E) Replaces the specified edit string  The index is 1 based
    :type replaceEditString: [int, string]
    :param replaceFixedState: (E) Replaces the specified fixed state value (true|false)  The
    index is 1 based
    :type replaceFixedState: [int, boolean]
    :param replaceLabel: (E) Replaces the specified label  The index is 1 based
    :type replaceLabel: [int, string]
    :param replacePanel: (C E) Replaces the specified panel in the configuration  Arguments
    are: index, isFixed, label string, type string, create string, edit string  The index is
    :type replacePanel: [int, boolean, string, string, string, string]
    :param replaceTypeString: (E) Replaces the specified type string  The index is 1 based
    :type replaceTypeString: [int, string]
    :param sceneConfig: (C Q E) Specifies whether the configuration is associated with the
    scene  Scene configurations are created when the scene is opened and deleted when the scen
    :type sceneConfig: boolean
    :param typeStrings: (Q) Returns an string array of the panel types
    :type typeStrings: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param userCreated: (C Q E) Returns true if the configuration was created by the user  If
    it is user created, the configuration will show up in the RMB menu in the toolbox's sav
    :type userCreated: boolean
    
    :returns: The name of the panelConfiguration created.
    :rtype: string
    """
    pass


def ArcLengthTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def cycleCheck(*args, all=True, children=True, dag=True, evaluation=True, firstCycleOnly=True,
               firstPlugPerNode=True, lastPlugPerNode=True, list=True, listSeparator="",
               parents=True, secondary=True, timeLimit=None, q=True, query=True, **kwargs):
    """
    This command searches for plug cycles in the dependency graph  If a plug or node is
    selected then it searches for cycles that that plug or node is involved with  Plugs or
    nodes can also be passed as arguments  If the -all flag is used then the entire graph is
    searched   Normally the return value is a boolean indicating whether or not the given item
    
    :param all: (C) search the entire graph for cycles instead of the selection list  (Note: if
    nothing is selected, -all is assumed)
    :type all: boolean
    :param children: (C) Do not consider cycles on the children, only the specified plugs
    :type children: boolean
    :param dag: (C) Also look for cycles due to relationships in the DAG  For each DAG node,
    the parenting connection on its children is also considered when searching f
    :type dag: boolean
    :param evaluation: (C Q) Turn on and off cycle detection during graph evaluation
    :type evaluation: boolean
    :param firstCycleOnly: (C) When -list is used to return a plug list, the list may contain
    multiple cycles or partial cycles  When -firstCycleOnly is specified only the first su
    :type firstCycleOnly: boolean
    :param firstPlugPerNode: (C) When -list is used to return a plug list, the list will
    typically contain multiple plugs per node (e.g  ..  A.output B.input B.output C.input ...),
    r
    :type firstPlugPerNode: boolean
    :param lastPlugPerNode: (C) When -list is used to return a plug list, the list will
    typically contain multiple plugs per node (e.g  ..  A.output B.input B.output C.input ...),
    r
    :type lastPlugPerNode: boolean
    :param list: (C) Return all plugs involved in one or more cycles  If not specified, returns
    a boolean indicating whether a cycle exists
    :type list: boolean
    :param listSeparator: (C) When -list is used to return a plug list, the list may contain
    multiple cycles or partial cycles  Use -listSeparator to specify a string that will be
    :type listSeparator: string
    :param parents: (C) Do not consider cycles on the parents, only the specified plugs
    :type parents: boolean
    :param secondary: (C) Look for cycles on related plugs as well as the specified plugs
    Default is "on" for the "-all" case and "off" for others
    :type secondary: boolean
    :param timeLimit: (C) Limit the search to the given amount of time
    :type timeLimit: time
    
    :returns: in the general case.
    :rtype: boolean
    """
    pass


def xgmDirectionBrushToolCmd(*args, **kwargs):
    """
    
    """
    pass


def SendAsNewScenePrintStudio(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ModifyOpacityPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Import(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dynExpression(*args, creation=True, name="", runtime=True, runtimeAfterDynamics=True,
                  runtimeBeforeDynamics=True, string="", q=True, query=True, e=True, edit=True,
                  **kwargs):
    """
    This command describes an expression that belongs to the specified particle shape  The
    expression is a block of code of unlimited length with a C-like syntax that can perform
    conversions, mathematical operations, and logical decision making on any numeric
    attribute(s) or per-particle attribute(s) in the scene  One expression can read and alter
    any 
    
    :param creation: (C Q E) Tells the command that the string passed will be a creation
    expression for the particle shape  This means that this expression will be executed when
    :type creation: boolean
    :param name: (C Q E) Name to use for this command
    :type name: string
    :param runtime: (C Q E) Tells the command that the string passed will be a runtime
    expression for the particle shape  This expression will be executed at the beginning of ru
    :type runtime: boolean
    :param runtimeAfterDynamics: (C Q E) Tells the command that the string passed will be a
    runtime expression for the particle shape  This expression will be executed after dynamics
    wheneve
    :type runtimeAfterDynamics: boolean
    :param runtimeBeforeDynamics: (C Q E) Tells the command that the string passed will be a
    runtime expression for the particle shape  This expression will be executed before dynamics
    whenev
    :type runtimeBeforeDynamics: boolean
    :param string: (C E) Set the expression string  This is queriable with the -q/query flag
    and the -rbd/runtimeBeforeDynamics, the -rab/runtimeAfterDynamics or the -c/creat
    :type string: string
    
    :returns: The particle shape which this expression belongs to
    :rtype: string
    """
    pass


def nClothCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def renderSetupFind(*args, **kwargs):
    """
    
    """
    pass


def AssignOfflineFileFromRefEd(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PreviousGreasePencilFrame(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def hyperShade(*args, assign="", clearWorkArea=True, collapse="", createNode="",
               dependGraphArea=True, downStream=True, duplicate=True, fixRenderSize=True,
               incremental=True, listDownstreamNodes=None, listDownstreamShaderNodes=None,
               listUpstreamNodes=None, name="", networks=True, noSGShapes=True, noShapes=True,
               noTransforms=True, objects="", renderCreateAndDrop="", reset=True,
               resetGraph=True, resetSwatch=True, setAllowsRegraphing=True, setWorkArea="",
               shaderNetwork="", shaderNetworks=True, shaderNetworksSelectMaterialNodes=True,
               snapShot=True, uncollapse="", upStream=True, userDefinedLayout=True,
               workAreaAddCmd="", workAreaDeleteCmd="", workAreaSelectCmd="", **kwargs):
    """
    Commands for shader editing in the hypergraph
    
    :param assign: (C) Assign the specified shader node to renderable objects on the active
    list  The node can either be a shading group or the shader node attached to the
    :type assign: string
    :param clearWorkArea: (C) Push the current work area on to the stack and create a clear
    work area
    :type clearWorkArea: boolean
    :param collapse: (C) Hide the upstream nodes from the specified node
    :type collapse: string
    :param createNode: (C) Create a node of the specified type  This is called when a new
    rendering node is created using drag and drop from the image browser or from the RMB c
    :type createNode: string
    :param dependGraphArea: (C) When setting a work area, and the work area doesn't already
    exist this flag inicates a new graph should be created that is either a depend graph or a
    :type dependGraphArea: boolean
    :param downStream: (C) Show nodes downstream from the specified node
    :type downStream: boolean
    :param duplicate: (C) Duplicate upstream nodes  If the node is a shader make sure duplicate
    include the shading group if there is one
    :type duplicate: boolean
    :param fixRenderSize: (C) If set to true dont rerender swatches when they change size as
    the user zooms
    :type fixRenderSize: boolean
    :param incremental: (C) Enable or disable incremental layout when making new nodes or
    connections
    :type incremental: boolean
    :param listDownstreamNodes: (C) List all the downstream render nodes from the specified
    nodes
    :type listDownstreamNodes: name
    :param listDownstreamShaderNodes: (C) List all the downstream shader nodes from the
    specified nodes
    :type listDownstreamShaderNodes: name
    :param listUpstreamNodes: (C) List all the upstream render nodes from the specified nodes
    :type listUpstreamNodes: name
    :param name: (C) Name for the work area created by this command
    :type name: string
    :param networks: (C) Do an incremental layout on all of the nodes in the current selection
    list and that are in the current work area
    :type networks: boolean
    :param noSGShapes: (C) Display only shapes that are connected to nodes in the network other
    than a shading group
    :type noSGShapes: boolean
    :param noShapes: (C) Display no shapes when graphing networks
    :type noShapes: boolean
    :param noTransforms: (C) Display no transforms when graphing networks
    :type noTransforms: boolean
    :param objects: (C) Select the objects which are attached to the specified shader node  The
    shader node can be either the shading group or the shader attached to the sha
    :type objects: string
    :param renderCreateAndDrop: (C) Create a render node of the specified type and put user
    into drag and drop mode to place or connect it
    :type renderCreateAndDrop: string
    :param reset: (C) Reset the Hypershade panel to its initial state  In particular delete all
    the work areas
    :type reset: boolean
    :param resetGraph: (C) Reset the current graph  Typically called prior to rebuilding a
    folder in a Hypershade view
    :type resetGraph: boolean
    :param resetSwatch: (C) For all selected nodes remove user defined swatches if the node has
    one
    :type resetSwatch: boolean
    :param setAllowsRegraphing: (C) For internal use only
    :type setAllowsRegraphing: boolean
    :param setWorkArea: (C) Set the work area to the existing named work area
    :type setWorkArea: string
    :param shaderNetwork: (C) Show the shader network for the specified material node  If the
    materials shading group has a displacement or volume map these will be shown  If not
    :type shaderNetwork: string
    :param shaderNetworks: (C) Show the shader network for all the objects on the selection
    list that have shaders
    :type shaderNetworks: boolean
    :param shaderNetworksSelectMaterialNodes: (C) Select the material nodes in the shader
    network for all the objects on the selection list that have shaders
    :type shaderNetworksSelectMaterialNodes: boolean
    :param snapShot: (C) Put hypergraph in snapshot mode  This is only for testing
    :type snapShot: boolean
    :param uncollapse: (C) Unhide the upstream nodes from the specified node
    :type uncollapse: string
    :param upStream: (C) Show nodes upstream from the specified node
    :type upStream: boolean
    :param userDefinedLayout: (C) Enable or disable remembrance of user defined layouts 
    Default is disabled until this functionality is better tested
    :type userDefinedLayout: boolean
    :param workAreaAddCmd: (C) Set the MEL procedure called when a new work area is added to
    HyperShade
    :type workAreaAddCmd: string
    :param workAreaDeleteCmd: (C) Set the MEL procedure called when a work area is deleted in
    HyperShade
    :type workAreaDeleteCmd: string
    :param workAreaSelectCmd: (C) Set the MEL procedure called when a work area is selected in
    HyperShade
    :type workAreaSelectCmd: string
    
    :returns: Command result
    :rtype: string
    """
    pass


def changeSubdivRegion(*args, action=0, level=0, **kwargs):
    """
    Changes a subdivision surface region based on the command parameters  The command operates
    on the selected subdivision surfaces
    
    :param action: (C) Specifies the action to the selection region 1 = delete selection region
    2 = enlarge selection region
    :type action: int
    :param level: (C) Specify the level of the subdivision surface to perform the operation
    :type level: int
    
    :returns: Command result
    :rtype: boolean
    """
    pass


def SculptMeshInvertFreeze(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def outlinerEditor(*args, allowMultiSelection=True, alwaysToggleSelect=True,
                   animLayerFilterOptions="", attrAlphaOrder="", attrFilter="", autoExpand=True,
                   autoExpandLayers=True, autoSelectNewObjects=True,
                   containersIgnoreFilters=True, control=True, defineTemplate="",
                   directSelect=True, displayMode="", doNotSelectNewObjects=True, docTag="",
                   dropIsParent=True, editAttrName=True, exists=True, expandAllItems=True,
                   expandAllSelectedItems=True, expandAttribute=True, expandConnections=True,
                   expandObjects=True, feedbackItemName=True, feedbackRowNumber=True, filter="",
                   forceMainConnection="", getCurrentSetOfItem=0, highlightActive=True,
                   highlightConnection="", highlightSecondary=True, ignoreDagHierarchy=True,
                   ignoreHiddenAttribute=True, ignoreOutlinerColor=True, isChildSelected=None,
                   isSet=0, isSetMember=0, lockMainConnection=True, longNames=True,
                   mainListConnection="", mapMotionTrails=True, masterOutliner="",
                   niceNames=True, object=None, organizeByClip=True, organizeByLayer=True,
                   panel="", parent="", parentObject=True, pinPlug=None, refresh=True,
                   removeFromCurrentSet=0, renameItem=0, renameSelectedItem=True,
                   renderFilterActive=True, renderFilterIndex=0, renderFilterVisible=True,
                   selectCommand=None, selectionConnection="", selectionOrder="", setFilter="",
                   setsIgnoreFilters=True, showAnimCurvesOnly=True, showAnimLayerWeight=True,
                   showAssets=True, showAssignedMaterials=True, showAttrValues=True,
                   showAttributes=True, showCompounds=True, showConnected=True,
                   showContainedOnly=True, showContainerContents=True, showDagOnly=True,
                   showLeafs=True, showMuteInfo=True, showNamespace=True,
                   showNumericAttrsOnly=True, showParentContainers=True, showPinIcons=True,
                   showPublishedAsConnected=True, showReferenceMembers=True,
                   showReferenceNodes=True, showSelected=True, showSetMembers=True,
                   showShapes=True, showTextureNodesOnly=True, showTimeEditor=True,
                   showUVAttrsOnly=True, showUnitlessCurves=True, showUpstreamCurves=True,
                   sortOrder="", stateString=True, transmitFilters=True, unParent=True,
                   unlockMainConnection=True, unpinPlug=None, updateMainConnection=True,
                   useTemplate="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates an outliner editor which can be used to display a list of objects.
    
    :param allowMultiSelection: (C E) If true then multiple selection will be allowed in the
    outliner
    :type allowMultiSelection: boolean
    :param alwaysToggleSelect: (C E) If true, then clicking on an item in the outliner will
    select or deselect it without affecting the selection of other items (unless
    allowMultiSelecti
    :type alwaysToggleSelect: boolean
    :param animLayerFilterOptions: (C Q E) Specifies whether a filter is to be applied when
    displaying animation layers  If so, the options can be "allAffecting" (no filter), "active"
    (only th
    :type animLayerFilterOptions: string
    :param attrAlphaOrder: (C Q E) Specify how attributes are to be sorted  Current recognised
    values are "default" for no sorting and "ascend" to sort attributes from 'a' to ''z' and
    :type attrAlphaOrder: string
    :param attrFilter: (C Q E) Specifies the name of an itemFilter object to be placed on this
    editor  This filters the attributes displayed in the editor
    :type attrFilter: string
    :param autoExpand: (C Q E) This flag specifies whether or not objects that are loaded in
    should have their attributes automatically expanded
    :type autoExpand: boolean
    :param autoExpandLayers: (C Q E) If true then when a node with animation layer is displayed,
    all the animation layers will show up in expanded form
    :type autoExpandLayers: boolean
    :param autoSelectNewObjects: (C Q E) This flag specifies whether or not new objects added
    to the outliner should be automatically selected
    :type autoSelectNewObjects: boolean
    :param containersIgnoreFilters: (C Q E) This flag specifices whether or not filters should
    be ignored when displaying container contents
    :type containersIgnoreFilters: boolean
    :param control: (Q) Query only  Returns the top level control for this editor  Usually used
    for getting a parent to attach popup menus  Caution: It is possible for an ed
    :type control: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param directSelect: (C E) If true then clicking on an item in the outliner will add or
    remove just that item from the selection connection  If false then clicking on an item i
    :type directSelect: boolean
    :param displayMode: (C Q E) Affects how the outliner displays when a filter is applied 
    List mode is a non-indented flat list  DAG mode indents to represent the hierarchical str
    :type displayMode: string
    :param doNotSelectNewObjects: (C Q E) If true this flag specifies that new objects added to
    the outliner will not be selected, even if they are active
    :type doNotSelectNewObjects: boolean
    :param docTag: (C Q E) Attaches a tag to the editor
    :type docTag: string
    :param dropIsParent: (C Q E) This flag specifies the mode for drag and drop  If the flag is
    true, dropping items will do a reparent  If it is false, dropping will reorder items
    :type dropIsParent: boolean
    :param editAttrName: (C Q E) This flag specifies whether or not attribute names can be
    edited  By default double-clicking on an attribute will open the expression editor for
    that
    :type editAttrName: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param expandAllItems: (C E) Expand or collapse all items in the outliner
    :type expandAllItems: boolean
    :param expandAllSelectedItems: (C E) Expand or collapse all selected items in the outliner
    :type expandAllSelectedItems: boolean
    :param expandAttribute: (E) Force the outliner to fill the selection list with only
    attributes
    :type expandAttribute: boolean
    :param expandConnections: (C Q E) This flag specifies whether or not attributes should be
    expanded to show their input connections  Note: currently the expansion will only show
    animCu
    :type expandConnections: boolean
    :param expandObjects: (C Q E) This flag specifies whether or not objects that are loaded in
    should be automatically expanded
    :type expandObjects: boolean
    :param feedbackItemName: (Q) Returns the outliner item name at the current mouse position,
    if any
    :type feedbackItemName: boolean
    :param feedbackRowNumber: (Q) Returns the outliner row number at the current mouse position,
    if any
    :type feedbackRowNumber: boolean
    :param filter: (C Q E) Specifies the name of an itemFilter object to be used with this
    editor  This filters the information coming onto the main list of the editor
    :type filter: string
    :param forceMainConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type forceMainConnection: string
    :param getCurrentSetOfItem: (Q) Returns the current set of item at the given row  As an
    item can belong to number of sets, current set is the set to which the item belongs to
    curren
    :type getCurrentSetOfItem: int
    :param highlightActive: (C Q E) This flag specifies whether or not the outliner should
    highlight objects that are active  Note: if the outliner is driving the contents of another
    ed
    :type highlightActive: boolean
    :param highlightConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its highlight list  Not all editors have a highlight list 
    F
    :type highlightConnection: string
    :param highlightSecondary: (C Q E) This flag specifies whether or not the outliner should
    highlight objects that are contained in the highlightConnection
    :type highlightSecondary: boolean
    :param ignoreDagHierarchy: (C Q E) This flag specifies whether or not DAG objects are
    displayed in their DAG hierarchy  Warning: using this flag without some other form of
    sensible fil
    :type ignoreDagHierarchy: boolean
    :param ignoreHiddenAttribute: (C Q E) Sets whether or not the outliner ignores the 'hidden
    in outliner' flag on nodes
    :type ignoreHiddenAttribute: boolean
    :param ignoreOutlinerColor: (C Q E) Sets whether or not the outliner ignores the 'use
    outliner color' flag on nodes
    :type ignoreOutlinerColor: boolean
    :param isChildSelected: (Q) This flag allows you to query if one or more of the children of
    the specified item is selected in the outliner  The item should be specified using a
    :type isChildSelected: name
    :param isSet: (Q) Returns true if the item present at the given row is a set
    :type isSet: int
    :param isSetMember: (Q) Returns true if the item present at the given row is a set member
    :type isSetMember: int
    :param lockMainConnection: (C E) Locks the current list of objects within the
    mainConnection, so that only those objects are displayed within the editor  Further changes
    to the origi
    :type lockMainConnection: boolean
    :param longNames: (Q E) Controls whether long or short attribute names will be used in the
    interface  Note that this flag is ignored if the -niceNames flag is set  Default i
    :type longNames: boolean
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type mainListConnection: string
    :param mapMotionTrails: (C Q E) Sets whether or not we replace the motion trail in the
    outliner with the object it is trailing
    :type mapMotionTrails: boolean
    :param masterOutliner: (C Q E) This flag is the name of an outliner that this outliner will
    share the objects and state from  When an outliner is shared, all of its state informati
    :type masterOutliner: string
    :param niceNames: (Q E) Controls whether the attribute names will be displayed in a more
    user-friendly, readable way  When this is on, the longNames flag is ignored  When th
    :type niceNames: boolean
    :param object: (Q) This flags is used together with the parentObject flag to get the name
    of the parent object for the specified object
    :type object: name
    :param organizeByClip: (C Q E) If true then when a node with Time Editor clips is displayed,
    attributes will be displayed according to the clip(s) it belongs to  eg: Clip1 Attr1 At
    :type organizeByClip: boolean
    :param organizeByLayer: (C Q E) If true then when a node with animation layer is displayed,
    attributes will be displayed according to the layer(s) it belongs to  eg: Layer1 Attr1 At
    :type organizeByLayer: boolean
    :param panel: (C Q) Specifies the panel for this editor  By default if an editor is created
    in the create callback of a scripted panel it will belong to that panel  If a
    :type panel: string
    :param parent: (C Q E) Specifies the parent layout for this editor  This flag will only
    have an effect if the editor is currently un-parented
    :type parent: string
    :param parentObject: (Q) 
    :type parentObject: boolean
    :param pinPlug: (C Q E) Pins the named plug, so it always appears in the outliner,
    irrespective of the incoming selection connection  In query mode, returns a list of the pi
    :type pinPlug: name
    :param refresh: (E) Causes the outliner to refresh itself
    :type refresh: boolean
    :param removeFromCurrentSet: (E) Removes selected members of a set from their current set 
    Current set is the set to which item at the given row belongs to  If no selected items,
    the
    :type removeFromCurrentSet: int
    :param renameItem: (E) Renames the item at the given row index in the outliner
    :type renameItem: int
    :param renameSelectedItem: (E) Rename the first selected item in the outliner
    :type renameSelectedItem: boolean
    :param renderFilterActive: (Q) This is a query only flag which returns true if the render
    setup filter is Active, i.e one of the four render filters (Inside Selected, Outside Selec
    :type renderFilterActive: boolean
    :param renderFilterIndex: (C Q E) Sets the Render Setup Filter to the index passed  This
    only works if the filter is visible in outliner and its selection is not locked  Valid
    indices
    :type renderFilterIndex: int
    :param renderFilterVisible: (C Q E) Show/Hide the Render Setup Filter in outliner  In query
    mode returns whether the Render Setup Filter is visible or not
    :type renderFilterVisible: boolean
    :param selectCommand: (C Q E) A command to be executed when an item is selected
    :type selectCommand: script
    :param selectionConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its own selection list  As the user selects things in this
    e
    :type selectionConnection: string
    :param selectionOrder: (E) Specify how objects are sorted in selection list  Current
    recognised values are "chronological" for sorting in selection order and "display" to sort
    :type selectionOrder: string
    :param setFilter: (C Q E) Specifies the name of a filter which is used to filter which (if
    any) sets to display
    :type setFilter: string
    :param setsIgnoreFilters: (C Q E) This flag specifies whether or not the filter should be
    ignored for expanding sets to show set members (default is true)
    :type setsIgnoreFilters: boolean
    :param showAnimCurvesOnly: (C Q E) This flag modifies the showConnected flag  If
    showConnected is set to true then this flag will cause display of only those attributes
    that are connec
    :type showAnimCurvesOnly: boolean
    :param showAnimLayerWeight: (C Q E) If true then when a node with animation layer is
    displayed, the weight of the layer will be displayed if it is keyed
    :type showAnimLayerWeight: boolean
    :param showAssets: (C Q E) This flags specifies whether assets should be shown in the
    outliner
    :type showAssets: boolean
    :param showAssignedMaterials: (C Q E) Specifies whether to show assigned materials under
    shapes
    :type showAssignedMaterials: boolean
    :param showAttrValues: (C Q E) This flag specifies whether attribute values or attribute
    names should be displayed  Note: currently only string attributes can have their values
    dis
    :type showAttrValues: boolean
    :param showAttributes: (C Q E) Specifies whether to show attributes or not
    :type showAttributes: boolean
    :param showCompounds: (C Q E) This flag specifies whether or not compound attributes should
    be displayed, or just the leaf attributes  Note: if showConnected is true, and the comp
    :type showCompounds: boolean
    :param showConnected: (C Q E) This flag modifies the showAttributes flag  If showAttributes
    is set to true then this flag will cause display of only those attributes that are conn
    :type showConnected: boolean
    :param showContainedOnly: (C Q E) This flags specifies whether nodes belonging to
    containers should be show under the container node only  Otherwise, it will show up under
    the world a
    :type showContainedOnly: boolean
    :param showContainerContents: (C Q E) This flags specifies whether the contents of the
    container should be shown under the container node in the outliner
    :type showContainerContents: boolean
    :param showDagOnly: (C Q E) This flag specifies whether all dependency graph objects will
    be displayed, or just DAG objects
    :type showDagOnly: boolean
    :param showLeafs: (C Q E) This flag specifies whether or not leaf attributes should be
    displayed, or just the compound attributes  Note: if showConnected is true, and the leaf
    :type showLeafs: boolean
    :param showMuteInfo: (C Q E) This flag specifies whether mute information will be
    displayed
    :type showMuteInfo: boolean
    :param showNamespace: (C Q E) This flag specifies whether all objects will have their
    namespace displayed, if namespace different than root
    :type showNamespace: boolean
    :param showNumericAttrsOnly: (C Q E) This flag specifies whether or not all attributes
    should be displayed, or just numeric attributes  Note: if showConnected is true, and the
    attribute
    :type showNumericAttrsOnly: boolean
    :param showParentContainers: (C Q E) This flags specifies whether nodes belonging to
    containers/assets should show their containers/assets as well in its outliner
    :type showParentContainers: boolean
    :param showPinIcons: (C Q E) Sets whether pin icons are shown for unpinned plugs
    :type showPinIcons: boolean
    :param showPublishedAsConnected: (C Q E) This flags enables attributes that are published
    to be displayed in italics  Otherwise, only attributes connected as a destination are shown
    in itali
    :type showPublishedAsConnected: boolean
    :param showReferenceMembers: (C Q E) Specifies whether to show reference node members under
    the reference node in the outliner
    :type showReferenceMembers: boolean
    :param showReferenceNodes: (C Q E) Specifies whether to show reference nodes or not
    :type showReferenceNodes: boolean
    :param showSelected: (C E) If true then the selected items are expanded in the outliner
    :type showSelected: boolean
    :param showSetMembers: (C Q E) If true then when a set is expanded, the set members will be
    displayed  If false, then only other sets will be displayed
    :type showSetMembers: boolean
    :param showShapes: (C Q E) Specifies whether to show shapes or not
    :type showShapes: boolean
    :param showTextureNodesOnly: (C Q E) This flag modifies the showConnected flag  If
    showConnected is set to true then this flag will cause display of only those attributes
    that are connec
    :type showTextureNodesOnly: boolean
    :param showTimeEditor: (C Q E) If true, all nodes related to the Time Editor will be shown
    as a hierarchy
    :type showTimeEditor: boolean
    :param showUVAttrsOnly: (C Q E) This flag specifies whether or not all attributes should be
    displayed, or just uv attributes  Note: currently the only attribute which will be displa
    :type showUVAttrsOnly: boolean
    :param showUnitlessCurves: (C Q E) This flag (in combination with -expandConnections)
    specifies whether or not connection expansion should show unitless animCurves
    :type showUnitlessCurves: boolean
    :param showUpstreamCurves: (C Q E) Specifies exactly which attributes are displayed when
    showAttributes and expandConnections are both true  If true, the dependency graph is
    searched u
    :type showUpstreamCurves: boolean
    :param sortOrder: (C Q E) Specify how objects are to be sorted  Current recognised values
    are "none" for no sorting and "dagName" to sort DAG objects by name  Notes: a) non-DA
    :type sortOrder: string
    :param stateString: (Q) Query only flag  Returns the MEL command that will create an editor
    to match the current editor state  The returned command string uses the string va
    :type stateString: boolean
    :param transmitFilters: (C Q E) This flag specifies how the selectionConnection is
    populated when attribute filters are enabled  If this flag is set to true, then all the
    attributes
    :type transmitFilters: boolean
    :param unParent: (C E) Specifies that the editor should be removed from its layout  This
    cannot be used in query mode
    :type unParent: boolean
    :param unlockMainConnection: (C E) Unlocks the mainConnection, effectively restoring the
    original mainConnection (if it is still available), and dynamic updates
    :type unlockMainConnection: boolean
    :param unpinPlug: (C E) Unpins the named plug
    :type unpinPlug: name
    :param updateMainConnection: (C E) Causes a locked mainConnection to be updated from the
    orginal mainConnection, but preserves the lock state
    :type updateMainConnection: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: (the name of the editor)
    :rtype: string
    """
    pass


def ConvertSelectionToUVShell(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteAllStaticChannels(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetBreakdownKeyOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateFBIK(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateCameraOnly(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RenderOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyCylindricalProjection(*args, caching=True, constructionHistory=True, createNewMap=True,
                              imageCenter=None, imageCenterX=0.0, imageCenterY=0.0,
                              imageScale=None, imageScaleU=0.0, imageScaleV=0.0,
                              insertBeforeDeformers=True, keepImageRatio=True, mapDirection="",
                              name="", nodeState=0, perInstance=True, projectionCenter=None,
                              projectionCenterX=0.0, projectionCenterY=0.0,
                              projectionCenterZ=0.0, projectionHeight=0.0,
                              projectionHorizontalSweep=0.0, projectionScale=None,
                              projectionScaleU=0.0, projectionScaleV=0.0, radius=10.0,
                              rotationAngle=0.0, seamCorrect=False, smartFit=True,
                              worldSpace=True, q=True, query=True, e=True, edit=True,
                              **kwargs):
    """
    TpolyProjCmdBase is a base class for the command to create a mapping on the selected
    polygonal faces  Projects a cylindrical map onto an object
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param createNewMap: (C Q) This flag when set true will create a new map with a the name
    passed in, if the map does not already exist
    :type createNewMap: boolean
    :param imageCenter: (C Q E) The center point of the 2D model layout  Default: 0.5, 0.5
    :type imageCenter: [float, float]
    :param imageCenterX: (C Q E) Image center X coord
    :type imageCenterX: float
    :param imageCenterY: (C Q E) Image center Y coord
    :type imageCenterY: float
    :param imageScale: (C Q E) Specifies the UV scale : Enlarges or reduces the 2D version of
    the model in U or V space relative to the 2D centerpoint  Default: 1.0, 1.0
    :type imageScale: [float, float]
    :param imageScaleU: (C Q E) Specifies the UV scale : Enlarges or reduces the 2D version of
    the model in U or V space relative to the 2D centerpoint
    :type imageScaleU: float
    :param imageScaleV: (C Q E) The V scale : Enlarges or reduces the 2D version of the model
    in V space relative to the 2D centerpoint
    :type imageScaleV: float
    :param insertBeforeDeformers: (C) This flag specifies if the projection node should be
    inserted before or after deformer nodes already applied to the shape  Inserting the
    projection a
    :type insertBeforeDeformers: boolean
    :param keepImageRatio: (C) True means keep any image ratio
    :type keepImageRatio: boolean
    :param mapDirection: (C) This flag specifies the mapping direction  'x', 'y' and 'z'
    projects the map along the corresponding axis  'c' projects along the current camera view
    :type mapDirection: string
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param perInstance: (C) True if the new map is per-instance, otherwise it is shared
    :type perInstance: boolean
    :param projectionCenter: (C Q E) The origin point from which the map is projected  Default:
    0.0, 0.0, 0.0
    :type projectionCenter: [float, float, float]
    :param projectionCenterX: (C Q E) Projection center X coord
    :type projectionCenterX: float
    :param projectionCenterY: (C Q E) Projection center Y coord
    :type projectionCenterY: float
    :param projectionCenterZ: (C Q E) Projection center Z coord
    :type projectionCenterZ: float
    :param projectionHeight: (C Q E) The height of the map relative to the 3D projection axis
    :type projectionHeight: float
    :param projectionHorizontalSweep: (C Q E) The angle swept by the 3D projection axis
    :type projectionHorizontalSweep: float
    :param projectionScale: (C Q E) The width and the height of the map relative to the 3D
    projection axis  Default: 180.0, 1.0
    :type projectionScale: [float, float]
    :param projectionScaleU: (C Q E) The width of the map relative to the 3D projection axis
    :type projectionScaleU: float
    :param projectionScaleV: (C Q E) The height of the map relative to the 3D projection axis
    :type projectionScaleV: float
    :param radius: (C Q E) Used by the UI : Manipulator  Default: 10.0
    :type radius: float
    :param rotationAngle: (C Q E) The for the rotation  When the angle is positive, then the
    map rotates counterclockwise on the mapped model, whereas when it is negative then the map
    :type rotationAngle: float
    :param seamCorrect: (C Q E) Used to indicate fixing UV seams  Default: false
    :type seamCorrect: boolean
    :param smartFit: (C) True means use the smart fit algorithm
    :type smartFit: boolean
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def MoveToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def memory(*args, adjustedVirtualMemory=True, asFloat=True, debug=True, freeMemory=True,
           gigaByte=True, heapMemory=True, kiloByte=True, megaByte=True, pageFaults=True,
           pageReclaims=True, physicalMemory=True, processVirtualMemory=True, summary=True,
           swapFree=True, swapLogical=True, swapMax=True, swapPhysical=True, swapReserved=True,
           swapVirtual=True, swaps=True, **kwargs):
    """
    Used to query essential statistics on memory availability and usage   By default memory
    sizes are returned in bytes  Since Maya's command engine only supports 32-bit signed
    integers, any returned value which cannot fit into 31 bits will be truncated to 2,147,483,
    647 and a warning message displayed  To avoid having memory sizes truncated use one of
    
    :param adjustedVirtualMemory: (C) Returns size of adjusted virtual memory allocated by the
    process  The adjustment is done by computing an offset when the application is launched
    that
    :type adjustedVirtualMemory: boolean
    :param asFloat: (C) Causes numeric values to be returned as floats rather than ints  This
    can be useful if you wish to retain some of the significant digits lost when us
    :type asFloat: boolean
    :param debug: (C) Print debugging statistics on arena memory (if it exists)
    :type debug: boolean
    :param freeMemory: (C) Returns size of free memory
    :type freeMemory: boolean
    :param gigaByte: (C) Return memory sizes in gigabytes (1024*1024*1024 bytes)
    :type gigaByte: boolean
    :param heapMemory: (C) Returns size of memory heap
    :type heapMemory: boolean
    :param kiloByte: (C) Return memory sizes in kilobytes (1024 bytes)
    :type kiloByte: boolean
    :param megaByte: (C) Return memory sizes in megabytes (1024*1024 bytes)
    :type megaByte: boolean
    :param pageFaults: (C) Returns number of page faults
    :type pageFaults: boolean
    :param pageReclaims: (C) Returns number of page reclaims
    :type pageReclaims: boolean
    :param physicalMemory: (C) Returns size of physical memory
    :type physicalMemory: boolean
    :param processVirtualMemory: (C) Returns size of virtual memory allocated by the process
    :type processVirtualMemory: boolean
    :param summary: (C) Returns a summary of memory usage  The size flags are ignored and all
    memory sizes are given in megabytes
    :type summary: boolean
    :param swapFree: (C) Returns size of free swap
    :type swapFree: boolean
    :param swapLogical: (C) Returns size of logical swap
    :type swapLogical: boolean
    :param swapMax: (C) Returns maximum swap size
    :type swapMax: boolean
    :param swapPhysical: (C) Returns size of physical swap
    :type swapPhysical: boolean
    :param swapReserved: (C) Returns size of reserved swap
    :type swapReserved: boolean
    :param swapVirtual: (C) Returns size of virtual swap
    :type swapVirtual: boolean
    :param swaps: (C) Returns number of swaps
    :type swaps: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def polyNormalizeUV(*args, centerOnTile=True, normalizeDirection=0, normalizeType=0,
                    preserveAspectRatio=True, caching=True, constructionHistory=True,
                    createNewMap=True, insertBeforeDeformers=True, name="", nodeState=0,
                    uvSetName="", worldSpace=True, q=True, query=True, e=True, edit=True,
                    **kwargs):
    """
    Normalizes the UVs of input polyFaces  The existing UVs of the faces are normalized between
    0 and 1
    
    :param centerOnTile: (C Q E) If true, will center UV's on the UV tile they are most over 
    If false, will center UV's in the 0-1 region
    :type centerOnTile: boolean
    :param normalizeDirection: (C Q E) V
    :type normalizeDirection: int
    :param normalizeType: (C Q E) Collective
    :type normalizeType: int
    :param preserveAspectRatio: (C Q E) Scale uniform along u and v  C: Default is on  Q: When
    queried, returns an int
    :type preserveAspectRatio: boolean
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param createNewMap: (C) Set to true if a new map should be created
    :type createNewMap: boolean
    :param insertBeforeDeformers: (C) Set to true if the new node created should inserted
    before any deformer nodes
    :type insertBeforeDeformers: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param uvSetName: (C) Name of the UV set to be created
    :type uvSetName: string
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def SelectAllAssets(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def geometryCacheOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyBlindData(*args, associationType="", binaryData="", booleanData=True, delete=True,
                  doubleData=0.0, int64Data=None, intData=0, longDataName="", rescan=True,
                  reset=True, shape=True, shortDataName="", stringData="", typeId=0, e=True,
                  edit=True, **kwargs):
    """
    Command creates blindData types (basically creates an instance of TdnPolyBlindData)  When
    used with the query flag, it returns the data types that define this blindData type  This
    command is to be used create a blindData node *and* to edit the same.  The associationType
    flag *has* to be specified at all times.  This is because if an instance of the
    
    :param associationType: (C E) Specifies the dataTypes that are part of BlindData node being
    created  Allowable associations are "object" for any object, and "vertex" "edge" and "f
    :type associationType: string
    :param binaryData: (C E M) Specifies the data type is a binary data value
    :type binaryData: string
    :param booleanData: (C E M) Specifies the data type is a boolean logic value
    :type booleanData: boolean
    :param delete: (C E) Specifies that this will remove the blind data if found
    :type delete: boolean
    :param doubleData: (C E M) Specifies the data type is a floating point double value
    :type doubleData: float
    :param int64Data: (C E M) Specifies the data type is an 64-bit integer value
    :type int64Data: int64
    :param intData: (C E M) Specifies the data type is an integer value
    :type intData: int
    :param longDataName: (C E M) Specifies the long name of the data that is being modified by
    this command
    :type longDataName: string
    :param rescan: (C E) Enables a rescan of blind data nodes for cached information
    :type rescan: boolean
    :param reset: (C E) Specifies that this command will reset the given attribute to default
    value
    :type reset: boolean
    :param shape: (C E) For object association only, apply blind data to the shape(s) below
    this node instead of the node itself
    :type shape: boolean
    :param shortDataName: (C E M) Specifies the short name of the data that is being modified
    by this command
    :type shortDataName: string
    :param stringData: (C E M) Specifies the data type is a string value
    :type stringData: string
    :param typeId: (C E) Specifies the typeId of the BlindData type being created
    :type typeId: int
    
    :returns: Name of nodes created
    :rtype: string
    """
    pass


def colorSliderButtonGrp(*args, adjustableColumn=0, adjustableColumn2=0, adjustableColumn3=0,
                         adjustableColumn4=0, adjustableColumn5=0, adjustableColumn6=0,
                         annotation="", backgroundColor=None, buttonCommand=None,
                         buttonLabel="", changeCommand=None, columnAlign=None,
                         columnAlign2=None, columnAlign3=None, columnAlign4=None,
                         columnAlign5=None, columnAlign6=None, columnAttach=None,
                         columnAttach2=None, columnAttach3=None, columnAttach4=None,
                         columnAttach5=None, columnAttach6=None, columnOffset2=None,
                         columnOffset3=None, columnOffset4=None, columnOffset5=None,
                         columnOffset6=None, columnWidth=None, columnWidth1=0,
                         columnWidth2=None, columnWidth3=None, columnWidth4=None,
                         columnWidth5=None, columnWidth6=None, defineTemplate="", docTag="",
                         dragCallback=None, dragCommand=None, dropCallback=None, enable=True,
                         enableBackground=True, enableKeyboardFocus=True, exists=True,
                         forceDragRefresh=True, fullPathName=True, height=0,
                         highlightColor=None, hsvValue=None, image="", isObscured=True,
                         label="", manage=True, noBackground=True, numberOfPopupMenus=True,
                         parent="", popupMenuArray=True, preventOverride=True, rgbValue=None,
                         rowAttach=None, statusBarMessage="", symbolButtonCommand=None,
                         symbolButtonDisplay=True, useTemplate="", visible=True,
                         visibleChangeCommand=None, width=0, q=True, query=True, e=True,
                         edit=True, **kwargs):
    """
    All of the group commands position their individual controls in columns starting at column
    1  The layout of each control (ie  column) can be customized using the -cw/columnWidth,
    -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumn flags  By
    default, columns are left aligned with no offset and are 100 pixels wide  Only o
    
    :param adjustableColumn: (C E) Specifies which column has an adjustable size that changes
    with the sizing of the layout  The column value is a 1-based index  Passing 0 as argument
    :type adjustableColumn: int
    :param adjustableColumn2: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly two columns
    :type adjustableColumn2: int
    :param adjustableColumn3: (C E) Specifies that the column has an adjustable size that
    changes with the size of the parent layout  Ignored if there are not exactly three columns
    :type adjustableColumn3: int
    :param adjustableColumn4: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly four columns
    :type adjustableColumn4: int
    :param adjustableColumn5: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly five columns
    :type adjustableColumn5: int
    :param adjustableColumn6: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly six columns
    :type adjustableColumn6: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param buttonCommand: (C E) Command string executed when the button is pressed
    :type buttonCommand: script
    :param buttonLabel: (C Q E) The button text
    :type buttonLabel: string
    :param changeCommand: (C E) Command string executed when slider value changes
    :type changeCommand: script
    :param columnAlign: (C E M) Arguments are : column number, alignment type  Possible
    alignments are: left | right | center  Specifies alignment type for the specified column
    :type columnAlign: [int, string]
    :param columnAlign2: (C E) Sets the text alignment of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "center"
    :type columnAlign2: [string, string]
    :param columnAlign3: (C E) Sets the text alignment for all three columns  Ignored if there
    are not exactly three columns  Valid values are "left", "right", and "center"
    :type columnAlign3: [string, string, string]
    :param columnAlign4: (C E) Sets the text alignment for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "center"
    :type columnAlign4: [string, string, string, string]
    :param columnAlign5: (C E) Sets the text alignment for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "center"
    :type columnAlign5: [string, string, string, string, string]
    :param columnAlign6: (C E) Sets the text alignment for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "center"
    :type columnAlign6: [string, string, string, string, string, string]
    :param columnAttach: (C E M) Arguments are : column number, attachment type, and offset 
    Possible attachments are: left | right | both  Specifies column attachment types and offe
    :type columnAttach: [int, string, int]
    :param columnAttach2: (C E) Sets the attachment type of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "both"
    :type columnAttach2: [string, string]
    :param columnAttach3: (C E) Sets the attachment type for all three columns  Ignored if
    there are not exactly three columns  Valid values are "left", "right", and "both"
    :type columnAttach3: [string, string, string]
    :param columnAttach4: (C E) Sets the attachment type for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "both"
    :type columnAttach4: [string, string, string, string]
    :param columnAttach5: (C E) Sets the attachment type for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "both"
    :type columnAttach5: [string, string, string, string, string]
    :param columnAttach6: (C E) Sets the attachment type for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "both"
    :type columnAttach6: [string, string, string, string, string, string]
    :param columnOffset2: (C E) This flag is used in conjunction with the -columnAttach2 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the tw
    :type columnOffset2: [int, int]
    :param columnOffset3: (C E) This flag is used in conjunction with the -columnAttach3 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the th
    :type columnOffset3: [int, int, int]
    :param columnOffset4: (C E) This flag is used in conjunction with the -columnAttach4 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fo
    :type columnOffset4: [int, int, int, int]
    :param columnOffset5: (C E) This flag is used in conjunction with the -columnAttach5 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fi
    :type columnOffset5: [int, int, int, int, int]
    :param columnOffset6: (C E) This flag is used in conjunction with the -columnAttach6 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the si
    :type columnOffset6: [int, int, int, int, int, int]
    :param columnWidth: (C E M) Arguments are : column number, column width  Sets the width of
    the specified column where the first parameter specifies the column (1 based index) an
    :type columnWidth: [int, int]
    :param columnWidth1: (C E) Sets the width of the first column  Ignored if there is not
    exactly one column
    :type columnWidth1: int
    :param columnWidth2: (C E) Sets the column widths of both columns  Ignored if there are not
    exactly two columns
    :type columnWidth2: [int, int]
    :param columnWidth3: (C E) Sets the column widths for all 3 columns  Ignored if there are
    not exactly 3 columns
    :type columnWidth3: [int, int, int]
    :param columnWidth4: (C E) Sets the column widths for all 4 columns  Ignored if there are
    not exactly 4 columns
    :type columnWidth4: [int, int, int, int]
    :param columnWidth5: (C E) Sets the column widths for all 5 columns  Ignored if there are
    not exactly 5 columns
    :type columnWidth5: [int, int, int, int, int]
    :param columnWidth6: (C E) Sets the column widths for all 6 columns  Ignored if there are
    not exactly 6 columns
    :type columnWidth6: [int, int, int, int, int, int]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dragCommand: (C E) Command string executed when slider value marker is dragged
    :type dragCommand: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param forceDragRefresh: (C Q E) If used then force refresh on drag
    :type forceDragRefresh: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param hsvValue: (C Q E) Color in hue, saturation, and value format
    :type hsvValue: [float, float, float]
    :param image: (C Q E) Image displayed on the symbol button
    :type image: string
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) Label text for the group
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rgbValue: (C Q E) Color in red, green, and blue format
    :type rgbValue: [float, float, float]
    :param rowAttach: (C E M) Arguments are : column, attachment type, offset  Possible
    attachments are: top | bottom | both  Specifies attachment types and offsets for the
    entire
    :type rowAttach: [int, string, int]
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param symbolButtonCommand: (C E) Command string executed when the symbol button is
    pressed
    :type symbolButtonCommand: script
    :param symbolButtonDisplay: (C Q E) Visibility of the symbol button
    :type symbolButtonDisplay: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def PointConstraint(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GridOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddInBetweenTargetShapeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_bridgeTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def fontDialog(*args, FontList=True, scalable=True, **kwargs):
    """
    Displays a dialog of available fonts for the user to select from  The name of the selected
    font is returned, or an empty string if no font was selected   When the FontList flag is
    used, no dialog is displayed  Instead the command returns an array of the available fonts
    
    :param FontList: (C) Returns an array of all available font names  No dialog is displayed
    :type FontList: boolean
    :param scalable: (C) Limits the fonts returned or displayed to just those that are
    scalable
    :type scalable: boolean
    
    :returns: Dialog name
    :rtype: string
    """
    pass


def PreInfinityConstant(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddDivisions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def readPDC(*args, **kwargs):
    """
    
    """
    pass


def NodeEditorCopy(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyLayoutUV(*args, caching=True, constructionHistory=True, flipReversed=True, layout=0,
                 layoutMethod=0, name="", nodeState=0, percentageSpace=0.0, rotateForBestFit=0,
                 scale=0, separate=0, uvSetName="", worldSpace=True, q=True, query=True, e=True,
                 edit=True, **kwargs):
    """
    Move UVs in the texture plane to avoid overlaps
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param flipReversed: (C Q E) If this flag is turned on, the reversed UV pieces are fliped
    :type flipReversed: boolean
    :param layout: (C Q E) How to move the UV pieces, after cuts are applied: 0 No move is
    applied  1 Layout the pieces along the U axis  2 Layout the pieces in a square shape
    :type layout: int
    :param layoutMethod: (C Q E) Which layout method to use: 0 Block Stacking  1 Shape
    Stacking
    :type layoutMethod: int
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param percentageSpace: (C Q E) When layout is set to square, this value is a percentage of
    the texture area which is added around each UV piece  It can be used to ensure each UV pi
    :type percentageSpace: float
    :param rotateForBestFit: (C Q E) 0 No rotation is applied  1 Only allow 90 degree rotations
     2 Allow free rotations
    :type rotateForBestFit: int
    :param scale: (C Q E) How to scale the pieces, after move and cuts: 0 No scale is applied 
    1 Uniform scale to fit in unit square  2 Non proportional scale to fit in unit s
    :type scale: int
    :param separate: (C Q E) Which UV edges should be cut: 0 No cuts  1 Cut only along folds  2
    Make all necessary cuts to avoid all intersections
    :type separate: int
    :param uvSetName: (C) Name of the UV set to be created
    :type uvSetName: string
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def FBXUICallBack(*args, **kwargs):
    """
    
    """
    pass


def OffsetSurfaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def arnoldFlushCache(*args, **kwargs):
    """
    
    """
    pass


def SelectPreviousObjectsMotionBuilder(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def timeFieldGrp(*args, adjustableColumn=0, adjustableColumn2=0, adjustableColumn3=0,
                 adjustableColumn4=0, adjustableColumn5=0, adjustableColumn6=0, annotation="",
                 backgroundColor=None, changeCommand=None, columnAlign=None, columnAlign2=None,
                 columnAlign3=None, columnAlign4=None, columnAlign5=None, columnAlign6=None,
                 columnAttach=None, columnAttach2=None, columnAttach3=None, columnAttach4=None,
                 columnAttach5=None, columnAttach6=None, columnOffset2=None, columnOffset3=None,
                 columnOffset4=None, columnOffset5=None, columnOffset6=None, columnWidth=None,
                 columnWidth1=0, columnWidth2=None, columnWidth3=None, columnWidth4=None,
                 columnWidth5=None, columnWidth6=None, defineTemplate="", docTag="",
                 dragCallback=None, dragCommand=None, dropCallback=None, enable=True,
                 enable1=True, enable2=True, enable3=True, enable4=True, enableBackground=True,
                 enableKeyboardFocus=True, exists=True, extraLabel="", fullPathName=True,
                 height=0, highlightColor=None, isObscured=True, label="", manage=True,
                 noBackground=True, numberOfFields=0, numberOfPopupMenus=True, parent="",
                 popupMenuArray=True, precision=0, preventOverride=True, rowAttach=None,
                 statusBarMessage="", step=None, useTemplate="", value=None, value1=None,
                 value2=None, value3=None, value4=None, visible=True, visibleChangeCommand=None,
                 width=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    All of the group commands position their individual controls in columns starting at column
    1  The layout of each control (ie  column) can be customized using the -cw/columnWidth,
    -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumn flags  By
    default, columns are left aligned with no offset and are 100 pixels wide  Only o
    
    :param adjustableColumn: (C E) Specifies which column has an adjustable size that changes
    with the sizing of the layout  The column value is a 1-based index  Passing 0 as argument
    :type adjustableColumn: int
    :param adjustableColumn2: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly two columns
    :type adjustableColumn2: int
    :param adjustableColumn3: (C E) Specifies that the column has an adjustable size that
    changes with the size of the parent layout  Ignored if there are not exactly three columns
    :type adjustableColumn3: int
    :param adjustableColumn4: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly four columns
    :type adjustableColumn4: int
    :param adjustableColumn5: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly five columns
    :type adjustableColumn5: int
    :param adjustableColumn6: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly six columns
    :type adjustableColumn6: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Command string executed when the value of any of the fields
    changes
    :type changeCommand: script
    :param columnAlign: (C E M) Arguments are : column number, alignment type  Possible
    alignments are: left | right | center  Specifies alignment type for the specified column
    :type columnAlign: [int, string]
    :param columnAlign2: (C E) Sets the text alignment of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "center"
    :type columnAlign2: [string, string]
    :param columnAlign3: (C E) Sets the text alignment for all three columns  Ignored if there
    are not exactly three columns  Valid values are "left", "right", and "center"
    :type columnAlign3: [string, string, string]
    :param columnAlign4: (C E) Sets the text alignment for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "center"
    :type columnAlign4: [string, string, string, string]
    :param columnAlign5: (C E) Sets the text alignment for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "center"
    :type columnAlign5: [string, string, string, string, string]
    :param columnAlign6: (C E) Sets the text alignment for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "center"
    :type columnAlign6: [string, string, string, string, string, string]
    :param columnAttach: (C E M) Arguments are : column number, attachment type, and offset 
    Possible attachments are: left | right | both  Specifies column attachment types and offe
    :type columnAttach: [int, string, int]
    :param columnAttach2: (C E) Sets the attachment type of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "both"
    :type columnAttach2: [string, string]
    :param columnAttach3: (C E) Sets the attachment type for all three columns  Ignored if
    there are not exactly three columns  Valid values are "left", "right", and "both"
    :type columnAttach3: [string, string, string]
    :param columnAttach4: (C E) Sets the attachment type for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "both"
    :type columnAttach4: [string, string, string, string]
    :param columnAttach5: (C E) Sets the attachment type for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "both"
    :type columnAttach5: [string, string, string, string, string]
    :param columnAttach6: (C E) Sets the attachment type for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "both"
    :type columnAttach6: [string, string, string, string, string, string]
    :param columnOffset2: (C E) This flag is used in conjunction with the -columnAttach2 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the tw
    :type columnOffset2: [int, int]
    :param columnOffset3: (C E) This flag is used in conjunction with the -columnAttach3 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the th
    :type columnOffset3: [int, int, int]
    :param columnOffset4: (C E) This flag is used in conjunction with the -columnAttach4 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fo
    :type columnOffset4: [int, int, int, int]
    :param columnOffset5: (C E) This flag is used in conjunction with the -columnAttach5 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fi
    :type columnOffset5: [int, int, int, int, int]
    :param columnOffset6: (C E) This flag is used in conjunction with the -columnAttach6 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the si
    :type columnOffset6: [int, int, int, int, int, int]
    :param columnWidth: (C E M) Arguments are : column number, column width  Sets the width of
    the specified column where the first parameter specifies the column (1 based index) an
    :type columnWidth: [int, int]
    :param columnWidth1: (C E) Sets the width of the first column  Ignored if there is not
    exactly one column
    :type columnWidth1: int
    :param columnWidth2: (C E) Sets the column widths of both columns  Ignored if there are not
    exactly two columns
    :type columnWidth2: [int, int]
    :param columnWidth3: (C E) Sets the column widths for all 3 columns  Ignored if there are
    not exactly 3 columns
    :type columnWidth3: [int, int, int]
    :param columnWidth4: (C E) Sets the column widths for all 4 columns  Ignored if there are
    not exactly 4 columns
    :type columnWidth4: [int, int, int, int]
    :param columnWidth5: (C E) Sets the column widths for all 5 columns  Ignored if there are
    not exactly 5 columns
    :type columnWidth5: [int, int, int, int, int]
    :param columnWidth6: (C E) Sets the column widths for all 6 columns  Ignored if there are
    not exactly 6 columns
    :type columnWidth6: [int, int, int, int, int, int]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dragCommand: (C E) Command string executed when dragging the invisible slider in any
    of the fields
    :type dragCommand: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enable1: (C Q E) 
    :type enable1: boolean
    :param enable2: (C Q E) 
    :type enable2: boolean
    :param enable3: (C Q E) 
    :type enable3: boolean
    :param enable4: (C Q E) Enable state for the respective field
    :type enable4: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param extraLabel: (C Q E) If present on creation this specifies that there will be an
    extra label in the group  Sets the string to be label text to the right of fields
    :type extraLabel: string
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) If present on creation this specifies that there will be a label to
    the left of the fields  Sets the string to be the label text
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfFields: (C) Set the number of fields on creation  One to four fields are
    available  The default is one field
    :type numberOfFields: int
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param precision: (C E) Set the number of digits to the right of the decimal
    :type precision: int
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rowAttach: (C E M) Arguments are : column, attachment type, offset  Possible
    attachments are: top | bottom | both  Specifies attachment types and offsets for the
    entire
    :type rowAttach: [int, string, int]
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param step: (C Q E) Set the delta of invisioSlider delta , the invisioSlider step is
    delta/10.0 in LMB , delta in MMB,delta*10.0 in RMB  Default is 10.0
    :type step: time
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param value: (C Q E) Values for all fields
    :type value: [time, time, time, time]
    :param value1: (C Q E) 
    :type value1: time
    :param value2: (C Q E) 
    :type value2: time
    :param value3: (C Q E) 
    :type value3: time
    :param value4: (C Q E) Value for the respective field
    :type value4: time
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def CreatePoseInterpolatorEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RotateTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ChangeUVSize(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def disableIncorrectNameWarning(*args, **kwargs):
    """
    Disable the warning dialog which complains about incorrect node names when opening Maya
    files
    
    
    :returns: 
    :rtype: None
    """
    pass


def CreateClip(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OrientJointOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AttachBrushToCurves(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def headsUpDisplay(*args, allDescendants=True, allowOverlap=True, attachToRefresh=True,
                   attributeChange="", block=0, blockAlignment="", blockSize="", command=None,
                   conditionChange="", conditionFalse="", conditionTrue="", connectionChange="",
                   dataAlignment="", dataFontSize="", dataWidth=0, decimalPrecision=0,
                   disregardIndex=True, event="", exists=True, getOption="", gridColor=0,
                   label="", labelFontSize="", labelWidth=0, lastOccupiedBlock=0,
                   layoutVisibility=True, listConditions=True, listEvents=True,
                   listHeadsUpDisplays=True, listNodeChanges=True, listPresets=True, name="",
                   nextFreeBlock=0, nodeChanges="", padding=0, preset="", refresh=True,
                   remove=True, removeID=0, removePosition=None, resetNodeChanges="",
                   scriptResult=True, section=0, setOption=None, showGrid=True, visible=True,
                   q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a Heads-up Display (HUD) object which is placed in a 2D inactive
    overlay plane on the 3D viewport  It is to be used to provide hands-on information
    designated by a user script  The text string displayed on the viewport is formatted using
    the various flags of this command   The only mandatory flags, on creation are the section
    a
    
    :param allDescendants: (C E) This flag can only be used in conjunction with the
    -ac/attributeChange flag  If it is specified, and the HUD is attached to a compound or
    multi attri
    :type allDescendants: boolean
    :param allowOverlap: (C Q E) Sets the Heads-Up Display to be visible regardless of
    overlapping section widths/limitations (see -s/section flag description for more details)
    :type allowOverlap: boolean
    :param attachToRefresh: (C Q E) Attaches the command to the refresh process  The script is
    then run each time an idle refresh is run and updates directly following it
    :type attachToRefresh: boolean
    :param attributeChange: (C E) Runs the command when the named attribute changes value  The
    string must identify both the dependency node and the particular attribute  If the depen
    :type attributeChange: string
    :param block: (C Q E) Denotes the individual block that the HUD will reside in, within a
    section  Each section is composed of a single column of blocks  The total number o
    :type block: int
    :param blockAlignment: (C Q E) Specifies the alignment of the block within its respective
    column  Available alignments are: "center", "left" and "right"  The default alignment is "
    :type blockAlignment: string
    :param blockSize: (C Q E) Sets the height of each block  Available heights are: small,
    medium and large  In pixel measurements, each corresponds to a 20, 35 or 50 pixel height
    :type blockSize: string
    :param command: (C Q E) Specifies the procedure or script to run, in order to obtain the
    desired information  This must return a value or an array of values  A warning will
    :type command: script
    :param conditionChange: (C E) A trigger which runs the command (to sample the data), when
    the named condition changes  The named condition must be pre-defined or a user defined bo
    :type conditionChange: string
    :param conditionFalse: (C E) A trigger which runs the command (to sample the data), when
    the named condition becomes false  The named condition must be pre-defined or a user defi
    :type conditionFalse: string
    :param conditionTrue: (C E) A trigger which runs the command (to sample the data), when the
    named condition becomes true  The named condition must be pre-defined or a user defin
    :type conditionTrue: string
    :param connectionChange: (C E) Runs the command when the named attribute changes its
    connectivity  The string must identify both the dependency node and the particular
    attribute  I
    :type connectionChange: string
    :param dataAlignment: (C Q E) Specifies the alignment of the data blocks and the data text,
    within a HUD block  Available alignments are: "left" and "right"  The default alignment
    :type dataAlignment: string
    :param dataFontSize: (C Q E) Sets the font size of the returned data  Available sizes are:
    small and large
    :type dataFontSize: string
    :param dataWidth: (C Q E) Specifies the pixel width of the virtual "textbox" which will
    hold a data value  For commands which return more than one value (ie  arrays), one of t
    :type dataWidth: int
    :param decimalPrecision: (C Q E) Sets the decimal precision of any floating point value
    returned by the command  The valid range of precision values are 1 to 8
    :type decimalPrecision: int
    :param disregardIndex: (C E) This flag can only be used in conjunction with the
    -ac/attributeChange flag  If it is specified, and the HUD is attached to a multi (indexed)
    attribu
    :type disregardIndex: boolean
    :param event: (C E) Runs the command when the named event occurs  The named event, must be
    a pre-defined Maya event  To get a list of what events exist, use the -le/list
    :type event: string
    :param exists: (C Q) This flag returns whether the given object exists in the Heads-Up
    Display layout  An object name must be supplied with this command  This flag cannot
    :type exists: boolean
    :param getOption: (Q) This flag will return the value of the option specified by the string
     See setOption for a list of options In query mode, this flag needs a value
    :type getOption: string
    :param gridColor: (C Q E) This flag specifies a color for the grid lines using the inactive
    color palette  Specifying an index number between 1 to 23 will select the correspon
    :type gridColor: int
    :param label: (C Q E) Text string that appears to the left of the desired information
    :type label: string
    :param labelFontSize: (C Q E) Sets the font size of the label  Available sizes are: small
    and large
    :type labelFontSize: string
    :param labelWidth: (C Q E) Specifies the pixel width of the virtual "textbox" which will
    hold the label  The contents of this "textbox" will be left justified  If the width of
    :type labelWidth: int
    :param lastOccupiedBlock: (C) Returns the block number of the last occupied block in a
    given section
    :type lastOccupiedBlock: int
    :param layoutVisibility: (C Q E) Sets the visibility of Heads-Up Display layout on and off 
    This does not modify individual visibilities of heads-up displays, but turns off the layou
    :type layoutVisibility: boolean
    :param listConditions: (C Q) This flag will return a string array containing all names of
    the available conditions
    :type listConditions: boolean
    :param listEvents: (C Q) This flag will return a string array containing all names of the
    available events
    :type listEvents: boolean
    :param listHeadsUpDisplays: (C Q) This flag will return a string array containing all names
    of existing HUDs
    :type listHeadsUpDisplays: boolean
    :param listNodeChanges: (C Q) This flag will return a string array containing all names of
    the available node changes
    :type listNodeChanges: boolean
    :param listPresets: (C Q) This flag will return a string array containing all names of the
    available preset HUDs
    :type listPresets: boolean
    :param name: (E) This flag only permits the EDITING of the name of the Heads-Up Display
    :type name: string
    :param nextFreeBlock: (C) Returns the block number of the next free block in a given
    section
    :type nextFreeBlock: int
    :param nodeChanges: (C Q E M) Works only with selection based triggers (ie 
    "SelectionChanged" or "SomethingSelected"), otherwise this flag is ignored  This flag
    attaches the HUD
    :type nodeChanges: string
    :param padding: (C Q E) Specifies the width of both the left and right margins of a block 
    Default value is 15 pixels
    :type padding: int
    :param preset: (C Q E) This setting is used to select certain pre-defined HUDs, some of
    which retrieve specific data, that is unobtainable through normal MEL commands or sc
    :type preset: string
    :param refresh: (C) This flag forces the given Heads-Up Display element to refresh,
    updating the value displayed  This flag cannot be combined with any other flag
    :type refresh: boolean
    :param remove: (C E) This command will remove a given HUD object, given a specified HUD
    name  This flag will override all other flags and is mutually exclusive from the o
    :type remove: boolean
    :param removeID: (C E) This command will remove a given HUD object, given a specified HUD
    ID number assigned to it at creation time  This flag will override all other flags
    :type removeID: int
    :param removePosition: (C E) This command will remove the contents of a specific block
    location in the HUD layout  This flag will override all other flags and is mutually
    exclusi
    :type removePosition: [int, int]
    :param resetNodeChanges: (E M) This flag will reset a specificied nodeChange back to false 
    This flag only operates under the edit flag  See the description for the -nc/nodeChanges
    :type resetNodeChanges: string
    :param scriptResult: (Q) This flag is only used in conjunction with the query flag  Calling
    a query on this flag returns the most recent result of the HUD
    :type scriptResult: boolean
    :param section: (C Q E) Defines the section the HUD will appear in  There are 10 sections
    divided across the screen  Five columns and two rows make up the ten element matrix
    :type section: int
    :param setOption: (E) This flag will edit the option specified by the first string  Current
    options are: smpPolyCount - "cage" or "smp" - in smooth mesh preview, determine
    :type setOption: [string, string]
    :param showGrid: (C Q E) This flag will toggle the display of the grid lines of the HUD
    layout
    :type showGrid: boolean
    :param visible: (C Q E) Sets the visibility of the Heads-Up Display on and off
    :type visible: boolean
    
    :returns: ID number of the Heads-Up Display (HUD), for regular command execution.
    :rtype: int
    """
    pass


def OneClickFetchRemoteCharacter(*args, **kwargs):
    """
    
    """
    pass


def PolyBrushMarkingMenuPopDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RenameAttribute(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def psdConvSolidTxOptions(*args, **kwargs):
    """
    
    """
    pass


def sphere(*args, axis=None, caching=True, degree=3, endSweep=2, heightRatio=2.0, nodeState=0,
           pivot=None, radius=1.0, sections=8, spans=1, startSweep=0, tolerance=0.01,
           useTolerance=False, constructionHistory=True, name="", object=True, polygon=0,
           q=True, query=True, e=True, edit=True, **kwargs):
    """
    The sphere command creates a new sphere  The number of spans in the in each direction of
    the sphere is determined by the useTolerance attribute  If -ut is true then the -tolerance
    attribute will be used  If -ut is false then the -sections attribute will be used
    
    :param axis: (C Q E) The primitive's axis
    :type axis: [float, float, float]
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param degree: (C Q E) The degree of the resulting surface: 1 - linear, 3 - cubic Default:
    3
    :type degree: int
    :param endSweep: (C Q E) The angle at which to end the surface of revolution  Default is
    2Pi radians, or 360 degrees  Default: 6.2831853
    :type endSweep: float
    :param heightRatio: (C Q E) Ratio of "height" to "width" Default: 2.0
    :type heightRatio: float
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param pivot: (C Q E) The primitive's pivot point
    :type pivot: [float, float, float]
    :param radius: (C Q E) The radius of the object Default: 1.0
    :type radius: float
    :param sections: (C Q E) The number of sections determines the resolution of the surface in
    the sweep direction  Used only if useTolerance is false  Default: 8
    :type sections: int
    :param spans: (C Q E) The number of spans determines the resolution of the surface in the
    opposite direction  Default: 1
    :type spans: int
    :param startSweep: (C Q E) The angle at which to start the surface of revolution Default:
    0
    :type startSweep: float
    :param tolerance: (C Q E) The tolerance with which to build the surface  Used only if
    useTolerance is true Default: 0.01
    :type tolerance: float
    :param useTolerance: (C Q E) Use the specified tolerance to determine resolution  Otherwise
    number of sections will be used  Default: false
    :type useTolerance: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param polygon: (C) The value of this argument controls the type of the object created by
    this operation 0: nurbs surface 1: polygon (use nurbsToPolygonsPref to set the
    :type polygon: int
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def FourViewArrangement(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddTimeWarp(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def aliasAttr(*args, remove=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Allows aliases (alternate names) to be defined for any attribute of a specified node  When
    an attribute is aliased, the alias will be used by the system to display information about
    the attribute  The user may, however, freely use either the alias or the original name of
    the attribute  Only a single alias can be specified for an attribute so settin
    
    :param remove: (C) Specifies that aliases listed should be removed (otherwise new aliases
    are added)
    :type remove: boolean
    
    :returns: in query mode.
    :rtype: string[]
    """
    pass


def dR_bridgeRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def attrFieldSliderGrp(*args, adjustableColumn=0, adjustableColumn2=0, adjustableColumn3=0,
                       adjustableColumn4=0, adjustableColumn5=0, adjustableColumn6=0,
                       annotation="", attribute="", backgroundColor=None, changeCommand=None,
                       columnAlign=None, columnAlign2=None, columnAlign3=None,
                       columnAlign4=None, columnAlign5=None, columnAlign6=None,
                       columnAttach=None, columnAttach2=None, columnAttach3=None,
                       columnAttach4=None, columnAttach5=None, columnAttach6=None,
                       columnOffset2=None, columnOffset3=None, columnOffset4=None,
                       columnOffset5=None, columnOffset6=None, columnWidth=None, columnWidth1=0,
                       columnWidth2=None, columnWidth3=None, columnWidth4=None,
                       columnWidth5=None, columnWidth6=None, defineTemplate="", docTag="",
                       dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
                       enableKeyboardFocus=True, exists=True, extraButton=True,
                       extraButtonCommand=None, extraButtonIcon="", fieldMaxValue=0.0,
                       fieldMinValue=0.0, fieldStep=0.0, forceAddMapButton=True,
                       fullPathName=True, height=0, hideMapButton=True, highlightColor=None,
                       isObscured=True, label="", manage=True, maxValue=0.0, minValue=0.0,
                       noBackground=True, numberOfPopupMenus=True, parent="",
                       popupMenuArray=True, precision=0, preventOverride=True, rowAttach=None,
                       sliderMaxValue=0.0, sliderMinValue=0.0, sliderStep=0.0,
                       statusBarMessage="", step=0.0, useTemplate="", vertical=True,
                       visible=True, visibleChangeCommand=None, width=0, q=True, query=True,
                       e=True, edit=True, **kwargs):
    """
    All of the group commands position their individual controls in columns starting at column
    1  The layout of each control (ie  column) can be customized using the -cw/columnWidth,
    -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumn flags  By
    default, columns are left aligned with no offset and are 100 pixels wide  Only o
    
    :param adjustableColumn: (C E) Specifies which column has an adjustable size that changes
    with the sizing of the layout  The column value is a 1-based index  Passing 0 as argument
    :type adjustableColumn: int
    :param adjustableColumn2: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly two columns
    :type adjustableColumn2: int
    :param adjustableColumn3: (C E) Specifies that the column has an adjustable size that
    changes with the size of the parent layout  Ignored if there are not exactly three columns
    :type adjustableColumn3: int
    :param adjustableColumn4: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly four columns
    :type adjustableColumn4: int
    :param adjustableColumn5: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly five columns
    :type adjustableColumn5: int
    :param adjustableColumn6: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly six columns
    :type adjustableColumn6: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param attribute: (C Q E) The name of a unique attribute of type double or int  This newly
    created field will be attached to the attribute, so that modifications to one will c
    :type attribute: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) The command string is executed when the value of the slider or
    floatField changes  It will be executed only once after a drag of the slider
    :type changeCommand: script
    :param columnAlign: (C E M) Arguments are : column number, alignment type  Possible
    alignments are: left | right | center  Specifies alignment type for the specified column
    :type columnAlign: [int, string]
    :param columnAlign2: (C E) Sets the text alignment of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "center"
    :type columnAlign2: [string, string]
    :param columnAlign3: (C E) Sets the text alignment for all three columns  Ignored if there
    are not exactly three columns  Valid values are "left", "right", and "center"
    :type columnAlign3: [string, string, string]
    :param columnAlign4: (C E) Sets the text alignment for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "center"
    :type columnAlign4: [string, string, string, string]
    :param columnAlign5: (C E) Sets the text alignment for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "center"
    :type columnAlign5: [string, string, string, string, string]
    :param columnAlign6: (C E) Sets the text alignment for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "center"
    :type columnAlign6: [string, string, string, string, string, string]
    :param columnAttach: (C E M) Arguments are : column number, attachment type, and offset 
    Possible attachments are: left | right | both  Specifies column attachment types and offe
    :type columnAttach: [int, string, int]
    :param columnAttach2: (C E) Sets the attachment type of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "both"
    :type columnAttach2: [string, string]
    :param columnAttach3: (C E) Sets the attachment type for all three columns  Ignored if
    there are not exactly three columns  Valid values are "left", "right", and "both"
    :type columnAttach3: [string, string, string]
    :param columnAttach4: (C E) Sets the attachment type for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "both"
    :type columnAttach4: [string, string, string, string]
    :param columnAttach5: (C E) Sets the attachment type for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "both"
    :type columnAttach5: [string, string, string, string, string]
    :param columnAttach6: (C E) Sets the attachment type for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "both"
    :type columnAttach6: [string, string, string, string, string, string]
    :param columnOffset2: (C E) This flag is used in conjunction with the -columnAttach2 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the tw
    :type columnOffset2: [int, int]
    :param columnOffset3: (C E) This flag is used in conjunction with the -columnAttach3 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the th
    :type columnOffset3: [int, int, int]
    :param columnOffset4: (C E) This flag is used in conjunction with the -columnAttach4 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fo
    :type columnOffset4: [int, int, int, int]
    :param columnOffset5: (C E) This flag is used in conjunction with the -columnAttach5 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fi
    :type columnOffset5: [int, int, int, int, int]
    :param columnOffset6: (C E) This flag is used in conjunction with the -columnAttach6 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the si
    :type columnOffset6: [int, int, int, int, int, int]
    :param columnWidth: (C E M) Arguments are : column number, column width  Sets the width of
    the specified column where the first parameter specifies the column (1 based index) an
    :type columnWidth: [int, int]
    :param columnWidth1: (C E) Sets the width of the first column  Ignored if there is not
    exactly one column
    :type columnWidth1: int
    :param columnWidth2: (C E) Sets the column widths of both columns  Ignored if there are not
    exactly two columns
    :type columnWidth2: [int, int]
    :param columnWidth3: (C E) Sets the column widths for all 3 columns  Ignored if there are
    not exactly 3 columns
    :type columnWidth3: [int, int, int]
    :param columnWidth4: (C E) Sets the column widths for all 4 columns  Ignored if there are
    not exactly 4 columns
    :type columnWidth4: [int, int, int, int]
    :param columnWidth5: (C E) Sets the column widths for all 5 columns  Ignored if there are
    not exactly 5 columns
    :type columnWidth5: [int, int, int, int, int]
    :param columnWidth6: (C E) Sets the column widths for all 6 columns  Ignored if there are
    not exactly 6 columns
    :type columnWidth6: [int, int, int, int, int, int]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param extraButton: (C) Add an extra icon button to the end of this control
    :type extraButton: boolean
    :param extraButtonCommand: (C E) The command string is executed when the extra button is
    clicked
    :type extraButtonCommand: script
    :param extraButtonIcon: (C Q E) The icon file name of the extra button
    :type extraButtonIcon: string
    :param fieldMaxValue: (C Q E) Set the maximum value for the field  This flag allows you to
    specify a maximum bound for the field higher than that of the slider  (See note above ab
    :type fieldMaxValue: float
    :param fieldMinValue: (C Q E) Set the minimum value for the field  This flag allows you to
    specify a minimum bound for the field lower than that of the slider  (See note above abo
    :type fieldMinValue: float
    :param fieldStep: (C Q E) Sets the increment for the float field
    :type fieldStep: float
    :param forceAddMapButton: (C) Force adding a map button to this control  If this option is
    true, option hideMapButton is suppressed
    :type forceAddMapButton: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param hideMapButton: (C) Force the map button to remain hidden for this control
    :type hideMapButton: boolean
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) By default, the label of this field will be the name of the attribute
     This flag can be used to override that name with whatever string you want
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param maxValue: (C Q E) Sets the maximum value for both the slider and the field  (See
    note above about min and max values)
    :type maxValue: float
    :param minValue: (C Q E) Sets the minimum value for both the slider and the field  (by
    default max and min are set according to what is in the attribute, if anything  If no m
    :type minValue: float
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param precision: (C E) Sets the number of digits to the right of the decimal  (If attached
    to an int attribute, this is automatically set to 0 and cannot be overridden.)
    :type precision: int
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rowAttach: (C E M) Arguments are : column, attachment type, offset  Possible
    attachments are: top | bottom | both  Specifies attachment types and offsets for the
    entire
    :type rowAttach: [int, string, int]
    :param sliderMaxValue: (C Q E) Set the maximum value for the slider  The slider max will be
    clipped to the field max
    :type sliderMaxValue: float
    :param sliderMinValue: (C Q E) Set the minimum value for the slider  The slider min will be
    clipped to the field min
    :type sliderMinValue: float
    :param sliderStep: (C Q E) On Linux the slider step value represents the amount the value
    will increase or decrease when you click either side of the slider
    :type sliderStep: float
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param step: (C Q E) Sets the increment for both the slider and float field
    :type step: float
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param vertical: (C Q) Whether the orientation of the controls in this group are horizontal
    (default) or vertical
    :type vertical: boolean
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def outlinerPanel(*args, control=True, copy="", createString=True, defineTemplate="", docTag="",
                  editString=True, exists=True, init=True, isUnique=True, label="",
                  menuBarRepeatLast=True, menuBarVisible=True, needsInit=True,
                  outlinerEditor=True, parent="", popupMenuProcedure=None, replacePanel="",
                  tearOff=True, tearOffCopy="", tearOffRestore=True, unParent=True,
                  useTemplate="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates, edit and queries outliner panels which contain only an outliner
    editor
    
    :param control: (Q) Returns the top level control for this panel  Usually used for getting
    a parent to attach popup menus  CAUTION: panels may not have controls at times
    :type control: boolean
    :param copy: (E) Makes this panel a copy of the specified panel  Both panels must be of the
    same type
    :type copy: string
    :param createString: (E) Command string used to create a panel
    :type createString: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Attaches a tag to the Maya panel
    :type docTag: string
    :param editString: (E) Command string used to edit a panel
    :type editString: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param init: (C E) Initializes the panel's default state  This is usually done
    automatically on file -new and file -open
    :type init: boolean
    :param isUnique: (Q) Returns true if only one instance of this panel type is allowed
    :type isUnique: boolean
    :param label: (Q E) Specifies the user readable label for the panel
    :type label: string
    :param menuBarRepeatLast: (C Q E) Controls whether clicking on the menu header with the
    middle mouse button would repeat the last selected menu item
    :type menuBarRepeatLast: boolean
    :param menuBarVisible: (C Q E) Controls whether the menu bar for the panel is displayed
    :type menuBarVisible: boolean
    :param needsInit: (Q E) (Internal) On Edit will mark the panel as requiring initialization 
    Query will return whether the panel is marked for initialization  Used during fil
    :type needsInit: boolean
    :param outlinerEditor: (Q) This flag returns the name of the outliner editor contained by
    the panel
    :type outlinerEditor: boolean
    :param parent: (C) Specifies the parent layout for this panel
    :type parent: string
    :param popupMenuProcedure: (Q E) Specifies the procedure called for building the panel's
    popup menu(s)  The default value is "buildPanelPopupMenu"  The procedure should take one
    stri
    :type popupMenuProcedure: script
    :param replacePanel: (E) Will replace the specified panel with this panel  If the target
    panel is within the same layout it will perform a swap
    :type replacePanel: string
    :param tearOff: (Q E) Will tear off this panel into a separate window with a paneLayout as
    the parent of the panel  When queried this flag will return if the panel has bee
    :type tearOff: boolean
    :param tearOffCopy: (C) Will create this panel as a torn of copy of the specified source
    panel
    :type tearOffCopy: string
    :param tearOffRestore: (C E) Restores panel if it is torn off and focus is given to it  If
    docked, becomes the active panel in the docked window  This should be the default flag
    :type tearOffRestore: boolean
    :param unParent: (E) Specifies that the panel should be removed from its layout  This
    (obviously) cannot be used with query
    :type unParent: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: (the name of the panel)
    :rtype: string
    """
    pass


def NodeEditorAdditiveGraphingMode(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def modelPanel(*args, barLayout=True, camera="", control=True, copy="", createString=True,
               defineTemplate="", docTag="", editString=True, exists=True, init=True,
               isUnique=True, label="", menuBarRepeatLast=True, menuBarVisible=True,
               modelEditor=True, needsInit=True, parent="", popupMenuProcedure=None,
               replacePanel="", tearOff=True, tearOffCopy="", tearOffRestore=True,
               unParent=True, useTemplate="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a panel consisting of a model editor  See the modelEditor command
    documentation for more information
    
    :param barLayout: (Q) This flag returns the name of the layout which is the parent of the
    panels icon bar
    :type barLayout: boolean
    :param camera: (Q E) Query or edit the camera in a modelPanel
    :type camera: string
    :param control: (Q) Returns the top level control for this panel  Usually used for getting
    a parent to attach popup menus  CAUTION: panels may not have controls at times
    :type control: boolean
    :param copy: (E) Makes this panel a copy of the specified panel  Both panels must be of the
    same type
    :type copy: string
    :param createString: (E) Command string used to create a panel
    :type createString: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Attaches a tag to the Maya panel
    :type docTag: string
    :param editString: (E) Command string used to edit a panel
    :type editString: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param init: (C E) Initializes the panel's default state  This is usually done
    automatically on file -new and file -open
    :type init: boolean
    :param isUnique: (Q) Returns true if only one instance of this panel type is allowed
    :type isUnique: boolean
    :param label: (Q E) Specifies the user readable label for the panel
    :type label: string
    :param menuBarRepeatLast: (C Q E) Controls whether clicking on the menu header with the
    middle mouse button would repeat the last selected menu item
    :type menuBarRepeatLast: boolean
    :param menuBarVisible: (C Q E) Controls whether the menu bar for the panel is displayed
    :type menuBarVisible: boolean
    :param modelEditor: (Q) This flag returns the name of the model editor contained by the
    panel
    :type modelEditor: boolean
    :param needsInit: (Q E) (Internal) On Edit will mark the panel as requiring initialization 
    Query will return whether the panel is marked for initialization  Used during fil
    :type needsInit: boolean
    :param parent: (C) Specifies the parent layout for this panel
    :type parent: string
    :param popupMenuProcedure: (Q E) Specifies the procedure called for building the panel's
    popup menu(s)  The default value is "buildPanelPopupMenu"  The procedure should take one
    stri
    :type popupMenuProcedure: script
    :param replacePanel: (E) Will replace the specified panel with this panel  If the target
    panel is within the same layout it will perform a swap
    :type replacePanel: string
    :param tearOff: (Q E) Will tear off this panel into a separate window with a paneLayout as
    the parent of the panel  When queried this flag will return if the panel has bee
    :type tearOff: boolean
    :param tearOffCopy: (C) Will create this panel as a torn of copy of the specified source
    panel
    :type tearOffCopy: string
    :param tearOffRestore: (C E) Restores panel if it is torn off and focus is given to it  If
    docked, becomes the active panel in the docked window  This should be the default flag
    :type tearOffRestore: boolean
    :param unParent: (E) Specifies that the panel should be removed from its layout  This
    (obviously) cannot be used with query
    :type unParent: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: The name of the panel.
    :rtype: string
    """
    pass


def HypershadeSetTraversalDepthUnlim(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PokePolygonOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ctxEditMode(*args, buttonDown=True, buttonUp=True, **kwargs):
    """
    This command tells the current context to switch edit modes.
    
    :param buttonDown: (C) Edit mode is being invoked from a hotkey press event
    :type buttonDown: boolean
    :param buttonUp: (C) Edit mode is being invoked from a hotkey release event
    :type buttonUp: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def MirrorPolygonGeometry(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExportOfflineFileFromRefEdOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BrushAnimationMarkingMenu(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PinSelectionOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectLightsShadowingObject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetKeyAnimated(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmPushOver(*args, **kwargs):
    """
    
    """
    pass


def dR_graphEditorTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleViewAxis(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OutlinerWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleEditPoints(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RaiseMainWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def stroke(*args, name="", pressure=False, seed=0, **kwargs):
    """
    The stroke command creates a new Paint Effects stroke node
    
    :param name: (C) Sets the name of the stroke to the input string
    :type name: string
    :param pressure: (C) On creation, allows the copying of the pressure mapping settings from
    the Paint Effects Tool  Default is false
    :type pressure: boolean
    :param seed: (C) Sets the random seed for this stroke
    :type seed: int
    
    :returns: (The path to the new stroke or the replaced stroke)
    :rtype: string
    """
    pass


def CreateEmptyUVSetOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmCreateInteractiveGroomSplinesOption(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeDisplayAsSmallSwatches(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ReplaceObjectsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UndoCanvas(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ungroup(*args, absolute=True, parent="", relative=True, world=True, **kwargs):
    """
    This command ungroups the specified objects   The objects will be placed at the same level
    in the hierarchy the group node occupied unless the -w flag is specified, in which case
    they will be placed under the world   If an object is ungrouped and there is an object in
    the new group with the same name then this command will rename the ungrouped obje
    
    :param absolute: (C) preserve existing world object transformations (overall object
    transformation is preserved by modifying the objects local transformation) [default]
    :type absolute: boolean
    :param parent: (C) put the ungrouped objects under the given parent
    :type parent: string
    :param relative: (C) preserve existing local object transformations (don't modify local
    transformation)
    :type relative: boolean
    :param world: (C) put the ungrouped objects under the world
    :type world: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def rebuildCurve(*args, caching=True, degree=3, endKnots=0, fitRebuild=True,
                 keepControlPoints=False, keepEndPoints=True, keepRange=1, keepTangents=True,
                 nodeState=0, rebuildType=0, smartSurfaceCurveRebuild=False, spans=4,
                 tolerance=0.01, constructionHistory=True, name="", object=True, range=True,
                 replaceOriginal=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command rebuilds a curve by modifying its parameterization  In some cases the shape
    may also change  The rebuildType (-rt) determines how the curve is to be rebuilt   The
    optional second curve can be used to specify a reference parameterization
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param degree: (C Q E) The degree of the resulting curve 1 - linear, 2 - quadratic, 3 -
    cubic, 5 - quintic, 7 - heptic Default: 3
    :type degree: int
    :param endKnots: (C Q E) End conditions for the curve 0 - uniform end knots, 1 - multiple
    end knots, Default: 0
    :type endKnots: int
    :param fitRebuild: (C Q E) If true use the least squares fit rebuild  Otherwise use the
    convert method  Default: true
    :type fitRebuild: boolean
    :param keepControlPoints: (C Q E) If true, the CVs will remain the same  This forces
    uniform parameterization unless rebuildType is matchKnots  Default: false
    :type keepControlPoints: boolean
    :param keepEndPoints: (C Q E) If true, keep the endpoints the same  Default: true
    :type keepEndPoints: boolean
    :param keepRange: (C Q E) Determine the parameterization for the resulting curve  0 -
    reparameterize the resulting curve from 0 to 1, 1 - keep the original curve parameterizat
    :type keepRange: int
    :param keepTangents: (C Q E) If true, keep the end tangents the same  Default: true
    :type keepTangents: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param rebuildType: (C Q E) How to rebuild the input curve  0 - uniform, 1 - reduce spans,
    2 - match knots, 3 - remove multiple knots, 4 - curvature 5 - rebuild ends 6 - clean D
    :type rebuildType: int
    :param smartSurfaceCurveRebuild: (C Q E) If true, curve on surface is rebuild in 3D and 2D
    info is kept Default: false
    :type smartSurfaceCurveRebuild: boolean
    :param spans: (C Q E) The number of spans in resulting curve Used only if rebuildType is
    uniform  Default: 4
    :type spans: int
    :param tolerance: (C Q E) The tolerance with which to rebuild  Default: 0.01
    :type tolerance: float
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param range: (C) Force a curve range on complete input curve
    :type range: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def CreateVolumeCone(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def instanceable(*args, allow=True, recursive=True, shape=True, q=True, query=True, **kwargs):
    """
    Flags one or more DAG nodes so that they can (or cannot) be instanced  This command sets an
    internal state on the specified DAG nodes which is checked whenever Maya attempts an
    instancing operation  If no node names are provided on the command line then the current
    selection list is used   Sets are automatically expanded to their constituent object
    
    :param allow: (C Q) Specifies the new instanceable state for the node  Specify true to
    allow the node to be instanceable, and false to prevent it from being instanced  T
    :type allow: boolean
    :param recursive: (C) Can be specified with the -allow flag in create or edit mode to
    recursively apply the -allow setting to all non-shape children of the selected node(s
    :type recursive: boolean
    :param shape: (C) Can be specified with the -allow flag in create or edit mode to apply the
    -allow setting to all shape children of the selected node(s)  This flag can
    :type shape: boolean
    
    :returns: For query execution.
    :rtype: boolean[]
    """
    pass


def xgmFileRender(*args, **kwargs):
    """
    
    """
    pass


def extendSurface(*args, caching=True, distance=1, extendDirection=0, extendMethod=0,
                  extendSide=1, extensionType=0, join=True, nodeState=0,
                  constructionHistory=True, name="", object=True, replaceOriginal=True, q=True,
                  query=True, e=True, edit=True, **kwargs):
    """
    This command extends a surface or creates a new surface as an extension
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param distance: (C Q E) The distance to extend (for by distance only) Default: 1
    :type distance: float
    :param extendDirection: (C Q E) Which parametric direction of the surface to extend ( 0 - U,
    1 - V, 2 - both ) Default: 0
    :type extendDirection: int
    :param extendMethod: (C Q E) The extend method (0 - distance) Default: 0
    :type extendMethod: int
    :param extendSide: (C Q E) Which end of the surface to extend ( 0 - end, 1 - start, 2 -
    both ) Default: 1
    :type extendSide: int
    :param extensionType: (C Q E) The type of extension (0 - tangent, 2 - extrapolate) Default:
    0
    :type extensionType: int
    :param join: (C Q E) Join extension to original Default: true
    :type join: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def rangeControl(*args, annotation="", backgroundColor=None, changedCommand=None,
                 defineTemplate="", docTag="", dragCallback=None, dropCallback=None,
                 enable=True, enableBackground=True, enableKeyboardFocus=True, exists=True,
                 fullPathName=True, height=0, highlightColor=None, isObscured=True, manage=True,
                 maxRange=None, minRange=None, noBackground=True, numberOfPopupMenus=True,
                 parent="", popupMenuArray=True, preventOverride=True, statusBarMessage="",
                 useTemplate="", visible=True, visibleChangeCommand=None, width=0,
                 widthHeight=None, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a control used for displaying and modifying the current playback range
     Note: only one master rangeControl may exist  Any addition rangeControls that a user
    creates are slaved to the master range control widget
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changedCommand: (C E) script to be executed when the range changes
    :type changedCommand: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param maxRange: (C Q E) Controls the max range displayable in the control
    :type maxRange: time
    :param minRange: (C Q E) Controls the max range displayable in the control
    :type minRange: time
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    :param widthHeight: (C E) Controls the dimensions of the control
    :type widthHeight: [int, int]
    
    :returns: Name of newly created rangeControl.
    :rtype: string
    """
    pass


def renderSetupSelect(*args, **kwargs):
    """
    
    """
    pass


def HypershadeSelectDownStream(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_modeObject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolyCreaseTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def renderManip(*args, camera=None, light=None, spotLight=None, state=True, q=True, query=True,
                e=True, edit=True, **kwargs):
    """
    This command creates manipulators for cameras or lights
    
    :param camera: (Q E) Query or edit the visiblity status of the component camera
    manipulators  The order of components are: cycling index, center of interest, pivot, clipp
    :type camera: [boolean, boolean, boolean, boolean, boolean]
    :param light: (Q E) Query or edit the visiblity status of the component light manipulators 
    The order of components are: cycling index, center of interest, and pivot
    :type light: [boolean, boolean, boolean]
    :param spotLight: (Q E) Query or edit the visiblity status of the component spot light
    manipulators  The order of components are: cycling index, center of interest, pivot, c
    :type spotLight: [boolean, boolean, boolean, boolean, boolean, boolean, boolean]
    :param state: (Q E) Query or edit the state of manipulators on an camera, ambient light,
    directional light, point light, or spot light  This flag's default value is on
    :type state: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def ToggleZoomInMode(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Birail1Options(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def cMuscleWeightDefault(*args, **kwargs):
    """
    
    """
    pass


def LoopBrushAnimation(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleFbikDetails(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeSortReverseOrder(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def containerBind(*args, allNames=True, bindingSet="", bindingSetConditions=True,
                  bindingSetList=True, force=True, preview=True, q=True, query=True, e=True,
                  edit=True, **kwargs):
    """
    This is an accessory command to the container command which is used for some automated
    binding operations on the container  A container's published interface can be bound using a
    bindingSet on the associated container template
    
    :param allNames: (C) Specifies that all published names on the container should be
    considered during the binding operation  By default only unbound published names will b
    :type allNames: boolean
    :param bindingSet: (Q) Specifies the name of the template binding set to use for the bind
    or query operation  This flag is not available in query mode  In query mode, this
    :type bindingSet: string
    :param bindingSetConditions: (Q) Used in query mode, returns a list of binding set
    condition entries from the specified template binding set  The list returned is composed of
    of all
    :type bindingSetConditions: boolean
    :param bindingSetList: (Q E) Used in query mode, returns a list of available binding sets
    that are defined on the associated container template
    :type bindingSetList: boolean
    :param force: (C) This flag is used to force certain operations to proceed that would
    normally not be performed
    :type force: boolean
    :param preview: (C) This flag will provide a preview of the results of a binding operation
    but will not actually perform it  A list of publishedName/boundName pairs are
    :type preview: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def TimeEditorExplodeGroup(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def setDrivenKeyframe(*args, attribute="", controlPoints=False, currentDriver="", driven=True,
                      driver=True, driverValue=0.0, hierarchy="", inTangentType="", insert=True,
                      insertBlend=True, outTangentType="", shape=True, value=0.0, q=True,
                      query=True, e=True, edit=True, **kwargs):
    """
    This command sets a driven keyframe  A driven keyframe is similar to a regular keyframe 
    However, while a standard keyframe always has an x-axis of time in the graph editor, for a
    drivenkeyframe the user may choose any attribute as the x-axis of the graph editor
    
    :param attribute: (C M) Attribute name to set keyframes on
    :type attribute: string
    :param controlPoints: (C) Explicitly specify whether or not to include the control points
    of a shape (see "-s" flag) in the list of attributes  Default: false
    :type controlPoints: boolean
    :param currentDriver: (C Q) Set the driver to be used for the current driven keyframe to
    the attribute passed as an argument
    :type currentDriver: string
    :param driven: (Q) Returns list of driven attributes for the selected item
    :type driven: boolean
    :param driver: (Q) Returns list of available drivers for the attribute
    :type driver: boolean
    :param driverValue: (C M) Value of the driver to use for this keyframe  Default value is
    the current value
    :type driverValue: float
    :param hierarchy: (C) Controls the objects this command acts on, relative to the specified
    (or active) target objects  Valid values are "above," "below," "both," and "none
    :type hierarchy: string
    :param inTangentType: (C) The in tangent type for keyframes set by this command  Valid
    values are: "auto", clamped", "fast", "flat", "linear", "plateau", "slow", "spline", and
    :type inTangentType: string
    :param insert: (C) Insert keys at the given time(s) and preserve the shape of the animation
    curve(s)  Note: the tangent type on inserted keys will be fixed so that the
    :type insert: boolean
    :param insertBlend: (C) If true, a pairBlend node will be inserted for channels that have
    nodes other than animCurves driving them, so that such channels can have blended an
    :type insertBlend: boolean
    :param outTangentType: (C) The out tangent type for keyframes set by this command  Valid
    values are: "auto", "clamped", "fast", "flat", "linear", "plateau", "slow", "spline", "
    :type outTangentType: string
    :param shape: (C) Consider attributes of shapes below transforms as well, except
    "controlPoints"  Default: true
    :type shape: boolean
    :param value: (C) Value to set the keyframe at  Default is the current value
    :type value: float
    
    :returns: Number of keyframes set.
    :rtype: int
    """
    pass


def geomToBBox(*args, bakeAnimation=True, combineMesh=True, endTime=None, keepOriginal=True,
               name="", nameSuffix="", sampleBy=None, shaderColor=None, single=True,
               startTime=None, **kwargs):
    """
    Create polygonal mesh bounding boxes for geometry  Can also create a single bounding box
    per hierarchy
    
    :param bakeAnimation: (C) Bake the animation  Can be used with startTime, endTime and
    sampleBy flags  If used alone, the time slider will be used to specify the startTime and
    :type bakeAnimation: boolean
    :param combineMesh: (C) Combine resulting bounding boxes  Mutually exclusive with -s/single
    option
    :type combineMesh: boolean
    :param endTime: (C) Used with bakeAnimation flag  Specifies the end time of the baking
    process
    :type endTime: time
    :param keepOriginal: (C) Do not remove the selected nodes used to create the bounding
    boxes
    :type keepOriginal: boolean
    :param name: (C) Specifies the bounding box name
    :type name: string
    :param nameSuffix: (C) Specifies the bounding box name suffix
    :type nameSuffix: string
    :param sampleBy: (C) Used with bakeAnimation flag  Specifies the animation evaluation time
    increment
    :type sampleBy: time
    :param shaderColor: (C) Set the color attribute of the Lambert material associate with the
    bounding box  The RGB values should be defined between 0 to 1.0  Default value is
    :type shaderColor: [float, float, float]
    :param single: (C) Create a single bounding box per hierarchy selected
    :type single: boolean
    :param startTime: (C) Used with bakeAnimation flag  Specifies the start time of the baking
    process
    :type startTime: time
    
    :returns: 
    :rtype: None
    """
    pass


def createPolyHelixCtx(*args, **kwargs):
    """
    
    """
    pass


def getRenderTasks(*args, camera="", renderLayer="", **kwargs):
    """
    Command to return render tasks to render an image source  Image source can depend on
    upstream image sources that result from renderings of 3D scene, or 2D renderings (e.g 
    render targets)  This command obtains the graph of image source render dependencies, and
    creates render tasks according to these dependencies  A render task has context, which ca
    
    :param camera: (C) Camera node to use in the render context for the image source render
    task
    :type camera: string
    :param renderLayer: (C) Render layer to use in the render context for the image source
    render task
    :type renderLayer: string
    
    :returns: Render tasks (one per string) for argument render target.
    :rtype: string[]
    """
    pass


def polyCrease(*args, createHistory=True, operation=0, relativeValue=0.0, value=0.0,
               vertexValue=0.0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Command to set the crease values on the edges or vertices of a poly  The crease values are
    used by the smoothing algorithm
    
    :param createHistory: (C Q E) For objects that have no construction history, this flag can
    be used to force the creation of construction history for creasing  By default, history
    :type createHistory: boolean
    :param operation: (C Q E) Operation to perform  Valid values are: 0: Crease the specified
    components  1: Remove the crease values for the specified components  2: Remove all c
    :type operation: int
    :param relativeValue: (C Q E) Specifies a new relative value for all selected vertex and
    edge components  This flag can not be used at the same time as either the value or vertexV
    :type relativeValue: float
    :param value: (C Q E M) Specifies the crease value for the selected edge components  When
    specified multiple times, the values are assigned respectively to the specified edg
    :type value: float
    :param vertexValue: (C Q E M) Specifies the crease value for the selected vertex components
     When specified multiple times, the values are assigned respectively to the specified v
    :type vertexValue: float
    
    :returns: Success or Failure.
    :rtype: boolean
    """
    pass


def FBXExportQuaternion(*args, **kwargs):
    """
    
    """
    pass


def CleanupPolygon(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def EditFluidResolutionOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportIncludeChildren(*args, **kwargs):
    """
    
    """
    pass


def scriptCtx(*args, allComponents=True, allObjects=True, animBreakdown=True, animCurve=True,
              animInTangent=True, animKeyframe=True, animOutTangent=True,
              baseClassName="scriptTool", camera=True, cluster=True, collisionModel=True,
              controlVertex=True, cumulativeLists=True, curve=True, curveKnot=True,
              curveOnSurface=True, curveParameterPoint=True, dimension=True,
              dynamicConstraint=True, edge=True, editPoint=True, emitter=True,
              enableRootSelection=False, escToQuit=False, exists=True, exitUponCompletion=True,
              expandSelectionList=True, facet=True, field=True, finalCommandScript=None,
              fluid=True, follicle=True, forceAddSelect=False, hairSystem=True, handle=True,
              history=True, hull=True, ignoreInvalidItems=True, ikEndEffector=True,
              ikHandle=True, image1="", image2="", image3="", imagePlane=True,
              implicitGeometry=True, isoparm=True, joint=True, jointPivot=True,
              lastAutoComplete=True, lattice=True, latticePoint=True, light=True,
              localRotationAxis=True, locator=True, locatorUV=True, locatorXYZ=True,
              nCloth=True, nParticle=True, nParticleShape=True, nRigid=True, name="",
              nonlinear=True, nurbsCurve=True, nurbsSurface=True, objectComponent=True,
              orientationLocator=True, particle=True, particleShape=True, plane=True,
              polymesh=True, polymeshEdge=True, polymeshFace=True, polymeshFreeEdge=True,
              polymeshUV=True, polymeshVertex=True, polymeshVtxFace=True, rigidBody=True,
              rigidConstraint=True, rotatePivot=True, scalePivot=True, sculpt=True,
              selectHandle=True, setAllowExcessCount=True, setAutoComplete=True,
              setAutoToggleSelection=True, setDoneSelectionPrompt="", setNoSelectionHeadsUp="",
              setNoSelectionPrompt="", setSelectionCount=0, setSelectionHeadsUp="",
              setSelectionPrompt="", showManipulators=True, spring=True, springComponent=True,
              stroke=True, subdiv=True, subdivMeshEdge=True, subdivMeshFace=True,
              subdivMeshPoint=True, subdivMeshUV=True, surfaceEdge=True, surfaceFace=True,
              surfaceKnot=True, surfaceParameterPoint=True, surfaceRange=True, surfaceUV=True,
              texture=True, title="", toolCursorType="", toolFinish=None, toolStart=None,
              totalSelectionSets=0, vertex=True, q=True, query=True, e=True, edit=True,
              **kwargs):
    """
    This command allows a user to create their own tools based on the selection tool  A number
    of selection lists can be collected, the behaviour of the selection and the selection masks
    are fully customizable, etc   The command is processed prior to being executed  The keyword
    "$Selection#" where # is a number 1 or greater specifies a selection set  T
    
    :param allComponents: (C Q M) Set all component selection masks on/off
    :type allComponents: boolean
    :param allObjects: (C Q M) Set all object selection masks on/off
    :type allObjects: boolean
    :param animBreakdown: (C Q M) Set animation breakdown selection mask on/off
    :type animBreakdown: boolean
    :param animCurve: (C Q M) Set animation curve selection mask on/off
    :type animCurve: boolean
    :param animInTangent: (C Q M) Set animation in-tangent selection mask on/off
    :type animInTangent: boolean
    :param animKeyframe: (C Q M) Set animation keyframe selection mask on/off
    :type animKeyframe: boolean
    :param animOutTangent: (C Q M) Set animation out-tangent selection mask on/off
    :type animOutTangent: boolean
    :param baseClassName: (C Q E) This string will be used to produce MEL function names for
    the property sheets for the tool  For example, if "myScriptTool" was given, the functions
    :type baseClassName: string
    :param camera: (C Q M) Set camera selection mask on/off  (object flag)
    :type camera: boolean
    :param cluster: (C Q M) Set cluster selection mask on/off  (object flag)
    :type cluster: boolean
    :param collisionModel: (C Q M) Set collision model selection mask on/off  (object flag)
    :type collisionModel: boolean
    :param controlVertex: (C Q M) Set control vertex selection mask on/off  (component flag)
    :type controlVertex: boolean
    :param cumulativeLists: (C Q E) If set, the selection lists will be cumulative  For example,
    the second list will contain all the items from the first list, the third all the items
    :type cumulativeLists: boolean
    :param curve: (C Q M) Set curve selection mask on/off  (object flag)
    :type curve: boolean
    :param curveKnot: (C Q M) Set curve knot selection mask on/off  (component flag)
    :type curveKnot: boolean
    :param curveOnSurface: (C Q M) Set curve-on-surface selection mask on/off  (object flag)
    :type curveOnSurface: boolean
    :param curveParameterPoint: (C Q M) Set curve parameter point selection mask on/off 
    (component flag)
    :type curveParameterPoint: boolean
    :param dimension: (C Q M) Set dimension shape selection mask on/off  (object flag)
    :type dimension: boolean
    :param dynamicConstraint: (C Q M) Set dynamicConstraint selection mask on/off  (object
    flag)
    :type dynamicConstraint: boolean
    :param edge: (C Q M) Set mesh edge selection mask on/off  (component flag)
    :type edge: boolean
    :param editPoint: (C Q M) Set edit-point selection mask on/off  (component flag)
    :type editPoint: boolean
    :param emitter: (C Q M) Set emitter selection mask on/off  (object flag)
    :type emitter: boolean
    :param enableRootSelection: (C Q E) If set, the items to be selected are at their root
    transform level  Default is false
    :type enableRootSelection: boolean
    :param escToQuit: (C Q E) If set to true, exit the tool when press "Esc"  Default is false
    :type escToQuit: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param exitUponCompletion: (C Q E) If set, completing the last selection set will exit the
    tool  Default is true
    :type exitUponCompletion: boolean
    :param expandSelectionList: (C Q E) If set, the selection lists will expand to have a
    single component in each item  You probably want this as a default, otherwise two isoparms
    on the s
    :type expandSelectionList: boolean
    :param facet: (C Q M) Set mesh face selection mask on/off  (component flag)
    :type facet: boolean
    :param field: (C Q M) Set field selection mask on/off  (object flag)
    :type field: boolean
    :param finalCommandScript: (C Q E) Supply the script that will be run when the user presses
    the enter key and the context is completed  Depending on the number of selection sets you
    ha
    :type finalCommandScript: script
    :param fluid: (C Q M) Set fluid selection mask on/off  (object flag)
    :type fluid: boolean
    :param follicle: (C Q M) Set follicle selection mask on/off  (object flag)
    :type follicle: boolean
    :param forceAddSelect: (C Q E) If set to true, together with -setAutoToggleSelection (see
    below) on the first selection set, causes the first selection after the computation of the
    :type forceAddSelect: boolean
    :param hairSystem: (C Q M) Set hairSystem selection mask on/off  (object flag)
    :type hairSystem: boolean
    :param handle: (C Q M) Set object handle selection mask on/off  (object flag)
    :type handle: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param hull: (C Q M) Set hull selection mask on/off  (component flag)
    :type hull: boolean
    :param ignoreInvalidItems: (C Q E) If you have multiple selection sets, the state of the
    selection set is recorded at the time you "complete it"  You could then delete some of the
    item
    :type ignoreInvalidItems: boolean
    :param ikEndEffector: (C Q M) Set ik end effector selection mask on/off  (object flag)
    :type ikEndEffector: boolean
    :param ikHandle: (C Q M) Set ik handle selection mask on/off  (object flag)
    :type ikHandle: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param imagePlane: (C Q M) Set image plane selection mask on/off  (component flag)
    :type imagePlane: boolean
    :param implicitGeometry: (C Q M) Set implicit geometry selection mask on/off  (object
    flag)
    :type implicitGeometry: boolean
    :param isoparm: (C Q M) Set surface iso-parm selection mask on/off  (component flag)
    :type isoparm: boolean
    :param joint: (C Q M) Set ik handle selection mask on/off  (object flag)
    :type joint: boolean
    :param jointPivot: (C Q M) Set joint pivot selection mask on/off  (component flag)
    :type jointPivot: boolean
    :param lastAutoComplete: (C Q E) True if auto complete is set for the last selection set,
    false otherwise  Mostly used for query, but if present in conjuction with
    -sac/setAutoComple
    :type lastAutoComplete: boolean
    :param lattice: (C Q M) Set lattice selection mask on/off  (object flag)
    :type lattice: boolean
    :param latticePoint: (C Q M) Set lattice point selection mask on/off  (component flag)
    :type latticePoint: boolean
    :param light: (C Q M) Set light selection mask on/off  (object flag)
    :type light: boolean
    :param localRotationAxis: (C Q M) Set local rotation axis selection mask on/off  (component
    flag)
    :type localRotationAxis: boolean
    :param locator: (C Q M) Set locator (all types) selection mask on/off  (object flag)
    :type locator: boolean
    :param locatorUV: (C Q M) Set uv locator selection mask on/off  (object flag)
    :type locatorUV: boolean
    :param locatorXYZ: (C Q M) Set xyz locator selection mask on/off  (object flag)
    :type locatorXYZ: boolean
    :param nCloth: (C Q M) Set nCloth selection mask on/off  (object flag)
    :type nCloth: boolean
    :param nParticle: (C Q M) Set nParticle point selection mask on/off  (component flag)
    :type nParticle: boolean
    :param nParticleShape: (C Q M) Set nParticle shape selection mask on/off  (object flag)
    :type nParticleShape: boolean
    :param nRigid: (C Q M) Set nRigid selection mask on/off  (object flag)
    :type nRigid: boolean
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param nonlinear: (C Q M) Set nonlinear selection mask on/off  (object flag)
    :type nonlinear: boolean
    :param nurbsCurve: (C Q M) Set nurbs-curve selection mask on/off  (object flag)
    :type nurbsCurve: boolean
    :param nurbsSurface: (C Q M) Set nurbs-surface selection mask on/off  (object flag)
    :type nurbsSurface: boolean
    :param objectComponent: (C Q) Component flags apply to object mode
    :type objectComponent: boolean
    :param orientationLocator: (C Q M) Set orientation locator selection mask on/off  (object
    flag)
    :type orientationLocator: boolean
    :param particle: (C Q M) Set particle point selection mask on/off  (component flag)
    :type particle: boolean
    :param particleShape: (C Q M) Set particle shape selection mask on/off  (object flag)
    :type particleShape: boolean
    :param plane: (C Q M) Set sketch plane selection mask on/off  (object flag)
    :type plane: boolean
    :param polymesh: (C Q M) Set poly-mesh selection mask on/off  (object flag)
    :type polymesh: boolean
    :param polymeshEdge: (C Q M) Set poly-mesh edge selection mask on/off  (component flag)
    :type polymeshEdge: boolean
    :param polymeshFace: (C Q M) Set poly-mesh face selection mask on/off  (component flag)
    :type polymeshFace: boolean
    :param polymeshFreeEdge: (C Q M) Set poly-mesh free-edge selection mask on/off  (component
    flag)
    :type polymeshFreeEdge: boolean
    :param polymeshUV: (C Q M) Set poly-mesh UV point selection mask on/off  (component flag)
    :type polymeshUV: boolean
    :param polymeshVertex: (C Q M) Set poly-mesh vertex selection mask on/off  (component
    flag)
    :type polymeshVertex: boolean
    :param polymeshVtxFace: (C Q M) Set poly-mesh vertexFace selection mask on/off  (component
    flag)
    :type polymeshVtxFace: boolean
    :param rigidBody: (C Q M) Set rigid body selection mask on/off  (object flag)
    :type rigidBody: boolean
    :param rigidConstraint: (C Q M) Set rigid constraint selection mask on/off  (object flag)
    :type rigidConstraint: boolean
    :param rotatePivot: (C Q M) Set rotate pivot selection mask on/off  (component flag)
    :type rotatePivot: boolean
    :param scalePivot: (C Q M) Set scale pivot selection mask on/off  (component flag)
    :type scalePivot: boolean
    :param sculpt: (C Q M) Set sculpt selection mask on/off  (object flag)
    :type sculpt: boolean
    :param selectHandle: (C Q M) Set select handle selection mask on/off  (component flag)
    :type selectHandle: boolean
    :param setAllowExcessCount: (C E M) If set, the number if items is to be interpreted as the
    minimum
    :type setAllowExcessCount: boolean
    :param setAutoComplete: (C E M) If set to true, as soon as the specified number of items is
    selected the tool will start the next selection set or run the command
    :type setAutoComplete: boolean
    :param setAutoToggleSelection: (C E M) If set to true, it is as if "shift" key is pressed
    when there are no modifiers pressed  That means that you get the "toggle select" behaviour
    by defa
    :type setAutoToggleSelection: boolean
    :param setDoneSelectionPrompt: (C E M) If setAutoComplete is not set (see below) this
    string will be shown as soon as the tool has enough items for a particular selection set 
    If this is n
    :type setDoneSelectionPrompt: string
    :param setNoSelectionHeadsUp: (C E M) Supply a string that will be shown as a heads up
    prompt when there is nothing selected  This must be set separately for each selection set
    :type setNoSelectionHeadsUp: string
    :param setNoSelectionPrompt: (C E M) Supply a string that will be shown as help when there
    is nothing selected  This must be set separately for each selection set
    :type setNoSelectionPrompt: string
    :param setSelectionCount: (C E M) The number of items in this selection set  0 means as
    many as you need until completion
    :type setSelectionCount: int
    :param setSelectionHeadsUp: (C E M) Supply a string that will be shown as a heads up prompt
    when there is something selected  This must be set separately for each selection set
    :type setSelectionHeadsUp: string
    :param setSelectionPrompt: (C E M) Supply a string that will be shown as help when there is
    something selected  This must be set separately for each selection set
    :type setSelectionPrompt: string
    :param showManipulators: (C Q E) If set, the manipulators will be shown for any active
    objects  Basically, it is as if you are in the Show Manipulator tool
    :type showManipulators: boolean
    :param spring: (C Q M) Set spring shape selection mask on/off  (object flag)
    :type spring: boolean
    :param springComponent: (C Q M) Set individual spring selection mask on/off  (component
    flag)
    :type springComponent: boolean
    :param stroke: (C Q M) Set the Paint Effects stroke selection mask on/off  (object flag)
    :type stroke: boolean
    :param subdiv: (C Q M) Set subdivision surfaces selection mask on/off  (object flag)
    :type subdiv: boolean
    :param subdivMeshEdge: (C Q M) Set subdivision surfaces mesh edge selection mask on/off 
    (component flag)
    :type subdivMeshEdge: boolean
    :param subdivMeshFace: (C Q M) Set subdivision surfaces mesh face selection mask on/off 
    (component flag)
    :type subdivMeshFace: boolean
    :param subdivMeshPoint: (C Q M) Set subdivision surfaces mesh point selection mask on/off 
    (component flag)
    :type subdivMeshPoint: boolean
    :param subdivMeshUV: (C Q M) Set subdivision surfaces mesh UV map selection mask on/off 
    (component flag)
    :type subdivMeshUV: boolean
    :param surfaceEdge: (C Q M) Set surface edge selection mask on/off  (component flag)
    :type surfaceEdge: boolean
    :param surfaceFace: (C Q M) Set surface face selection mask on/off  (component flag)
    :type surfaceFace: boolean
    :param surfaceKnot: (C Q M) Set surface knot selection mask on/off  (component flag)
    :type surfaceKnot: boolean
    :param surfaceParameterPoint: (C Q M) Set surface parameter point selection mask on/off 
    (component flag)
    :type surfaceParameterPoint: boolean
    :param surfaceRange: (C Q M) Set surface range selection mask on/off  (component flag)
    :type surfaceRange: boolean
    :param surfaceUV: (C Q M) Set surface uv selection mask on/off  (component flag)
    :type surfaceUV: boolean
    :param texture: (C Q M) Set texture selection mask on/off  (object flag)
    :type texture: boolean
    :param title: (C Q E) Supply a string that will be used as a precursor to all the messages;
    i.e., the "name" of the tool
    :type title: string
    :param toolCursorType: (C Q E) Supply the string identifier to set the tool cursor type
    when inside of tool  The following are the valid ids: "create", "dolly", "edit", "pencil",
    "
    :type toolCursorType: string
    :param toolFinish: (C Q E) Supply the script that will be run when the user exits the
    script
    :type toolFinish: script
    :param toolStart: (C Q E) Supply the script that will be run when the user first enters the
    script
    :type toolStart: script
    :param totalSelectionSets: (C Q E) Total number of selection sets
    :type totalSelectionSets: int
    :param vertex: (C Q M) Set mesh vertex selection mask on/off  (component flag)
    :type vertex: boolean
    
    :returns: Context name
    :rtype: string
    """
    pass


def surfaceSampler(*args, camera=None, fileFormat="", filename="", filterSize=0.0, filterType=0,
                   flipU=True, flipV=True, ignoreMirroredFaces=True, ignoreTransforms=True,
                   mapHeight=0, mapMaterials=True, mapOutput="", mapSpace="", mapWidth=0,
                   maxSearchDistance=0.0, maximumValue=0.0, overscan=0, searchCage="",
                   searchMethod=0, searchOffset=0.0, shadows=True, source="", sourceUVSpace="",
                   superSampling=0, target="", targetUVSpace="", useGeometryNormals=True,
                   uvSet="", **kwargs):
    """
    Maps surface detail from a source surface to a new texture map on a target surface  Both
    objects must be selected when the command is invoked, with the source surface selected
    first, and the target last
    
    :param camera: (C) Specify the camera to use for camera specific lighting calculations such
    as specular highlights or reflections
    :type camera: name
    :param fileFormat: (C M) The image format as a file extension (e.g  "dds")  This must be
    included once for every output map specified
    :type fileFormat: string
    :param filename: (C M) The filename to use when creating the map  This must be included
    once for every output map specified
    :type filename: string
    :param filterSize: (C) The filter size to use in pixels  Larger values (e.g  over 2.0) will
    produce smoother/softer results, while values closer to 1.0 will produce sharper
    :type filterSize: float
    :param filterType: (C) The filter type to use  0 is a Guassian filter, 1 is a triangular
    filter, 2 is a box filter
    :type filterType: int
    :param flipU: (C) Flip the U coordinate of the generated image
    :type flipU: boolean
    :param flipV: (C) Flip the V coordinate of the generated image
    :type flipV: boolean
    :param ignoreMirroredFaces: (C) Stops reverse wound (i.e  mirrored) faces from contributing
    to the map generation
    :type ignoreMirroredFaces: boolean
    :param ignoreTransforms: (C) Controls whether transforms are used (meaning the search is
    performed in worldspace), or not (meaning the search is performed in object space)
    :type ignoreTransforms: boolean
    :param mapHeight: (C M) Pixel width of the generated map  This must be included once for
    every output map specified
    :type mapHeight: int
    :param mapMaterials: (C M) Where appropriate (e.g  normal maps), this controls whether the
    material should be included when sampling the map attribute  This must be included on
    :type mapMaterials: boolean
    :param mapOutput: (C M) Specifies a new output map to create  One of "normal",
    "displacement" "diffuseRGB", "litAndShadedRGB", or "alpha"
    :type mapOutput: string
    :param mapSpace: (C M) The space to generate the map in  Valid keyword is "object"  Default
    is tangent space  This must be included once for every output map specified
    :type mapSpace: string
    :param mapWidth: (C M) Pixel width of the generated map  Some output image formats require
    even or power of 2  This must be included once for every output map specified
    :type mapWidth: int
    :param maxSearchDistance: (C M) Controls the maximum distance away from a target surface
    that will be searched for source surfaces  A value of 0 indicates no limit  When generated
    m
    :type maxSearchDistance: float
    :param maximumValue: (C M) The maximum value to include in the map  This allows control of
    how floating point values (like displacement) are quantised into integer image format
    :type maximumValue: float
    :param overscan: (C) The number of additional pixels to render around UV borders  This will
    help to minimise texel filtering artifacts on UV seams  When mipmaps are going
    :type overscan: int
    :param searchCage: (C M) Specifies a search envelope surface to use as a search guide when
    looking for source surfaces  If this flag is included, it must be included once for
    :type searchCage: string
    :param searchMethod: (C) Controls the search method used to match sample points on a target
    surface to points on the sources  0 is closest to envelope, 1 is prefer any inters
    :type searchMethod: int
    :param searchOffset: (C M) Specifies a fixed offset from a target surface to use as the
    starting point when looking for source surfaces  This value is only used when no search
    :type searchOffset: float
    :param shadows: (C M) Where appropriate (e.g  lit and shaded), this controls whether
    shadows are included in the calculation  Currently only depth map shadows are supporte
    :type shadows: boolean
    :param source: (C M) Specifies a surface to use as a sampling source
    :type source: string
    :param sourceUVSpace: (C M) Specifies that the transfer of data between the surfaces should
    be done in UV space and specifies the name of the UV set on the source surface(s) tha
    :type sourceUVSpace: string
    :param superSampling: (C) Controls the number of sampling points calculated for each output
    value  The algorithm will use 2 ^ n squared samples for each point (so a value of 0
    :type superSampling: int
    :param target: (C M) Specified a surface to sample output information for
    :type target: string
    :param targetUVSpace: (C M) Specifies that the transfer of data between the surfaces should
    be done in UV space and specifies the name of the UV set on the target surface(s) tha
    :type targetUVSpace: string
    :param useGeometryNormals: (C) Controls whether geometry or surface normals are used for
    surface searching  Using geometry normals will ensure a smooth mapping but can introduce
    di
    :type useGeometryNormals: boolean
    :param uvSet: (C M) The name of the UV set to use when creating output maps  If this flag
    is included, it must be included once for every target
    :type uvSet: string
    
    :returns: 
    :rtype: None
    """
    pass


def PolygonBooleanDifferenceOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideControllers(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dynControl(*args, **kwargs):
    """
    
    """
    pass


def nexMultiCutCtx(*args, **kwargs):
    """
    
    """
    pass


def date(*args, date=True, format="", shortDate=True, shortTime=True, time=True, **kwargs):
    """
    Returns information about current time and date  Use the predefined formats, or the -format
    flag to specify the output format
    
    :param date: (C) Returns the current date  Format is YYYY/MM/DD
    :type date: boolean
    :param format: (C) Current second, with leading 0 if necessary
    :type format: string
    :param shortDate: (C) Returns the current date  Format is MM/DD
    :type shortDate: boolean
    :param shortTime: (C) Returns the current time  Format is hh:mm
    :type shortTime: boolean
    :param time: (C) Returns the current time  Format is hh:mm:ss
    :type time: boolean
    
    :returns: Command result
    :rtype: string
    """
    pass


def AddOceanDynamicLocator(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GraphSnapOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def goal(*args, goal="", index=True, useTransformAsGoal=True, weight=0.0, q=True, query=True,
         **kwargs):
    """
    Specifies the given objects as being goals for the given particle object  If the goal
    objects are geometry, each particle in the particle object will each try to follow or match
    its position to that of a certain vertex/CV/lattice point of the goal  If the goal object
    is another particle object, each particle will try to follow a paricle of the goal
    
    :param goal: (C Q M) This flag specifies string to be a goal of the particle object on the
    command line or the currently selected particle object  This flag can be used m
    :type goal: string
    :param index: (Q) Returns array of multi-attribute indices for the goals  Intended for use
    by the Attribute Editor
    :type index: boolean
    :param useTransformAsGoal: (C) Use transform of specified object instead of the shape 
    Meaningful only for particle and geometry objects  Can only be passed once, applies to all
    ob
    :type useTransformAsGoal: boolean
    :param weight: (C) This specifies the goal weight as a value from 0 to 1  A value of 0
    means that the goal's position will have no effect on the particle object, while
    :type weight: float
    
    :returns: Command result
    :rtype: string
    """
    pass


def displacementToPoly(*args, findBboxOnly=True, q=True, query=True, e=True, edit=True,
                       **kwargs):
    """
    Command bakes geometry with displacement mapping into a polygonal object
    
    :param findBboxOnly: (C Q E) When used, only the bounding box scale for the displaced
    object is found
    :type findBboxOnly: boolean
    
    :returns: Success or Failure.
    :rtype: boolean
    """
    pass


def SelectToolOptionsMarkingMenuPopDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorPaste(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ConvertSelectionToUVs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SingleViewArrangement(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleGrid(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AssumePreferredAngleOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def squareSurface(*args, caching=True, continuityType1=2, continuityType2=2, continuityType3=2,
                  continuityType4=2, curveFitCheckpoints=5, endPointTolerance=0.1, nodeState=0,
                  rebuildCurve1=False, rebuildCurve2=False, rebuildCurve3=False,
                  rebuildCurve4=False, constructionHistory=True, name="", object=True,
                  polygon=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command produces a square surface given 3 or 4 curves  This resulting square surface
    is created within the intersecting region of the selected curves  The order of selection is
    important and the curves must intersect or their ends must meet.
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param continuityType1: (C Q E) Continuity type legal values for curve 1: 1 - fixed
    boundary 2 - tangent continuity 3 - implied tangent continuity Default: 2
    :type continuityType1: int
    :param continuityType2: (C Q E) Continuity type legal values for curve 2: 1 - fixed
    boundary 2 - tangent continuity 3 - implied tangent continuity Default: 2
    :type continuityType2: int
    :param continuityType3: (C Q E) Continuity type legal values for curve 3: 1 - fixed
    boundary 2 - tangent continuity 3 - implied tangent continuity Default: 2
    :type continuityType3: int
    :param continuityType4: (C Q E) Continuity type legal values for curve 4: 1 - fixed
    boundary 2 - tangent continuity 3 - implied tangent continuity Default: 2
    :type continuityType4: int
    :param curveFitCheckpoints: (C Q E) The number of points per span to check the tangency
    deviation between the boundary curve and the created tangent square surface  Only available
    for t
    :type curveFitCheckpoints: int
    :param endPointTolerance: (C Q E) Tolerance for end points, only used if endPoint attribute
    is true  Default: 0.1
    :type endPointTolerance: float
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param rebuildCurve1: (C Q E) A boolean to determine if input curve 1 should be rebuilt
    (with curvature continuity)  Default: false
    :type rebuildCurve1: boolean
    :param rebuildCurve2: (C Q E) A boolean to determine if input curve 2 should be rebuilt
    (with curvature continuity)  Default: false
    :type rebuildCurve2: boolean
    :param rebuildCurve3: (C Q E) A boolean to determine if input curve 3 should be rebuilt
    (with curvature continuity)  Default: false
    :type rebuildCurve3: boolean
    :param rebuildCurve4: (C Q E) A boolean to determine if input curve 4 should be rebuilt
    (with curvature continuity)  Default: false
    :type rebuildCurve4: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param polygon: (C) The value of this argument controls the type of the object created by
    this operation 0: nurbs surface 1: polygon (use nurbsToPolygonsPref to set the
    :type polygon: int
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def texSelectShortestPathCtx(*args, exists=True, image1="", image2="", image3="", q=True,
                             query=True, e=True, edit=True, **kwargs):
    """
    Creates a new context to select shortest edge path between two vertices or UVs in the
    texture editor window
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    
    :returns: 
    :rtype: None
    """
    pass


def FBXImportUpAxis(*args, **kwargs):
    """
    
    """
    pass


def XgmSplineCacheDeleteNodesAhead(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeShowDirectoriesAndFiles(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PickWalkRight(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateCameraOnlyOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeUnpinSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def subdMapSewMove(*args, caching=True, nodeState=0, constructionHistory=True,
                   limitPieceSize=True, name="", numberFaces=0, worldSpace=True, q=True,
                   query=True, e=True, edit=True, **kwargs):
    """
    This command can be used to Move and Sew together separate UV pieces along geometric edges 
    UV pieces that correspond to the same geometric edge, are merged together by moving the
    smaller piece to the larger one   The argument is a UV selection list
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param limitPieceSize: (C Q E) When on, this flag specifies that the face number limit
    described above should be used
    :type limitPieceSize: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param numberFaces: (C Q E) Maximum number of faces in a UV piece  When trying to combine
    two UV pieces into a single one, the merge operation is rejected if the smaller piece h
    :type numberFaces: int
    :param worldSpace: (C Q E) If true, performs the operation in world space coordinates as
    opposed to local space
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def ToggleUnsharedUVs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def hyperPanel(*args, control=True, copy="", createString=True, defineTemplate="", docTag="",
               editString=True, exists=True, hyperEditor=True, init=True, isUnique=True,
               label="", menuBarRepeatLast=True, menuBarVisible=True, needsInit=True, parent="",
               popupMenuProcedure=None, replacePanel="", tearOff=True, tearOffCopy="",
               tearOffRestore=True, unParent=True, useTemplate="", q=True, query=True, e=True,
               edit=True, **kwargs):
    """
    This command creates, edit and queries hypergraph panels which contain only a hypergraph
    editor
    
    :param control: (Q) Returns the top level control for this panel  Usually used for getting
    a parent to attach popup menus  CAUTION: panels may not have controls at times
    :type control: boolean
    :param copy: (E) Makes this panel a copy of the specified panel  Both panels must be of the
    same type
    :type copy: string
    :param createString: (E) Command string used to create a panel
    :type createString: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Attaches a tag to the Maya panel
    :type docTag: string
    :param editString: (E) Command string used to edit a panel
    :type editString: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param hyperEditor: (Q) This flag returns the name of the hypergraph editor contained by
    the panel
    :type hyperEditor: boolean
    :param init: (C E) Initializes the panel's default state  This is usually done
    automatically on file -new and file -open
    :type init: boolean
    :param isUnique: (Q) Returns true if only one instance of this panel type is allowed
    :type isUnique: boolean
    :param label: (Q E) Specifies the user readable label for the panel
    :type label: string
    :param menuBarRepeatLast: (C Q E) Controls whether clicking on the menu header with the
    middle mouse button would repeat the last selected menu item
    :type menuBarRepeatLast: boolean
    :param menuBarVisible: (C Q E) Controls whether the menu bar for the panel is displayed
    :type menuBarVisible: boolean
    :param needsInit: (Q E) (Internal) On Edit will mark the panel as requiring initialization 
    Query will return whether the panel is marked for initialization  Used during fil
    :type needsInit: boolean
    :param parent: (C) Specifies the parent layout for this panel
    :type parent: string
    :param popupMenuProcedure: (Q E) Specifies the procedure called for building the panel's
    popup menu(s)  The default value is "buildPanelPopupMenu"  The procedure should take one
    stri
    :type popupMenuProcedure: script
    :param replacePanel: (E) Will replace the specified panel with this panel  If the target
    panel is within the same layout it will perform a swap
    :type replacePanel: string
    :param tearOff: (Q E) Will tear off this panel into a separate window with a paneLayout as
    the parent of the panel  When queried this flag will return if the panel has bee
    :type tearOff: boolean
    :param tearOffCopy: (C) Will create this panel as a torn of copy of the specified source
    panel
    :type tearOffCopy: string
    :param tearOffRestore: (C E) Restores panel if it is torn off and focus is given to it  If
    docked, becomes the active panel in the docked window  This should be the default flag
    :type tearOffRestore: boolean
    :param unParent: (E) Specifies that the panel should be removed from its layout  This
    (obviously) cannot be used with query
    :type unParent: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: The name of the panel
    :rtype: string
    """
    pass


def xgmSplineQuery(*args, **kwargs):
    """
    
    """
    pass


def HideMarkers(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def WhatsNewHighlightingOff(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def EnableConstraints(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PerspRelationshipEditorLayout(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_softSelDistanceTypeGlobal(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dynamicConstraintRemove(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeCreateAsset(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeSelectCamerasAndImagePlanes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CutUVs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AimConstraint(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteAllConstraints(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorUnmuteSelectedTracks(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PublishChildAnchorOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def commandEcho(*args, addFilter=None, filter=None, lineNumbers=True, state=True, q=True,
                query=True, **kwargs):
    """
    This command controls what is echoed to the command window
    
    :param addFilter: (C) This flag allows you to append filters to the current list of
    filtered commands when echo all commands is enabled  Just like the filter flag, you can
    :type addFilter: string[]
    :param filter: (C Q) This flag allows you to filter out unwanted commands when echo all
    commands is enabled  You can provide a partial command name, so all commands that
    :type filter: string[]
    :param lineNumbers: (C Q) If true then file name and line number information is provided in
    error and warning messages  If false then no file name and line number information
    :type lineNumbers: boolean
    :param state: (C Q) If true then all commands are echoed to the command window  If false
    then only relevant commands are echoed
    :type state: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def UVContourStretchProjectionOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowStrokes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ArtPaintSelectTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteExpressions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def projectCurve(*args, caching=True, direction=None, directionX=0.0, directionY=0.0,
                 directionZ=1.0, nodeState=0, tolerance=0.01, useNormal=False,
                 constructionHistory=True, name="", object=True, range=True, q=True, query=True,
                 e=True, edit=True, **kwargs):
    """
    The projectCurve command creates curves on surface where all selected curves project onto
    the selected surfaces  Projection can be done using the surface normals or the user can
    specify the vector to project along  Note: the user does not have to specify the curves and
    surfaces in any particular order in the command line
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param direction: (C Q E) Direction of projection  Available only if useNormal is false
    :type direction: [float, float, float]
    :param directionX: (C Q E) X direction of projection  Default: 0.0
    :type directionX: float
    :param directionY: (C Q E) Y direction of projection  Default: 0.0
    :type directionY: float
    :param directionZ: (C Q E) Z direction of projection  Default: 1.0
    :type directionZ: float
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param tolerance: (C Q E) Tolerance to fit to  Default: 0.01
    :type tolerance: float
    :param useNormal: (C Q E) True if the surface normal is to be used and false if the
    direction vector should be used instead  Default: false
    :type useNormal: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param range: (C) Force a curve range on complete input curve
    :type range: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def ToggleCreaseEdges(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateTextureDeformerOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def group(*args, absolute=True, empty=True, name="", parent="", relative=True, useAsGroup="",
          world=True, **kwargs):
    """
    This command groups the specified objects under a new group and returns the name of the new
    group   If the -em flag is specified, then an empty group (with no objects) is created   If
    the -w flag is specified then the new group is placed under the world, otherwise if -p is
    specified it is placed under the specified node  If neither -w or -p is spec
    
    :param absolute: (C) preserve existing world object transformations (overall object
    transformation is preserved by modifying the objects local transformation) [default]
    :type absolute: boolean
    :param empty: (C) create an empty group (with no objects in it)
    :type empty: boolean
    :param name: (C) Assign given name to new group node
    :type name: string
    :param parent: (C) put the new group under the given parent
    :type parent: string
    :param relative: (C) preserve existing local object transformations (relative to the new
    group node)
    :type relative: boolean
    :param useAsGroup: (C) Use the specified node as the group node  The specified node must be
    derived from the transform node and must not have any existing parents or childr
    :type useAsGroup: string
    :param world: (C) put the new group under the world
    :type world: boolean
    
    :returns: - name of the group node
    :rtype: string
    """
    pass


def dR_snapToBackfacesTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SubdivSmoothnessHull(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorFrameCenterView(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ConnectToTime(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MakeCollideOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DynamicRelationshipEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExtrudeVertex(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PaintEffectsToCurveOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def arnoldRender(*args, **kwargs):
    """
    
    """
    pass


def Birail2Options(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AnimationSweepOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExportAnimOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AutobindContainerOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UpdateBindingSet(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowBaseWire(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nucleusDisplayNComponentNodes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportLights(*args, **kwargs):
    """
    
    """
    pass


def SelectPointsMask(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def LastActionTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddOceanDynamicLocatorOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def referenceEdit(*args, applyFailedEdits=True, changeEditTarget=None, failedEdits=True,
                  removeEdits=True, successfulEdits=True, editCommand="", onReferenceNode="",
                  **kwargs):
    """
    Use this command to remove and change the modifications which have been applied to
    references  A valid commandTarget is either a reference node, a reference file, a node in a
    reference, or a plug from a reference  Only modifications that have been made from the
    currently open scene can be changed or removed  The 'referenceQuery -topReference' comma
    
    :param applyFailedEdits: (C) Attempts to apply any unapplied edits  This flag is useful if
    previously failing edits have been fixed using the -changeEditTarget flag  This flag ca
    :type applyFailedEdits: boolean
    :param changeEditTarget: (C) Used to change a target of the specified edits  This flag
    takes two parameters: the old target of the edits, and the new target to change it to  The
    :type changeEditTarget: [string, string]
    :param failedEdits: (C) This is a secondary flag used to indicate whether or not failed
    edits should be acted on (e.g  queried, removed, etc...)  A failed edit is an edit wh
    :type failedEdits: boolean
    :param removeEdits: (C) Remove edits which affect the specified unloaded commandTarget
    :type removeEdits: boolean
    :param successfulEdits: (C) This is a secondary flag used to indicate whether or not
    successful edits should be acted on (e.g  queried, removed, etc...)  A successful edit is
    an
    :type successfulEdits: boolean
    :param editCommand: (C Q M) This is a secondary flag used to indicate which type of
    reference edits should be considered by the command  If this flag is not specified all edit
    t
    :type editCommand: string
    :param onReferenceNode: (C Q M) This is a secondary flag used to indicate that only those
    edits which are stored on the indicated reference node should be considered  This flag
    only
    :type onReferenceNode: string
    
    :returns: 
    :rtype: None
    """
    pass


def xgmSetActive(*args, **kwargs):
    """
    
    """
    pass


def SetKey(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmPrimSelectionContext(*args, **kwargs):
    """
    
    """
    pass


def nClothReplaceCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreatePointLightOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nop(*args, **kwargs):
    """
    
    """
    pass


def TogglePolyDisplayHardEdges(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteUVs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GraphEditorAlwaysDisplayTangents(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeToggleZoomOut(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateClipOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddWrapInfluence(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeShapeMenuStateNoShapes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OffsetCurve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AppendToHairCacheOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def animView(*args, endTime=None, maxValue=0.0, minValue=0.0, nextView=True, previousView=True,
             startTime=None, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command allows you to specify the current view range within an animation editor
    
    :param endTime: () End time to display within the editor
    :type endTime: time
    :param maxValue: () Upper value to display within the editor
    :type maxValue: float
    :param minValue: () Lower value to display within the editor
    :type minValue: float
    :param nextView: (E) Switches to the next view
    :type nextView: boolean
    :param previousView: (E) Switches to the previous view
    :type previousView: boolean
    :param startTime: () Start time to display within the editor
    :type startTime: time
    
    :returns: 
    :rtype: None
    """
    pass


def attachNclothCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideFkSkeleton(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleIKSolvers(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideSelectedObjects(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorCreateDoWhileCompound(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExtractSubdivSurfaceVerticesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def viewSet(*args, animate=True, back=True, bottom=True, fit=True, fitFactor=0.0, front=True,
            home=True, keepRenderSettings=True, leftSide=True, namespace="", nextView=True,
            persp=True, previousView=True, rightSide=True, side=True, top=True,
            viewNegativeX=True, viewNegativeY=True, viewNegativeZ=True, viewX=True, viewY=True,
            viewZ=True, q=True, query=True, **kwargs):
    """
    This command positions the camera to one of the pre-defined positions  If the fit flag is
    set in conjunction with persp, top, side, or front, the view is "fit" based on the list of
    selected objects (if there are any) or on all the objects if nothing is selected  Notice
    that the fit flag cannot be set in conjunction with view along axis commands lik
    
    :param animate: (C) Specifies that the transition between camera positions should be
    animated
    :type animate: boolean
    :param back: (C) Moves the camera to the back position
    :type back: boolean
    :param bottom: (C) Moves the camera to the bottom position
    :type bottom: boolean
    :param fit: (C Q) Apply a viewFit after positioning camera to persp, top, side, or front
    :type fit: boolean
    :param fitFactor: (C) Specifies how much of the view should be filled with the "fitted"
    items
    :type fitFactor: float
    :param front: (C) Moves the camera to the front position
    :type front: boolean
    :param home: (C) Executes the camera's home attribute command  Before the string is
    executed, all occurances of "%camera" will be replaced by the camera's name  Use t
    :type home: boolean
    :param keepRenderSettings: (C Q) Retain the 'renderable' flag vaue on the view  Especially
    important if it switches from perspective to orthographic and then back again
    :type keepRenderSettings: boolean
    :param leftSide: (C) Moves the camera to the left side position
    :type leftSide: boolean
    :param namespace: (C) Specifies a namespace that should be excluded  All objects in the
    specified namespace will be excluded from the fit process
    :type namespace: string
    :param nextView: (C Q) Moves the camera to the next position
    :type nextView: boolean
    :param persp: (C) Moves the camera to the persp position
    :type persp: boolean
    :param previousView: (C Q) Moves the camera to the previous position
    :type previousView: boolean
    :param rightSide: (C) Moves the camera to the right side position
    :type rightSide: boolean
    :param side: (C) Moves the camera to the (right) side position (deprecated)
    :type side: boolean
    :param top: (C) Moves the camera to the top position
    :type top: boolean
    :param viewNegativeX: (C) Moves the camera to view along negative X axis
    :type viewNegativeX: boolean
    :param viewNegativeY: (C) Moves the camera to view along negative Y axis
    :type viewNegativeY: boolean
    :param viewNegativeZ: (C) Moves the camera to view along negative Z axis
    :type viewNegativeZ: boolean
    :param viewX: (C) Moves the camera to view along X axis
    :type viewX: boolean
    :param viewY: (C) Moves the camera to view along Y axis
    :type viewY: boolean
    :param viewZ: (C) Moves the camera to view along Z axis
    :type viewZ: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def TimeEditorSetZeroKey(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def alignSurface(*args, caching=True, curvatureContinuity=False, curvatureScale1=0.0,
                 curvatureScale2=0.0, directionU=True, joinParameter=123456.0, nodeState=0,
                 positionalContinuity=True, positionalContinuityType=1, reverse1=False,
                 reverse2=False, swap1=False, swap2=False, tangentContinuity=True,
                 tangentContinuityType=1, tangentScale1=1.0, tangentScale2=1.0, twist=False,
                 attach=True, constructionHistory=True, keepMultipleKnots=True, name="",
                 object=True, replaceOriginal=True, q=True, query=True, e=True, edit=True,
                 **kwargs):
    """
    The surface align command is used to align surfaces in maya  The main alignment options are
    positional, tangent and curvature continuity  Curvature continuity implies tangent
    continuity   NOTE: this tool is based on Studio's align tool   Positional continuity means
    the surfaces (move) or the ends of the surfaces (modify) are changed   Tangent conti
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param curvatureContinuity: (C Q E) Curvature continuity is on if true and off otherwise 
    Default: false
    :type curvatureContinuity: boolean
    :param curvatureScale1: (C Q E) Curvature scale applied to curvature of first surface for
    curvature continuity  Default: 0.0
    :type curvatureScale1: float
    :param curvatureScale2: (C Q E) Curvature scale applied to curvature of second surface for
    curvature continuity  Default: 0.0
    :type curvatureScale2: float
    :param directionU: (C Q E) If true use U direction of surface and V direction otherwise 
    Default: true
    :type directionU: boolean
    :param joinParameter: (C Q E) Parameter on reference surface where modified surface is to
    be aligned to  Default: 123456.0
    :type joinParameter: float
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param positionalContinuity: (C Q E) Positional continuity is on if true and off otherwise 
    Default: true
    :type positionalContinuity: boolean
    :param positionalContinuityType: (C Q E) Positional continuity type legal values: 1 - move
    first surface, 2 - move second surface, 3 - move both surfaces, 4 - modify first surface, 5
    - modif
    :type positionalContinuityType: int
    :param reverse1: (C Q E) If true, reverse the direction (specified by directionU) of the
    first input surface before doing align  Otherwise, do nothing to the first input surf
    :type reverse1: boolean
    :param reverse2: (C Q E) If true, reverse the direction (specified by directionU) of the
    second input surface before doing align  Otherwise, do nothing to the second input su
    :type reverse2: boolean
    :param swap1: (C Q E) If true, swap the UV directions of the first input surface before
    doing align  Otherwise, do nothing to the first input surface before aligning  NOTE
    :type swap1: boolean
    :param swap2: (C Q E) If true, swap the UV directions of the second input surface before
    doing align  Otherwise, do nothing to the second input surface before aligning  NO
    :type swap2: boolean
    :param tangentContinuity: (C Q E) Tangent continuity is on if true and off otherwise 
    Default: true
    :type tangentContinuity: boolean
    :param tangentContinuityType: (C Q E) Tangent continuity type legal values: 1 - do tangent
    continuity on first surface, 2 - do tangent continuity on second surface Default: 1
    :type tangentContinuityType: int
    :param tangentScale1: (C Q E) Tangent scale applied to tangent of first surface for tangent
    continuity  Default: 1.0
    :type tangentScale1: float
    :param tangentScale2: (C Q E) Tangent scale applied to tangent of second surface for
    tangent continuity  Default: 1.0
    :type tangentScale2: float
    :param twist: (C Q E) If true, reverse the second surface in the opposite direction
    (specified by directionU) before doing align  This will avoid twists in the aligned sur
    :type twist: boolean
    :param attach: (C) Should surfaces be attached after alignment?
    :type attach: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param keepMultipleKnots: (C) Should multiple knots be kept?
    :type keepMultipleKnots: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def cacheFileCombine(*args, cacheIndex=True, channelName="", connectCache="", keepWeights=True,
                     layerNode=True, nextAvailable=True, object="", objectIndex=0, q=True,
                     query=True, e=True, edit=True, **kwargs):
    """
    Creates a cacheBlend node that can be used to combine, layer or blend multiple cacheFiles
    for a given object
    
    :param cacheIndex: (Q) A query only flag that returns the index related to the cache
    specified with the connectCache flag
    :type cacheIndex: boolean
    :param channelName: (E M) Used in conjunction with the connectCache flag to indicate the
    channel(s) that should be connected  If not specified, the first channel in the file i
    :type channelName: string
    :param connectCache: (Q E) An edit flag that specifies a cacheFile node that should be
    connected to the next available index on the specified cacheBlend node  As a query flag,
    :type connectCache: string
    :param keepWeights: (E) This is a flag for use in combination with the connectCache flag
    only  By default, the connectCache flag will set all weights other than the newly ad
    :type keepWeights: boolean
    :param layerNode: (Q) A query flag that returns a string array of the existing cacheBlends
    on the selected object(s)  Returns an empty string array if no cacheBlends are f
    :type layerNode: boolean
    :param nextAvailable: (Q) A query flag that returns the next available index on the
    selected cacheBlend node
    :type nextAvailable: boolean
    :param object: (Q) This flag is used in combination with the objectIndex flag  It is used
    to specify the object whose index you wish to query  In query mode, this flag
    :type object: string
    :param objectIndex: (Q E) In edit mode, used in conjunction with the connectCache flag to
    indicate the objectIndex to be connected  In query mode, returns the index related to
    :type objectIndex: int
    
    :returns: Name of created cache layer node(s)
    :rtype: string
    """
    pass


def CreateEmitterOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolygonCopy(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def WhatsNewStartupDialogOff(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ActivateGlobalScreenSliderModeMarkingMenu(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ProjectCurveOnMeshOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def textScrollList(*args, allItems=True, allowAutomaticSelection=True, allowMultiSelection=True,
                   annotation="", append="", appendPosition=None, backgroundColor=None,
                   defineTemplate="", deleteKeyCommand=None, deselectAll=True,
                   deselectIndexedItem=0, deselectItem="", docTag="", doubleClickCommand=None,
                   dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
                   enableKeyboardFocus=True, exists=True, font="", fullPathName=True, height=0,
                   highlightColor=None, isObscured=True, lineFont=None, manage=True,
                   noBackground=True, numberOfItems=True, numberOfPopupMenus=True,
                   numberOfRows=0, numberOfSelectedItems=True, parent="", popupMenuArray=True,
                   preventOverride=True, removeAll=True, removeIndexedItem=0, removeItem="",
                   selectCommand=None, selectIndexedItem=0, selectItem="",
                   selectUniqueTagItem="", showIndexedItem=0, statusBarMessage="", uniqueTag="",
                   useTemplate="", visible=True, visibleChangeCommand=None, width=0, q=True,
                   query=True, e=True, edit=True, **kwargs):
    """
    This command creates/edits/queries a text scrolling list  The list can be in single select
    mode where only one item at at time is selected, or in multi-select mode where many items
    may be selected   Note: The -dgc/dragCallback flag works only on Windows
    
    :param allItems: (Q) All the items
    :type allItems: boolean
    :param allowAutomaticSelection: (C Q E) Specify automatic selection mode  When
    automaticSelection is on each item that the mouse is over (during dragging once an item has
    been selected) wil
    :type allowAutomaticSelection: boolean
    :param allowMultiSelection: (C Q E) Specify multi or single selection mode
    :type allowMultiSelection: boolean
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param append: (C E M) Add an item to the end of the list
    :type append: string
    :param appendPosition: (C E M) Append an item at the specified position  The position is a
    1-based index
    :type appendPosition: [int, string]
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param deleteKeyCommand: (C E) Specify the command to be executed when the delete or
    backspace key is pressed
    :type deleteKeyCommand: script
    :param deselectAll: (C E) Deselect all items
    :type deselectAll: boolean
    :param deselectIndexedItem: (C E M) Deselect the indexed item  Indices are 1-based
    :type deselectIndexedItem: int
    :param deselectItem: (C E M) Deselect the item that contains the specified text
    :type deselectItem: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param doubleClickCommand: (C E) Specify the command to be executed when an item is double
    clicked
    :type doubleClickCommand: script
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param font: (C Q E) The font for the list items  Valid values are "boldLabelFont",
    "smallBoldLabelFont", "tinyBoldLabelFont", "plainLabelFont", "smallPlainLabelFont", "o
    :type font: string
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param lineFont: (C E M) Specify the font for a specific line of the list  The indices are
    1-based  Valid font values are "boldLabelFont", "smallBoldLabelFont", "tinyBoldLabe
    :type lineFont: [int, string]
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfItems: (Q) Number of items
    :type numberOfItems: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param numberOfRows: (C Q E) Number of visible rows
    :type numberOfRows: int
    :param numberOfSelectedItems: (Q) Number of selected items
    :type numberOfSelectedItems: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param removeAll: (C E) Remove all items
    :type removeAll: boolean
    :param removeIndexedItem: (C E M) Remove the indexed item  Indices are 1-based
    :type removeIndexedItem: int
    :param removeItem: (C E M) Remove the item with the specified text
    :type removeItem: string
    :param selectCommand: (C E) Specify the command to be executed when an item is selected
    :type selectCommand: script
    :param selectIndexedItem: (C Q E M) Select the indexed item  Indices are 1-based
    :type selectIndexedItem: int
    :param selectItem: (C Q E M) Select the item that contains the specified text
    :type selectItem: string
    :param selectUniqueTagItem: (C Q E M) Allow item selections based on the unique tag  In
    query mode, it will return the unique tag of the selected items
    :type selectUniqueTagItem: string
    :param showIndexedItem: (C E) Show the indexed item  Scroll the list as necessary so that
    the indexed item is visible  Indices are 1-based
    :type showIndexedItem: int
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param uniqueTag: (C E M) This flag can only be used in conjunction with the append or the
    appendPosition flag  The string specifies a unique tag for the appended item; the ta
    :type uniqueTag: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def mayaPreviewRenderIntoNewWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteCurrentWorkspace(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXImportOCMerge(*args, **kwargs):
    """
    
    """
    pass


def IncreaseCheckerDensity(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def scaleConstraint(*args, layer="", maintainOffset=True, name="", offset=None, remove=True,
                    scaleCompensate=True, skip="", targetList=True, weight=0.0,
                    weightAliasList=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Constrain an object's scale to the scale of the target object or to the average scale of a
    number of targets   A scaleConstraint takes as input one or more "target" DAG transform
    nodes to which to scale the single "constraint object" DAG transform node  The
    scaleConstraint scales the constrained object at the weighted geometric mean of the world
    sp
    
    :param layer: (C E) Specify the name of the animation layer where the constraint should be
    added
    :type layer: string
    :param maintainOffset: (C) The offset necessary to preserve the constrained object's
    initial scale will be calculated and used as the offset
    :type maintainOffset: boolean
    :param name: (C Q E) Sets the name of the constraint node to the specified name  Default
    name is constrainedObjectName_constraintType
    :type name: string
    :param offset: (C Q E) Sets or queries the value of the offset  Default is 1,1,1
    :type offset: [float, float, float]
    :param remove: (E) removes the listed target(s) from the constraint
    :type remove: boolean
    :param scaleCompensate: (C E) Used only when constraining a joint  It specify if a
    scaleCompensate will be applied on constrained joint  If true it will connect
    Tjoint.aCompensate
    :type scaleCompensate: boolean
    :param skip: (C E M) Specify the axis to be skipped  Valid values are "x", "y", "z" and
    "none"  During creation, "none" is the default  This flag is multi-use
    :type skip: string
    :param targetList: (Q) Return the list of target objects
    :type targetList: boolean
    :param weight: (C Q E) Sets the weight value for the specified target(s)  If not given at
    creation time, the default value of 1.0 is used
    :type weight: float
    :param weightAliasList: (Q) Returns the names of the attributes that control the weight of
    the target objects  Aliases are returned in the same order as the targets are returned
    :type weightAliasList: boolean
    
    :returns: Name of the created constraint node
    :rtype: string[]
    """
    pass


def RenameCurrentUVSet(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def replaceCacheFramesOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CopyFlexor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def LockCurveLength(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def radioButtonGrp(*args, adjustableColumn=0, adjustableColumn2=0, adjustableColumn3=0,
                   adjustableColumn4=0, adjustableColumn5=0, adjustableColumn6=0, annotation="",
                   annotation1="", annotation2="", annotation3="", annotation4="",
                   backgroundColor=None, changeCommand=None, changeCommand1=None,
                   changeCommand2=None, changeCommand3=None, changeCommand4=None,
                   columnAlign=None, columnAlign2=None, columnAlign3=None, columnAlign4=None,
                   columnAlign5=None, columnAlign6=None, columnAttach=None, columnAttach2=None,
                   columnAttach3=None, columnAttach4=None, columnAttach5=None,
                   columnAttach6=None, columnOffset2=None, columnOffset3=None,
                   columnOffset4=None, columnOffset5=None, columnOffset6=None, columnWidth=None,
                   columnWidth1=0, columnWidth2=None, columnWidth3=None, columnWidth4=None,
                   columnWidth5=None, columnWidth6=None, data1=0, data2=0, data3=0, data4=0,
                   defineTemplate="", docTag="", dragCallback=None, dropCallback=None,
                   editable=True, enable=True, enable1=True, enable2=True, enable3=True,
                   enable4=True, enableBackground=True, enableKeyboardFocus=True, exists=True,
                   fullPathName=True, height=0, highlightColor=None, isObscured=True, label="",
                   label1="", label2="", label3="", label4="", labelAnnotation="",
                   labelArray2=None, labelArray3=None, labelArray4=None, manage=True,
                   noBackground=True, numberOfPopupMenus=True, numberOfRadioButtons=0,
                   offCommand=None, offCommand1=None, offCommand2=None, offCommand3=None,
                   offCommand4=None, onCommand=None, onCommand1=None, onCommand2=None,
                   onCommand3=None, onCommand4=None, parent="", popupMenuArray=True,
                   preventOverride=True, rowAttach=None, select=0, shareCollection="",
                   statusBarMessage="", useTemplate="", vertical=True, visible=True,
                   visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
                   **kwargs):
    """
    All of the group commands position their individual controls in columns starting at column
    1  The layout of each control (ie  column) can be customized using the -cw/columnWidth,
    -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumn flags  By
    default, columns are left aligned with no offset and are 100 pixels wide  Only o
    
    :param adjustableColumn: (C E) Specifies which column has an adjustable size that changes
    with the sizing of the layout  The column value is a 1-based index  Passing 0 as argument
    :type adjustableColumn: int
    :param adjustableColumn2: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly two columns
    :type adjustableColumn2: int
    :param adjustableColumn3: (C E) Specifies that the column has an adjustable size that
    changes with the size of the parent layout  Ignored if there are not exactly three columns
    :type adjustableColumn3: int
    :param adjustableColumn4: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly four columns
    :type adjustableColumn4: int
    :param adjustableColumn5: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly five columns
    :type adjustableColumn5: int
    :param adjustableColumn6: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly six columns
    :type adjustableColumn6: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param annotation1: (C Q E) specifies the tooptip of the first radiobutton
    :type annotation1: string
    :param annotation2: (C Q E) specifies the tooptip of the second radiobutton
    :type annotation2: string
    :param annotation3: (C Q E) specifies the tooptip of the third radiobutton
    :type annotation3: string
    :param annotation4: (C Q E) specifies the tooptip of the fourth radiobutton
    :type annotation4: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Command executed when the group changes state  Note that this
    flag should not be used in conjunction with onCommand and offCommand  That is, one shou
    :type changeCommand: script
    :param changeCommand1: (C E) 
    :type changeCommand1: script
    :param changeCommand2: (C E) 
    :type changeCommand2: script
    :param changeCommand3: (C E) 
    :type changeCommand3: script
    :param changeCommand4: (C E) Specify a changed state command for each respective radio
    button
    :type changeCommand4: script
    :param columnAlign: (C E M) Arguments are : column number, alignment type  Possible
    alignments are: left | right | center  Specifies alignment type for the specified column
    :type columnAlign: [int, string]
    :param columnAlign2: (C E) Sets the text alignment of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "center"
    :type columnAlign2: [string, string]
    :param columnAlign3: (C E) Sets the text alignment for all three columns  Ignored if there
    are not exactly three columns  Valid values are "left", "right", and "center"
    :type columnAlign3: [string, string, string]
    :param columnAlign4: (C E) Sets the text alignment for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "center"
    :type columnAlign4: [string, string, string, string]
    :param columnAlign5: (C E) Sets the text alignment for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "center"
    :type columnAlign5: [string, string, string, string, string]
    :param columnAlign6: (C E) Sets the text alignment for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "center"
    :type columnAlign6: [string, string, string, string, string, string]
    :param columnAttach: (C E M) Arguments are : column number, attachment type, and offset 
    Possible attachments are: left | right | both  Specifies column attachment types and offe
    :type columnAttach: [int, string, int]
    :param columnAttach2: (C E) Sets the attachment type of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "both"
    :type columnAttach2: [string, string]
    :param columnAttach3: (C E) Sets the attachment type for all three columns  Ignored if
    there are not exactly three columns  Valid values are "left", "right", and "both"
    :type columnAttach3: [string, string, string]
    :param columnAttach4: (C E) Sets the attachment type for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "both"
    :type columnAttach4: [string, string, string, string]
    :param columnAttach5: (C E) Sets the attachment type for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "both"
    :type columnAttach5: [string, string, string, string, string]
    :param columnAttach6: (C E) Sets the attachment type for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "both"
    :type columnAttach6: [string, string, string, string, string, string]
    :param columnOffset2: (C E) This flag is used in conjunction with the -columnAttach2 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the tw
    :type columnOffset2: [int, int]
    :param columnOffset3: (C E) This flag is used in conjunction with the -columnAttach3 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the th
    :type columnOffset3: [int, int, int]
    :param columnOffset4: (C E) This flag is used in conjunction with the -columnAttach4 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fo
    :type columnOffset4: [int, int, int, int]
    :param columnOffset5: (C E) This flag is used in conjunction with the -columnAttach5 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fi
    :type columnOffset5: [int, int, int, int, int]
    :param columnOffset6: (C E) This flag is used in conjunction with the -columnAttach6 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the si
    :type columnOffset6: [int, int, int, int, int, int]
    :param columnWidth: (C E M) Arguments are : column number, column width  Sets the width of
    the specified column where the first parameter specifies the column (1 based index) an
    :type columnWidth: [int, int]
    :param columnWidth1: (C E) Sets the width of the first column  Ignored if there is not
    exactly one column
    :type columnWidth1: int
    :param columnWidth2: (C E) Sets the column widths of both columns  Ignored if there are not
    exactly two columns
    :type columnWidth2: [int, int]
    :param columnWidth3: (C E) Sets the column widths for all 3 columns  Ignored if there are
    not exactly 3 columns
    :type columnWidth3: [int, int, int]
    :param columnWidth4: (C E) Sets the column widths for all 4 columns  Ignored if there are
    not exactly 4 columns
    :type columnWidth4: [int, int, int, int]
    :param columnWidth5: (C E) Sets the column widths for all 5 columns  Ignored if there are
    not exactly 5 columns
    :type columnWidth5: [int, int, int, int, int]
    :param columnWidth6: (C E) Sets the column widths for all 6 columns  Ignored if there are
    not exactly 6 columns
    :type columnWidth6: [int, int, int, int, int, int]
    :param data1: (C Q E) 
    :type data1: int
    :param data2: (C Q E) 
    :type data2: int
    :param data3: (C Q E) 
    :type data3: int
    :param data4: (C Q E) Internal data associated with each radio button
    :type data4: int
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param editable: (C Q E) The edit state of the group  By default, this flag is set to true
    and the radio button values may be changed by clicking on them  If false then the r
    :type editable: boolean
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enable1: (C Q E) 
    :type enable1: boolean
    :param enable2: (C Q E) 
    :type enable2: boolean
    :param enable3: (C Q E) 
    :type enable3: boolean
    :param enable4: (C Q E) Enable state of the individual radio buttons
    :type enable4: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) When present on creation an optional text label will be built with
    the group  The string specifies the label text
    :type label: string
    :param label1: (C Q E) 
    :type label1: string
    :param label2: (C Q E) 
    :type label2: string
    :param label3: (C Q E) 
    :type label3: string
    :param label4: (C Q E) Specify label strings for the respective radio buttons in the group
    :type label4: string
    :param labelAnnotation: (C Q E) when present on creation an optional text label will be
    built with the group   The string specifies the label tooltip
    :type labelAnnotation: string
    :param labelArray2: (C Q E) 
    :type labelArray2: [string, string]
    :param labelArray3: (C Q E) 
    :type labelArray3: [string, string, string]
    :param labelArray4: (C Q E) Specify multiple labels in a single flag  These flags are
    ignored if the number of radio buttons doesn't match
    :type labelArray4: [string, string, string, string]
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param numberOfRadioButtons: (C) Number of radio buttons in the group (1 - 4)
    :type numberOfRadioButtons: int
    :param offCommand: (C E) Command executed when any radio button turns off
    :type offCommand: script
    :param offCommand1: (C E) 
    :type offCommand1: script
    :param offCommand2: (C E) 
    :type offCommand2: script
    :param offCommand3: (C E) 
    :type offCommand3: script
    :param offCommand4: (C E) Off command for each respective radio button
    :type offCommand4: script
    :param onCommand: (C E) Command executed when any radio button turns on
    :type onCommand: script
    :param onCommand1: (C E) 
    :type onCommand1: script
    :param onCommand2: (C E) 
    :type onCommand2: script
    :param onCommand3: (C E) 
    :type onCommand3: script
    :param onCommand4: (C E) On command for each respective radio button
    :type onCommand4: script
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rowAttach: (C E M) Arguments are : column, attachment type, offset  Possible
    attachments are: top | bottom | both  Specifies attachment types and offsets for the
    entire
    :type rowAttach: [int, string, int]
    :param select: (C Q E) Selected radio button  The argument is a 1 based integer
    :type select: int
    :param shareCollection: (C) Specify the radioButtonGrp that this radio group is to be
    associated with  By default the radio group will be a separate collection
    :type shareCollection: string
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param vertical: (C Q) Whether the orientation of the radio buttons in this group are
    horizontal (default) or vertical
    :type vertical: boolean
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def RenderIntoNewWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyQueryBlindData(*args, associationType="", binaryData="", booleanData=True,
                       doubleData=0.0, intData=0, longDataName="", maxValue=0.0, minValue=0.0,
                       shortDataName="", showComp=True, stringData="", subString="", typeId=0,
                       **kwargs):
    """
    Command query's blindData associated with particular polygonal components  So, the command
    will require the following to be specified: - selection list to query Optional are the: -
    typeId - associationType - longDataName or shortDataName of data being queried  - The
    actual data being specified  - showComponent flag Note that for object level blind 
    
    :param associationType: (C) Specifies the dataTypes that are part of BlindData node being
    queried  Allowable associations are "object" for any object, and "vertex" "edge" and "f
    :type associationType: string
    :param binaryData: (C) Specifies the binary string value to search for
    :type binaryData: string
    :param booleanData: (C) Specifies the string value to search for
    :type booleanData: boolean
    :param doubleData: (C) Specifies the double/float value to search for
    :type doubleData: float
    :param intData: (C) Specifies the integer value to search for
    :type intData: int
    :param longDataName: (C M) Specifies the long name of the data that is being queried by
    this command
    :type longDataName: string
    :param maxValue: (C) Specifies the maximum value to search for  This option will query
    float, double, and integer types of blind data
    :type maxValue: float
    :param minValue: (C) Specifies the minimum value to search for  This option will query
    float, double and integer types of blind data
    :type minValue: float
    :param shortDataName: (C M) Specifies the short name of the data that is being queried by
    this command
    :type shortDataName: string
    :param showComp: (C) The showComponent option controls whether the
    object.[component].attribute name is output preceeding the actual value  If the
    showComponent option is
    :type showComp: boolean
    :param stringData: (C) Specifies the string value to search for
    :type stringData: string
    :param subString: (C) Specifies the substring that should be checked against a STRING type
    blind data  If the sub string is found query is successful  Will not look at non
    :type subString: string
    :param typeId: (C) Specifies the typeId of the BlindData type being queried  If the typeId
    is not specified, then all of the components that match the query will be out
    :type typeId: int
    
    :returns: Blind data
    :rtype: string
    """
    pass


def xgmFreezeBrushToolCmd(*args, **kwargs):
    """
    
    """
    pass


def polyClean(*args, caching=True, cleanEdges=True, cleanPartialUVMapping=True, cleanUVs=True,
              cleanVertices=True, constructionHistory=True, frozen=True, name="", nodeState=0,
              q=True, query=True, e=True, edit=True, **kwargs):
    """
    polyClean will attempt to remove components that are invalid in the description of a poly
    mesh
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param cleanEdges: (C Q E) If true, the operation will look for and delete edges that are
    not associated with any face in the mesh
    :type cleanEdges: boolean
    :param cleanPartialUVMapping: (C Q E) If true, the operation will look for any faces on the
    mesh that do not have complete UV mapping  Maya requires that all vertices that make up a
    mesh
    :type cleanPartialUVMapping: boolean
    :param cleanUVs: (C Q E) If true, the operation will look for and delete UVs that are not
    associated with any face in the mesh
    :type cleanUVs: boolean
    :param cleanVertices: (C Q E) If true, the operation will look for and delete vertices that
    are not associated with any face in the mesh
    :type cleanVertices: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param frozen: (C Q E) Toggle frozen state for a particular node to keep current evaluation
    state and prevent any other indirect changes to it
    :type frozen: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def bindSkin(*args, byClosestPoint=True, byPartition=True, colorJoints=True, delete=True,
             doNotDescend=True, enable=True, name="", partition="", toAll=True,
             toSelectedBones=True, toSkeleton=True, unbind=True, unbindKeepHistory=True,
             unlock=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command binds the currently selected objects to the currently selected skeletons 
    Shapes which can be bound are: meshes, nurbs curves, nurbs surfaces, lattices, subdivision
    surfaces, and API shapes  Multiple shapes and multiple skeletons can be bound at once by
    selecting them or specifying them on the command line  Selection order is not impor
    
    :param byClosestPoint: (C) bind each point in the object to the segment closest to the
    point  The byClosestPoint and byPartition flags are mutually exclusive  The byClosestPoin
    :type byClosestPoint: boolean
    :param byPartition: (C) bind each group in the partition to the segment closest to the
    group's centroid  A partition must be specified with the -p/-partition flag
    :type byPartition: boolean
    :param colorJoints: (C) In bind mode, this flag assigns colors to the joints based on the
    colors assigned to the joint's skin set  In delete and unlock mode, this flag remov
    :type colorJoints: boolean
    :param delete: (C) Detach the skin on the selected skeletons and remove all bind- related
    construction history
    :type delete: boolean
    :param doNotDescend: (C) Do not descend to shapes that are parented below the selected
    object(s)  Bind only the selected objects
    :type doNotDescend: boolean
    :param enable: (C) Enable or disable a bind that has been disabled on the selected
    skeletons  To enable the bind on selected bones only, select the bones and use the -t
    :type enable: boolean
    :param name: (C) This flag is obsolete
    :type name: string
    :param partition: (C) Specify a partition to bind by  This is only valid when used with the
    -bp/-byPartition flag
    :type partition: string
    :param toAll: (C) objects will be bound to the entire selected skeletons  Even bones with
    zero influence will be bound, whereas the toSkeleton will only bind non-zero
    :type toAll: boolean
    :param toSelectedBones: (C) objects will be bound to the selected bones only
    :type toSelectedBones: boolean
    :param toSkeleton: (C) objects will be bound to the selected skeletons  The toSkeleton,
    toAll and toSelectedBones flags are mutually exclusive  The toSkeleton flag is the d
    :type toSkeleton: boolean
    :param unbind: (C) unbind the selected objects  They will no longer move with the skeleton 
    Any bindSkin history that is no longer used will be deleted
    :type unbind: boolean
    :param unbindKeepHistory: (C) unbind the selected objects  They will no longer move with
    the skeleton  However, existing weights on the skin will be kept for use the next time the
    :type unbindKeepHistory: boolean
    :param unlock: (C) unlock the selected objects  Since bindSkin will no longer give normal
    results if bound objects are moved away from the skeleton, bindSkin locks tran
    :type unlock: boolean
    
    :returns: Command result
    :rtype: string
    """
    pass


def container(*args, addNode=None, asset=None, assetMember="", bindAttr=None,
              connectionList=True, current=True, fileName=None, findContainer=None, force=True,
              includeHierarchyAbove=True, includeHierarchyBelow=True, includeNetwork=True,
              includeNetworkDetails="", includeShaders=True, includeShapes=True,
              includeTransform=True, isContainer=True, name="", nodeList=True,
              nodeNamePrefix=True, parentContainer=True, preview=True, publishAndBind=None,
              publishAsChild=None, publishAsParent=None, publishAsRoot=None, publishAttr="",
              publishConnections=True, publishName="", removeContainer=True, removeNode=None,
              type="", unbindAndUnpublish="", unbindAttr=None, unbindChild="", unbindParent="",
              unpublishChild="", unpublishName="", unpublishParent="", unsortedOrder=True,
              q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command can be used to create and query container nodes  It is also used to perform
    operations on containers such as:  add and remove nodes from the container publish
    attributes from nodes inside the container replace the connections and values from one
    container onto another one remove a container without removing its member nodes
    
    :param addNode: (C E) Specifies the list of nodes to add to container
    :type addNode: string[]
    :param asset: (Q) When queried, if all the nodes in nodeList belong to the same container,
    returns container's name  Otherwise returns empty string  This flag is funct
    :type asset: string[]
    :param assetMember: (Q) Can be used during query in conjunction with the bindAttr flag to
    query for the only published attributes related to the specified node within the co
    :type assetMember: string
    :param bindAttr: (Q E) Bind a contained attribute to an unbound published name on the
    interface of the container; returns a list of bound published names  The first string
    :type bindAttr: [string, string]
    :param connectionList: (Q) Returns a list of the exterior connections to the container
    node
    :type connectionList: boolean
    :param current: (C Q E) In create mode, specify that the newly created asset should be
    current  In edit mode, set the selected asset as current  In query, return the current
    :type current: boolean
    :param fileName: (Q) Used to query for the assets associated with a given file name  In
    query mode, this flag needs a value
    :type fileName: string[]
    :param findContainer: (Q) When queried, if all the nodes in nodeList belong to the same
    container, returns container's name  Otherwise returns empty string  In query mode, thi
    :type findContainer: string[]
    :param force: (C E) This flag can be used in conjunction with -addNode and -removeNode
    flags only  If specified with -addNode, nodes will be disconnected from their curr
    :type force: boolean
    :param includeHierarchyAbove: (C E) Used to specify that the parent hierarchy of the
    supplied node list should also be included in the container (or deleted from the container)
     Hierarc
    :type includeHierarchyAbove: boolean
    :param includeHierarchyBelow: (C E) Used to specify that the hierarchy below the supplied
    node list should also be included in the container (or delete from the container) 
    Hierarchy in
    :type includeHierarchyBelow: boolean
    :param includeNetwork: (C E) Used to specify that the node network connected to supplied
    node list should also be included in the container  Network traversal will stop at defaul
    :type includeNetwork: boolean
    :param includeNetworkDetails: (C E M) Used to specify specific parts of the network that
    should be included  Valid arguments to this flag are: "channels", "sdk", "constraints",
    "history"
    :type includeNetworkDetails: string
    :param includeShaders: (C E) Used to specify that for any shapes included, their shaders
    will also be included in the container
    :type includeShaders: boolean
    :param includeShapes: (C E) Used to specify that for any transforms selected, their direct
    child shapes will be included in the container (or deleted from the container)  This f
    :type includeShapes: boolean
    :param includeTransform: (C E) Used to specify that for any shapes selected, their parent
    transform will be included in the container (or deleted from the container)  This flag is
    :type includeTransform: boolean
    :param isContainer: (Q) Return true if the selected or specified node is a container node 
    If multiple containers are queried, only the state of the first will be returned
    :type isContainer: boolean
    :param name: (C) Sets the name of the newly-created container
    :type name: string
    :param nodeList: (Q) When queried, returns a list of nodes in container  The list will be
    sorted in the order they were added to the container  This will also display any
    :type nodeList: boolean
    :param nodeNamePrefix: (C E) Specifies that the name of published attributes should be of
    the form "node_attr"  Must be used with the -publishConnections/-pc flag
    :type nodeNamePrefix: boolean
    :param parentContainer: (Q) Flag to query the parent container of a specified container
    :type parentContainer: boolean
    :param preview: (C) This flag is valid in create mode only  It indicates that you do not
    want the container to be created, instead you want to preview its contents  When
    :type preview: boolean
    :param publishAndBind: (E) Publish the given name and bind the attribute to the given name 
    First string specifies the node and attribute name in "node.attr" format  Second str
    :type publishAndBind: [string, string]
    :param publishAsChild: (Q E) Publish contained node to the interface of the container to
    indicate it can be a child of external nodes  The second string is the name of the publis
    :type publishAsChild: [string, string]
    :param publishAsParent: (Q E) Publish contained node to the interface of the container to
    indicate it can be a parent to external nodes  The second string is the name of the publi
    :type publishAsParent: [string, string]
    :param publishAsRoot: (Q E) Publish or unpublish a node as a root  The significance of root
    transform node is twofold  When container-centric selection is enabled, the root tran
    :type publishAsRoot: [string, boolean]
    :param publishAttr: (Q) In query mode, can only be used with the -publishName(-pn) flag,
    and takes an attribute as an argument; returns the published name of the attribute,
    :type publishAttr: string
    :param publishConnections: (C E) Publish all connections from nodes inside the container to
    nodes outside the container
    :type publishConnections: boolean
    :param publishName: (Q E) Publish a name to the interface of the container, and returns the
    actual name published to the interface  In query mode, returns the published names
    :type publishName: string
    :param removeContainer: (E) Disconnects all the nodes from container and deletes container
    node
    :type removeContainer: boolean
    :param removeNode: (E) Specifies the list of nodes to remove from container  If node is a
    member of a nested container, it will be added to the parent container  To remove
    :type removeNode: string[]
    :param type: (C Q) By default, a container node will be created  Alternatively, the type
    flag can be used to indicate that a different type of container should be creat
    :type type: string
    :param unbindAndUnpublish: (E) Unbind the given attribute (in "node.attr" format) and
    unpublish its associated name  Unbinding a compound may trigger unbinds of its compound
    parent
    :type unbindAndUnpublish: string
    :param unbindAttr: (Q E) Unbind a published attribute from its published name on the
    interface of the container, leaving an unbound published name on the interface of the con
    :type unbindAttr: [string, string]
    :param unbindChild: (E) Unbind the node published as child, but do not remove its published
    name from the interface of the container
    :type unbindChild: string
    :param unbindParent: (E) Unbind the node published as parent, but do not remove its
    published name from the interface of the container
    :type unbindParent: string
    :param unpublishChild: (E) Unpublish node published as child from the interface of the
    container
    :type unpublishChild: string
    :param unpublishName: (E) Unpublish an unbound name from the interface of the container
    :type unpublishName: string
    :param unpublishParent: (E) Unpublish node published as parent from the interface of the
    container
    :type unpublishParent: string
    :param unsortedOrder: (Q) This flag has no effect on the operation of the container command
    (OBSOLETE)
    :type unsortedOrder: boolean
    
    :returns: Name of the node created.
    :rtype: string
    """
    pass


def SubdividePolygon(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SoftModDeformer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddAuxEffector(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def QuickRigEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def itemFilter(*args, byBin="", byName="", byScript="", byType="", category="",
               classification="", clearByBin=True, clearByType=True, difference=None,
               exists=True, intersect=None, listBuiltInFilters=True, listOtherFilters=True,
               listUserFilters=True, negate=True, parent="", pythonModule="", secondScript="",
               text="", union=None, uniqueNodeNames=True, q=True, query=True, e=True, edit=True,
               **kwargs):
    """
    This command creates a named itemFilter object  This object can be attached to
    selectionConnection objects, or to editors, in order to filter the item lists going through
    them  Using union, intersection and difference filters, complex composite filters can be
    created
    
    :param byBin: (C Q E M) The filter will only pass items whose bin list contains the given
    string as a bin name  This is a multi-use flag  If more than one occurance of this
    :type byBin: string
    :param byName: (C Q E) The filter will only pass items whose names match the given regular
    expression string  This string can contain the special characters * and ?  '?' ma
    :type byName: string
    :param byScript: (C Q E) The filter will run a MEL script named by the given string on each
    item name  Items will pass the filter if the script returns a non-zero value  The
    :type byScript: string
    :param byType: (C Q E M) The filter will only pass items whose typeName matches the given
    string  The typeName of an object can be found using the nodeType command  This is a
    :type byType: string
    :param category: (C Q E M) A string for categorizing the filter
    :type category: string
    :param classification: (C Q E) Indicates whether the filter is a built-in or user filter 
    The string argument must be either "builtIn" or "user"  The "other" classification is depr
    :type classification: string
    :param clearByBin: (C E) This flag will clear any existing bins associated with this
    filter
    :type clearByBin: boolean
    :param clearByType: (C E) This flag will clear any existing typeNames associated with this
    filter
    :type clearByType: boolean
    :param difference: (C Q E) The filter will consist of the set difference of two other
    filters, whose names are the given strings  Items will pass this filter if and only if the
    :type difference: [string, string]
    :param exists: (C) Returns true|false depending upon whether the specified object exists 
    Other flags are ignored
    :type exists: boolean
    :param intersect: (C Q E) The filter will consist of the intersection of two other filters,
    whose names are the given strings  Items will pass this filter if and only if they
    :type intersect: [string, string]
    :param listBuiltInFilters: (Q) Returns an array of all item filters with classification
    "builtIn"
    :type listBuiltInFilters: boolean
    :param listOtherFilters: (Q) The "other" classification is deprecated  Use "user" instead 
    Returns an array of all item filters with classification "other"
    :type listOtherFilters: boolean
    :param listUserFilters: (Q) Returns an array of all item filters with classification
    "user"
    :type listUserFilters: boolean
    :param negate: (C Q E) This flag can be used to cause the filter to invert itself, and
    reverse what passes and what fails
    :type negate: boolean
    :param parent: (C Q E) Optional  If specified, the filter's life-span is linked to that of
    the parent  When the parent goes out of scope, so does the filter  If not specifi
    :type parent: string
    :param pythonModule: (C Q E) Treat -bs/byScript and -ss/secondScript as Python functions
    located in the specified module
    :type pythonModule: string
    :param secondScript: (C Q E) Cannot be used in conjunction with the -bs flag  The second
    script is for filtering whole lists at once, rather than individually  Its signature must
    :type secondScript: string
    :param text: (C Q E) Defines an annotation string to be stored with the filter
    :type text: string
    :param union: (C Q E) The filter will consist of the union of two other filters, whose
    names are the given strings  Items will pass this filter if they pass at least one o
    :type union: [string, string]
    :param uniqueNodeNames: (C Q E) Returns unique node names to script filters so there are no
    naming conflicts
    :type uniqueNodeNames: boolean
    
    :returns: Single command result
    :rtype: string
    """
    pass


def polyShortestPathCtx(*args, exists=True, image1="", image2="", image3="", q=True, query=True,
                        e=True, edit=True, **kwargs):
    """
    Creates a new context to select shortest edge path between two vertices or UVs in the 3d
    viewport
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    
    :returns: 
    :rtype: None
    """
    pass


def PolygonBooleanUnionOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TestTexture(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeDeleteAllCamerasAndImagePlanes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def freezeOptions(*args, displayLayers=True, downstream="", explicitPropagation=True,
                  invisible=True, referencedNodes=True, runtimePropagation=True, upstream="",
                  q=True, query=True, **kwargs):
    """
    This command provides access to the options used by the evaluation manager to handle
    propagation and recognition of when a node is in a frozen state  See the individual flags
    for the different options available  These values are all stored as user preferences and
    persist across sessions
    
    :param displayLayers: (C Q) If this option is enabled then any nodes that are in an enabled,
    invisible display layer will be considered to be frozen, and the frozen state will p
    :type displayLayers: boolean
    :param downstream: (C Q) Controls how frozen state is propagated downstream from currently
    frozen nodes  Valid values are "none" for no propagation, "safe" for propagation do
    :type downstream: string
    :param explicitPropagation: (C Q) When turned on this will perform an extra pass when the
    evaluation graph is constructed to perform intelligent propagation of the frozen state to
    rel
    :type explicitPropagation: boolean
    :param invisible: (C Q) If this option is enabled then any nodes that are invisible, either
    directly or via an invisible parent node, will be considered to be frozen, and th
    :type invisible: boolean
    :param referencedNodes: (C Q) If this option is enabled then any nodes that are referenced
    in from a frozen referenced node will also be considered to be frozen, and the frozen st
    :type referencedNodes: boolean
    :param runtimePropagation: (C Q) When turned on this will allow the frozen state to
    propagate during execution of the evaluation graph  See also "explicitPropagation"  This
    option al
    :type runtimePropagation: boolean
    :param upstream: (C Q) Controls how frozen state is propagated upstream from currently
    frozen nodes  Valid values are "none" for no propagation, "safe" for propagation upst
    :type upstream: string
    
    :returns: Current value of the option if querying the downstream or upstream flags
    :rtype: string
    """
    pass


def SelectUVTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def superCtx(*args, **kwargs):
    """
    
    """
    pass


def AveragePolygonNormalsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteUVsWithoutHotkey(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ModifyPaintValueRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def texMoveContext(*args, editPivotMode=True, exists=True, image1="", image2="", image3="",
                   position=True, snap=True, snapComponentsRelative=True, snapPixelMode=0,
                   snapValue=0.0, tweakMode=True, q=True, query=True, e=True, edit=True,
                   **kwargs):
    """
    This command can be used to create, edit, or query a texture editor move manip context 
    Note that the above flags control the global behaviour of all texture editor move manip
    contexts  Changing one context independently is not allowed  Changing a context's behaviour
    using the above flags, will change all existing texture editor move manip contexts
    
    :param editPivotMode: (Q) Returns true when the manipulator is in edit pivot mode
    :type editPivotMode: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param position: (Q) Returns the current position of the manipulator
    :type position: boolean
    :param snap: (Q E) Sets or queries whether snapping is to be used
    :type snap: boolean
    :param snapComponentsRelative: (Q E) Value can be : true or false  If true, while snapping
    a group of UVs, the relative spacing between them will be preserved  If false, all the UVs
    will
    :type snapComponentsRelative: boolean
    :param snapPixelMode: (Q E) Sets the snapping mode to be the pixel center or upper left
    corner
    :type snapPixelMode: int
    :param snapValue: (Q E) Sets or queries the size of the snapping increment
    :type snapValue: float
    :param tweakMode: (Q E) When true, the manipulator is hidden and highlighted components can
    be selected and moved in one step using a click-drag interaction
    :type tweakMode: boolean
    
    :returns: (the name of the new context)
    :rtype: string
    """
    pass


def PolyMergeEdgesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ReattachSkeleton(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateJiggleOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSplineCacheDisableSelectedCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyAppendVertex(*args, append=None, constructionHistory=True, hole=True, name="",
                     point=None, texture=0, vertex=0, q=True, query=True, e=True, edit=True,
                     **kwargs):
    """
    Appends a new face to the selected polygonal object  The direction of the normal is given
    by the vertex order: the face normal points towards the user when the vertices rotate
    counter clockwise  Note that holes must be described in the opposite direction
    
    :param append: (C M) Append a vertex or a point to the selected object, or mark the start
    of a hole  This flag may also be used in place of the "hole", "vertex" and "poin
    :type append: [[, float, float, float, ]]
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param hole: (C M) Add a hole  The following points and edges will define a hole  Note that
    this flag should be avoided in Python  You may use the "append" flag instead
    :type hole: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param point: (C M) Adds a new point to the new face  Coordinates of free points are given
    in the local object reference  Note that this flag should be avoided in Python
    :type point: [float, float, float]
    :param texture: (C Q E) Specifies how new faces are mapped  0 - None; 1 - Normalize; 2 -
    Unitize C: Default is 0 (no mapping)  Q: When queried, this flag returns an int
    :type texture: int
    :param vertex: (C M) Adds the given vertex of the selected object to the new face  Note
    that this flag should be avoided in Python  You may use the "append" flag instead
    :type vertex: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def ShowTexturePlacements(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def hikGetNodeCount(*args, **kwargs):
    """
    
    """
    pass


def dgmodified(*args, **kwargs):
    """
    The dgmodified command is used to find out which nodes in the dependency graph have been
    modified  This is mostly useful for fixing instances where file new asks you to save when
    no changes have been made to the scene
    
    
    :returns: list of all nodes that have been modified
    :rtype: string[]
    """
    pass


def NodeEditorPublishCompound(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GoToWorkingFrame(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def KeyBlendShapeTargetsWeight(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def renderPartition(*args, q=True, query=True, **kwargs):
    """
    Set or query the model's current partition  When flag q is not used, a partion name must be
    passed as an argument  In this case the current partition is set to that name
    
    
    :returns: The render partition
    :rtype: string
    """
    pass


def CreateUVsBasedOnCamera(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def fluidVoxelInfo(*args, checkBounds=True, inBounds=None, objectSpace=True, radius=0.0,
                   voxel=None, voxelCenter=True, xIndex=0, yIndex=0, zIndex=0, **kwargs):
    """
    Provides basic information about the mapping of a fluid voxel grid into world- or object
    space of the fluid  Use this command to determine the center point of a voxel, or to find
    the voxel containing a given point, among other things
    
    :param checkBounds: (C) If this flag is on, and the voxel index of a point that is out of
    bounds is requested, then we return nothing
    :type checkBounds: boolean
    :param inBounds: (C) Are the three ints representing the x, y, z indices of a voxel within
    the bounds of the fluid's voxel grid? True if yes, false if not  (For 2D fluids
    :type inBounds: [int, int, int]
    :param objectSpace: (C) Whether the queried value should be returned in object space (TRUE),
    or world space (FALSE, the default)
    :type objectSpace: boolean
    :param radius: (C) Modifier for the -voxel flag  Returns a list of index triples
    identifying voxels that fall within the given radius of the point specified by the -vox
    :type radius: float
    :param voxel: (C) Returns array of three ints representing the x, y, z indices of the voxel
    within which the given point position is contained  If the checkBounds flag
    :type voxel: [float, float, float]
    :param voxelCenter: (C) The center position of the specified voxels  Returns an array of
    floats (three for each of the indices in the query)  (Valid only with the -xIndex, -
    :type voxelCenter: boolean
    :param xIndex: (C) Only return values for cells with this X index
    :type xIndex: int
    :param yIndex: (C) Only return values for cells with this Y index
    :type yIndex: int
    :param zIndex: (C) Only return values for cells with this Z index
    :type zIndex: int
    
    :returns: 
    :rtype: None
    """
    pass


def SmoothHairCurvesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NewtonOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def lsUI(*args, cmdTemplates=True, collection=True, contexts=True, controlLayouts=True,
         controls=True, dumpWidgets=True, editors=True, head=0, long=True, menuItems=True,
         menus=True, numWidgets=True, panels=True, radioMenuItemCollections=True, tail=0,
         type="", windows=True, **kwargs):
    """
    This command returns the names of UI objects
    
    :param cmdTemplates: (C) UI command templates created using ELF UI commands
    :type cmdTemplates: boolean
    :param collection: (C) Control collections created using ELF UI commands
    :type collection: boolean
    :param contexts: (C) Tool contexts created using ELF UI commands
    :type contexts: boolean
    :param controlLayouts: (C) Control layouts created using ELF UI commands [e.g  formLayouts,
    paneLayouts, etc.]
    :type controlLayouts: boolean
    :param controls: (C) Controls created using ELF UI commands  [e.g  buttons, checkboxes,
    etc]
    :type controls: boolean
    :param dumpWidgets: (C) Dump all QT widgets used by Maya
    :type dumpWidgets: boolean
    :param editors: (C) All currently existing editors
    :type editors: boolean
    :param head: (C) The parameter specifies the maximum number of elements to be returned from
    the beginning of the list of items  (Note: each flag will return at most t
    :type head: int
    :param long: (C) Use long pathnames instead of short non-path names
    :type long: boolean
    :param menuItems: (C) Menu items created using ELF UI commands
    :type menuItems: boolean
    :param menus: (C) Menus created using ELF UI commands
    :type menus: boolean
    :param numWidgets: (C) Reports the number of QT widgets used by Maya
    :type numWidgets: boolean
    :param panels: (C) All currently existing panels
    :type panels: boolean
    :param radioMenuItemCollections: (C) Menu item collections created using ELF UI commands
    :type radioMenuItemCollections: boolean
    :param tail: (C) The parameter specifies the maximum number of elements to be returned from
    the end of the list of items  (Note: each flag will return at most this ma
    :type tail: int
    :param type: (C M) List all objects of a certain type specified by the string argument  For
    example, "window", "menu", "control", or "controlLayout"
    :type type: string
    :param windows: (C) Windows created using ELF UI commands
    :type windows: boolean
    
    :returns: The names of the object arguments.
    :rtype: string[]
    """
    pass


def hikGetNodeIdFromName(*args, **kwargs):
    """
    
    """
    pass


def subdToPoly(*args, applyMatrixToResult=True, caching=True, copyUVTopology=False, depth=0,
               extractPointPosition=False, format=0, inSubdCVId=None, inSubdCVIdLeft=0,
               inSubdCVIdRight=0, maxPolys=0, nodeState=0, outSubdCVId=None, outSubdCVIdLeft=0,
               outSubdCVIdRight=0, outv=0, preserveVertexOrdering=True, sampleCount=1,
               shareUVs=False, subdNormals=False, addUnderTransform=True, connectShaders=True,
               constructionHistory=True, name="", object=True, q=True, query=True, e=True,
               edit=True, **kwargs):
    """
    This command tessellates a subdivision surface and produces polygon  The name of the new
    polygon is returned  If construction history is ON, then the name of the new dependency
    node is returned as well
    
    :param applyMatrixToResult: (C Q E) If true, the matrix on the input geometry is applied to
    the object and the resulting geometry will have identity matrix on it  If false the
    conversio
    :type applyMatrixToResult: boolean
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param copyUVTopology: (C Q E) Copy over uv topology (shared/unshared) from the original
    subdivision surface to the converted polygonal mesh  Default: false
    :type copyUVTopology: boolean
    :param depth: (C Q E) The depth at which constant-depth tessellates the surface Default: 0
    :type depth: int
    :param extractPointPosition: (C Q E) Determines how the position of a mesh point is
    calculated If on the position of the mesh point is returned  If off the position of the
    point of the s
    :type extractPointPosition: boolean
    :param format: (C Q E) Format: 0 - Uniform 1 - Adaptive 2 - Polygon Count 3 - Vertices
    Default: 0
    :type format: int
    :param inSubdCVId: (C Q E M) Input CV Id
    :type inSubdCVId: [int, int]
    :param inSubdCVIdLeft: (C Q E) Higher 32 bit integer of the input CV Id
    :type inSubdCVIdLeft: int
    :param inSubdCVIdRight: (C Q E) Lower 32 bit integer of the input CV Id
    :type inSubdCVIdRight: int
    :param maxPolys: (C Q E) The maximum number of polygons at which by polygons tessellates 
    If this attribute is greater than zero, it will override the sample count and depth
    :type maxPolys: int
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param outSubdCVId: (C Q E M) Output CV Id
    :type outSubdCVId: [int, int]
    :param outSubdCVIdLeft: (C Q E) Higher 32 bit integer of the output CV Id
    :type outSubdCVIdLeft: int
    :param outSubdCVIdRight: (C Q E) Lower 32 bit integer of the output CV Id
    :type outSubdCVIdRight: int
    :param outv: (C Q E M) Out Vertices corresponding to the inSubDCVs
    :type outv: int
    :param preserveVertexOrdering: (C Q E) Preserve vertex ordering in conversion Default:
    true
    :type preserveVertexOrdering: boolean
    :param sampleCount: (C Q E) The number of samples per face Default: 1
    :type sampleCount: int
    :param shareUVs: (C Q E) Force sharing of uvs on all common vertices - the value of this
    attribute gets overridden by the value of the copyUVTopology attribute  Default: fals
    :type shareUVs: boolean
    :param subdNormals: (C Q E) Keep subdiv surface normals Default: false
    :type subdNormals: boolean
    :param addUnderTransform: (C Q) If true then add the result underneath a transform node
    :type addUnderTransform: boolean
    :param connectShaders: (C) If true, all shader assignment will be copied from the original
    subdiv surface to the converted polygonal surface  Default: true
    :type connectShaders: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    
    :returns: The polygon and optionally the dependency node name
    :rtype: string[]
    """
    pass


def NodeEditorCloseAllTabs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXProperty(*args, **kwargs):
    """
    
    """
    pass


def cmdScrollFieldExecuter(*args, annotation="", appendText="", autoCloseBraces=True,
                           backgroundColor=None, clear=True, commandCompletion=True,
                           copySelection=True, currentLine=0, cutSelection=True,
                           defineTemplate="", docTag="", dragCallback=None, dropCallback=None,
                           enable=True, enableBackground=True, enableKeyboardFocus=True,
                           execute=True, executeAll=True, exists=True, fileChangedCommand=None,
                           filename=True, filterKeyPress=None, fullPathName=True, hasFocus=True,
                           hasSelection=True, height=0, highlightColor=None, insertText="",
                           isObscured=True, load=True, loadContents="", loadFile="",
                           manage=True, modificationChangedCommand=None, modified=True,
                           noBackground=True, numberOfLines=0, numberOfPopupMenus=True,
                           objectPathCompletion=True, parent="", pasteSelection=True,
                           popupMenuArray=True, preventOverride=True, redo=True,
                           removeStoredContents="", replaceAll=None, saveFile="",
                           saveSelection="", saveSelectionToShelf=True, searchAndSelect=True,
                           searchDown=True, searchMatchCase=True, searchString="",
                           searchWraps=True, select=None, selectAll=True, selectedText=True,
                           showLineNumbers=True, showTooltipHelp=True, source=True,
                           sourceType="", spacesPerTab=4, statusBarMessage="", storeContents="",
                           tabsForIndent=True, text="", textLength=True, undo=True,
                           useTemplate="", visible=True, visibleChangeCommand=None, width=0,
                           q=True, query=True, e=True, edit=True, **kwargs):
    """
    A script editor executer control used to issue script commands to Maya
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param appendText: (C E) Appends text to the end of this field
    :type appendText: string
    :param autoCloseBraces: (C Q E) Specifies whether a closing brace should automatically be
    added when hitting enter after an opening brace  (default on)
    :type autoCloseBraces: boolean
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param clear: (C E) Clears the field
    :type clear: boolean
    :param commandCompletion: (C Q E) Enable/disable command completion
    :type commandCompletion: boolean
    :param copySelection: (C E) Copies the current selection from this field
    :type copySelection: boolean
    :param currentLine: (C Q E) Sets/returns the current line which the cursor is on
    :type currentLine: int
    :param cutSelection: (C E) Cuts the current selection from this field
    :type cutSelection: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param execute: (C E) Executes the current selection  If there is no selection, all text is
    executed
    :type execute: boolean
    :param executeAll: (C E) Executes all text
    :type executeAll: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fileChangedCommand: (C E) Only valid when this field contains a file  Sets a script
    which will be called whenever the file is externally modified, renamed or removed from
    disk
    :type fileChangedCommand: script
    :param filename: (Q) Returns the full path + filename of the script which was either loaded
    or saved  If there isn't one returns an empty string
    :type filename: boolean
    :param filterKeyPress: (C Q E) Sets a script which will be called to handle key-press
    events  The function should have the following signature: proc int filterKeyPress(int
    $modifie
    :type filterKeyPress: script
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param hasFocus: (Q) Whether this control is currently in focus
    :type hasFocus: boolean
    :param hasSelection: (Q) Whether this control currently has a selection or not
    :type hasSelection: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param insertText: (C E) Inserts the specified text into the position under the cursor,
    replacing any currently selected text  The selection and cursor position can be set us
    :type insertText: string
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param load: (C E) Prompts the user for a script to load into this field  The loaded
    filename becomes associated with this executer field and saving will save directly
    :type load: boolean
    :param loadContents: (C E) Loads the contents of the specified filename into this field 
    The path and extension for this filename is provided internally  This command is only i
    :type loadContents: string
    :param loadFile: (C E) If the provided string is a fully specified file path, then attempts
    to load the file contents into this field  If the string is empty or not valid t
    :type loadFile: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param modificationChangedCommand: (C E) Sets a script which will be called whenever the
    content of this field changes in a way that affects the modification state  In MEL, the
    function shou
    :type modificationChangedCommand: script
    :param modified: (Q E) Sets or returns whether the field has been modified
    :type modified: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfLines: (Q) Returns the total number of lines in the document
    :type numberOfLines: int
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param objectPathCompletion: (C Q E) Enable/disable path completion
    :type objectPathCompletion: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param pasteSelection: (C E) Pastes text into this field at the current caret position
    :type pasteSelection: boolean
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param redo: (C E) Redo the last operation
    :type redo: boolean
    :param removeStoredContents: (C E) Removes the stored contents of this field with the
    specified filename  The path and extension for the file is provided internally  This
    command is on
    :type removeStoredContents: string
    :param replaceAll: (C E) Replaces all instances of the first string in the field text with
    the second string  The case sensitivity of this operation is set with the -searchMa
    :type replaceAll: [string, string]
    :param saveFile: (C E) Saves the entire script contents of this field directly to the
    specified file path
    :type saveFile: string
    :param saveSelection: (C E) Prompts to save the current selection to a file  The default
    filename prompt will be prepended with the given string
    :type saveSelection: string
    :param saveSelectionToShelf: (C E) Prompts to save the current selection to an item in the
    shelf
    :type saveSelectionToShelf: boolean
    :param searchAndSelect: (Q) Searches for (and selects) the specified search string using
    the specified search options
    :type searchAndSelect: boolean
    :param searchDown: (C Q E) Specifies whether to search from the cursor down, or up
    :type searchDown: boolean
    :param searchMatchCase: (C Q E) Specifies whether the search is to be case sensitive or
    not
    :type searchMatchCase: boolean
    :param searchString: (C Q E) Specifies the string to search for
    :type searchString: string
    :param searchWraps: (C Q E) Specifies whether the search should wrap around
    :type searchWraps: boolean
    :param select: (C E) Selects text within a specified range
    :type select: [int, int]
    :param selectAll: (C E) Selects all text
    :type selectAll: boolean
    :param selectedText: (Q) The text in the current selection range
    :type selectedText: boolean
    :param showLineNumbers: (C Q E) Shows/hides the line numbes column
    :type showLineNumbers: boolean
    :param showTooltipHelp: (C Q E) Enable/disable tooltips in the command execution window
    :type showTooltipHelp: boolean
    :param source: (C E) Prompts the user for a script to source (execute without loading)
    :type source: boolean
    :param sourceType: (C Q) Sets the source type for this command executer field  Valid values
    are "mel" (enabled by default) and "python"
    :type sourceType: string
    :param spacesPerTab: (C Q E) Specifies the number of spaces equivalent to one tab stop 
    (default 4)
    :type spacesPerTab: int
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param storeContents: (C E) If the provided string is a fully specified file path, then
    attempts to store the contents of this field to that path  Otherwise, uses the provided s
    :type storeContents: string
    :param tabsForIndent: (C Q E) Specifies whether tab characters should be inserted when
    indenting  (default on)
    :type tabsForIndent: boolean
    :param text: (C Q E) Replaces the field text with the given string
    :type text: string
    :param textLength: (Q) The number of characters in this text field
    :type textLength: boolean
    :param undo: (C E) Undo the last operation
    :type undo: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the executer control
    :rtype: string
    """
    pass


def ShowClusters(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeSelectUtilities(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AssetEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def characterMap(*args, mapAttr=None, mapMethod="", mapNode=None, mapping="",
                 proposedMapping=True, unmapAttr=None, unmapNode=None, q=True, query=True,
                 e=True, edit=True, **kwargs):
    """
    This command is used to create a correlation between the attributes of 2 or more characters
    
    :param mapAttr: (C Q E) In query mode, this flag can be used to query the mapping stored by
    the specified map node  It returns an array of strings  In non-query mode, this f
    :type mapAttr: [string, string]
    :param mapMethod: (C) This is is valid in create mode only  It specifies how the mapping
    should be done  Valid options are: "byNodeName", "byAttrName", and "byAttrOrder"
    :type mapMethod: string
    :param mapNode: (C Q) This flag can be used to map all the attributes on the source node to
    their matching attributes on the destination node
    :type mapNode: [string, string]
    :param mapping: (Q) This flag is valid in query mode only  It must be used before the query
    flag with a string argument  It is used for querying the mapping for a partic
    :type mapping: string
    :param proposedMapping: (Q) This flag is valid in query mode only  It is used to get an
    array of the mapping that the character map would prvide if called with the specified cha
    :type proposedMapping: boolean
    :param unmapAttr: (C E) This flag can be used to unmap the mapping stored by the specified
    map node
    :type unmapAttr: [string, string]
    :param unmapNode: (C) This flag can be used to unmap all the attributes on the source node
    to their matching attributes on the destination node  Note that mapped attribute
    :type unmapNode: [string, string]
    
    :returns: characterMap name
    :rtype: string
    """
    pass


def FBXLoadMBImportPresetFile(*args, **kwargs):
    """
    
    """
    pass


def dR_edgedFacesTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def wrinkleContext(*args, branchCount=2, branchDepth=0, exists=True, history=True, image1="",
                   image2="", image3="", name="", randomness=0.0, style="radial", thickness=0.0,
                   wrinkleCount=3, wrinkleIntensity=0.0, q=True, query=True, e=True, edit=True,
                   **kwargs):
    """
    This command creates a context that creates wrinkles
    
    :param branchCount: (C Q E) Set the number of branches spawned from a crease for radial
    wrinkles  Default is 2
    :type branchCount: int
    :param branchDepth: (C Q E) Set the depth of branching for radial wrinkles  Defaults to 0
    :type branchDepth: int
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param randomness: (C Q E) Set the deviation of the wrinkle creases from straight lines and
    other elements of the wrinkle structure  Defaults to 0.2
    :type randomness: float
    :param style: (C Q E) Set the wrinkle characteristic shape."lines"|"radial"|"custom 
    Default is "radial"
    :type style: string
    :param thickness: (C Q E) Set the thickness of wrinkle creases by setting the dropoff
    distance on the underlying wires
    :type thickness: float
    :param wrinkleCount: (C Q E) Set the number of wrinkle creases  Default is 3
    :type wrinkleCount: int
    :param wrinkleIntensity: (C Q E) Set the depth intensity of the wrinkle furrows  Defaults
    to 0.5
    :type wrinkleIntensity: float
    
    :returns: The name of the context created
    :rtype: string
    """
    pass


def ToggleIKHandleSnap(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def InvertSelection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def disable(*args, value=True, **kwargs):
    """
    This command enables or disables the control passed as argument
    
    :param value: (C) If true, this command disables the control  If false, this command
    enables the control  Default value is true (disable)
    :type value: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def CreateSculptDeformerOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TumbleTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def textFieldButtonGrp(*args, adjustableColumn=0, adjustableColumn2=0, adjustableColumn3=0,
                       adjustableColumn4=0, adjustableColumn5=0, adjustableColumn6=0,
                       annotation="", backgroundColor=None, buttonCommand=None, buttonLabel="",
                       changeCommand=None, columnAlign=None, columnAlign2=None,
                       columnAlign3=None, columnAlign4=None, columnAlign5=None,
                       columnAlign6=None, columnAttach=None, columnAttach2=None,
                       columnAttach3=None, columnAttach4=None, columnAttach5=None,
                       columnAttach6=None, columnOffset2=None, columnOffset3=None,
                       columnOffset4=None, columnOffset5=None, columnOffset6=None,
                       columnWidth=None, columnWidth1=0, columnWidth2=None, columnWidth3=None,
                       columnWidth4=None, columnWidth5=None, columnWidth6=None,
                       defineTemplate="", docTag="", dragCallback=None, dropCallback=None,
                       editable=True, enable=True, enableBackground=True, enableButton=True,
                       enableKeyboardFocus=True, exists=True, fileName="",
                       forceChangeCommand=True, fullPathName=True, height=0,
                       highlightColor=None, insertText="", insertionPosition=0, isObscured=True,
                       label="", manage=True, noBackground=True, numberOfPopupMenus=True,
                       parent="", placeholderText="", popupMenuArray=True, preventOverride=True,
                       rowAttach=None, statusBarMessage="", text="", textChangedCommand=None,
                       useTemplate="", visible=True, visibleChangeCommand=None, width=0, q=True,
                       query=True, e=True, edit=True, **kwargs):
    """
    All of the group commands position their individual controls in columns starting at column
    1  The layout of each control (ie  column) can be customized using the -cw/columnWidth,
    -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumn flags  By
    default, columns are left aligned with no offset and are 100 pixels wide  Only o
    
    :param adjustableColumn: (C E) Specifies which column has an adjustable size that changes
    with the sizing of the layout  The column value is a 1-based index  Passing 0 as argument
    :type adjustableColumn: int
    :param adjustableColumn2: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly two columns
    :type adjustableColumn2: int
    :param adjustableColumn3: (C E) Specifies that the column has an adjustable size that
    changes with the size of the parent layout  Ignored if there are not exactly three columns
    :type adjustableColumn3: int
    :param adjustableColumn4: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly four columns
    :type adjustableColumn4: int
    :param adjustableColumn5: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly five columns
    :type adjustableColumn5: int
    :param adjustableColumn6: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly six columns
    :type adjustableColumn6: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param buttonCommand: (C E) Command attached to the button
    :type buttonCommand: script
    :param buttonLabel: (C Q E) Label text of the button
    :type buttonLabel: string
    :param changeCommand: (C E) Command executed when the field text changes and user presses
    Enter or Return
    :type changeCommand: script
    :param columnAlign: (C E M) Arguments are : column number, alignment type  Possible
    alignments are: left | right | center  Specifies alignment type for the specified column
    :type columnAlign: [int, string]
    :param columnAlign2: (C E) Sets the text alignment of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "center"
    :type columnAlign2: [string, string]
    :param columnAlign3: (C E) Sets the text alignment for all three columns  Ignored if there
    are not exactly three columns  Valid values are "left", "right", and "center"
    :type columnAlign3: [string, string, string]
    :param columnAlign4: (C E) Sets the text alignment for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "center"
    :type columnAlign4: [string, string, string, string]
    :param columnAlign5: (C E) Sets the text alignment for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "center"
    :type columnAlign5: [string, string, string, string, string]
    :param columnAlign6: (C E) Sets the text alignment for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "center"
    :type columnAlign6: [string, string, string, string, string, string]
    :param columnAttach: (C E M) Arguments are : column number, attachment type, and offset 
    Possible attachments are: left | right | both  Specifies column attachment types and offe
    :type columnAttach: [int, string, int]
    :param columnAttach2: (C E) Sets the attachment type of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "both"
    :type columnAttach2: [string, string]
    :param columnAttach3: (C E) Sets the attachment type for all three columns  Ignored if
    there are not exactly three columns  Valid values are "left", "right", and "both"
    :type columnAttach3: [string, string, string]
    :param columnAttach4: (C E) Sets the attachment type for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "both"
    :type columnAttach4: [string, string, string, string]
    :param columnAttach5: (C E) Sets the attachment type for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "both"
    :type columnAttach5: [string, string, string, string, string]
    :param columnAttach6: (C E) Sets the attachment type for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "both"
    :type columnAttach6: [string, string, string, string, string, string]
    :param columnOffset2: (C E) This flag is used in conjunction with the -columnAttach2 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the tw
    :type columnOffset2: [int, int]
    :param columnOffset3: (C E) This flag is used in conjunction with the -columnAttach3 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the th
    :type columnOffset3: [int, int, int]
    :param columnOffset4: (C E) This flag is used in conjunction with the -columnAttach4 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fo
    :type columnOffset4: [int, int, int, int]
    :param columnOffset5: (C E) This flag is used in conjunction with the -columnAttach5 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fi
    :type columnOffset5: [int, int, int, int, int]
    :param columnOffset6: (C E) This flag is used in conjunction with the -columnAttach6 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the si
    :type columnOffset6: [int, int, int, int, int, int]
    :param columnWidth: (C E M) Arguments are : column number, column width  Sets the width of
    the specified column where the first parameter specifies the column (1 based index) an
    :type columnWidth: [int, int]
    :param columnWidth1: (C E) Sets the width of the first column  Ignored if there is not
    exactly one column
    :type columnWidth1: int
    :param columnWidth2: (C E) Sets the column widths of both columns  Ignored if there are not
    exactly two columns
    :type columnWidth2: [int, int]
    :param columnWidth3: (C E) Sets the column widths for all 3 columns  Ignored if there are
    not exactly 3 columns
    :type columnWidth3: [int, int, int]
    :param columnWidth4: (C E) Sets the column widths for all 4 columns  Ignored if there are
    not exactly 4 columns
    :type columnWidth4: [int, int, int, int]
    :param columnWidth5: (C E) Sets the column widths for all 5 columns  Ignored if there are
    not exactly 5 columns
    :type columnWidth5: [int, int, int, int, int]
    :param columnWidth6: (C E) Sets the column widths for all 6 columns  Ignored if there are
    not exactly 6 columns
    :type columnWidth6: [int, int, int, int, int, int]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param editable: (C Q E) The edit state of the field  By default, this flag is set to true
    and the field value may be changed by typing into it  If false then the field is 'r
    :type editable: boolean
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableButton: (C Q E) Enable state of the button  By default, this flag is set to
    true and the button is enabled  Specify true, and the button will appear dimmed or greyed
    :type enableButton: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fileName: (C Q E) Text in the field as a filename  This does conversions between
    internal and external (UI) file representation
    :type fileName: string
    :param forceChangeCommand: (C E) If used together with -text or -inserText flag, change
    command will be executed after text modification
    :type forceChangeCommand: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param insertText: (C E) Insert text into the field at the current insertion position
    (specified by the -ip/insertionPosition flag)
    :type insertText: string
    :param insertionPosition: (C Q E) The insertion position for inserted text  This is a 1
    based value where position 1 specifies the beginning of the field  Position 0 may be used
    to sp
    :type insertionPosition: int
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) Label text for the group
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param placeholderText: (C Q E) Setting this property makes the line edit display a
    grayed-out placeholder text as long as the text field is empty and the widget doesn't have
    focus
    :type placeholderText: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rowAttach: (C E M) Arguments are : column, attachment type, offset  Possible
    attachments are: top | bottom | both  Specifies attachment types and offsets for the
    entire
    :type rowAttach: [int, string, int]
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param text: (C Q E) Text in the field
    :type text: string
    :param textChangedCommand: (C E) Command executed immediately when the field text changes
    :type textChangedCommand: script
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def RigidBodySolver(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FrameAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def psdExport(*args, alphaChannelIdx=0, bytesPerChannel=0, emptyLayerSet=True, format="",
              layerName="", layerSetName="", outFileName="", preMultiplyAlpha=True,
              psdFileName="", q=True, query=True, **kwargs):
    """
    Writes the Photoshop file layer set into different formats  The output file depth (bit per
    channel ) can be different from that of the input  If the input is 16 bpc and output is 8
    bpc, there will be data loss
    
    :param alphaChannelIdx: (C Q) Index of the alpha channel to output, if not supplied, writes
    out the default alpha channel  The index is zero based  This is useful to write out spe
    :type alphaChannelIdx: int
    :param bytesPerChannel: (C Q) Output file depth  Any of these keyword: 0 for choosing depth
    based on input 1 for 8 bits per channel 2 for 16 bits per channel Default is 0
    :type bytesPerChannel: int
    :param emptyLayerSet: (C Q) Option to check if the given layer set is empty or not  This
    should be used in query mode and input file name and layer set names should be specified
    :type emptyLayerSet: boolean
    :param format: (C Q) Output file format  Any of these keyword: "iff", "sgi", "pic", "tif",
    "als", "gif", "rla", "jpg" Default is iff
    :type format: string
    :param layerName: (C Q) Name of the layer to output
    :type layerName: string
    :param layerSetName: (C Q) Name of the layer set to output, if not supplied, writes out the
    Composite image  In query mode, this flag needs a value
    :type layerSetName: string
    :param outFileName: (C Q) Name(with path) of the output file
    :type outFileName: string
    :param preMultiplyAlpha: (C Q) Option to multiply RGB colors with alpha values  If (r,g,b,
    a) is the value of pixel, it will be changed to (r*a, g*a, b*a, a) when this flag is used
    :type preMultiplyAlpha: boolean
    :param psdFileName: (C Q) Name(with path) of the input Photoshop file  In query mode, this
    flag needs a value
    :type psdFileName: string
    
    :returns: 
    :rtype: None
    """
    pass


def evaluationManager(*args, cycleCluster="", disableInfo="", empty=True, enabled=True,
                      idleAction=0, idleBuild=True, invalidate=True, manipulation=True,
                      manipulationReady=True, mode="", downstreamFrom="",
                      nodeTypeGloballySerialize=True, nodeTypeParallel=True,
                      nodeTypeSerialize=True, nodeTypeUntrusted=True, upstreamFrom="",
                      safeMode=True, q=True, query=True, **kwargs):
    """
    Handles turning on and off the evaluation manager method of evaluating the DG  Query the
    'mode' flag to see all available evaluation modes  The special mode 'off' disables the
    evaluation manager  The scheduling override flags 'nodeTypeXXX' force certain node types to
    use specific scheduling types, even though the node descriptions might indicate ot
    
    :param cycleCluster: (C Q) Returns a list of nodes that are stored together with the given
    one in a cycle cluster  The list will be empty when the evaluation mode is not active
    :type cycleCluster: string
    :param disableInfo: (Q) Returns a list of strings that contain the reasons that the
    evaluation manager has been disabled (as distinct from it being deliberately turned off,
    :type disableInfo: string
    :param empty: (Q) Valid in query mode only  Checks to see if the evaluation graph has any
    nodes in it  This is independent of the current mode
    :type empty: boolean
    :param enabled: (Q) Valid in query mode only  Checks to see if the evaluation manager is
    currently enabled  This is independent of the current mode
    :type enabled: boolean
    :param idleAction: (C Q) This flag sets the actions EM will perform on idle  It accepts the
    following values: 0 - No action 1 - Graph Rebuild 2 - EM Manipulation Preparation
    :type idleAction: int
    :param idleBuild: (C Q) This flag is obsolete  Please use the -idleAction flag with a value
    of 1 in order to activate evaluation graph rebuild on idle
    :type idleBuild: boolean
    :param invalidate: (C Q) This flag invalidates the graph  Value is used to control auto
    rebuilding on idle (false) or forced (true)  This command should be used as a last res
    :type invalidate: boolean
    :param manipulation: (C Q) This flag is used to activate evaluation manager manipulation
    support
    :type manipulation: boolean
    :param manipulationReady: (Q) Valid in query mode only  Checks to see if the evaluation
    manager manipulation is currently ready/allowed  This is independent of the current mode
    :type manipulationReady: boolean
    :param mode: (C Q) Changes the current evaluation mode in the evaluation manager  Supported
    values are "off", "serial" and "parallel"
    :type mode: string
    :param downstreamFrom: (C Q) Find the DG nodes that are immediately downstream of the named
    one in the evaluation graph  Note that the connectivity is via evaluation mode connect
    :type downstreamFrom: string
    :param nodeTypeGloballySerialize: (C Q) This flag is used only when the evaluation manager
    is in "parallel" mode but can be set at anytime  It activates or deactivates the override
    to force
    :type nodeTypeGloballySerialize: boolean
    :param nodeTypeParallel: (C Q) This flag is used only when the evaluation manager is in
    "parallel" mode but can be set at anytime  It activates or deactivates the override to
    force
    :type nodeTypeParallel: boolean
    :param nodeTypeSerialize: (C Q) This flag is used only when the evaluation manager is in
    "parallel" mode but can be set at anytime  It activates or deactivates the override to
    force
    :type nodeTypeSerialize: boolean
    :param nodeTypeUntrusted: (C Q) This flag is used only when the evaluation manager is in
    "parallel" mode but can be set at anytime  It activates or deactivates the override to
    force
    :type nodeTypeUntrusted: boolean
    :param upstreamFrom: (C Q) Find the DG nodes that are immediately upstream of the named one
    in the evaluation graph  Note that the connectivity is via evaluation mode connectio
    :type upstreamFrom: string
    :param safeMode: (C Q) This flag activates/deactivates parallel evaluation safe mode  When
    enabled, parallel execution will fall back to serial when evaluation graph is mis
    :type safeMode: boolean
    
    :returns: The names of all evaluation manager modes (querying without flags)
    :rtype: string[]
    """
    pass


def DuplicateFace(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def artSetPaintCtx(*args, accopacity=False, afterStrokeCmd="", beforeStrokeCmd="",
                   brushalignment=True, brushfeedback=True, clear=True, dragSlider="",
                   dynclonemode=True, exists=True, expandfilename=True, exportaspectratio=0.0,
                   exportfilemode="luminance/rgb", exportfilesave="", exportfilesizex=0,
                   exportfilesizey=0, exportfiletype="", history=True, image1="", image2="",
                   image3="", importfileload="", importfilemode="alpha", importreassign=False,
                   lastRecorderCmd="", lastStampName="", lowerradius=0.0, makeStroke=0,
                   mappressure="none", name="", objectsetnames="", opacity=1.0, outline=True,
                   outwhilepaint=False, paintmode="screen", paintoperationtype="Paint",
                   pickColor=True, pickValue=True, playbackCursor=None, playbackPressure=0.0,
                   preserveclonesource=True, profileShapeFile="", projective=False, radius=1.0,
                   record=True, reflection=False, reflectionaboutorigin=True,
                   reflectionaxis="x", screenRadius=0.0, selectclonesource=True,
                   setcolorfeedback=True, setdisplaycvs=True, setopertype="add", settomodify="",
                   showactive=True, stampDepth=0.0, stampProfile="", stampSpacing=1.0,
                   strokesmooth="", surfaceConformedBrushVertices=True, tablet=True,
                   tangentOutline=True, usepressure=False, worldRadius=0.0, q=True, query=True,
                   e=True, edit=True, **kwargs):
    """
    This tool allows the user to modify the set membership (add, transfer, remove cvs) on nurbs
    surfaces using Maya Artisan's interface
    
    :param accopacity: (C Q E) Sets opacity accumulation on/off  C: Default is false (Except
    for sculpt tool for which it is true by default)  Q: When queried, it returns a boolean
    :type accopacity: boolean
    :param afterStrokeCmd: (C Q E) The passed string is executed as a MEL command immediately
    after the end of a stroke  C: Default is no command  Q: When queried, it returns the curre
    :type afterStrokeCmd: string
    :param beforeStrokeCmd: (C Q E) The passed string is executed as a MEL command immediately
    before the start of a stroke  C: Default is no command  Q: When queried, it returns the cu
    :type beforeStrokeCmd: string
    :param brushalignment: (C Q E) Specifies the path brush alignemnt  If true, the brush will
    align to stroke path, otherwise it will align to up vector  C: Default is true  Q: When q
    :type brushalignment: boolean
    :param brushfeedback: (C Q E) Specifies if the brush additional feedback should be drawn 
    C: Default is TRUE  Q: When queried, it returns a boolean
    :type brushfeedback: boolean
    :param clear: (C E) Floods all cvs/vertices to the current value
    :type clear: boolean
    :param dragSlider: (C E) Sets the current brush drag state for resizing or offsetting the
    brush (like the 'b' and 'm' default hotkeys)  The string argument is one of: "radius
    :type dragSlider: string
    :param dynclonemode: (C Q E) Enable or disable dynamic clone mode
    :type dynclonemode: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param expandfilename: (C E) If true, it will expand the name of the export file and
    concatenate it with the surface name  Otherwise it will take the name as it is  C: Default
    is
    :type expandfilename: boolean
    :param exportaspectratio: (C Q E) Value of aspect ratio for export
    :type exportaspectratio: float
    :param exportfilemode: (C Q E) Specifies the export channel.The valid entries here are:
    "alpha", "luminance", "rgb", "rgba"  C: Default is "luminance/rgb"  Q: When queried, it
    retu
    :type exportfilemode: string
    :param exportfilesave: (E) Exports the attribute map and saves to a specified file
    :type exportfilesave: string
    :param exportfilesizex: (C Q E) Specifies the width of the attribute map to export  C:
    Default width is 256  Q: When queried, it returns an integer
    :type exportfilesizex: int
    :param exportfilesizey: (C Q E) Specifies the width of the attribute map to export  C:
    Default width is 256  Q: When queried, it returns an integer
    :type exportfilesizey: int
    :param exportfiletype: (C Q E) Specifies the image file format  It can be one of the
    following: "iff", "tiff", "jpeg", "alias", "rgb", "fit" "postScriptEPS", "softimage",
    "wavefron
    :type exportfiletype: string
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param importfileload: (E) Load the attribute map a specified file
    :type importfileload: string
    :param importfilemode: (C Q E) Specifies the channel to import  The valid entries here are:
    "alpha", "luminance", "red", "green", "blue", and "rgb" C: Default is "alpha"  Q: When q
    :type importfilemode: string
    :param importreassign: (C Q E) Specifies if the multiply atrribute maps are to be
    reassigned while importing  Only maps previously exported from within Artisan can be
    reassigned  C
    :type importreassign: boolean
    :param lastRecorderCmd: (C Q E) Value of last recorded command
    :type lastRecorderCmd: string
    :param lastStampName: (C Q E) Value of the last stamp name
    :type lastStampName: string
    :param lowerradius: (C Q E) Sets the lower size of the brush (only apply on tablet)
    :type lowerradius: float
    :param makeStroke: (C Q E M) Stroke point values
    :type makeStroke: int
    :param mappressure: (C Q E) Sets the tablet pressure mapping when the table is used  There
    are four options: "none" - the pressure has no effect, "opacity" - the pressure is map
    :type mappressure: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param objectsetnames: (C Q E) Default name of object sets
    :type objectsetnames: string
    :param opacity: (C Q E) Sets the brush opacity  C: Default is 1.0  Q: When queried, it
    returns a float
    :type opacity: float
    :param outline: (C Q E) Specifies if the brush should be drawn  C: Default is TRUE  Q: When
    queried, it returns a boolean
    :type outline: boolean
    :param outwhilepaint: (C Q E) Specifies if the brush outline should be drawn while painting
     C: Default is FALSE  Q: When queried, it returns a boolean
    :type outwhilepaint: boolean
    :param paintmode: (C Q E) Specifies the paint mode  There are two possibilities: "screen"
    and "tangent"  C: Default is "screen"  Q: When queried, it returns a string
    :type paintmode: string
    :param paintoperationtype: (C Q E) Specifies the operation type used by the Paint Tool 
    Currently, we support the following paint modes: "Paint", "Smear", "Blur", "Erase" and
    "Clone"
    :type paintoperationtype: string
    :param pickColor: (C Q E) Set pick color mode on or off
    :type pickColor: boolean
    :param pickValue: (C Q E) Toggle for picking
    :type pickValue: boolean
    :param playbackCursor: (C Q E M) Values for the playback cursor
    :type playbackCursor: [float, float]
    :param playbackPressure: (C Q E M) Valus for the playback pressure
    :type playbackPressure: float
    :param preserveclonesource: (C Q E) Whether or not to preserve a clone source
    :type preserveclonesource: boolean
    :param profileShapeFile: (Q E) Passes a name of the image file for the stamp shape profile
    :type profileShapeFile: string
    :param projective: (C Q E) Specifies the projective paint mode  C: Default is 'false'  Q:
    When queried, it returns a boolean
    :type projective: boolean
    :param radius: (C Q E) Sets the size of the brush  C: Default is 1.0 cm  Q: When queried,
    it returns a float
    :type radius: float
    :param record: (C Q E) Toggle on for recording
    :type record: boolean
    :param reflection: (C Q E) Specifies the reflection mode  C: Default is 'false'  Q: When
    queried, it returns a boolean
    :type reflection: boolean
    :param reflectionaboutorigin: (C Q E) Toggle on to reflect about the origin
    :type reflectionaboutorigin: boolean
    :param reflectionaxis: (C Q E) Specifies the reflection axis  There are three
    possibilities: "x", "y" and "z"  C: Default is "x"  Q: When queried, it returns a string
    :type reflectionaxis: string
    :param screenRadius: (C Q E) Brush radius on the screen
    :type screenRadius: float
    :param selectclonesource: (C Q E) Toggle on to select the clone source
    :type selectclonesource: boolean
    :param setcolorfeedback: (C Q E) Specifies if the color feedback is on or off  C: Default
    is ON  Q: When queried, it returns a boolean
    :type setcolorfeedback: boolean
    :param setdisplaycvs: (C Q E) Specifies if the active cvs are displayed  C: Default is ON 
    Q: When queried, it returns a boolean
    :type setdisplaycvs: boolean
    :param setopertype: (C Q E) Specifies the setEdit operation ("add", "transfer", "remove") 
    C: Default is "add"  Q: When queried, it returns a string
    :type setopertype: string
    :param settomodify: (C Q E) Specifies the name of the set to modify  Q: When queried, it
    returns a string
    :type settomodify: string
    :param showactive: (C Q E) Sets on/off the display of the surface isoparms  C: Default is
    TRUE  Q: When queried, it returns a boolean
    :type showactive: boolean
    :param stampDepth: (C Q E) Depth of the stamps
    :type stampDepth: float
    :param stampProfile: (C Q E) Sets the brush profile of the current stamp  Currently, the
    following profiles are supported: "gaussian", "poly", "solid" and "square"  C: Default is
    :type stampProfile: string
    :param stampSpacing: (C Q E) Specifies the stamp spacing  Default is 1.0
    :type stampSpacing: float
    :param strokesmooth: (C Q E) Stroke smoothing type name
    :type strokesmooth: string
    :param surfaceConformedBrushVertices: (C Q E) Enables/disables the the display of the
    effective brush area as affected vertices
    :type surfaceConformedBrushVertices: boolean
    :param tablet: (Q) Returns true if the tablet device is present, false if it is absent
    :type tablet: boolean
    :param tangentOutline: (C Q E) Enables/disables the display of the brush circle tangent to
    the surface
    :type tangentOutline: boolean
    :param usepressure: (C Q E) Sets the tablet pressure on/off  C: Default is false  Q: When
    queried, it returns a boolean
    :type usepressure: boolean
    :param worldRadius: (C Q E) Radius in worldspace
    :type worldRadius: float
    
    :returns: 
    :rtype: None
    """
    pass


def igConvertToLogical(*args, **kwargs):
    """
    
    """
    pass


def PublishConnectionsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolygonBooleanIntersectionOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def cacheFile(*args, appendFrame=True, attachFile=True, cacheFileNode="", cacheFormat="",
              cacheInfo="", cacheableAttrs="", cacheableNode="", channelIndex=True,
              channelName="", convertPc2=True, createCacheNode=True, creationChannelName="",
              dataSize=True, deleteCachedFrame=True, descriptionFileName=True, directory="",
              doubleToFloat=True, endTime=None, fileName="", format="", geometry=True,
              inAttr="", inTangent="", interpEndTime=None, interpStartTime=None, noBackup=True,
              outAttr="", outTangent="", pc2File="", pointCount=True, points="",
              pointsAndNormals="", prefix=True, refresh=True, replaceCachedFrame=True,
              replaceWithoutSimulating=True, runupFrames=2, sampleMultiplier=1,
              simulationRate=None, singleCache=True, startTime=None, staticCache=True,
              worldSpace=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Creates one or more cache files on disk to store attribute data for a span of frames  The
    caches can be created for points/normals on a geometry (using the pts/points or
    pan/pointsAndNormals flag), for vectorArray output data (using the oa/outAttr flag), or for
    additional node specific data (using the cnd/cacheableNode flag for those nodes that
    sup
    
    :param appendFrame: (C) Appends data to the cache for the times specified by the startTime
    and endTime flags  If no time is provided, appends the current time  Must be used
    :type appendFrame: boolean
    :param attachFile: (C) Used to indicate that rather than creating a cache file, that an
    existing cache file on disk should be attached to an attribute in the scene  The inA
    :type attachFile: boolean
    :param cacheFileNode: (C M) Specifies the name of the cache file node(s) we are
    appending/replacing to if more than one cache is attached to the specified geometries  In
    query m
    :type cacheFileNode: string
    :param cacheFormat: (C Q) Cache file format, default is Maya's .mcx format, but others
    available via plugin
    :type cacheFormat: string
    :param cacheInfo: (C Q M) In create mode, used to specify a mel script returning a string
    array  When creating the cache, this mel script will be executed and the returned str
    :type cacheInfo: string
    :param cacheableAttrs: (Q) Returns the list of cacheable attributes defined on the
    accompanying cache node  This argument requires the use of the cacheableNode flag
    :type cacheableAttrs: string
    :param cacheableNode: (C M) Specifies the name of a cacheable node whose contents will be
    cached  A cacheable node is a node that is specially designed to work with the caching
    :type cacheableNode: string
    :param channelIndex: (C Q) A query-only flag which returns the channel index for the
    selected geometry for the cacheFile node specified using the cacheFileNode flag
    :type channelIndex: boolean
    :param channelName: (C Q M) When attachFile is used, used to indicate the channel in the
    file that should be attached to inAttr  If not specified, the first channel in the file
    :type channelName: string
    :param convertPc2: (C) Convert a PC2 file to the Maya cache format (true), or convert Maya
    cache to pc2 format (false)
    :type convertPc2: boolean
    :param createCacheNode: (C) Used to indicate that rather than creating a cache file, that a
    cacheFile node should be created related to an existing cache file on disk
    :type createCacheNode: boolean
    :param creationChannelName: (C M) When creating a new cache, this multi-use flag specifies
    the channels to be cached  The names come from the cacheable channel names defined by the
    ob
    :type creationChannelName: string
    :param dataSize: (Q) This is a query-only flag that returns the size of the data being
    cached per frame  This flag is to be used in conjunction with the cacheableNode, po
    :type dataSize: boolean
    :param deleteCachedFrame: (C) Deletes cached data for the times specified by the
    startTime/endTime flags  If no time is provided, deletes the current frame  Must be used in
    conjun
    :type deleteCachedFrame: boolean
    :param descriptionFileName: (Q) This is a query-only flag that returns the name of the
    description file for an existing cacheFile node  Or if no cacheFile node is specified, it
    retu
    :type descriptionFileName: boolean
    :param directory: (C Q) Specifies the directory where the cache files will be located  If
    the directory flag is not specified, the cache files will be placed in the project
    :type directory: string
    :param doubleToFloat: (C) During cache creation, double data is stored in the file as
    floats  This helps cut down file size
    :type doubleToFloat: boolean
    :param endTime: (C) Specifies the end frame of the cache range
    :type endTime: time
    :param fileName: (C Q) Specifies the base file name for the cache files  If more than one
    object is being cached and the format is OneFilePerFrame, each cache file will be
    :type fileName: string
    :param format: (C) Specifies the distribution format of the cache  Valid values are
    "OneFile" and "OneFilePerFrame"
    :type format: string
    :param geometry: (Q) A query flag which returns the geometry controlled by the specified
    cache node
    :type geometry: boolean
    :param inAttr: (C M) Specifies the name of the attribute that the cache file will drive 
    This file is optional when creating cache files  If this flag is not used during
    :type inAttr: string
    :param inTangent: (C) Specifies the in-tangent type when interpolating frames before the
    replaced frame(s)  Must be used with the ist/interpStartTime and iet/interpEndTime
    :type inTangent: string
    :param interpEndTime: (C) Specifies the frame until which there will be linear
    interpolation, beginning at endTime  Must be used with the rpf/replaceCachedFrame or
    apf/appendF
    :type interpEndTime: time
    :param interpStartTime: (C) Specifies the frame from which to begin linear interpolation,
    ending at startTime  Must be used with the rpf/replaceCachedFrame or apf/appendFrame fl
    :type interpStartTime: time
    :param noBackup: (C) Specifies that backup files should not be created for any files that
    may be over-written during append, replace or delete cache frames  Can only be u
    :type noBackup: boolean
    :param outAttr: (C M) Specifies the name of the attribute that will be cached to disk  In
    query mode, this flag needs a value
    :type outAttr: string
    :param outTangent: (C) Specifies the out-tangent type when interpolating frames after the
    replaced frame(s)  Must be used with the ist/interpStartTime and iet/interpEndTime
    :type outTangent: string
    :param pc2File: (C) Specifies the full path to the pc2 file  Must be used in conjunction
    with the pc2 flag
    :type pc2File: string
    :param pointCount: (Q) A query flag which returns the number of points stored in the cache
    file  The channelName flag should be used to specify the channel to be queried
    :type pointCount: boolean
    :param points: (C M) Specifies the name of a geometry whose points will be cached  In query
    mode, this flag needs a value
    :type points: string
    :param pointsAndNormals: (C M) Specifies the name of a geometry whose points and normals
    will be cached  The normals is per-vertex per-polygon  The normals cache cannot be
    imported
    :type pointsAndNormals: string
    :param prefix: (C) Indicates that the specified fileName should be used as a prefix for the
    cacheName
    :type prefix: boolean
    :param refresh: (C) When used during cache creation, forces a screen refresh during caching
     This causes the cache creation to be slower but allows you to see how the si
    :type refresh: boolean
    :param replaceCachedFrame: (C) Replaces cached data for the times specified by the
    startTime/endTime flags  If no time is provided, replaces cache file for the current time 
    Must b
    :type replaceCachedFrame: boolean
    :param replaceWithoutSimulating: (E) When replacing cached frames, this flag specifies
    whether the replacement should come from the cached node without simulating or from
    advancing time
    :type replaceWithoutSimulating: boolean
    :param runupFrames: (C Q E) Specifies the number of frames of runup to simulate ahead of
    the starting frame  The value must be greater than or equal to 0  The default is 2
    :type runupFrames: int
    :param sampleMultiplier: (C Q E) Specifies the sample rate when caches are being created as
    a multiple of simulation Rate  If the value is 1, then a sample will be cached everytime t
    :type sampleMultiplier: int
    :param simulationRate: (C Q E) Specifies the simulation rate when caches are being created 
    During cache creation, the time will be advanced by the simulation rate, until the end t
    :type simulationRate: time
    :param singleCache: (C) When used in conjunction with the points, pointsAndNormal or
    cacheableNode flag, specifies whether multiple geometries should be put into a single ca
    :type singleCache: boolean
    :param startTime: (C) Specifies the start frame of the cache range
    :type startTime: time
    :param staticCache: (C Q) If false, during cache creation, do not save a cache for the
    object if it appears to have no animation or deformation  If true, save a cache even if
    :type staticCache: boolean
    :param worldSpace: (C) If the points flag is used, turning on this flag will result in the
    world space positions of the points being written  The expected use of this flag
    :type worldSpace: boolean
    
    :returns: name of created cache description file(s)
    :rtype: string
    """
    pass


def LookAtSelection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def setToolTo(*args, **kwargs):
    """
    This command switches control to the named context
    
    
    :returns: 
    :rtype: None
    """
    pass


def setKeyCtx(*args, breakdown=True, exists=True, history=True, image1="", image2="", image3="",
              name="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a context which may be used to set keys within the graph editor
    
    :param breakdown: (Q E) Specifies whether or not to create breakdown keys
    :type breakdown: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: Value of the breakdown flag, when queried
    :rtype: boolean
    """
    pass


def SetProject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def defaultNavigation(*args, connectToExisting=True, createNew=True, defaultAttribute=True,
                      defaultTraversal=True, defaultWorkingNode=True, delete=True,
                      destination=None, disconnect=True, force=True, ignore=True,
                      navigatorDecisionString="", quiet=True, relatedNodes=True, source=None,
                      unignore=True, **kwargs):
    """
    The defaultNavigation command defines default behaviours when creating or manipulating
    connections between nodes and when navigating between nodes via those connections  This
    command is primarily used by attribute editors
    
    :param connectToExisting: (C) Connect the destination (which is a node.attribute or simply
    node) to an existing source  If the source is specified (as node.attribute or simply as
    :type connectToExisting: boolean
    :param createNew: (C) Create a new node and connect it to the node.attribute specified
    using the destination flag
    :type createNew: boolean
    :param defaultAttribute: (C) Returns the name of the attribute to which a connectNodeToNode
    would connect, given the source (attribute) and destination (node) flags  Returns a st
    :type defaultAttribute: boolean
    :param defaultTraversal: (C) Returns the name of the node to which it would make the most
    sense to navigate to from the destination node.attribute specified  The destination is s
    :type defaultTraversal: boolean
    :param defaultWorkingNode: (C) Returns the name of the node which the user is most likely
    to want to work with if they are interested in the attributes of the destination node  The
    :type defaultWorkingNode: boolean
    :param delete: (C) Delete nodes with connections flowing into the node.attribute specified
    by the destination flag
    :type delete: boolean
    :param destination: (C) Specifies an existing destination attribute for a createNew or
    connectToExisting
    :type destination: name
    :param disconnect: (C) If used then disconnect the destination if it exists
    :type disconnect: boolean
    :param force: (C) If set to true, then an attempt to connect a source attribute to a
    destination attribute which already has a source will cause the existing source to
    :type force: boolean
    :param ignore: (C) Ignore any connections flowing into the node.attribute specified by the
    destination flag
    :type ignore: boolean
    :param navigatorDecisionString: (C) This is your opportunity to pass the navigator a string
    that can help it decide what behaviour to execute
    :type navigatorDecisionString: string
    :param quiet: (C) If set to true, then under no circumstances should the user be prompted
    for more information  Default value is false
    :type quiet: boolean
    :param relatedNodes: (C) List nodes which are conceptually related to the node.attribute
    specified by the destination  Related nodes may include, but are not limited to, node
    :type relatedNodes: boolean
    :param source: (C) Specifies an existing source attribute for a connectToExisting
    :type source: name
    :param unignore: (C) Stop ignoring any connections flowing into the node.attribute
    specified by the destination flag
    :type unignore: boolean
    
    :returns: or array of strings
    :rtype: string
    """
    pass


def NodeEditorToggleZoomIn(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyCreaseCtx(*args, createSet="", exists=True, extendSelection=True, image1="", image2="",
                  image3="", relative=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Create a new context to crease components on polygonal objects
    
    :param createSet: (E) Creates a set for the selected components
    :type createSet: string
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param extendSelection: (C Q E) Enable/disable extending selection to all connected creased
    components
    :type extendSelection: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param relative: (C Q E) Enable/disable applying value relative to existing crease value 
    If disabled, absolute value is applied
    :type relative: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def hikGetEffectorIdFromName(*args, **kwargs):
    """
    
    """
    pass


def SetVertexNormal(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowMeshCloneTargetToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polySplitCtx2(*args, exists=True, image1="", image2="", image3="", adjustEdgeFlow=0.0,
                  constrainToEdges=True, edgeMagnets=0, insertWithEdgeFlow=True,
                  snapTolerance=0.0, snappedToEdgeColor=None, snappedToFaceColor=None,
                  snappedToMagnetColor=None, snappedToVertexColor=None, q=True, query=True,
                  e=True, edit=True, **kwargs):
    """
    Create a new context to split facets on polygonal objects
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param adjustEdgeFlow: (C Q E) The weight value of the edge vertices to be positioned
    :type adjustEdgeFlow: float
    :param constrainToEdges: (C Q E) Enable/disable snapping to edge  If enabled any click in
    the current face will snap to the closest valid edge  If there is no valid edge, the click
    w
    :type constrainToEdges: boolean
    :param edgeMagnets: (C Q E) number of extra magnets to snap onto, regularly spaced along
    the edge
    :type edgeMagnets: int
    :param insertWithEdgeFlow: (C Q E) True to enable edge flow  Otherwise, the edge flow is
    disabled
    :type insertWithEdgeFlow: boolean
    :param snapTolerance: (C Q E) precision for custom magnet snapping  Range[0,1]  Value 1
    means any click on an edge will snap to either extremities or magnets
    :type snapTolerance: float
    :param snappedToEdgeColor: (C Q E) Color for edge snapping
    :type snappedToEdgeColor: [float, float, float]
    :param snappedToFaceColor: (C Q E) Color for face snapping
    :type snappedToFaceColor: [float, float, float]
    :param snappedToMagnetColor: (C Q E) Color for magnet snapping
    :type snappedToMagnetColor: [float, float, float]
    :param snappedToVertexColor: (C Q E) Color for vertex snapping
    :type snappedToVertexColor: [float, float, float]
    
    :returns: 
    :rtype: None
    """
    pass


def IntersectSurfaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SculptSubdivsToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GpuCacheExportAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def InTangentAuto(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CenterViewOfSelection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorClipScaleToggle(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleRotationPivots(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MoveRight(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MergeEdgeToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleProxyDisplay(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UntemplateObject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateWrapOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GraphEditorFrameAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowSmoothSkinInfluences(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectUVShell(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ZoomTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ParticleFillOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ResetWeightsToDefault(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UVPlanarProjection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def psdEditTextureFile(*args, addChannel="", addChannelColor=None, addChannelImage=None,
                       deleteChannel="", psdFileName="", snapShotImage="",
                       uvSnapPostionTop=True, **kwargs):
    """
    Edits the existing PSD file  Addition and deletion of the channels (layer sets) are
    supported
    
    :param addChannel: (C M) Adds an empty layer set with the given name to a already existing
    PSD file
    :type addChannel: string
    :param addChannelColor: (C M) (M) Specifies the filled color of the layer which is created
    in a layer set given by the layer name
    :type addChannelColor: [string, float, float, float]
    :param addChannelImage: (C M) (M) Specifies the image file name whose image needs to be
    added as a layer to a given layer set which is the first string
    :type addChannelImage: [string, string]
    :param deleteChannel: (C M) (M) Deletes the channels (layer sets) from a PSD file  This is
    a multiuse flag
    :type deleteChannel: string
    :param psdFileName: (C) PSD file name
    :type psdFileName: string
    :param snapShotImage: (C) Image file name on the disk containing UV snapshot / reference
    image
    :type snapShotImage: string
    :param uvSnapPostionTop: (C) Specifies the position of UV snapshot image layer in the PSD
    file  "True" positions this layer at the top and "False" positions the layer at the bott
    :type uvSnapPostionTop: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def SelectAllPolygonGeometry(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TwoSideBySideViewArrangement(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleFastInteraction(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TogglePaintOnPaintableObjects(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dynPaintCtx(*args, **kwargs):
    """
    
    """
    pass


def RenderTextureRangeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateVolumeLightOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleSelectionHandles(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowMeshBulgeToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def mouldSrf(*args, **kwargs):
    """
    
    """
    pass


def ApplySettingsToSelectedStroke(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sequenceManager(*args, addSequencerAudio="", attachSequencerAudio="", currentShot="",
                    currentTime=None, listSequencerAudio="", listShots=True, modelPanel="",
                    node="", writableSequencer="", q=True, query=True, e=True, edit=True,
                    **kwargs):
    """
    The sequenceManager command manages sequences, shots, and their related scenes
    
    :param addSequencerAudio: (C) Add an audio clip to the sequencer by specifying a filename
    :type addSequencerAudio: string
    :param attachSequencerAudio: (C) Add an audio clip to the sequencer by specifying an audio
    node
    :type attachSequencerAudio: string
    :param currentShot: (Q) Returns the shot that is being used at the current sequence time
    :type currentShot: string
    :param currentTime: (C Q) Set the current sequence time
    :type currentTime: time
    :param listSequencerAudio: (C) List the audio clips added to the sequencer
    :type listSequencerAudio: string
    :param listShots: (C) List all the currently defined shots across all scene segments
    :type listShots: boolean
    :param modelPanel: (C Q) Sets a dedicated modelPanel to be used as the panel that the
    sequencer will control
    :type modelPanel: string
    :param node: (Q) Returns the SequenceManager node, of which there is only ever one
    :type node: string
    :param writableSequencer: (Q) Get the writable sequencer node  Create it if it doesn't
    exist
    :type writableSequencer: string
    
    :returns: 
    :rtype: None
    """
    pass


def DeleteRigidBodies(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FlipUVsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyColorSetCmdWrapper(*args, **kwargs):
    """
    
    """
    pass


def TimeEditorClipResetTiming(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ikHandleCtx(*args, autoPriorityH=True, createCurve=True, createRootAxis=True, exists=True,
                forceSolverH=True, history=True, image1="", image2="", image3="", name="",
                numSpans=1, parentCurve=True, poWeightH=1, priorityH=1, rootOnCurve=True,
                rootTwistMode=True, simplifyCurve=True, snapCurve=True, snapHandleH=True,
                solverTypeH="", stickyH="off", twistType="linear", weightH=1, q=True,
                query=True, e=True, edit=True, **kwargs):
    """
    The ikHandle context command (ikHandleCtx) updates parameters of ikHandle tool  The options
    for the tool will be set to the flags that the user specifies
    
    :param autoPriorityH: (C Q E) Specifies that this handle's priority is assigned
    automatically  C: The default is off  Q: When queried, this flag returns an int
    :type autoPriorityH: boolean
    :param createCurve: (C Q E) Specifies if a curve should be automatically created for the
    ikSplineHandle  The flag is ignored in the ikHandleCtx  C: The default is on  Q: When qu
    :type createCurve: boolean
    :param createRootAxis: (E) Specifies if a root transform should automatically be created
    above the joints affected by the ikSplineHandle  This option is used to prevent the roo
    :type createRootAxis: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param forceSolverH: (C Q E) Specifies if the ikSolver is enabled for the ikHandle  C: The
    default is on  Q: When queried, this flag returns an int
    :type forceSolverH: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param numSpans: (E) Specifies the number of spans in the automatically generated curve of
    the ikSplineHandle  This flag is ignored in the ikHandleCtx  C: The default is
    :type numSpans: int
    :param parentCurve: (E) Specifies if the curve should automatically be parented to the
    parent of the first joint affected by the ikSplineHandle  The flag is ignored in the i
    :type parentCurve: boolean
    :param poWeightH: (C Q E) Specifies the position/orientation weight of the ikHandle  C: The
    default is 1  Q: When queried, this flag returns a float
    :type poWeightH: float
    :param priorityH: (C Q E) Specifies the priority of the ikHandle  C: The default is 1  Q:
    When queried, this flag returns an int
    :type priorityH: int
    :param rootOnCurve: (E) Specifies if the root is locked onto the curve of the
    ikSplineHandle  This flag is ignored in the ikHandleCtx  C: The default is on  Q: When
    queried,
    :type rootOnCurve: boolean
    :param rootTwistMode: (E) Specifies whether the start joint is allowed to twist or not  If
    not, then the required twist is distributed over the remaining joints  This applies
    :type rootTwistMode: boolean
    :param simplifyCurve: (E) Specifies if the ikSplineHandle curve should be simplified  This
    flag is ignored in the ikHandleCtx  C: The default is on  Q: When queried, this retu
    :type simplifyCurve: boolean
    :param snapCurve: (E) Specifies if the curve should automatically snap to the first joint
    affected by the ikSplineHandle  This flag is ignored in the ikHandleCtx  C: The d
    :type snapCurve: boolean
    :param snapHandleH: (C Q E) Specifies if the ikHandle snapping is on  C: The default is on 
    Q: When queried, this flag returns an int
    :type snapHandleH: boolean
    :param solverTypeH: (C Q E) Lists what ikSolver is being used  The ikSplineSolver may not
    be selected  To use an ikSplineSolver use the ikSplineHandleCtx command  C: The default
    :type solverTypeH: string
    :param stickyH: (C Q E) Specifies if the ikHandle is sticky or not  Valid strings are
    "sticky" and "off"  C: The default is "off"  Q: When queried, this flag returns a strin
    :type stickyH: string
    :param twistType: (E) Specifies the type of interpolation to be used by the ikSplineHandle 
    This flag is ignored in the ikHandleCtx  The interpolation options are "linear"
    :type twistType: string
    :param weightH: (C Q E) Specifies the weight of the ikHandle  C: The default is 1  Q: When
    queried, this flag returns a float
    :type weightH: float
    
    :returns: Context name
    :rtype: string
    """
    pass


def PrelightPolygon(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TransplantHairOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def geomBind(*args, bindMethod=0, falloff=0.0, geodesicVoxelParams=None, maxInfluences=0,
             q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command is used to compute weights using geodesic voxel binding algorithm  It works by
    setting the right weights values on an already-existing skinCluster node
    
    :param bindMethod: (C) Specifies which bind algorithm to use  By default, Geodesic Voxel
    will be used  Available algorithms are: 3 - Geodesic Voxel
    :type bindMethod: int
    :param falloff: (C Q E) Falloff controlling the bind stiffness  Valid values range from
    [0..1]
    :type falloff: float
    :param geodesicVoxelParams: (C Q E) Specifies the geodesic voxel binding parameters  This
    flag is composed of three parameters: 0 - Maximum voxel grid resolution which must be a
    power o
    :type geodesicVoxelParams: [int, boolean]
    :param maxInfluences: (C Q E) Specifies the maximum influences a vertex can have  By
    default, all influences are used (-1)
    :type maxInfluences: int
    
    :returns: 
    :rtype: None
    """
    pass


def getRenderDependencies(*args, **kwargs):
    """
    Command to return dependencies of an image source  Image sources (such as render targets)
    can depend on other upstream image sources that result from renderings of 3D scene, or
    renderings of 2D compositing graphs  This command returns these dependencies, so that they
    can be analyzed and rendered
    
    
    :returns: Dependencies for argument image source
    :rtype: string
    """
    pass


def SoftModTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def psdChannelOutliner(*args, addChild=None, allItems=True, annotation="", backgroundColor=None,
                       defineTemplate="", docTag="", doubleClickCommand="", dragCallback=None,
                       dropCallback=None, enable=True, enableBackground=True,
                       enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
                       highlightColor=None, isObscured=True, manage=True, noBackground=True,
                       numberOfItems=True, numberOfPopupMenus=True, parent="",
                       popupMenuArray=True, preventOverride=True, psdParent="", removeAll=True,
                       removeChild="", select="", selectCommand="", selectItem=True,
                       statusBarMessage="", useTemplate="", visible=True,
                       visibleChangeCommand=None, width=0, q=True, query=True, e=True,
                       edit=True, **kwargs):
    """
    Create a psdChannelOutliner control which is capable of displaying a tree structure upto
    one level
    
    :param addChild: (E M) This flag should be used along with the "-psdParent/ppa" flag  A
    string item gets added as a child to the parent specifed with "-psdParent/ppa" flag
    :type addChild: [string, string]
    :param allItems: (Q) Returns all the items in the form parent.child
    :type allItems: boolean
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param doubleClickCommand: (C E) Specify the command to be executed when an item is double
    clicked
    :type doubleClickCommand: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfItems: (Q) Total number of items in the control
    :type numberOfItems: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param psdParent: (E) Adds an item string to the controls which is treated as parent
    :type psdParent: string
    :param removeAll: (E) Removes all the items from the control
    :type removeAll: boolean
    :param removeChild: (E M) Deletes the particular child of the parent as specifed in
    "-psdParent/ppa" flag
    :type removeChild: string
    :param select: (E) Select the named item
    :type select: string
    :param selectCommand: (C E) Specify the command to be executed when an item is selected
    :type selectCommand: string
    :param selectItem: (Q) Returns the selected items
    :type selectItem: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The full name of the psdChannelOutliner control
    :rtype: string
    """
    pass


def selectionConnection(*args, activeCacheList=True, activeCharacterList=True, activeList=True,
                        addScript=None, addTo="", characterList=True, clear=True,
                        connectionList=True, defineTemplate="", deselect=None, editor="",
                        exists=True, filter="", findObject=None, g=True, highlightList=True,
                        identify=True, keyframeList=True, lock=True, modelList=True,
                        object=None, parent="", remove="", removeScript=None, select=None,
                        setList=True, switch=True, useTemplate="", worldList=True, q=True,
                        query=True, e=True, edit=True, **kwargs):
    """
    This command creates a named selectionConnection object  This object is simply a shared
    selection list  It may be used by editors to share their highlight data  For example, an
    outliner may attach its selected list to one of these objects, and a graph editor may use
    the same object as a list source  Then, the graph editor would only display objects
    
    :param activeCacheList: (C) Specifies that this connection should reflect the cache that
    objects on the active list belong to
    :type activeCacheList: boolean
    :param activeCharacterList: (C) Specifies that this connection should reflect the
    characters that objects on the active list belong to
    :type activeCharacterList: boolean
    :param activeList: (C) Specifies that this connection should reflect the active list
    (geometry objects and keys)
    :type activeList: boolean
    :param addScript: (C Q E) Specify a script to be called when something is added to the
    selection
    :type addScript: script
    :param addTo: (C E) The name of a selection connection that should be added to this list of
    connections
    :type addTo: string
    :param characterList: (C) Specifies that this connection should reflect all the characters
    in the world
    :type characterList: boolean
    :param clear: (C E) Remove everything from the selection connection
    :type clear: boolean
    :param connectionList: (C Q) Specifies that this connection should contain a list of
    selection connections
    :type connectionList: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param deselect: (C E) Remove something from the selection
    :type deselect: name
    :param editor: (C Q E) Specifies that this connection should reflect the
    -mainListConnection of the specified editor
    :type editor: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param filter: (C Q E) Optionally specifies an itemFilter for this connection  An empty
    string ("") clears the current filter  If a filter is specified, all the information
    :type filter: string
    :param findObject: (Q) Find a selection connection in this list that wraps the specified
    object
    :type findObject: name
    :param g: (C Q E) A global selection connection cannot be deleted by any script commands
    :type g: boolean
    :param highlightList: (C) Specifies that this connection is being used as a highlight list
    :type highlightList: boolean
    :param identify: (Q) Find out what type of selection connection this is  May be: activeList
    | modelList | keyframeList | worldList | objectList listList | editorList | co
    :type identify: boolean
    :param keyframeList: (C) Specifies that this connection should reflect the animation
    portion of the active list
    :type keyframeList: boolean
    :param lock: (C Q E) For activeList connections, locking the connection means that it will
    not listen to activeList changes
    :type lock: boolean
    :param modelList: (C) Specifies that this connection should reflect the modeling (i.e 
    excluding keys) portion of the active list
    :type modelList: boolean
    :param object: (C Q E) Specifies that this connection should wrap around the specified
    object (which may be a set)  Query will return all the members of the selection conne
    :type object: name
    :param parent: (C Q E) The name of a UI object this should be attached to  When the parent
    is destroyed, the selectionConnection will auto-delete  If no parent is specified
    :type parent: string
    :param remove: (C E) The name of a selection connection that should be removed from this
    list of connections
    :type remove: string
    :param removeScript: (C Q E) Specify a script to be called when something is removed from
    the selection
    :type removeScript: script
    :param select: (C E) Add something to the selection  This does not replace the existing
    selection
    :type select: name
    :param setList: (C) Specifies that this connection should reflect all the sets in the
    world
    :type setList: boolean
    :param switch: (C Q) Acts as a modifier to -connectionList which sets the list of objects
    to be the first non-empty selection connection  selection connections are tested
    :type switch: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param worldList: (C) Specifies that this connection should reflect all objects in the
    world
    :type worldList: boolean
    
    :returns: Value of the queried flag
    :rtype: string
    """
    pass


def geometryMergeCacheOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateConstraint(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def scmh(*args, absolute=True, ignore=0, quiet=True, relative=True, **kwargs):
    """
    Set the current manipulator handle value(s)  In UI units (where applicable), though the
    syntax is set to handle the unit type of the current manipulator handle (if available)
    
    :param absolute: (C) The values are absolute
    :type absolute: boolean
    :param ignore: (C M) This is a multiuse flag which specifies that the index-th (1-based)
    entry is to be ignored
    :type ignore: int
    :param quiet: (C) This flag suppresses all error messages
    :type quiet: boolean
    :param relative: (C) The values are relative
    :type relative: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def NodeEditorShowAllCustomAttrs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeCreateTab(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PublishRootTransform(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorToggleTimeCursorPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXImportProtectDrivenKeys(*args, **kwargs):
    """
    
    """
    pass


def SplitMeshWithProjectedCurve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportColladaFrameRate(*args, **kwargs):
    """
    
    """
    pass


def recordDevice(*args, cleanup=True, data=True, device="", duration=60, playback=False,
                 state=True, wait=True, q=True, query=True, **kwargs):
    """
    Starts and stops server side device recording  The data is recorded at the device rate 
    Once recorded, the data may be brought into Maya with the applyTake command
    
    :param cleanup: (C) Removes the recorded data from the device
    :type cleanup: boolean
    :param data: (Q) Specifies if the device has recorded data  If the device is recording at
    the time of query, the flag will return false  Q: When queried, this flag re
    :type data: boolean
    :param device: (C M) Specifies which device(s) to start record recording  The listed
    device(s) will start recording regardless of their record enable state  C: The defaul
    :type device: string
    :param duration: (C Q) Duration (in seconds) of the recording  When the duration expires,
    the device will still be in a recording state and must be told to stop recording
    :type duration: int
    :param playback: (C Q) If any attribute is connected to an animation curve, the animation
    curve will play back while recording the device(s) including any animation curves
    :type playback: boolean
    :param state: (C Q) Start or stop device recording  C: The default is true  Q: When queried,
    this flag returns an int
    :type state: boolean
    :param wait: (C) If -p/playback specified, wait until playback completion before returning
    control to the user  This flag is ignored if -p is not used
    :type wait: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def FBXGetTakeName(*args, **kwargs):
    """
    
    """
    pass


def MakeCurvesDynamicOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def timeEditorPanel(*args, activeClipEditMode=0, activeTabRootClipId=True, activeTabTime=True,
                    activeTabView=0, autoFit="", autoFitTime="", control=True,
                    defineTemplate="", displayActiveKeyTangents="", displayActiveKeys="",
                    displayInfinities="", displayKeys="", displayTangents="", displayValues="",
                    docTag="", exists=True, filter="", forceMainConnection="",
                    groupIdForTabView=0, highlightConnection="", keyingTarget=0, layerId=0,
                    lockMainConnection=True, lookAt="", mainListConnection="", menu=None,
                    minClipWidth=0, panel="", parent="", selectionConnection="",
                    setToPrevClipEditMode=True, snapTime="", snapToClip=True, snapToFrame=True,
                    snapTolerance=0, snapValue="", stateString=True, tabView=0, timeCursor=True,
                    unParent=True, unlockMainConnection=True, updateMainConnection=True,
                    useTemplate="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    Time Editor - non-linear animation editor
    
    :param activeClipEditMode: (Q E) Set the appropriate clip edit mode for the editor  0:
    Default Mode 1: Trim Mode 2: Scale Mode 3: Loop Mode 4: Hold Mode
    :type activeClipEditMode: int
    :param activeTabRootClipId: (Q) Get the clip id for which current active tab has been
    opened  In case of main tab, this will return -1 meaning there is no root clip
    :type activeTabRootClipId: boolean
    :param activeTabTime: (Q) Get current time displayed inside the active tab  This will be
    global time in case of the main tab and local time for others
    :type activeTabTime: boolean
    :param activeTabView: (Q E) Get/set the index of the tab widget's (active) visible tab 
    Note: the index is zero-based
    :type activeTabView: int
    :param autoFit: (Q E) on | off | tgl Auto fit-to-view
    :type autoFit: string
    :param autoFitTime: (Q E) on | off | tgl Auto fit-to-view along the time axis, as well
    :type autoFitTime: string
    :param control: (Q) Query only  Returns the top level control for this editor  Usually used
    for getting a parent to attach popup menus  Caution: It is possible for an ed
    :type control: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param displayActiveKeyTangents: (E) on | off | tgl Display active key tangents in the
    editor
    :type displayActiveKeyTangents: string
    :param displayActiveKeys: (E) on | off | tgl Display active keys in the editor
    :type displayActiveKeys: string
    :param displayInfinities: (E) on | off | tgl Display infinities in the editor
    :type displayInfinities: string
    :param displayKeys: (E) on | off | tgl Display keyframes in the editor
    :type displayKeys: string
    :param displayTangents: (E) on | off | tgl Display tangents in the editor
    :type displayTangents: string
    :param displayValues: (E) on | off | tgl Display active keys and tangents values in the
    editor
    :type displayValues: string
    :param docTag: (C Q E) Attaches a tag to the editor
    :type docTag: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param filter: (C Q E) Specifies the name of an itemFilter object to be used with this
    editor  This filters the information coming onto the main list of the editor
    :type filter: string
    :param forceMainConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type forceMainConnection: string
    :param groupIdForTabView: (Q) Get the group clip id for the given tab view index  To
    specify the tab index, this flag must appear before the -query flag  In query mode, this
    flag
    :type groupIdForTabView: int
    :param highlightConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its highlight list  Not all editors have a highlight list 
    F
    :type highlightConnection: string
    :param keyingTarget: (Q E) Set keying target to specified clip ID  If keying into layer,
    '-layer' flag must be used  In query mode, the clip id is omitted, and the name of the
    :type keyingTarget: int
    :param layerId: (E) Indicate layer ID of keying target
    :type layerId: int
    :param lockMainConnection: (C E) Locks the current list of objects within the
    mainConnection, so that only those objects are displayed within the editor  Further changes
    to the origi
    :type lockMainConnection: boolean
    :param lookAt: (E) all | selected | currentTime FitView helpers
    :type lookAt: string
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type mainListConnection: string
    :param menu: (C) Specify a script to be run when the editor is created  The function will
    be passed one string argument which is the new editor's name
    :type menu: script
    :param minClipWidth: (Q E) Set the minimum clip width
    :type minClipWidth: int
    :param panel: (C Q) Specifies the panel for this editor  By default if an editor is created
    in the create callback of a scripted panel it will belong to that panel  If a
    :type panel: string
    :param parent: (C Q E) Specifies the parent layout for this editor  This flag will only
    have an effect if the editor is currently un-parented
    :type parent: string
    :param selectionConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its own selection list  As the user selects things in this
    e
    :type selectionConnection: string
    :param setToPrevClipEditMode: (E) Revert to previous clip edit mode
    :type setToPrevClipEditMode: boolean
    :param snapTime: (Q E) none | integer | keyframe Keyframe move snap in time
    :type snapTime: string
    :param snapToClip: (Q E) Enable/Disable snap-to-clip option in Time Editor while
    manipulating and drag-and-drop clips  When snapToClip is on all manipulated timing will
    land
    :type snapToClip: boolean
    :param snapToFrame: (Q E) Enable/Disable snap-to-frame option in Time Editor while
    manipulating and drag-and-drop clips  When snapToFrame is on all manipulated timing will
    lan
    :type snapToFrame: boolean
    :param snapTolerance: (Q E) Set the tolerance value for snapping
    :type snapTolerance: int
    :param snapValue: (Q E) none | integer | keyframe Keyframe move snap in values
    :type snapValue: string
    :param stateString: (Q) Query only flag  Returns the MEL command that will create an editor
    to match the current editor state  The returned command string uses the string va
    :type stateString: boolean
    :param tabView: (E) Create a tab view for the given group clip ID
    :type tabView: int
    :param timeCursor: (Q E) Activate the time cursor in Time Editor for scrubbing
    :type timeCursor: boolean
    :param unParent: (C E) Specifies that the editor should be removed from its layout  This
    cannot be used in query mode
    :type unParent: boolean
    :param unlockMainConnection: (C E) Unlocks the mainConnection, effectively restoring the
    original mainConnection (if it is still available), and dynamic updates
    :type unlockMainConnection: boolean
    :param updateMainConnection: (C E) Causes a locked mainConnection to be updated from the
    orginal mainConnection, but preserves the lock state
    :type updateMainConnection: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: Command result
    :rtype: string
    """
    pass


def fluidReplaceFrames(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def parentConstraint(*args, createCache=None, decompRotationToChild=True, deleteCache=True,
                     layer="", maintainOffset=True, name="", remove=True, skipRotate="",
                     skipTranslate="", targetList=True, weight=0.0, weightAliasList=True,
                     q=True, query=True, e=True, edit=True, **kwargs):
    """
    Constrain an object's position and rotation so that it behaves as if it were a child of the
    target object(s)  In the case of multiple targets, the overall position and rotation of the
    constrained object is the weighted average of each target's contribution to the position
    and rotation of the object   A parentConstraint takes as input one or more "t
    
    :param createCache: (E) This flag is used to generate an animation curve that serves as a
    cache for the constraint  The two arguments define the start and end frames  The ca
    :type createCache: [float, float]
    :param decompRotationToChild: (C) During constraint creation, if the rotation offset
    between the constrained object and the target object is maintained, this flag indicates
    close to w
    :type decompRotationToChild: boolean
    :param deleteCache: (E) Delete an existing interpolation cache
    :type deleteCache: boolean
    :param layer: (C E) Specify the name of the animation layer where the constraint should be
    added
    :type layer: string
    :param maintainOffset: (C) If this flag is specified the position and rotation of the
    constrained object will be maintained
    :type maintainOffset: boolean
    :param name: (C Q E) Sets the name of the constraint node to the specified name  Default
    name is constrainedObjectName_constraintType
    :type name: string
    :param remove: (E) removes the listed target(s) from the constraint
    :type remove: boolean
    :param skipRotate: (C M) Causes the axis specified not to be considered when constraining
    rotation  Valid arguments are "x", "y", "z" and "none"
    :type skipRotate: string
    :param skipTranslate: (C M) Causes the axis specified not to be considered when
    constraining translation  Valid arguments are "x", "y", "z" and "none"
    :type skipTranslate: string
    :param targetList: (Q) Return the list of target objects
    :type targetList: boolean
    :param weight: (C Q E) Sets the weight value for the specified target(s)  If not given at
    creation time, the default value of 1.0 is used
    :type weight: float
    :param weightAliasList: (Q) Returns the names of the attributes that control the weight of
    the target objects  Aliases are returned in the same order as the targets are returned
    :type weightAliasList: boolean
    
    :returns: Name of the created constraint node
    :rtype: string[]
    """
    pass


def arnoldRenderToTexture(*args, **kwargs):
    """
    
    """
    pass


def AirOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def popupMenu(*args, allowOptionBoxes=True, altModifier=True, button=0, ctrlModifier=True,
              defineTemplate="", deleteAllItems=True, exists=True, itemArray=True,
              markingMenu=True, numberOfItems=True, parent="", postMenuCommand=None,
              postMenuCommandOnce=True, shiftModifier=True, useTemplate="", q=True, query=True,
              e=True, edit=True, **kwargs):
    """
    This command creates a popup menu and attaches it to the current control if no parent is
    specified  The popup menu is posted with the right mouse button by default   Popup menus
    can be added to any kind of control, however, on some widgets, only the standard menu
    button (3rd mouse button) can be used to trigger popup menus  This is to meet generall
    
    :param allowOptionBoxes: (C Q) Indicate whether the menu will be able to support option box
    menu items  An error results if an option box item is added to a menu that doesn't allow
    :type allowOptionBoxes: boolean
    :param altModifier: (C Q E) Specify this flag if the Alt modifier must be pressed when
    posting the popup menu
    :type altModifier: boolean
    :param button: (C Q E) Indicate which button posts the popup menu  Valid values range from
    1 to 3 where 1 is the left most button on the mouse
    :type button: int
    :param ctrlModifier: (C Q E) Specify this flag if the Cntl modifier must be pressed when
    posting the popup menu
    :type ctrlModifier: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param deleteAllItems: (E) Delete all the items in this menu
    :type deleteAllItems: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param itemArray: (Q) Return string array of the menu item names
    :type itemArray: boolean
    :param markingMenu: (C Q E) Set the marking menu state of this popup menu
    :type markingMenu: boolean
    :param numberOfItems: (Q) Return number of items in the menu
    :type numberOfItems: boolean
    :param parent: (C) Specify the control that the popup menu will appear in
    :type parent: string
    :param postMenuCommand: (C E) Specify a script to be executed when the popup menu is about
    to be shown
    :type postMenuCommand: script
    :param postMenuCommandOnce: (C Q E) Indicate the -pmc/postMenuCommand should only be
    invoked once  Default value is false, ie  the -pmc/postMenuCommand is invoked every time
    the popup m
    :type postMenuCommandOnce: boolean
    :param shiftModifier: (C Q E) Specify this flag if the Shift modifier must be pressed when
    posting the popup menu
    :type shiftModifier: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: Full path name to the menu.
    :rtype: string
    """
    pass


def SaveSceneAs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def artPuttyCtx(*args, accopacity=False, activeListChangedProc="", afterStrokeCmd="",
                alphaclamp="none", alphaclamplower=0.0, alphaclampupper=1.0, attrSelected="",
                autosmooth=False, beforeStrokeCmd="", brushStrength=1.0, brushalignment=True,
                brushfeedback=True, clamp="none", clamplower=0.0, clampupper=1.0, clear=True,
                collapsecvtol=0.005, colorAlphaValue=0.0, colorRGBAValue=None,
                colorRGBValue=None, colorRamp="", colorfeedback=False,
                colorfeedbackOverride=False, colorrangelower=0.0, colorrangeupper=1.0,
                dataTypeIndex=0, disablelighting=False, dispdecr=True, dispincr=True,
                dragSlider="", duringStrokeCmd="", dynclonemode=True, erasesrfupd=True,
                exists=True, expandfilename=True, exportaspectratio=0.0,
                exportfilemode="luminance/rgb", exportfilesave="", exportfilesizex=0,
                exportfilesizey=0, exportfiletype="", filterNodes=True, history=True, image1="",
                image2="", image3="", importfileload="", importfilemode="alpha",
                importreassign=False, interactiveUpdate=True, invertrefvector=False,
                lastRecorderCmd="", lastStampName="", lowerradius=0.0, makeStroke=0,
                mappressure="none", maxdisp=1.0, maxvalue=1.0, minvalue=0.0, mouldtypehead="",
                mouldtypemouse="push", mouldtypetail="", name="", objattrArray="", opacity=1.0,
                outline=True, outwhilepaint=False, paintNodeArray="", paintattrselected="",
                paintmode="screen", paintoperationtype="Paint", pickColor=True, pickValue=True,
                playbackCursor=None, playbackPressure=0.0, polecv=True,
                preserveclonesource=True, profileShapeFile="", projective=False, radius=1.0,
                rampMaxColor=None, rampMinColor=None, record=True, reflection=False,
                reflectionaboutorigin=True, reflectionaxis="x", refsurface=True,
                refvector="normal", refvectoru=0.0, refvectorv=0.0, screenRadius=0.0,
                selectclonesource=True, selectedattroper="absolute", showactive=True,
                smoothiters=3, stampDepth=0.0, stampProfile="", stampSpacing=1.0,
                stitchcorner=True, stitchedgeflood=True, stitchtype="position", strokesmooth="",
                surfaceConformedBrushVertices=True, tablet=True, tangentOutline=True,
                toolOffProc="", toolOnProc="", updateerasesrf=True, updaterefsrf=True,
                useColorRamp=True, useMaxMinColor=True, usepressure=False, value=0.0,
                whichTool="", worldRadius=0.0, q=True, query=True, e=True, edit=True,
                **kwargs):
    """
    This is a context command to set the flags on the artAttrContext, which is the base context
    for attribute painting operations  All commands require the name of the context as the last
    argument as this provides the name of the context to create, edit or query   This command
    is used to modify NURBS surfaces using a brush based interface (Maya Artisan
    
    :param accopacity: (C Q E) Sets opacity accumulation on/off  C: Default is false (Except
    for sculpt tool for which it is true by default)  Q: When queried, it returns a boolean
    :type accopacity: boolean
    :param activeListChangedProc: (C Q E) Accepts a string that contains a MEL command that is
    invoked whenever the active list changes  There may be some situations where the UI, for
    example
    :type activeListChangedProc: string
    :param afterStrokeCmd: (C Q E) The passed string is executed as a MEL command immediately
    after the end of a stroke  C: Default is no command  Q: When queried, it returns the curre
    :type afterStrokeCmd: string
    :param alphaclamp: (C Q E) Specifies if the weight value should be alpha clamped to the
    lower and upper bounds  There are four options here: "none" - no clamping is performed,
    :type alphaclamp: string
    :param alphaclamplower: (C Q E) Specifies the lower bound for the alpha values  C: Default
    is 0.0  Q: When queried, it returns a float
    :type alphaclamplower: float
    :param alphaclampupper: (C Q E) Specifies the upper bound for the alpha values  C: Default
    is 1.0  Q: When queried, it returns a float
    :type alphaclampupper: float
    :param attrSelected: (Q) Returns a name of the currently selected attribute  Q: When
    queried, it returns a string
    :type attrSelected: string
    :param autosmooth: (C Q E) Sets up the auto smoothing option  When the brush is in the
    smooth mode, adjusting the strength will adjust how fast the surfaces is smoothed out  C:
    :type autosmooth: boolean
    :param beforeStrokeCmd: (C Q E) The passed string is executed as a MEL command immediately
    before the start of a stroke  C: Default is no command  Q: When queried, it returns the cu
    :type beforeStrokeCmd: string
    :param brushStrength: (C Q E) Sets the strength of the brush  Brush strength is supported
    by the pinch and slide brushes  In pinch mode, adjusting the strength will adjust how qui
    :type brushStrength: float
    :param brushalignment: (C Q E) Specifies the path brush alignemnt  If true, the brush will
    align to stroke path, otherwise it will align to up vector  C: Default is true  Q: When q
    :type brushalignment: boolean
    :param brushfeedback: (C Q E) Specifies if the brush additional feedback should be drawn 
    C: Default is TRUE  Q: When queried, it returns a boolean
    :type brushfeedback: boolean
    :param clamp: (C Q E) Specifies if the weight value should be clamped to the lower and
    upper bounds  There are four options here: "none" - no clamping is performed, "lower
    :type clamp: string
    :param clamplower: (C Q E) Specifies the lower bound for the values  C: Default is 0.0  Q:
    When queried, it returns a float
    :type clamplower: float
    :param clampupper: (C Q E) Specifies the upper bound for the values  C: Default is 1.0  Q:
    When queried, it returns a float
    :type clampupper: float
    :param clear: (C E) Floods all cvs/vertices to the current value
    :type clear: boolean
    :param collapsecvtol: (C Q E) Specifies the tolerance for the collapse cv detection  C:
    Default is 0.005 cm  Q: When queried, it returns a float
    :type collapsecvtol: float
    :param colorAlphaValue: (C Q E) The Alpha value of the color
    :type colorAlphaValue: float
    :param colorRGBAValue: (C Q E) The RGBA value of the color
    :type colorRGBAValue: [float, float, float, float]
    :param colorRGBValue: (C Q E) The RGB value of the color
    :type colorRGBValue: [float, float, float]
    :param colorRamp: (C Q E) Allows a user defined color ramp to be used to map values to
    colors
    :type colorRamp: string
    :param colorfeedback: (C Q E) Sets on/off the color feedback display  C: Default is FALSE 
    Q: When queried, it returns a boolean
    :type colorfeedback: boolean
    :param colorfeedbackOverride: (C Q E) Sets on/off the color feedback override  C: Default
    is FALSE  Q: When queried, it returns a boolean
    :type colorfeedbackOverride: boolean
    :param colorrangelower: (C Q E) Specifies the value that maps to black when color feedback
    mode is on  C: Default is 0.0  Q: When queried, it returns a float
    :type colorrangelower: float
    :param colorrangeupper: (C Q E) Specifies the value that maps to the maximum color when
    color feedback mode is on  C: Default is 1.0  Q: When queried, it returns a float
    :type colorrangeupper: float
    :param dataTypeIndex: (Q E) When the selected paintable attribute is a vectorArray, it
    specifies which field to paint on
    :type dataTypeIndex: int
    :param disablelighting: (C Q E) If color feedback is on, this flag determines whether
    lighting is disabled or not for the surfaces that are affected  C: Default is FALSE  Q:
    When qu
    :type disablelighting: boolean
    :param dispdecr: (C E) Decreases a maximum displacement by 10%
    :type dispdecr: boolean
    :param dispincr: (C E) Increases a maximum displacement by 10%
    :type dispincr: boolean
    :param dragSlider: (C E) Sets the current brush drag state for resizing or offsetting the
    brush (like the 'b' and 'm' default hotkeys)  The string argument is one of: "radius
    :type dragSlider: string
    :param duringStrokeCmd: (C Q E) The passed string is executed as a MEL command during the
    stroke, each time the mouse is dragged  C: Default is no command  Q: When queried, it
    retur
    :type duringStrokeCmd: string
    :param dynclonemode: (C Q E) Enable or disable dynamic clone mode
    :type dynclonemode: boolean
    :param erasesrfupd: (C Q E) Toggles the update for the erase surface
    :type erasesrfupd: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param expandfilename: (C E) If true, it will expand the name of the export file and
    concatenate it with the surface name  Otherwise it will take the name as it is  C: Default
    is
    :type expandfilename: boolean
    :param exportaspectratio: (C Q E) Value of aspect ratio for export
    :type exportaspectratio: float
    :param exportfilemode: (C Q E) Specifies the export channel.The valid entries here are:
    "alpha", "luminance", "rgb", "rgba"  C: Default is "luminance/rgb"  Q: When queried, it
    retu
    :type exportfilemode: string
    :param exportfilesave: (E) Exports the attribute map and saves to a specified file
    :type exportfilesave: string
    :param exportfilesizex: (C Q E) Specifies the width of the attribute map to export  C:
    Default width is 256  Q: When queried, it returns an integer
    :type exportfilesizex: int
    :param exportfilesizey: (C Q E) Specifies the width of the attribute map to export  C:
    Default width is 256  Q: When queried, it returns an integer
    :type exportfilesizey: int
    :param exportfiletype: (C Q E) Specifies the image file format  It can be one of the
    following: "iff", "tiff", "jpeg", "alias", "rgb", "fit" "postScriptEPS", "softimage",
    "wavefron
    :type exportfiletype: string
    :param filterNodes: (E) Sets the node filter
    :type filterNodes: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param importfileload: (E) Load the attribute map a specified file
    :type importfileload: string
    :param importfilemode: (C Q E) Specifies the channel to import  The valid entries here are:
    "alpha", "luminance", "red", "green", "blue", and "rgb" C: Default is "alpha"  Q: When q
    :type importfilemode: string
    :param importreassign: (C Q E) Specifies if the multiply atrribute maps are to be
    reassigned while importing  Only maps previously exported from within Artisan can be
    reassigned  C
    :type importreassign: boolean
    :param interactiveUpdate: (C Q E) Specifies how often to transfer the painted values into
    the attribute  TRUE: transfer them "continuously" (many times per stroke) FALSE: transfer
    the
    :type interactiveUpdate: boolean
    :param invertrefvector: (C Q E) Sets the invert of the reference vector option when the
    reflection is ON  If it is true, the reference vector for the reflected stroke is negated
    wit
    :type invertrefvector: boolean
    :param lastRecorderCmd: (C Q E) Value of last recorded command
    :type lastRecorderCmd: string
    :param lastStampName: (C Q E) Value of the last stamp name
    :type lastStampName: string
    :param lowerradius: (C Q E) Sets the lower size of the brush (only apply on tablet)
    :type lowerradius: float
    :param makeStroke: (C Q E M) Stroke point values
    :type makeStroke: int
    :param mappressure: (C Q E) Sets the tablet pressure mapping when the table is used  There
    are four options: "none" - the pressure has no effect, "opacity" - the pressure is map
    :type mappressure: string
    :param maxdisp: (C Q E) Defines a maximum displacement ( maxDisp in [0.0..5.0] )  C:
    Default is 1.0  Q: When queried, it returns a float
    :type maxdisp: float
    :param maxvalue: (C Q E) Specifies the maximum value for each attribute  C: Default is 1.0 
    Q: When queried, it returns a float
    :type maxvalue: float
    :param minvalue: (C Q E) Specifies the minimum value for each attribute  C: Default is 0.0 
    Q: When queried, it returns a float
    :type minvalue: float
    :param mouldtypehead: (C Q E) Type of type mould to use
    :type mouldtypehead: string
    :param mouldtypemouse: (C Q E) Specifies the putty operations/mode ("push" - pushes CVs
    along the given direction (see refvector flag), "pull" - pulls CVs along the specified
    direc
    :type mouldtypemouse: string
    :param mouldtypetail: (C Q E) Type of eraser mould to use
    :type mouldtypetail: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param objattrArray: (Q) An array of all paintable attributes  Each element of the array is
    a string with the following information: NodeType.NodeName.AttributeName.MenuType
    :type objattrArray: string
    :param opacity: (C Q E) Sets the brush opacity  C: Default is 1.0  Q: When queried, it
    returns a float
    :type opacity: float
    :param outline: (C Q E) Specifies if the brush should be drawn  C: Default is TRUE  Q: When
    queried, it returns a boolean
    :type outline: boolean
    :param outwhilepaint: (C Q E) Specifies if the brush outline should be drawn while painting
     C: Default is FALSE  Q: When queried, it returns a boolean
    :type outwhilepaint: boolean
    :param paintNodeArray: (Q) An array of paintable nodes  Q: When queried, it returns a
    string
    :type paintNodeArray: string
    :param paintattrselected: (E) An array of selected paintable attributes  Each element of
    the array is a string with the following information: NodeType.NodeName.AttributeName
    :type paintattrselected: string
    :param paintmode: (C Q E) Specifies the paint mode  There are two possibilities: "screen"
    and "tangent"  C: Default is "screen"  Q: When queried, it returns a string
    :type paintmode: string
    :param paintoperationtype: (C Q E) Specifies the operation type used by the Paint Tool 
    Currently, we support the following paint modes: "Paint", "Smear", "Blur", "Erase" and
    "Clone"
    :type paintoperationtype: string
    :param pickColor: (C Q E) Set pick color mode on or off
    :type pickColor: boolean
    :param pickValue: (C Q E) Toggle for picking
    :type pickValue: boolean
    :param playbackCursor: (C Q E M) Values for the playback cursor
    :type playbackCursor: [float, float]
    :param playbackPressure: (C Q E M) Valus for the playback pressure
    :type playbackPressure: float
    :param polecv: (C Q E) Pull all the pole CVs to the same position
    :type polecv: boolean
    :param preserveclonesource: (C Q E) Whether or not to preserve a clone source
    :type preserveclonesource: boolean
    :param profileShapeFile: (Q E) Passes a name of the image file for the stamp shape profile
    :type profileShapeFile: string
    :param projective: (C Q E) Specifies the projective paint mode  C: Default is 'false'  Q:
    When queried, it returns a boolean
    :type projective: boolean
    :param radius: (C Q E) Sets the size of the brush  C: Default is 1.0 cm  Q: When queried,
    it returns a float
    :type radius: float
    :param rampMaxColor: (C Q E) Defines a special color to be used when the value is greater
    than or equal to the maximum value
    :type rampMaxColor: [float, float, float]
    :param rampMinColor: (C Q E) Defines a special color to be used when the value is less than
    or equal to the minimum value
    :type rampMinColor: [float, float, float]
    :param record: (C Q E) Toggle on for recording
    :type record: boolean
    :param reflection: (C Q E) Specifies the reflection mode  C: Default is 'false'  Q: When
    queried, it returns a boolean
    :type reflection: boolean
    :param reflectionaboutorigin: (C Q E) Toggle on to reflect about the origin
    :type reflectionaboutorigin: boolean
    :param reflectionaxis: (C Q E) Specifies the reflection axis  There are three
    possibilities: "x", "y" and "z"  C: Default is "x"  Q: When queried, it returns a string
    :type reflectionaxis: string
    :param refsurface: (C Q E) Sets on/off the update of the reference surface  If it is true
    the reference surface is automatically updated on the per stroke bases  If it is false
    :type refsurface: boolean
    :param refvector: (C Q E) Specifies the direction of the push/pull operation ("normal" -
    sculpt along normals, "firstnormal" - sculpt along the first normal of the stroke, "vi
    :type refvector: string
    :param refvectoru: (C Q E) Specifies the U component of the UV vector to be used when
    -refVector is set to "uvvector"
    :type refvectoru: float
    :param refvectorv: (C Q E) Specifies the V component of the UV vector to be used when
    -refVector is set to "uvvector"
    :type refvectorv: float
    :param screenRadius: (C Q E) Brush radius on the screen
    :type screenRadius: float
    :param selectclonesource: (C Q E) Toggle on to select the clone source
    :type selectclonesource: boolean
    :param selectedattroper: (C Q E) Sets the edit weight operation  Four edit weights
    operations are provided : "absolute" - the value of the weight is replaced by the current
    one, "add
    :type selectedattroper: string
    :param showactive: (C Q E) Sets on/off the display of the surface isoparms  C: Default is
    TRUE  Q: When queried, it returns a boolean
    :type showactive: boolean
    :param smoothiters: (C Q E) Sets the quality of the smoothing operation (number of
    iterations)  C: Default is 3  Q: When queried, it returns an int
    :type smoothiters: int
    :param stampDepth: (C Q E) Depth of the stamps
    :type stampDepth: float
    :param stampProfile: (C Q E) Sets the brush profile of the current stamp  Currently, the
    following profiles are supported: "gaussian", "poly", "solid" and "square"  C: Default is
    :type stampProfile: string
    :param stampSpacing: (C Q E) Specifies the stamp spacing  Default is 1.0
    :type stampSpacing: float
    :param stitchcorner: (C Q E) Sets on/off the stitching corner mode C: Default is "off"  Q:
    When queried, it returns a boolean
    :type stitchcorner: boolean
    :param stitchedgeflood: (E) Triggers postprocessing stitching edge procedure
    :type stitchedgeflood: boolean
    :param stitchtype: (C Q E) Sets on/off the stitching mode ( "off" - stitching is turned off,
    "position" - position stitching is done without taking care about the tangent conti
    :type stitchtype: string
    :param strokesmooth: (C Q E) Stroke smoothing type name
    :type strokesmooth: string
    :param surfaceConformedBrushVertices: (C Q E) Enables/disables the the display of the
    effective brush area as affected vertices
    :type surfaceConformedBrushVertices: boolean
    :param tablet: (Q) Returns true if the tablet device is present, false if it is absent
    :type tablet: boolean
    :param tangentOutline: (C Q E) Enables/disables the display of the brush circle tangent to
    the surface
    :type tangentOutline: boolean
    :param toolOffProc: (C Q E) Accepts a strings describing the name of a MEL procedure that
    is invoked whenever the tool is turned off  For example, cloth invokes "clothPaintToolO
    :type toolOffProc: string
    :param toolOnProc: (C Q E) Accepts a strings describing the name of a MEL procedure that is
    invoked whenever the tool is turned on  For example, cloth invokes "clothPaintToolOn
    :type toolOnProc: string
    :param updateerasesrf: (C E) Updates the erase surface
    :type updateerasesrf: boolean
    :param updaterefsrf: (C E) Updates the reference surface
    :type updaterefsrf: boolean
    :param useColorRamp: (C Q E) Specifies whether the user defined color ramp should be used
    to map values from to colors  If this is turned off, the default greyscale feedback will
    :type useColorRamp: boolean
    :param useMaxMinColor: (C Q E) Specifies whether the out of range colors should be used 
    See rampMinColor and rampMaxColor flags for further details
    :type useMaxMinColor: boolean
    :param usepressure: (C Q E) Sets the tablet pressure on/off  C: Default is false  Q: When
    queried, it returns a boolean
    :type usepressure: boolean
    :param value: (C Q E) Specifies the value for each attribute  C: Default is 0.0  Q: When
    queried, it returns a float
    :type value: float
    :param whichTool: (C Q E) The string defines the name of the tool to be used for the
    Artisan context  An example is "artClothPaint"  In query mode, the tool name for the given
    :type whichTool: string
    :param worldRadius: (C Q E) Radius in worldspace
    :type worldRadius: float
    
    :returns: 
    :rtype: None
    """
    pass


def ToggleViewportRenderer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_selectPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorGridToggleSnap(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def illustratorCurves(*args, caching=True, constructionHistory=True, illustratorFilename="",
                      nodeState=0, object=True, tolerance=0.001, q=True, query=True, e=True,
                      edit=True, **kwargs):
    """
    The illustratorCurves command creates NURBS curves from an input Adobe(R) Illustrator(R)
    file
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param illustratorFilename: (C) Input Adobe(R) Illustrator(R) file name
    :type illustratorFilename: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param tolerance: (C Q E) CVs on the output curve get snapped if the distance between two
    contiguous CVs are lesser than this tolerance value  Default: 0.001f
    :type tolerance: float
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def ColorPreferencesWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AlignUV(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyVertexNormalCtx(*args, **kwargs):
    """
    
    """
    pass


def nucleusDisplayMaterialNodes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeToggleTransformDisplay(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SendAsNewScene3dsMax(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NParticleTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def track(*args, down=0.0, left=0.0, right=0.0, upDistance01=0.0, upDistance02=0.0, **kwargs):
    """
    The track command translates a camera horizontally or vertically in the world space  The
    viewing-direction and up-direction of the camera are not altered  There is no translation
    in the viewing direction   The track command can be applied to either a perspective or an
    orthographic camera   When no camera name is supplied, this command is applied to
    
    :param down: (C) Set the amount of down translation in unit distance
    :type down: float
    :param left: (C) Set the amount of left translation in unit distance
    :type left: float
    :param right: (C) Set the amount of right translation in unit distance
    :type right: float
    :param upDistance01: (C) Set the amount of up translation in unit distance  This is
    equivalent to using up/upDistance02 flag
    :type upDistance01: float
    :param upDistance02: (C) Set the amount of up translation in unit distance  This is
    equivalent to using u/upDistance01 flag
    :type upDistance02: float
    
    :returns: 
    :rtype: None
    """
    pass


def FBXImportSkeletonDefinitionsAs(*args, **kwargs):
    """
    
    """
    pass


def FloatSelectedPondObjects(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RemoveBifrostFoam(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddToCurrentScene3dsMax(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetCutSewUVTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportConstraints(*args, **kwargs):
    """
    
    """
    pass


def timeEditorBakeClips(*args, bakeToAnimSource="", bakeToClip="", clipId=0, combineLayers=True,
                        forceSampling=True, keepOriginalClip=True, path="", sampleBy=None,
                        targetTrackIndex=0, targetTracksNode="", q=True, query=True, e=True,
                        edit=True, **kwargs):
    """
    This command is used to bake Time Editor clips and to blend them into a single clip
    
    :param bakeToAnimSource: (C) Bake/merge the selected clips into the animation source
    :type bakeToAnimSource: string
    :param bakeToClip: (C) Bake/merge the selected clips into a clip
    :type bakeToClip: string
    :param clipId: (C M) Clip IDs of the clips to bake
    :type clipId: int
    :param combineLayers: (C) Combine the layers of the input clip
    :type combineLayers: boolean
    :param forceSampling: (C) Force sampling on the whole time range when baking
    :type forceSampling: boolean
    :param keepOriginalClip: (C) Keep the source clips after baking
    :type keepOriginalClip: boolean
    :param path: (C M) Full path of clips on which to operate  For example:
    composition1|track1|group; composition1|track1|group|track2|clip1
    :type path: string
    :param sampleBy: (C) Sampling interval when baking crossfades and timewarps
    :type sampleBy: time
    :param targetTrackIndex: (C) Specify the target track when baking containers  If
    targetTrackIndex is specified, the track index within the specified node is used  If
    targetTrackI
    :type targetTrackIndex: int
    :param targetTracksNode: (C) Target tracks node when baking containers
    :type targetTracksNode: string
    
    :returns: Command result
    :rtype: int
    """
    pass


def AlignCurveOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def evaluator(*args, clusters=True, configuration="", enable=True, info=True, name="",
              nodeType="", nodeTypeChildren=True, priority=0, valueName="", q=True, query=True,
              **kwargs):
    """
    Handles turning on and off custom evaluation overrides used by the evaluation manager 
    Query no flag to see all available custom evaluators  Query the 'enable' flag to check if
    an evaluator is currently enabled  If the 'name' flag isn't used then return all modes and
    their current active state
    
    :param clusters: (Q) This flag queries the list of clusters currently assigned to the named
    custom evaluator  The return value will be an array of strings where the array
    :type clusters: boolean
    :param configuration: (C Q M) Sends configuration information to a custom evaluator  It's
    up to the evaluator to understand what they mean  Multiple configuration messages can be
    :type configuration: string
    :param enable: (C Q) Enables or disables a specific graph evaluation runtime, depending on
    the state of the flag  In order to use this flag you must also specify the name
    :type enable: boolean
    :param info: (Q) Queries the evaluator information  Only valid in query mode since the
    information is generated by the evaluator's internal state and cannot be change
    :type info: boolean
    :param name: (C Q) Names a particular DG evaluation override evaluator  Evaluators are
    registered automatically by name  Query this flag to get a list of available runt
    :type name: string
    :param nodeType: (C Q M) Names a particular node type to be passed to the evaluator request
     Evaluators can either use or ignore the node type information as passed  In query
    :type nodeType: string
    :param nodeTypeChildren: (C Q) If enabled when using the 'nodeType' flag then handle all of
    the node types derived from the given one as well  Default is to only handle the named n
    :type nodeTypeChildren: boolean
    :param priority: (C Q) Query or set the evaluator priority  Custom evaluator with highest
    priority order will get the chance to claim the nodes first  Evaluators must have
    :type priority: int
    :param valueName: (Q) Queries a value from a given evaluator  Evaluators can define a set
    of values for which they answer  In query mode, this flag can accept a value
    :type valueName: string
    
    :returns: the list of available evaluators (querying with no evaluator flag or invalid
    evaluator name)
    :rtype: string[]
    """
    pass


def PostInfinityLinear(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def artSelectCtx(*args, accopacity=False, addselection=True, afterStrokeCmd="",
                 beforeStrokeCmd="", brushalignment=True, brushfeedback=True, clear=True,
                 dragSlider="", dynclonemode=True, exists=True, expandfilename=True,
                 exportaspectratio=0.0, exportfilemode="luminance/rgb", exportfilesave="",
                 exportfilesizex=0, exportfilesizey=0, exportfiletype="", history=True,
                 image1="", image2="", image3="", importfileload="", importfilemode="alpha",
                 importreassign=False, importthreshold=0.5, lastRecorderCmd="",
                 lastStampName="", lowerradius=0.0, makeStroke=0, mappressure="none", name="",
                 opacity=1.0, outline=True, outwhilepaint=False, paintmode="screen",
                 paintoperationtype="Paint", pickColor=True, pickValue=True,
                 playbackCursor=None, playbackPressure=0.0, preserveclonesource=True,
                 profileShapeFile="", projective=False, radius=1.0, record=True,
                 reflection=False, reflectionaboutorigin=True, reflectionaxis="x",
                 screenRadius=0.0, selectall=True, selectclonesource=True, selectop="select",
                 showactive=True, stampDepth=0.0, stampProfile="", stampSpacing=1.0,
                 strokesmooth="", surfaceConformedBrushVertices=True, tablet=True,
                 tangentOutline=True, toggleall=True, unselectall=True, usepressure=False,
                 worldRadius=0.0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command is used to select/deselect/toggle components on selected surfaces using a
    brush interface (Maya Artisan)  Since, it selects components of the surface, it only works
    in the component mode
    
    :param accopacity: (C Q E) Sets opacity accumulation on/off  C: Default is false (Except
    for sculpt tool for which it is true by default)  Q: When queried, it returns a boolean
    :type accopacity: boolean
    :param addselection: (C Q E) If true, each new stroke adds cvs to the active list  If false,
    each stroke replaces the previous selection  C: Default is true  Q: When queried, it
    :type addselection: boolean
    :param afterStrokeCmd: (C Q E) The passed string is executed as a MEL command immediately
    after the end of a stroke  C: Default is no command  Q: When queried, it returns the curre
    :type afterStrokeCmd: string
    :param beforeStrokeCmd: (C Q E) The passed string is executed as a MEL command immediately
    before the start of a stroke  C: Default is no command  Q: When queried, it returns the cu
    :type beforeStrokeCmd: string
    :param brushalignment: (C Q E) Specifies the path brush alignemnt  If true, the brush will
    align to stroke path, otherwise it will align to up vector  C: Default is true  Q: When q
    :type brushalignment: boolean
    :param brushfeedback: (C Q E) Specifies if the brush additional feedback should be drawn 
    C: Default is TRUE  Q: When queried, it returns a boolean
    :type brushfeedback: boolean
    :param clear: (C E) Floods all cvs/vertices to the current value
    :type clear: boolean
    :param dragSlider: (C E) Sets the current brush drag state for resizing or offsetting the
    brush (like the 'b' and 'm' default hotkeys)  The string argument is one of: "radius
    :type dragSlider: string
    :param dynclonemode: (C Q E) Enable or disable dynamic clone mode
    :type dynclonemode: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param expandfilename: (C E) If true, it will expand the name of the export file and
    concatenate it with the surface name  Otherwise it will take the name as it is  C: Default
    is
    :type expandfilename: boolean
    :param exportaspectratio: (C Q E) Value of aspect ratio for export
    :type exportaspectratio: float
    :param exportfilemode: (C Q E) Specifies the export channel.The valid entries here are:
    "alpha", "luminance", "rgb", "rgba"  C: Default is "luminance/rgb"  Q: When queried, it
    retu
    :type exportfilemode: string
    :param exportfilesave: (E) Exports the attribute map and saves to a specified file
    :type exportfilesave: string
    :param exportfilesizex: (C Q E) Specifies the width of the attribute map to export  C:
    Default width is 256  Q: When queried, it returns an integer
    :type exportfilesizex: int
    :param exportfilesizey: (C Q E) Specifies the width of the attribute map to export  C:
    Default width is 256  Q: When queried, it returns an integer
    :type exportfilesizey: int
    :param exportfiletype: (C Q E) Specifies the image file format  It can be one of the
    following: "iff", "tiff", "jpeg", "alias", "rgb", "fit" "postScriptEPS", "softimage",
    "wavefron
    :type exportfiletype: string
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param importfileload: (E) Load the attribute map a specified file
    :type importfileload: string
    :param importfilemode: (C Q E) Specifies the channel to import  The valid entries here are:
    "alpha", "luminance", "red", "green", "blue", and "rgb" C: Default is "alpha"  Q: When q
    :type importfilemode: string
    :param importreassign: (C Q E) Specifies if the multiply atrribute maps are to be
    reassigned while importing  Only maps previously exported from within Artisan can be
    reassigned  C
    :type importreassign: boolean
    :param importthreshold: (C Q E) Specifies the threshold for the import of the attribute
    maps  C: Default is 0.5  Q: When queried, it returns a float
    :type importthreshold: float
    :param lastRecorderCmd: (C Q E) Value of last recorded command
    :type lastRecorderCmd: string
    :param lastStampName: (C Q E) Value of the last stamp name
    :type lastStampName: string
    :param lowerradius: (C Q E) Sets the lower size of the brush (only apply on tablet)
    :type lowerradius: float
    :param makeStroke: (C Q E M) Stroke point values
    :type makeStroke: int
    :param mappressure: (C Q E) Sets the tablet pressure mapping when the table is used  There
    are four options: "none" - the pressure has no effect, "opacity" - the pressure is map
    :type mappressure: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param opacity: (C Q E) Sets the brush opacity  C: Default is 1.0  Q: When queried, it
    returns a float
    :type opacity: float
    :param outline: (C Q E) Specifies if the brush should be drawn  C: Default is TRUE  Q: When
    queried, it returns a boolean
    :type outline: boolean
    :param outwhilepaint: (C Q E) Specifies if the brush outline should be drawn while painting
     C: Default is FALSE  Q: When queried, it returns a boolean
    :type outwhilepaint: boolean
    :param paintmode: (C Q E) Specifies the paint mode  There are two possibilities: "screen"
    and "tangent"  C: Default is "screen"  Q: When queried, it returns a string
    :type paintmode: string
    :param paintoperationtype: (C Q E) Specifies the operation type used by the Paint Tool 
    Currently, we support the following paint modes: "Paint", "Smear", "Blur", "Erase" and
    "Clone"
    :type paintoperationtype: string
    :param pickColor: (C Q E) Set pick color mode on or off
    :type pickColor: boolean
    :param pickValue: (C Q E) Toggle for picking
    :type pickValue: boolean
    :param playbackCursor: (C Q E M) Values for the playback cursor
    :type playbackCursor: [float, float]
    :param playbackPressure: (C Q E M) Valus for the playback pressure
    :type playbackPressure: float
    :param preserveclonesource: (C Q E) Whether or not to preserve a clone source
    :type preserveclonesource: boolean
    :param profileShapeFile: (Q E) Passes a name of the image file for the stamp shape profile
    :type profileShapeFile: string
    :param projective: (C Q E) Specifies the projective paint mode  C: Default is 'false'  Q:
    When queried, it returns a boolean
    :type projective: boolean
    :param radius: (C Q E) Sets the size of the brush  C: Default is 1.0 cm  Q: When queried,
    it returns a float
    :type radius: float
    :param record: (C Q E) Toggle on for recording
    :type record: boolean
    :param reflection: (C Q E) Specifies the reflection mode  C: Default is 'false'  Q: When
    queried, it returns a boolean
    :type reflection: boolean
    :param reflectionaboutorigin: (C Q E) Toggle on to reflect about the origin
    :type reflectionaboutorigin: boolean
    :param reflectionaxis: (C Q E) Specifies the reflection axis  There are three
    possibilities: "x", "y" and "z"  C: Default is "x"  Q: When queried, it returns a string
    :type reflectionaxis: string
    :param screenRadius: (C Q E) Brush radius on the screen
    :type screenRadius: float
    :param selectall: (C E) Selects all vertices/egdes/faces/uvs
    :type selectall: boolean
    :param selectclonesource: (C Q E) Toggle on to select the clone source
    :type selectclonesource: boolean
    :param selectop: (C Q E) Specifies the selection operation ("select", "unselect", "toggle")
     C: Default is "select"  Q: When queried, it returns a string
    :type selectop: string
    :param showactive: (C Q E) Sets on/off the display of the surface isoparms  C: Default is
    TRUE  Q: When queried, it returns a boolean
    :type showactive: boolean
    :param stampDepth: (C Q E) Depth of the stamps
    :type stampDepth: float
    :param stampProfile: (C Q E) Sets the brush profile of the current stamp  Currently, the
    following profiles are supported: "gaussian", "poly", "solid" and "square"  C: Default is
    :type stampProfile: string
    :param stampSpacing: (C Q E) Specifies the stamp spacing  Default is 1.0
    :type stampSpacing: float
    :param strokesmooth: (C Q E) Stroke smoothing type name
    :type strokesmooth: string
    :param surfaceConformedBrushVertices: (C Q E) Enables/disables the the display of the
    effective brush area as affected vertices
    :type surfaceConformedBrushVertices: boolean
    :param tablet: (Q) Returns true if the tablet device is present, false if it is absent
    :type tablet: boolean
    :param tangentOutline: (C Q E) Enables/disables the display of the brush circle tangent to
    the surface
    :type tangentOutline: boolean
    :param toggleall: (C E) Toggle all vertices/egdes/faces/uvs
    :type toggleall: boolean
    :param unselectall: (C E) Unselects all vertices/egdes/faces/uvs
    :type unselectall: boolean
    :param usepressure: (C Q E) Sets the tablet pressure on/off  C: Default is false  Q: When
    queried, it returns a boolean
    :type usepressure: boolean
    :param worldRadius: (C Q E) Radius in worldspace
    :type worldRadius: float
    
    :returns: 
    :rtype: None
    """
    pass


def timeEditorClipOffset(*args, applyToAllRoots=True, clipId=0, matchClipId=0,
                         matchDstTime=None, matchObj=None, matchOffsetRot=True,
                         matchOffsetTrans=True, matchPath="", matchRotOp=0, matchSrcTime=None,
                         matchTransOp=0, offsetTransform=True, path="", resetMatch=0,
                         resetMatchPath="", rootObj="", upVectorX=0.0, upVectorY=0.0,
                         upVectorZ=0.0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command is used to compute an offset to apply on a source clip in order to
    automatically align it to a destination clip at a specified match element  For this command
    to work, offset objects must be specified for the character
    
    :param applyToAllRoots: (C) Apply root offsets to all roots in the population  However, if
    the root objects are specified by rootObj flag, this flag will be ignored
    :type applyToAllRoots: boolean
    :param clipId: (C E M) ID of the clip to be edited
    :type clipId: int
    :param matchClipId: (C) Specify the ID of a clip to match
    :type matchClipId: int
    :param matchDstTime: (C) Specify the time on target clip
    :type matchDstTime: time
    :param matchObj: (C) Specify the object to match
    :type matchObj: name
    :param matchOffsetRot: (Q) Get the rotation of the match offset matrix
    :type matchOffsetRot: boolean
    :param matchOffsetTrans: (Q) Get the translation of the match offset matrix
    :type matchOffsetTrans: boolean
    :param matchPath: (C) Full path of the clip to match  For example:
    composition1|track1|Group|track2|clip1
    :type matchPath: string
    :param matchRotOp: (C) Specify the option for matching rotation  0 : full - All rotation
    components are matched 1 : Y - Y component is matched 2 : none - No rotation matchi
    :type matchRotOp: int
    :param matchSrcTime: (C) Specify the time on source clip
    :type matchSrcTime: time
    :param matchTransOp: (C) Specify the option for matching translation  0 : full - All
    translation components are matched 1 : XZ - X and Z components are matched 2 : none - No
    :type matchTransOp: int
    :param offsetTransform: (C Q) Create/get an offset for the specified clip
    :type offsetTransform: boolean
    :param path: (C E M) Full path of a clip to be edited  For example:
    composition1|track1|group; composition1|track1|group|track2|clip1  In query mode, this flag
    can accept
    :type path: string
    :param resetMatch: (C) Specify clip ID to remove offset
    :type resetMatch: int
    :param resetMatchPath: (C) Specify clip's full path to remove offset  For example:
    composition1|track1|Group|track2|clip1
    :type resetMatchPath: string
    :param rootObj: (C Q E M) Specify the root objects  If specified, this flag will take
    precedence over applyToAllRoots flag  When used in query mode, returns list of roots defi
    :type rootObj: string
    :param upVectorX: (C) Specify the X coordinate of the up vector
    :type upVectorX: float
    :param upVectorY: (C) Specify the Y coordinate of the up vector
    :type upVectorY: float
    :param upVectorZ: (C) Specify the Z coordinate of the up vector
    :type upVectorZ: float
    
    :returns: 
    :rtype: None
    """
    pass


def FBXImportSetTake(*args, **kwargs):
    """
    
    """
    pass


def HypershadeGridToggleVisibility(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolyConvertToRingAndSplit(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ThreePointArcToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SmoothCurveOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def WireDropoffLocatorOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PublishParentAnchor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BrushPresetBlend(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PencilCurveToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXImportConvertUnitString(*args, **kwargs):
    """
    
    """
    pass


def CreateFluidCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def toolButton(*args, allowMultipleTools=True, annotation="", backgroundColor=None,
               changeCommand=None, collection="", defineTemplate="", docTag="",
               doubleClickCommand=None, dragCallback=None, dropCallback=None, enable=True,
               enableBackground=True, enableKeyboardFocus=True, exists=True, fullPathName=True,
               height=0, highlightColor=None, image1="", image2="", image3="",
               imageOverlayLabel="", isObscured=True, ltVersion="", manage=True,
               noBackground=True, numberOfPopupMenus=True, offCommand=None, onCommand=None,
               parent="", popupIndicatorVisible=True, popupMenuArray=True, preventOverride=True,
               select=True, statusBarMessage="", style="", tool="", toolArray=True,
               toolCount=True, toolImage1=None, toolImage2=None, toolImage3=None,
               useTemplate="", version="", visible=True, visibleChangeCommand=None, width=0,
               q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a toolButton that is added to the most recently created tool button
    collection unless the cl/collection flag is used  It also attaches the named tool,
    activating it when this control is selected   By default, this control only handles one
    tool at a time  Using the t/tool flag to associate a new tool will simply override the
    pre
    
    :param allowMultipleTools: (C Q) Indicates whether this control will allow you to attach
    more than one tool  By default, this control accepts only one tool  You can add multiple
    tool
    :type allowMultipleTools: boolean
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Command executed when the control's state is changed  Note that
    this flag should not be used in conjunction with onCommand and offCommand  That is, o
    :type changeCommand: script
    :param collection: (C E) To explicitly add a tool button to a tool collection
    :type collection: string
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param doubleClickCommand: (C E) Command executed when the control is double clicked
    :type doubleClickCommand: script
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param image1: (C Q E) 
    :type image1: string
    :param image2: (C Q E) 
    :type image2: string
    :param image3: (C Q E) This control supports three images  The image that best fits the
    current size of the control will be displayed  This flag applies the image to the cu
    :type image3: string
    :param imageOverlayLabel: (C Q E) A short string (5 characters) label that will be
    displayed on top of the icon
    :type imageOverlayLabel: string
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param ltVersion: (C Q E) This flag is used to specify the Maya LT version that this
    control feature was introduced, if the version flag is not specified, or if the version fl
    :type ltVersion: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param offCommand: (C E) Command executed when the control is turned off
    :type offCommand: script
    :param onCommand: (C E) Command executed when the control is turned on
    :type onCommand: script
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupIndicatorVisible: (C Q E) Edit this flag to set the visibility of the popup
    tool indicator  The indicator is a simple image that appears in the top right corner of the
    button
    :type popupIndicatorVisible: boolean
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param select: (C E) Will set this button as the selected one  This flag also queries the
    select state of the control
    :type select: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param style: (C E) The draw style of the control  Valid styles are "iconOnly", "textOnly",
    "iconAndTextHorizontal" and "iconAndTextVertical"
    :type style: string
    :param tool: (C Q E M) The name of the tool to be attached to the button  If the tool
    specified is already attached to this button then it will be selected  Query this flag
    :type tool: string
    :param toolArray: (Q) This query only flag returns the names of all the tools attached to
    the toolButton control
    :type toolArray: boolean
    :param toolCount: (Q) This query only flag return the number of tools attached to the
    toolButton control
    :type toolCount: boolean
    :param toolImage1: (C Q E M) 
    :type toolImage1: [string, string]
    :param toolImage2: (C Q E M) 
    :type toolImage2: [string, string]
    :param toolImage3: (C Q E M) This control supports three images  The image that best fits
    the current size of the control will be displayed  This flag applies the image to the sp
    :type toolImage3: [string, string]
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param version: (C Q E) Specify the version that this tool button feature was introduced 
    The argument should be given as a string of the version number (e.g  "2013", "2014"
    :type version: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the toolButton created.
    :rtype: string
    """
    pass


def findKeyframe(*args, animation="keysOrObjects.", attribute="", controlPoints=False,
                 curve=True, float=None, hierarchy="", includeUpperBound=True, index=0,
                 shape=True, time=None, timeSlider=True, which="", **kwargs):
    """
    This command operates on a keyset  A keyset is defined as a group of keys within a
    specified time range on one or more animation curves   The animation curves comprising a
    keyset depend on the value of the "-animation" flag:  keysOrObjects: Any active keys, when
    no target objects or -attribute flags appear on the command line, or All animation curv
    
    :param animation: (C) Where this command should get the animation to act on  Valid values
    are "objects," "keys," and "keysOrObjects" Default: "keysOrObjects." (See Descrip
    :type animation: string
    :param attribute: (C M) List of attributes to select In query mode, this flag needs a
    value
    :type attribute: string
    :param controlPoints: (C) This flag explicitly specifies whether or not to include the
    control points of a shape (see "-s" flag) in the list of attributes  Default: false  (No
    :type controlPoints: boolean
    :param curve: (C) Return a list of the existing curves driving the selected object or
    attributes  The which, index, floatRange, timeRange, and includeUpperBound flags
    :type curve: boolean
    :param float: (C M) value uniquely representing a non-time-based key (or key range) on a
    time-based animCurve  Valid floatRange include single values (-f 10) or a string
    :type float: floatrange
    :param hierarchy: (C) Hierarchy expansion options  Valid values are "above," "below," "both,
    " and "none." (Not valid for "pasteKey" cmd.) In query mode, this flag needs a
    :type hierarchy: string
    :param includeUpperBound: (C) When the -t/time or -f/float flags represent a range of keys,
    this flag determines whether the keys at the upper bound of the range are included in t
    :type includeUpperBound: boolean
    :param index: (C M) index of a key on an animCurve In query mode, this flag needs a value
    :type index: int
    :param shape: (C) Consider attributes of shapes below transforms as well, except
    "controlPoints"  Default: true  (Not valid for "pasteKey" cmd.) In query mode, this fl
    :type shape: boolean
    :param time: (C M) time uniquely representing a key (or key range) on a time-based
    animCurve  See the code examples below on how to format for a single frame or frame r
    :type time: timerange
    :param timeSlider: (C) Get the next key time from the ticks displayed in the time slider 
    If this flag is set, then the -an/animation flag is ignored
    :type timeSlider: boolean
    :param which: (C) next | previous | first | last How to find the key
    :type which: string
    
    :returns: Command result
    :rtype: time
    """
    pass


def PolygonPasteOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateSubdivRegion(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nonLinear(*args, after=True, afterReference=True, autoParent=True, before=True,
              commonParent=True, defaultScale=True, deformerTools=True, exclusive="",
              frontOfChain=True, geometry="", geometryIndices=True, ignoreSelected=True,
              includeHiddenSelections=False, name="", parallel=True, prune=True, remove=True,
              split=True, type="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a functional deformer of the specified type that will deform the
    selected objects  The deformer consists of three nodes: The deformer driver that gets
    connected to the history of the selected objects, the deformer handle transform that
    controls position and orientation of the axis of the deformation and the deformer handle
    that
    
    :param after: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type after: boolean
    :param afterReference: (C E) The -afterReference flag is used to specify deformer ordering
    in a hybrid way that choses between -before and -after automatically  If the geometry b
    :type afterReference: boolean
    :param autoParent: (C) Parents the deformer handle under the selected object's transform 
    This flag is valid only when a single object is selected
    :type autoParent: boolean
    :param before: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type before: boolean
    :param commonParent: (C) Creates a new transform and parents the selected object and the
    deformer handle under it  This flag is valid only when a single object is selected
    :type commonParent: boolean
    :param defaultScale: (C) Sets the scale of the deformation handle to 1  By default the
    deformation handle is scaled to the match the largest dimension of the selected objects
    :type defaultScale: boolean
    :param deformerTools: (Q) Returns the name of the deformer tool objects (if any) as string
    string ..
    :type deformerTools: boolean
    :param exclusive: (C Q) Puts the deformation set in a deform partition
    :type exclusive: string
    :param frontOfChain: (C E) This command is used to specify that the new deformer node
    should be placed ahead (upstream) of existing deformer and skin nodes in the shape's histo
    :type frontOfChain: boolean
    :param geometry: (Q E M) The specified object will be added to the list of objects being
    deformed by this deformer object, unless the -rm flag is also specified  When queried
    :type geometry: string
    :param geometryIndices: (Q) Complements the -geometry flag in query mode  Returns the multi
    index of each geometry
    :type geometryIndices: boolean
    :param ignoreSelected: (C) Tells the command to not deform objects on the current selection
    list
    :type ignoreSelected: boolean
    :param includeHiddenSelections: (C) Apply the deformer to any visible and hidden objects in
    the selection list  Default is false
    :type includeHiddenSelections: boolean
    :param name: (C) Used to specify the name of the node being created
    :type name: string
    :param parallel: (C E) Inserts the new deformer in a parallel chain to any existing
    deformers in the history of the object  A blendShape is inserted to blend the parallel r
    :type parallel: boolean
    :param prune: (E) Removes any points not being deformed by the deformer in its current
    configuration from the deformer set
    :type prune: boolean
    :param remove: (E M) Specifies that objects listed after the -g flag should be removed from
    this deformer
    :type remove: boolean
    :param split: (C E) Branches off a new chain in the dependency graph instead of
    inserting/appending the deformer into/onto an existing chain  Works in create mode (and e
    :type split: boolean
    :param type: (C) Specifies the type of deformation  The current valid deformation types
    are: bend, twist, squash, flare, sine and wave
    :type type: string
    
    :returns: Deformer driver name, deformer handle transform name.
    :rtype: string[]
    """
    pass


def shot(*args, audio="", clip="", clipDuration=None, clipOpacity=0.0, clipSyncState=True,
         clipZeroOffset=None, copy=True, createCustomAnim=True, currentCamera="",
         customAnim=True, deleteCustomAnim=True, determineTrack=True, endTime=None,
         favorite=True, flag1=True, flag10=True, flag11=True, flag12=True, flag2=True,
         flag3=True, flag4=True, flag5=True, flag6=True, flag7=True, flag8=True, flag9=True,
         hasCameraSet=True, hasStereoCamera=True, imagePlaneVisibility=True, linkAudio="",
         lock=True, mute=True, paste=True, pasteInstance=True, postHoldTime=None,
         preHoldTime=None, scale=0.0, selfmute=True, sequenceDuration=None,
         sequenceEndTime=None, sequenceStartTime=None, shotName="", sourceDuration=None,
         startTime=None, track=0, transitionInLength=None, transitionInType=0,
         transitionOutLength=None, transitionOutType=0, unlinkAudio=True, q=True, query=True,
         e=True, edit=True, **kwargs):
    """
    Use this command to create a shot node or manipulate that node
    
    :param audio: (C Q E) Specify the audio clip for this shot  Audio can be linked to a shot
    to allow playback of specific sounds when that shot is being displayed in the Seq
    :type audio: string
    :param clip: (C Q E) The clip associated with this shot  This clip will be posted to the
    currentCamera's imagePlane  Refer to the shot node's documentation for details on
    :type clip: string
    :param clipDuration: (C Q E) Length of clip  This is used for the display of the clip
    indicator bar in the Sequencer
    :type clipDuration: time
    :param clipOpacity: (C Q E) Opacity for the shot's clip, this value is assigned to the
    currentCamera's imagePlane  Refer to the shot node's documentation for details on how came
    :type clipOpacity: float
    :param clipSyncState: (C Q E) The viewport synchronization status of the clip associated
    with this shot  Return values are, 0 = no clip associated with this shot 1 = clip is fully
    :type clipSyncState: boolean
    :param clipZeroOffset: (C Q E) Specify which time of the clip corresponds to the beginning
    of the shot  This is used to properly align splitted clips
    :type clipZeroOffset: time
    :param copy: (C Q E) This flag is used to copy a shot to the clipboard  In query mode, this
    flag allows you to query what, if anything, has been copied into the shot clip
    :type copy: boolean
    :param createCustomAnim: (E) Creates an animation layer and links the shot node's
    customAnim attr to the weight attr of the animation layer
    :type createCustomAnim: boolean
    :param currentCamera: (C Q E) The camera associated with this shot  Refer to the shot
    node's documentation for details on how cameras are used by shots and the Sequencer
    :type currentCamera: string
    :param customAnim: (Q) Returns the name of the animation layer node linked to this shot
    node's customAnim attr
    :type customAnim: boolean
    :param deleteCustomAnim: (E) Disconnects the animation layer from this shot's customAnim
    attr and deletes the animation layer node
    :type deleteCustomAnim: boolean
    :param determineTrack: (Q E) Determines an available track for the shot  Returns a new
    track number or the existing track number if the current track is available
    :type determineTrack: boolean
    :param endTime: (C Q E) The shot end time in the Maya timeline  Changing the startTime will
    extend the duration of a shot
    :type endTime: time
    :param favorite: (C Q E) Make the shot a favorite  This is a UI indicator only to
    streamline navigation in the Sequencer panel
    :type favorite: boolean
    :param flag1: (C Q E) User specified state flag 1/12 for this shot
    :type flag1: boolean
    :param flag10: (C Q E) User specified state flag 10/12 for this shot
    :type flag10: boolean
    :param flag11: (C Q E) User specified state flag 11/12 for this shot
    :type flag11: boolean
    :param flag12: (C Q E) User specified state flag 12/12 for this shot
    :type flag12: boolean
    :param flag2: (C Q E) User specified state flag 2/12 for this shot
    :type flag2: boolean
    :param flag3: (C Q E) User specified state flag 3/12 for this shot
    :type flag3: boolean
    :param flag4: (C Q E) User specified state flag 4/12 for this shot
    :type flag4: boolean
    :param flag5: (C Q E) User specified state flag 5/12 for this shot
    :type flag5: boolean
    :param flag6: (C Q E) User specified state flag 6/12 for this shot
    :type flag6: boolean
    :param flag7: (C Q E) User specified state flag 7/12 for this shot
    :type flag7: boolean
    :param flag8: (C Q E) User specified state flag 8/12 for this shot
    :type flag8: boolean
    :param flag9: (C Q E) User specified state flag 9/12 for this shot
    :type flag9: boolean
    :param hasCameraSet: (C Q E) Returns true if the camera associated with this shot is a
    camera set
    :type hasCameraSet: boolean
    :param hasStereoCamera: (C Q E) Returns true if the camera associated with this shot is a
    stereo camera
    :type hasStereoCamera: boolean
    :param imagePlaneVisibility: (C Q E) Visibility of the shot imageplane, this value is
    assigned to the currentCamera's imagePlane
    :type imagePlaneVisibility: boolean
    :param linkAudio: (C Q E) Specify an audio clip to link to this shot  Any currently linked
    audio will be unlinked
    :type linkAudio: string
    :param lock: (C Q E) Lock a specific shot  This is different than locking an entire track,
    which is done via the shotTrack command
    :type lock: boolean
    :param mute: (C Q E) Mute a specific shot  This is different than muting an entire track,
    which is done via the shotTrack command  Querying this attribute will return tru
    :type mute: boolean
    :param paste: (C Q E) This flag is used to paste a shot or shots from the clipboard to the
    sequence timeline  Shots are added to the clipboard using the c/copy flag
    :type paste: boolean
    :param pasteInstance: (C Q E) This flag is used to paste an instance of a shot or shots
    from the clipboard to the sequence timeline  Unlike the p/paste flag, which duplicates the
    :type pasteInstance: boolean
    :param postHoldTime: (C Q E) Specify the time length to append to the shot in the sequence
    timeline  This repeats the last frame of the shot, in sequence time, over the specified
    :type postHoldTime: time
    :param preHoldTime: (C Q E) Specify the time length to prepend to the shot in the sequence
    timeline  This repeats the first frame of the shot, in sequence time, over the specifi
    :type preHoldTime: time
    :param scale: (C Q E) Specify an amount to scale the Maya frame range of the shot  This
    will affect the sequenceEndFrame, leaving the sequenceStartFrame unchanged
    :type scale: float
    :param selfmute: (C Q E) Query if this individual shot's own mute state is set  This is
    different from the flag "mute", which will return true if this shot is muted due to th
    :type selfmute: boolean
    :param sequenceDuration: (Q E) Return the sequence duration of the shot, which will include
    the holds and scale  This flag can only be queried
    :type sequenceDuration: time
    :param sequenceEndTime: (C Q E) The shot end in the sequence timeline  Changing the endTime
    of a shot will scale it in sequence time
    :type sequenceEndTime: time
    :param sequenceStartTime: (C Q E) The shot start in the sequence timeline  Changing the
    startTime of a shot will shift it in sequence time
    :type sequenceStartTime: time
    :param shotName: (C Q E) Specify a user-defined name for this shot  This allows the
    assignment of names that are not valid as node names within Maya  Whenever the shotName at
    :type shotName: string
    :param sourceDuration: (Q E) Return the number of source frames in the shot  This flag can
    only be queried
    :type sourceDuration: time
    :param startTime: (C Q E) The shot start time in the Maya timeline  Changing the startTime
    will extend the duration of a shot
    :type startTime: time
    :param track: (Q E) Specify the track in which this shot resides
    :type track: int
    :param transitionInLength: (C Q E) Length of the transtion into the shot
    :type transitionInLength: time
    :param transitionInType: (Q E) Specify the the type of transition for the transition into
    the shot  0 = Fade 1 = Dissolve
    :type transitionInType: int
    :param transitionOutLength: (C Q E) Length of the transtion out of the shot
    :type transitionOutLength: time
    :param transitionOutType: (Q E) Specify the the type of transition for the transition out
    of the shot  0 = Fade 1 = Dissolve
    :type transitionOutType: int
    :param unlinkAudio: (Q E) COMMENT Unlinks any currently linked audio
    :type unlinkAudio: boolean
    
    :returns: Shot name
    :rtype: string
    """
    pass


def moveKeyCtx(*args, exists=True, history=True, image1="", image2="", image3="",
               moveFunction="", name="", option="", q=True, query=True, e=True, edit=True,
               **kwargs):
    """
    This command creates a context which may be used to move keyframes within the graph editor
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param moveFunction: (Q E) linear | power | constant  Specifies how the keys are dragged 
    The default move type is constant where all keys move the same amount as controlled by
    :type moveFunction: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param option: (C Q E) Valid values are "move," "insert," "over," and "segmentOver." When
    you "move" a key, the key will not cross over (in time) any keys before or after i
    :type option: string
    
    :returns: Context name
    :rtype: string
    """
    pass


def CreateDiskCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SymmetrizeUVBrushSizeOn(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorFrameAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HIKInitAxis(*args, **kwargs):
    """
    
    """
    pass


def CreateSpotLight(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SoloLastOutput(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def resampleFluid(*args, resampleDepth=0, resampleHeight=0, resampleWidth=0, q=True, query=True,
                  e=True, edit=True, **kwargs):
    """
    A command to extend the fluid grid, keeping the voxels the same size, and keeping the
    existing contents of the fluid in the same place  Note that the fluid transform is also
    modified to make this possible
    
    :param resampleDepth: (C Q E) Change depth resolution to this value
    :type resampleDepth: int
    :param resampleHeight: (C Q E) Change height resolution to this value
    :type resampleHeight: int
    :param resampleWidth: (C Q E) Change width resolution to this value
    :type resampleWidth: int
    
    :returns: 
    :rtype: None
    """
    pass


def XgmSplinePresetImport(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nucleusDisplayTransformNodes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OneClickAcknowledgeCallback(*args, **kwargs):
    """
    
    """
    pass


def SendAsNewSceneMotionBuilder(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideClusters(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_viewBottom(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GeometryConstraint(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def mtkShrinkWrap(*args, **kwargs):
    """
    
    """
    pass


def ExtendCurveOnSurface(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmModifierGuideOp(*args, **kwargs):
    """
    
    """
    pass


def CreateSculptDeformer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CameraModeToggle(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreatePoseOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DecreaseGammaFine(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def myTestCmd(*args, **kwargs):
    """
    
    """
    pass


def dR_tweakPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def EmitFluidFromObjectOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ProductInformation(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def namespaceInfo(*args, absoluteName=True, baseName=True, currentNamespace=True, dagPath=True,
                  fullName=True, internal=True, isRootNamespace=True, listNamespace=True,
                  listOnlyDependencyNodes=True, listOnlyNamespaces=True, parent=True,
                  recurse=True, shortName=True, **kwargs):
    """
    This command displays information about a namespace  The target namespace can optionally be
    specified on the command line  If no namespace is specified, the command will display
    information about the current namespace    A namespace is a simple grouping of objects
    under a given name  Each item in a namespace can then be identified by its own name, 
    
    :param absoluteName: (C) This is a general flag which can be used to specify the desired
    format for the namespace(s) returned by the command  The absolute name of the namespa
    :type absoluteName: boolean
    :param baseName: (C) This is a general flag which can be used to specify the desired format
    for the namespace(s) returned by the command  The base name of the namespace c
    :type baseName: boolean
    :param currentNamespace: (C) Display the name of the current namespace
    :type currentNamespace: boolean
    :param dagPath: (C) This flag modifies the 'listNamespace' and 'listOnlyDependencyNodes'
    flags to indicate that the names of any dag objects returned will include as muc
    :type dagPath: boolean
    :param fullName: (C) This is a general flag which can be used to specify the desired format
    for the namespace(s) returned by the command  The full name of the namespace c
    :type fullName: boolean
    :param internal: (C) This flag is used together with the 'listOnlyDependencyNodes' flag 
    When this flag is set, the returned list will include internal nodes (for example
    :type internal: boolean
    :param isRootNamespace: (C) Returns true if the namespace is root(":"), false if not
    :type isRootNamespace: boolean
    :param listNamespace: (C) List the contents of the namespace
    :type listNamespace: boolean
    :param listOnlyDependencyNodes: (C) List all dependency nodes in the namespace
    :type listOnlyDependencyNodes: boolean
    :param listOnlyNamespaces: (C) List all namespaces in the namespace
    :type listOnlyNamespaces: boolean
    :param parent: (C) Display the parent of the namespace  By default, the list returned will
    not include internal nodes (such as itemFilters)  To include the internal nod
    :type parent: boolean
    :param recurse: (C) Can be specified with 'listNamespace', 'listOnlyNamespaces' or
    'listOnlyDependencyNode' to cause the listing to recursively include any child namespa
    :type recurse: boolean
    :param shortName: (C) This flag is deprecated and may be removed in future releases of Maya
     It is a synonym for the baseName flag  Please use the baseName flag instead
    :type shortName: boolean
    
    :returns: Command result
    :rtype: string
    """
    pass


def ToggleWireframeInArtisan(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectComponentToolMarkingMenuPopDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def skinPercent(*args, ignoreBelow=0.0, normalize=True, pruneWeights=0.0, relative=True,
                resetToDefault=True, transform="", transformMoveWeights="", transformValue=None,
                value=True, zeroRemainingInfluences=True, q=True, query=True, **kwargs):
    """
    This command edits and queries the weight values on members of a skinCluster node, given as
    the first argument  If no object components are explicitly mentioned in the command line,
    the current selection list is used   Note that setting multiple weights in a single
    invocation of this command is far more efficient than calling it once per weighted v
    
    :param ignoreBelow: (Q) Limits the output of the -value and -transform queries to the
    entries whose weight values are over the specified limit  This flag has to be used befo
    :type ignoreBelow: float
    :param normalize: (C) If set, the weights not assigned by the -transformValue flag are
    normalized so that the sum of the all weights for the selected object component add
    :type normalize: boolean
    :param pruneWeights: (C) Sets to zero any weight smaller than the given value for all the
    selected components  To use this command to set all the weights to zero, you must tu
    :type pruneWeights: float
    :param relative: (C) Used with -transformValue to specify a relative setting of values  If
    -relative is true, the value passed to -tv is added to the previous value  Othe
    :type relative: boolean
    :param resetToDefault: (C) Sets the weights of the selected components to their default
    values, overwriting any custom weights
    :type resetToDefault: boolean
    :param transform: (Q) In Mel, when used after the -query flag (without an argument) the
    command returns an array of strings corresponding to the names of the transforms in
    :type transform: string
    :param transformMoveWeights: (C M) This flag is used to transfer weights from a source
    influence to one or more target influences  It acts on the selected vertices  The flag must
    be us
    :type transformMoveWeights: string
    :param transformValue: (C M) Accepts a pair consisting of a transform name and a value and
    assigns that value as the weight of the selected object components corresponding to the
    :type transformValue: [string, float]
    :param value: (Q) Returns an array of doubles corresponding to the joint weights for the
    selected object component
    :type value: boolean
    :param zeroRemainingInfluences: (C) If set, the weights not assigned by the -transformValue
    flag are set to 0  The default is off
    :type zeroRemainingInfluences: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def CreatePointLight(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeOpenPropertyEditorWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CurlCurvesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateCameraAim(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BlindDataEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sbs_GetEditionModeScale(*args, **kwargs):
    """
    
    """
    pass


def OffsetSurfacesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SnapPointToPointOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def artSetPaint(*args, **kwargs):
    """
    
    """
    pass


def dR_multiCutPointCmd(*args, **kwargs):
    """
    
    """
    pass


def SelectAllNURBSSurfaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PanZoomTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleMeshMaps(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleRangeSlider(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeAdditiveGraphingMode(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polySphere(*args, axis=None, createUVs=2, radius=0.5, subdivisionsAxis=0,
               subdivisionsHeight=0, subdivisionsX=20, subdivisionsY=20, texture=0,
               caching=True, constructionHistory=True, name="", nodeState=0, object=True,
               q=True, query=True, e=True, edit=True, **kwargs):
    """
    The sphere command creates a new polygonal sphere
    
    :param axis: (C Q E) This flag specifies the primitive axis used to build the sphere  Q:
    When queried, this flag returns a float[3]
    :type axis: [float, float, float]
    :param createUVs: (C) This flag alows a specific UV mechanism to be selected, while
    creating the sphere  The valid values are 0, 1, or 2  0 implies that no UVs will be gen
    :type createUVs: int
    :param radius: (C Q E) This flag specifies the radius of the sphere  C: Default is 0.5  Q:
    When queried, this flag returns a float
    :type radius: float
    :param subdivisionsAxis: (C Q E) Subdivisions around the axis
    :type subdivisionsAxis: int
    :param subdivisionsHeight: (C Q E) Subdivisions along the height of the sphere
    :type subdivisionsHeight: int
    :param subdivisionsX: (C Q E) This specifies the number of subdivisions in the X direction
    for the sphere  C: Default is 20  Q: When queried, this flag returns an int
    :type subdivisionsX: int
    :param subdivisionsY: (C Q E) This flag specifies the number of subdivisions in the Y
    direction for the sphere  C: Default is 20  Q: When queried, this flag returns an int
    :type subdivisionsY: int
    :param texture: (C) This flag is obsolete and will be removed in the next release  The
    -cuv/createUVs flag should be used instead
    :type texture: int
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param object: (C) Create the result, or just the dependency node (where applicable)
    :type object: boolean
    
    :returns: Object name and node name.
    :rtype: string[]
    """
    pass


def PaintEffectsTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeConvertPSDToFileTexture(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DollyTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateNURBSPlane(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def loadPlugin(*args, addCallback=None, allPlugins=True, name="", quiet=True,
               removeCallback=None, **kwargs):
    """
    Load plug-ins into Maya  The parameter(s) to this command are either the names or pathnames
    of plug-in files  The convention for naming plug-ins is to use a .so extension on Linux, a
    .mll extension on Windows and .bundle extension on Mac OS X  If no extension is provided
    then the default extension for the platform will be used  To load a Python plu
    
    :param addCallback: (C) Add a MEL or Python callback script to be called after a plug-in is
    loaded  For MEL, the procedure should have the following signature: global proc p
    :type addCallback: script
    :param allPlugins: (C) Cause all plug-ins in the search path specified in MAYA_PLUG_IN_PATH
    to be loaded
    :type allPlugins: boolean
    :param name: (C) Set a user defined name for the plug-ins that are loaded  If the name is
    already taken, then a number will be added to the end of the name to make it
    :type name: string
    :param quiet: (C) Don't print a warning if you attempt to load a plug-in that is already
    loaded
    :type quiet: boolean
    :param removeCallback: (C) Removes a procedure which was previously added with
    -addCallback
    :type removeCallback: script
    
    :returns: the internal names of the successfully loaded plug-ins
    :rtype: string[]
    """
    pass


def setUITemplate(*args, popTemplate=True, pushTemplate=True, q=True, query=True, **kwargs):
    """
    This command sets the current(default) command template for the ELF commands  The special
    name NONE can be used to set no templates current  See "uiTemplate" command also
    
    :param popTemplate: (C) Pop the current template off of the stack and sets the next
    template on the stack to be current
    :type popTemplate: boolean
    :param pushTemplate: (C) Push the current template onto a stack that can later be popped
    :type pushTemplate: boolean
    
    :returns: The name of the currently selected command template.
    :rtype: string
    """
    pass


def boundary(*args, caching=True, endPoint=False, endPointTolerance=0.1, nodeState=0,
             order=True, constructionHistory=True, name="", object=True, polygon=0, range=True,
             q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command produces a boundary surface given 3 or 4 curves  This resulting boundary
    surface passes through two of the given curves in one direction, while in the other
    direction the shape is defined by the remaining curve(s)  If the "endPoint" option is on,
    then the curve endpoints must touch before a surface will be created  This is the usual
    si
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param endPoint: (C Q E) True means the curve ends must touch before a surface will be
    created  Default: false
    :type endPoint: boolean
    :param endPointTolerance: (C Q E) Tolerance for end points, only used if endPoint attribute
    is true  Default: 0.1
    :type endPointTolerance: float
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param order: (C Q E) True if the curve order is important  Default: true
    :type order: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param polygon: (C) The value of this argument controls the type of the object created by
    this operation 0: nurbs surface 1: polygon (use nurbsToPolygonsPref to set the
    :type polygon: int
    :param range: (C) Force a curve range on complete input curve
    :type range: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def SelectPreviousObjectsMudbox(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def flowLayout(*args, annotation="", backgroundColor=None, childArray=True, columnSpacing=0,
               defineTemplate="", docTag="", dragCallback=None, dropCallback=None, enable=True,
               enableBackground=True, enableKeyboardFocus=True, exists=True, fullPathName=True,
               height=0, highlightColor=None, horizontal=True, isObscured=True, manage=True,
               noBackground=True, numberOfChildren=True, numberOfPopupMenus=True, parent="",
               popupMenuArray=True, preventOverride=True, statusBarMessage="", useTemplate="",
               vertical=True, visible=True, visibleChangeCommand=None, width=0, wrap=True,
               q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a layout that arranges its children along a single line (either
    horizontal or vertical)  Depending on the value of the -wrap boolean flag (default is
    false), if the layout's parent cannot fit all the children on one line, the children will
    either wrap onto the next line(s) or be truncated
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param childArray: (Q) Returns a string array of the names of the layout's immediate
    children
    :type childArray: boolean
    :param columnSpacing: (C Q E) Sets the space between children
    :type columnSpacing: int
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param horizontal: (C Q E) Orientation of the layout  This flag is true by default, which
    corresponds to a horizontally laid out control
    :type horizontal: boolean
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfChildren: (Q) Returns in an int the number of immediate children of the
    layout
    :type numberOfChildren: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param vertical: (C Q) This flag is obsolete  Please use the -hr/-horizontal flag instead
    :type vertical: boolean
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    :param wrap: (C Q E) When set to true, if the layout's parent cannot fit all the children
    in a single line, the children will wrap onto the next line(s)  Default setting
    :type wrap: boolean
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def xgmBakeGuideToUVSpace(*args, **kwargs):
    """
    
    """
    pass


def radioCollection(*args, collectionItemArray=True, defineTemplate="", exists=True, gl=True,
                    numberOfCollectionItems=True, parent="", select="", useTemplate="", q=True,
                    query=True, e=True, edit=True, **kwargs):
    """
    This command creates a radio button collection  Collections are parented to the current
    default layout if no parent is specified with the -p/parent flag  As children of the layout
    they will be deleted when the layout is deleted  Collections may also span more than one
    window if the -gl/global flag is used  In this case the collection has no parent 
    
    :param collectionItemArray: (Q) Return a string list giving the long names of all the items
    in this collection
    :type collectionItemArray: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param gl: (C Q) Set the collection to have no parent layout  Global collections must be
    explicitly deleted
    :type gl: boolean
    :param numberOfCollectionItems: (Q) Return the number of items in this collection
    :type numberOfCollectionItems: boolean
    :param parent: (C) The parent of the collection  The collection will be deleted along with
    the parent
    :type parent: string
    :param select: (C Q E) Select the specified collection item  If queried will return the
    name of the currently selected collection item
    :type select: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: Full path name to the collection.
    :rtype: string
    """
    pass


def floatFieldGrp(*args, adjustableColumn=0, adjustableColumn2=0, adjustableColumn3=0,
                  adjustableColumn4=0, adjustableColumn5=0, adjustableColumn6=0, annotation="",
                  backgroundColor=None, changeCommand=None, columnAlign=None, columnAlign2=None,
                  columnAlign3=None, columnAlign4=None, columnAlign5=None, columnAlign6=None,
                  columnAttach=None, columnAttach2=None, columnAttach3=None, columnAttach4=None,
                  columnAttach5=None, columnAttach6=None, columnOffset2=None,
                  columnOffset3=None, columnOffset4=None, columnOffset5=None,
                  columnOffset6=None, columnWidth=None, columnWidth1=0, columnWidth2=None,
                  columnWidth3=None, columnWidth4=None, columnWidth5=None, columnWidth6=None,
                  defineTemplate="", docTag="", dragCallback=None, dragCommand=None,
                  dropCallback=None, enable=True, enable1=True, enable2=True, enable3=True,
                  enable4=True, enableBackground=True, enableKeyboardFocus=True, exists=True,
                  extraLabel="", fullPathName=True, height=0, highlightColor=None,
                  isObscured=True, label="", manage=True, noBackground=True, numberOfFields=0,
                  numberOfPopupMenus=True, parent="", popupMenuArray=True, precision=0,
                  preventOverride=True, rowAttach=None, showTrailingZeros=True,
                  statusBarMessage="", step=10.0, useTemplate="", value=None, value1=0.0,
                  value2=0.0, value3=0.0, value4=0.0, visible=True, visibleChangeCommand=None,
                  width=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    All of the group commands position their individual controls in columns starting at column
    1  The layout of each control (ie  column) can be customized using the -cw/columnWidth,
    -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumn flags  By
    default, columns are left aligned with no offset and are 100 pixels wide  Only o
    
    :param adjustableColumn: (C E) Specifies which column has an adjustable size that changes
    with the sizing of the layout  The column value is a 1-based index  Passing 0 as argument
    :type adjustableColumn: int
    :param adjustableColumn2: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly two columns
    :type adjustableColumn2: int
    :param adjustableColumn3: (C E) Specifies that the column has an adjustable size that
    changes with the size of the parent layout  Ignored if there are not exactly three columns
    :type adjustableColumn3: int
    :param adjustableColumn4: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly four columns
    :type adjustableColumn4: int
    :param adjustableColumn5: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly five columns
    :type adjustableColumn5: int
    :param adjustableColumn6: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly six columns
    :type adjustableColumn6: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Command string executed when the value of any of the fields
    changes
    :type changeCommand: script
    :param columnAlign: (C E M) Arguments are : column number, alignment type  Possible
    alignments are: left | right | center  Specifies alignment type for the specified column
    :type columnAlign: [int, string]
    :param columnAlign2: (C E) Sets the text alignment of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "center"
    :type columnAlign2: [string, string]
    :param columnAlign3: (C E) Sets the text alignment for all three columns  Ignored if there
    are not exactly three columns  Valid values are "left", "right", and "center"
    :type columnAlign3: [string, string, string]
    :param columnAlign4: (C E) Sets the text alignment for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "center"
    :type columnAlign4: [string, string, string, string]
    :param columnAlign5: (C E) Sets the text alignment for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "center"
    :type columnAlign5: [string, string, string, string, string]
    :param columnAlign6: (C E) Sets the text alignment for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "center"
    :type columnAlign6: [string, string, string, string, string, string]
    :param columnAttach: (C E M) Arguments are : column number, attachment type, and offset 
    Possible attachments are: left | right | both  Specifies column attachment types and offe
    :type columnAttach: [int, string, int]
    :param columnAttach2: (C E) Sets the attachment type of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "both"
    :type columnAttach2: [string, string]
    :param columnAttach3: (C E) Sets the attachment type for all three columns  Ignored if
    there are not exactly three columns  Valid values are "left", "right", and "both"
    :type columnAttach3: [string, string, string]
    :param columnAttach4: (C E) Sets the attachment type for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "both"
    :type columnAttach4: [string, string, string, string]
    :param columnAttach5: (C E) Sets the attachment type for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "both"
    :type columnAttach5: [string, string, string, string, string]
    :param columnAttach6: (C E) Sets the attachment type for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "both"
    :type columnAttach6: [string, string, string, string, string, string]
    :param columnOffset2: (C E) This flag is used in conjunction with the -columnAttach2 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the tw
    :type columnOffset2: [int, int]
    :param columnOffset3: (C E) This flag is used in conjunction with the -columnAttach3 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the th
    :type columnOffset3: [int, int, int]
    :param columnOffset4: (C E) This flag is used in conjunction with the -columnAttach4 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fo
    :type columnOffset4: [int, int, int, int]
    :param columnOffset5: (C E) This flag is used in conjunction with the -columnAttach5 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fi
    :type columnOffset5: [int, int, int, int, int]
    :param columnOffset6: (C E) This flag is used in conjunction with the -columnAttach6 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the si
    :type columnOffset6: [int, int, int, int, int, int]
    :param columnWidth: (C E M) Arguments are : column number, column width  Sets the width of
    the specified column where the first parameter specifies the column (1 based index) an
    :type columnWidth: [int, int]
    :param columnWidth1: (C E) Sets the width of the first column  Ignored if there is not
    exactly one column
    :type columnWidth1: int
    :param columnWidth2: (C E) Sets the column widths of both columns  Ignored if there are not
    exactly two columns
    :type columnWidth2: [int, int]
    :param columnWidth3: (C E) Sets the column widths for all 3 columns  Ignored if there are
    not exactly 3 columns
    :type columnWidth3: [int, int, int]
    :param columnWidth4: (C E) Sets the column widths for all 4 columns  Ignored if there are
    not exactly 4 columns
    :type columnWidth4: [int, int, int, int]
    :param columnWidth5: (C E) Sets the column widths for all 5 columns  Ignored if there are
    not exactly 5 columns
    :type columnWidth5: [int, int, int, int, int]
    :param columnWidth6: (C E) Sets the column widths for all 6 columns  Ignored if there are
    not exactly 6 columns
    :type columnWidth6: [int, int, int, int, int, int]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dragCommand: (C E) Command string executed when dragging the invisible slider in any
    of the fields
    :type dragCommand: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enable1: (C Q E) 
    :type enable1: boolean
    :param enable2: (C Q E) 
    :type enable2: boolean
    :param enable3: (C Q E) 
    :type enable3: boolean
    :param enable4: (C Q E) Enable state for the respective field
    :type enable4: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param extraLabel: (C Q E) If present on creation this specifies that there will be an
    extra label in the group  Sets the string to be label text to the right of fields
    :type extraLabel: string
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) If present on creation this specifies that there will be a label to
    the left of the fields  Sets the string to be the label text
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfFields: (C) Set the number of fields on creation  One to four fields are
    available  The default is one field
    :type numberOfFields: int
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param precision: (C E) Set the number of digits to the right of the decimal
    :type precision: int
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rowAttach: (C E M) Arguments are : column, attachment type, offset  Possible
    attachments are: top | bottom | both  Specifies attachment types and offsets for the
    entire
    :type rowAttach: [int, string, int]
    :param showTrailingZeros: (C E) Show trailing zeros or not
    :type showTrailingZeros: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param step: (C Q E) Set the delta of invisioSlider delta , the invisioSlider step is
    delta/10.0 in LMB , delta in MMB,delta*10.0 in RMB  Default is 10.0
    :type step: float
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param value: (C Q E) Values for all fields
    :type value: [float, float, float, float]
    :param value1: (C Q E) 
    :type value1: float
    :param value2: (C Q E) 
    :type value2: float
    :param value3: (C Q E) 
    :type value3: float
    :param value4: (C Q E) Value for the respective field
    :type value4: float
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def flushThumbnailCache(*args, **kwargs):
    """
    
    """
    pass


def MakeFluidCollideOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def fontAttributes(*args, **kwargs):
    """
    
    """
    pass


def nurbsCube(*args, axis=None, caching=True, degree=3, heightRatio=1.0, lengthRatio=1.0,
              nodeState=0, patchesU=1, patchesV=1, pivot=None, width=1.0,
              constructionHistory=True, name="", object=True, polygon=0, q=True, query=True,
              e=True, edit=True, **kwargs):
    """
    The nurbsCube command creates a new NURBS Cube made up of six planes  It creates an unit
    cube with center at origin by default
    
    :param axis: (C Q E) The primitive's axis
    :type axis: [float, float, float]
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param degree: (C Q E) The degree of the resulting surface  1 - linear, 2 - quadratic, 3 -
    cubic, 5 - quintic, 7 - heptic Default: 3
    :type degree: int
    :param heightRatio: (C Q E) Ratio of "height" to "width" Default: 1.0
    :type heightRatio: float
    :param lengthRatio: (C Q E) Ratio of "length" to "width" Default: 1.0
    :type lengthRatio: float
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param patchesU: (C Q E) Number of sections in U Default: 1
    :type patchesU: int
    :param patchesV: (C Q E) Number of sections in V Default: 1
    :type patchesV: int
    :param pivot: (C Q E) The primitive's pivot point
    :type pivot: [float, float, float]
    :param width: (C Q E) Width of the object Default: 1.0
    :type width: float
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param polygon: (C) The value of this argument controls the type of the object created by
    this operation 0: nurbs surface 1: polygon (use nurbsToPolygonsPref to set the
    :type polygon: int
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def undoInfo(*args, chunkName="", closeChunk=True, infinity=True, length=0, openChunk=True,
             printQueue=True, printRedoQueue=True, redoName="", redoQueueEmpty=True, state=True,
             stateWithoutFlush=True, undoName="", undoQueueEmpty=True, q=True, query=True,
             **kwargs):
    """
    This command controls the undo/redo parameters   In query mode, if invoked without flags
    (other than the query flag), this command will return the number of items currently on the
    undo queue
    
    :param chunkName: (C Q) Sets the name used to identify a chunk for undo/redo purposes when
    opening a chunk
    :type chunkName: string
    :param closeChunk: (C) Closes the chunk that was opened earlier by openChunk  Once close
    chunk is called, all undoable operations in the chunk will undo as a single undo op
    :type closeChunk: boolean
    :param infinity: (C Q) Set the queue length to infinity
    :type infinity: boolean
    :param length: (C Q) Specifies the maximum number of items in the undo queue  The infinity
    flag overrides this one
    :type length: int
    :param openChunk: (C) Opens a chunk so that all undoable operations after this call will
    fall into the newly opened chunk, until close chunk is called  Once close chunk is
    :type openChunk: boolean
    :param printQueue: (Q) Prints to the Script Editor the contents of the undo queue
    :type printQueue: boolean
    :param printRedoQueue: (Q) Prints to the Script Editor the contents of the redo queue
    :type printRedoQueue: boolean
    :param redoName: (Q) Returns what will be redone (if anything)
    :type redoName: string
    :param redoQueueEmpty: (Q) Return true if the redo queue is empty  Return false if there is
    at least one command in the queue to be redone
    :type redoQueueEmpty: boolean
    :param state: (C Q) Turns undo/redo on or off
    :type state: boolean
    :param stateWithoutFlush: (C Q) Turns undo/redo on or off without flushing the queue  Use
    with CAUTION!! Note that if you perform destructive operations while stateWithoutFlush is
    d
    :type stateWithoutFlush: boolean
    :param undoName: (Q) Returns what will be undone (if anything)
    :type undoName: string
    :param undoQueueEmpty: (Q) Return true if the undo queue is empty  Return false if there is
    at least one command in the queue to be undone
    :type undoQueueEmpty: boolean
    
    :returns: If querying undoName or redoName
    :rtype: string
    """
    pass


def polyBevel3(*args, angleTolerance=20.0, autoFit=True, caching=True, chamfer=True,
               constructionHistory=True, depth=1.0, fillNgons=False, mergeVertexTolerance=0.0,
               mergeVertices=False, miterAlong=0, mitering=0, miteringAngle=0.0, name="",
               nodeState=0, offset=0.2, offsetAsFraction=False, roundness=0.5, segments=1,
               smoothingAngle=0.0, uvAssignment=0, worldSpace=True, q=True, query=True, e=True,
               edit=True, **kwargs):
    """
    Bevel edges
    
    :param angleTolerance: (C Q E) Angular tolerance for creation of extra triangles Note this
    attribute is for compatability only and should not be modified in Maya 7.0 files Default:
    :type angleTolerance: float
    :param autoFit: (C Q E) If autoFit is on, it computes a smooth roundness : new facets round
    off a smooth angle  Default: true
    :type autoFit: boolean
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param chamfer: (C Q E) If chamfer is on, the surface is smoothed out at bevels  When it is
    off, the shape of the surface remains the same  Default: true
    :type chamfer: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param depth: (C Q E) The depth of bevel  One means a smooth surface, -1 means maximum
    depth  Default: 1.0
    :type depth: float
    :param fillNgons: (C Q E) Subdivide new faces with more than 4 edges Default: false
    :type fillNgons: boolean
    :param mergeVertexTolerance: (C Q E) Tolerance within which to merge vertices Default: 0.0
    :type mergeVertexTolerance: float
    :param mergeVertices: (C Q E) Merge vertices within a tolerance Default: false
    :type mergeVertices: boolean
    :param miterAlong: (C Q E) Controls in which direction new vertices should we offseted 
    Default: 0
    :type miterAlong: int
    :param mitering: (C Q E) Controls how the topology should look like at corners  Default: 0
    :type mitering: int
    :param miteringAngle: (C Q E) Miter faces that have angles less than this value Default:
    0.0
    :type miteringAngle: float
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param offset: (C Q E) The offset for bevel  Default: 0.2
    :type offset: float
    :param offsetAsFraction: (C Q E) If on, the offset value is treated as a fraction between
    zero and one  Default: false
    :type offsetAsFraction: boolean
    :param roundness: (C Q E) The roundness of bevel, it is taken into account when autoFit is
    off  Default: 0.5
    :type roundness: float
    :param segments: (C Q E) The number of segments used for beveling  Default: 1
    :type segments: int
    :param smoothingAngle: (C Q E) Create new edges as hard edges if the angle between adjacent
    faces exceeds this value Default: 0.0
    :type smoothingAngle: float
    :param uvAssignment: (C Q E) Technique used to compute UVs on new faces 0 computes new UVs
    by projecting along surface normal of original mesh onto new mesh 1 computes new UVs by
    :type uvAssignment: int
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def OneClickGetContactingAppName(*args, **kwargs):
    """
    
    """
    pass


def SquareSurfaceOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ScaleUVTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def circle(*args, caching=True, center=None, centerX=0, centerY=0, centerZ=0, degree=3,
           first=None, firstPointX=1, firstPointY=0, firstPointZ=0, fixCenter=True, nodeState=0,
           normal=None, normalX=0, normalY=0, normalZ=1, radius=1.0, sections=8,
           sweep=6.2831853, tolerance=0.01, useTolerance=False, constructionHistory=True,
           name="", object=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The circle command creates a circle or partial circle (arc)
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param center: (C Q E) The center point of the circle
    :type center: [float, float, float]
    :param centerX: (C Q E) X of the center point  Default: 0
    :type centerX: float
    :param centerY: (C Q E) Y of the center point  Default: 0
    :type centerY: float
    :param centerZ: (C Q E) Z of the center point  Default: 0
    :type centerZ: float
    :param degree: (C Q E) The degree of the resulting circle: 1 - linear, 3 - cubic Default:
    3
    :type degree: int
    :param first: (C Q E) The start point of the circle if fixCenter is false  Determines the
    orientation of the circle if fixCenter is true
    :type first: [float, float, float]
    :param firstPointX: (C Q E) X of the first point  Default: 1
    :type firstPointX: float
    :param firstPointY: (C Q E) Y of the first point  Default: 0
    :type firstPointY: float
    :param firstPointZ: (C Q E) Z of the first point  Default: 0
    :type firstPointZ: float
    :param fixCenter: (C Q E) Fix the center of the circle to the specified center point 
    Otherwise the circle will start at the specified first point  Default: true
    :type fixCenter: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param normal: (C Q E) The normal of the plane in which the circle will lie
    :type normal: [float, float, float]
    :param normalX: (C Q E) X of the normal direction  Default: 0
    :type normalX: float
    :param normalY: (C Q E) Y of the normal direction  Default: 0
    :type normalY: float
    :param normalZ: (C Q E) Z of the normal direction  Default: 1
    :type normalZ: float
    :param radius: (C Q E) The radius of the circle  Default: 1.0
    :type radius: float
    :param sections: (C Q E) The number of sections determines the resolution of the circle 
    Used only if useTolerance is false  Default: 8
    :type sections: int
    :param sweep: (C Q E) The sweep angle determines the completeness of the circle  A full
    circle is 2Pi radians, or 360 degrees  Default: 6.2831853
    :type sweep: float
    :param tolerance: (C Q E) The tolerance with which to build a circle  Used only if
    useTolerance is true Default: 0.01
    :type tolerance: float
    :param useTolerance: (C Q E) Use the specified tolerance to determine resolution  Otherwise
    number of sections will be used  Default: false
    :type useTolerance: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def assembly(*args, active="", activeLabel="", canCreate="", createOptionBoxProc=None,
             createRepresentation="", defaultType="", deleteRepresentation="", deregister="",
             input="", isAType="", isTrackingMemberEdits="", label="", listRepTypes=True,
             listRepTypesProc=None, listRepresentations=True, listTypes=True, name="",
             newRepLabel="", postCreateUIProc=None, proc=None, renameRepresentation="",
             repLabel="", repName="", repNamespace="", repPostCreateUIProc="",
             repPreCreateUIProc="", repType="", repTypeLabel="", repTypeLabelProc=None, type="",
             q=True, query=True, e=True, edit=True, **kwargs):
    """
    Command to register assemblies for the scene assembly framework, to create them, and to
    edit and query them  Assembly nodes are DAG nodes, and are therefore shown in the various
    DAG editors (Outliner, Hypergraph, Node Editor)  At assembly creation time, the node name
    defaults to the node type name  The assembly command can create any node that is d
    
    :param active: (Q E) Set the active representation by name, or query the name of the active
    representation  Edit mode can be applied to more than one assembly  Query mode
    :type active: string
    :param activeLabel: (Q E) Set the active representation by label, or query the label of the
    active representation  Edit mode can be applied to more than one assembly  Query mo
    :type activeLabel: string
    :param canCreate: (Q) Query the representation types the specific assembly can create
    :type canCreate: string
    :param createOptionBoxProc: (Q E) Set or query the option box menu procedure for a specific
    assembly type  The assembly type will be the default type, unless the -type flag is used
    to
    :type createOptionBoxProc: script
    :param createRepresentation: (E) Create and add a specific type of representation for an
    assembly  If the representation type needs additional parameters, they must be specified
    usin
    :type createRepresentation: string
    :param defaultType: (Q E) Set or query the default type of assembly  When the assembly
    command is used to perform an operation on an assembly type rather than on an assembly o
    :type defaultType: string
    :param deleteRepresentation: (E) Delete a specific representation from an assembly
    :type deleteRepresentation: string
    :param deregister: (E) Deregister a registered assembly type  If the deregistered type is
    the default type, the default type will be set to the empty string
    :type deregister: string
    :param input: (E) Specify the additional parameters of representation creation procedure
    when creating a representation  This flag must be used with createRepresentati
    :type input: string
    :param isAType: (Q) Query whether the given object is of an assembly type
    :type isAType: string
    :param isTrackingMemberEdits: (Q) Query whether the given object is tracking member edits
    :type isTrackingMemberEdits: string
    :param label: (Q E) Set or query the label for an assembly type  Assembly type is specified
    with flag "type"  If no type specified, the default type is used
    :type label: string
    :param listRepTypes: (Q) Query the supported representation types for a given assembly type
     The assembly type will be the default type, unless the -type flag is used to spec
    :type listRepTypes: boolean
    :param listRepTypesProc: (Q E) Set or query the procedure that provides the representation
    type list which an assembly type supports  This procedure takes no argument, and returns
    :type listRepTypesProc: script
    :param listRepresentations: (Q) Query the created representations list for a specific
    assembly  The -repType flag can be used to filter the list and return representations for a
    sin
    :type listRepresentations: boolean
    :param listTypes: (Q) Query the supported assembly types
    :type listTypes: boolean
    :param name: (C) Specify the name of the assembly when creating it
    :type name: string
    :param newRepLabel: (E) Specify the representation label to set on representation label
    edit
    :type newRepLabel: string
    :param postCreateUIProc: (Q E) Set or query the UI post-creation procedure for a given
    assembly type  This procedure will be invoked by Maya immediately after an assembly of the
    sp
    :type postCreateUIProc: script
    :param proc: (E) Specify the procedure when setting the representation UI post- or
    pre-creation procedure, for a given assembly type  The assembly type will be the de
    :type proc: script
    :param renameRepresentation: (E) Renames the representation that is the argument to this
    flag  The repName flag must be used to provide the new name
    :type renameRepresentation: string
    :param repLabel: (Q E) Query or edit the label of the representation that is the argument
    to this flag, for a given assembly  In both query and edit modes, the -repLabel fl
    :type repLabel: string
    :param repName: (E) Specify the representation name to set on representation creation or
    rename  This flag is optional with the createRepresentation flag: if omitted, th
    :type repName: string
    :param repNamespace: (Q) Query the representation namespace of this assembly node  The
    value returned is used by Maya for creating the namespace where nodes created by the ac
    :type repNamespace: string
    :param repPostCreateUIProc: (Q E) Set or query the UI post-creation procedure for a
    specific representation type, and for a specific assembly type  This procedure takes two
    arguments,
    :type repPostCreateUIProc: string
    :param repPreCreateUIProc: (Q E) Set or query the UI pre-creation procedure for a specific
    representation type, and for a specific assembly type  This procedure takes no argument,
    an
    :type repPreCreateUIProc: string
    :param repType: (Q) Specify a representation type to use as a filter for the
    -listRepresentations query  The representation type is the argument to this flag  In query
    m
    :type repType: string
    :param repTypeLabel: (Q) Query the label of the specific representation type  In query mode,
    this flag needs a value
    :type repTypeLabel: string
    :param repTypeLabelProc: (Q E) Set or query the procedure that provides the representation
    type label, for a given assembly type  The procedure takes the representation type as its
    :type repTypeLabelProc: script
    :param type: (C Q E) Set or query properties for the specified registered assembly type  In
    query mode, this flag needs a value
    :type type: string
    
    :returns: 
    :rtype: None
    """
    pass


def FBXImportSkins(*args, **kwargs):
    """
    
    """
    pass


def createAttrPatterns(*args, patternDefinition="", patternFile="", patternType="", **kwargs):
    """
    Create a new instance of an attribute pattern given a pattern type (e.g  XML) and a string
    or data file containing the description of the attribute tree in the pattern's format
    
    :param patternDefinition: (C) Hardcoded string containing the pattern definition, for
    simpler formats that don't really need a separate file for definition
    :type patternDefinition: string
    :param patternFile: (C) File where the pattern information can be found
    :type patternFile: string
    :param patternType: (C) Name of the pattern definition type to use in creating this
    instance of the pattern
    :type patternType: string
    
    :returns: Name of created pattern
    :rtype: string
    """
    pass


def BakeDeformerTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def bakeResults(*args, animation="keysOrObjects.", attribute="", bakeOnOverrideLayer=True,
                controlPoints=False, destinationLayer="", disableImplicitControl=True,
                float=None, hierarchy="", includeUpperBound=True, index=0,
                minimizeRotation=True, oversamplingRate=1, preserveOutsideKeys=False,
                removeBakedAnimFromLayer=True, removeBakedAttributeFromLayer=True,
                resolveWithoutLayer="", sampleBy=None, shape=True, simulation=False, smart=None,
                sparseAnimCurveBake=False, time=None, q=True, query=True, e=True, edit=True,
                **kwargs):
    """
    This command allows the user to replace a chain of dependency nodes which define the value
    for an attribute with a single animation curve  Command allows the user to specify the
    range and frequency of sampling   This command operates on a keyset  A keyset is defined as
    a group of keys within a specified time range on one or more animation curves   
    
    :param animation: (C) Where this command should get the animation to act on  Valid values
    are "objects," "keys," and "keysOrObjects" Default: "keysOrObjects." See command
    :type animation: string
    :param attribute: (C M) List of attributes to select In query mode, this flag needs a
    value
    :type attribute: string
    :param bakeOnOverrideLayer: (C) If true, all layered and baked attribute will be added as a
    top override layer
    :type bakeOnOverrideLayer: boolean
    :param controlPoints: (C) This flag explicitly specifies whether or not to include the
    control points of a shape (see "-s" flag) in the list of attributes  Default: false  (No
    :type controlPoints: boolean
    :param destinationLayer: (C) This flag can be used to specify an existing layer where the
    baked results should be stored  Use this flag with caution  If the destination layer alr
    :type destinationLayer: string
    :param disableImplicitControl: (C) Whether to disable implicit control after the anim
    curves are obtained as the result of this command  An implicit control to an attribute is
    some fun
    :type disableImplicitControl: boolean
    :param float: (C M) value uniquely representing a non-time-based key (or key range) on a
    time-based animCurve  Valid floatRange include single values (-f 10) or a string
    :type float: floatrange
    :param hierarchy: (C) Hierarchy expansion options  Valid values are "above," "below," "both,
    " and "none." (Not valid for "pasteKey" cmd.) In query mode, this flag needs a
    :type hierarchy: string
    :param includeUpperBound: (C) When the -t/time or -f/float flags represent a range of keys,
    this flag determines whether the keys at the upper bound of the range are included in t
    :type includeUpperBound: boolean
    :param index: (C M) index of a key on an animCurve In query mode, this flag needs a value
    :type index: int
    :param minimizeRotation: (C) Specify whether to minimize the local Euler component from key
    to key during baking of rotation channels
    :type minimizeRotation: boolean
    :param oversamplingRate: (C) Amount of samples per sampleBy period  Default is 1
    :type oversamplingRate: int
    :param preserveOutsideKeys: (C) Whether to preserve keys that are outside the bake range
    when there are directly connected animation curves or a pairBlend node which has an
    animatio
    :type preserveOutsideKeys: boolean
    :param removeBakedAnimFromLayer: (C) If true, all baked animation will be removed from the
    layer  Otherwise all layer associated with the baked animation will be muted
    :type removeBakedAnimFromLayer: boolean
    :param removeBakedAttributeFromLayer: (C) If true, all baked attribute will be removed from
    the layer  Otherwise all layer associated with the baked attribute will be muted
    :type removeBakedAttributeFromLayer: boolean
    :param resolveWithoutLayer: (C M) This flag can be used to specify a list of layers to be
    merged together during the bake process  This is a multi-use flag  Its name refers to the
    fac
    :type resolveWithoutLayer: string
    :param sampleBy: (C) Amount to sample by  Default is 1.0 in current timeUnit
    :type sampleBy: time
    :param shape: (C) Consider attributes of shapes below transforms as well, except
    "controlPoints"  Default: true  (Not valid for "pasteKey" cmd.) In query mode, this fl
    :type shape: boolean
    :param simulation: (C) Using this flag instructs the command to preform a simulation
    instead of just evaluating each attribute separately over the range of time  The simula
    :type simulation: boolean
    :param smart: (C) Specify whether to enable smart bake and the optional smart bake
    tolerance
    :type smart: [[, boolean, float, ]]
    :param sparseAnimCurveBake: (C) When this is true and anim curves are being baked, do not
    insert any keys into areas of the curve where animation is defined  And, use as few keys
    as
    :type sparseAnimCurveBake: boolean
    :param time: (C M) time uniquely representing a key (or key range) on a time-based
    animCurve  See the code examples below on how to format for a single frame or frame r
    :type time: timerange
    
    :returns: - The number of channels baked
    :rtype: int
    """
    pass


def textField(*args, alwaysInvokeEnterCommandOnReturn=True, annotation="", backgroundColor=None,
              changeCommand=None, defineTemplate="", disableButtons=True,
              disableClearButton=True, disableHistoryButton=True, docTag="", dragCallback=None,
              drawInactiveFrame=True, dropCallback=None, editable=True, enable=True,
              enableBackground=True, enableKeyboardFocus=True, enterCommand=None, exists=True,
              fileName="", font="", fullPathName=True, height=0, highlightColor=None,
              insertText="", insertionPosition=0, isObscured=True, manage=True,
              noBackground=True, numberOfPopupMenus=True, parent="", placeholderText="",
              popupMenuArray=True, preventOverride=True, receiveFocusCommand=None,
              searchField=True, statusBarMessage="", text="", textChangedCommand=None,
              useTemplate="", visible=True, visibleChangeCommand=None, width=0, q=True,
              query=True, e=True, edit=True, **kwargs):
    """
    Create a text field control
    
    :param alwaysInvokeEnterCommandOnReturn: (C Q E) Sets whether to always invoke the enter
    command when the return key is pressed by the user  By default, this option is false
    :type alwaysInvokeEnterCommandOnReturn: boolean
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Command executed when the text changes  This command is not
    invoked when the value changes via the -tx/text flag
    :type changeCommand: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param disableButtons: (C Q E) Sets the visibility state of search field buttons to
    true/false depending on the passed value  In Query mode returns whether both buttons are
    visible
    :type disableButtons: boolean
    :param disableClearButton: (C Q E) Sets the visibility state of search field clear button
    to true/false depending on the passed value  In Query mode returns whether clear button of
    sea
    :type disableClearButton: boolean
    :param disableHistoryButton: (C Q E) Sets the visibility state of search field history
    button to true/false depending on the passed value  In Query mode returns whether history
    button of
    :type disableHistoryButton: boolean
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param drawInactiveFrame: (C Q E) Sets whether the text field draws itself with a frame
    when it's inactive  By default, this option is false
    :type drawInactiveFrame: boolean
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param editable: (C Q E) The edit state of the field  By default, this flag is set to true
    and the field value may be changed by typing into it  If false then the field is 'r
    :type editable: boolean
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param enterCommand: (C E) Command executed when the keypad 'Enter' key is pressed
    :type enterCommand: script
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fileName: (C Q E) Text in the field as a filename  This does conversions between
    internal and external (UI) file representation
    :type fileName: string
    :param font: (C Q E) The font for the text  Valid values are "boldLabelFont",
    "smallBoldLabelFont", "tinyBoldLabelFont", "plainLabelFont", "smallPlainLabelFont",
    "oblique
    :type font: string
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param insertText: (C E) Insert text into the field at the current insertion position
    (specified by the -ip/insertionPosition flag)
    :type insertText: string
    :param insertionPosition: (C Q E) The insertion position for inserted text  This is a 1
    based value where position 1 specifies the beginning of the field  Position 0 may be used
    to sp
    :type insertionPosition: int
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param placeholderText: (C Q E) Setting this property makes the line edit display a
    grayed-out placeholder text as long as the text field is empty and the widget doesn't have
    focus
    :type placeholderText: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param receiveFocusCommand: (C E) Command executed when the field receives focus
    :type receiveFocusCommand: script
    :param searchField: (C) Creates a search field instead of a text field
    :type searchField: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param text: (C Q E) The field text
    :type text: string
    :param textChangedCommand: (C E) Command executed immediately when the field text changes
    :type textChangedCommand: script
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def polyMoveFacetUV(*args, axisLen=None, axisLenX=1.0, axisLenY=1.0, caching=True,
                    constructionHistory=True, name="", nodeState=0, pivot=None, pivotU=0.0,
                    pivotV=0.0, random=0.0, rotationAngle=0.0, scale=None, scaleU=1.0,
                    scaleV=1.0, translate=None, translateU=0.0, translateV=0.0, q=True,
                    query=True, e=True, edit=True, **kwargs):
    """
    Modifies the map by moving all UV values associated with the selected face(s)   The UV
    coordinates of the model are manipulated without changing the vertices of the 3D object
    
    :param axisLen: (C Q E) Axis Length vector, used to draw the manip handles  C: Default is
    1.0, 1.0 Q: When queried, this flag returns a float[2]
    :type axisLen: [float, float]
    :param axisLenX: (C Q E) Axis Length in X, used to draw the manip handles  C: Default is
    1.0 Q: When queried, this flag returns a float
    :type axisLenX: float
    :param axisLenY: (C Q E) Axis Length in Y, used to draw the manip handles  C: Default is
    1.0 Q: When queried, this flag returns a float
    :type axisLenY: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param pivot: (C Q E) This flag specifies the pivot for scaling and rotation  C: Default is
    0.0 0.0  Q: When queried, this flag returns a float[2]
    :type pivot: [float, float]
    :param pivotU: (C Q E) This flag specifies U for the pivot for scaling and rotation  C:
    Default is 0.0  Q: When queried, this flag returns a float
    :type pivotU: float
    :param pivotV: (C Q E) This flag specifies V for the pivot for scaling and rotation  C:
    Default is 0.0  Q: When queried, this flag returns a float
    :type pivotV: float
    :param random: (C Q E) This flag specifies the random value for all parameters  C: Default
    is 0.0  The range is [-10.0, 10.0]  Q: When queried, this flag returns a float
    :type random: float
    :param rotationAngle: (C Q E) Angle of rotation  C: Default is 0.0  Q: When queried, this
    flag returns a float
    :type rotationAngle: float
    :param scale: (C Q E) This flag specifies the scaling vector  C: Default is 1.0 1.0  Q:
    When queried, this flag returns a float
    :type scale: [float, float]
    :param scaleU: (C Q E) This flag specifies U for the scaling vector  C: Default is 1.0  Q:
    When queried, this flag returns a float
    :type scaleU: float
    :param scaleV: (C Q E) This flag specifies V for the scaling vector  C: Default is 1.0  Q:
    When queried, this flag returns a float
    :type scaleV: float
    :param translate: (C Q E) This flag specifies the translation vector  C: Default is 0.0 0.0
     Q: When queried, this flag returns a float[2]
    :type translate: [float, float]
    :param translateU: (C Q E) This flag specifies the U translation vector  C: Default is 0.0 
    Q: When queried, this flag returns a float
    :type translateU: float
    :param translateV: (C Q E) This flag specifies the V translation vector  C: Default is 0.0 
    Q: When queried, this flag returns a float
    :type translateV: float
    
    :returns: The node name.
    :rtype: string
    """
    pass


def FBXImportForcedFileAxis(*args, **kwargs):
    """
    
    """
    pass


def PanePop(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectAllMarkingMenuPopDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TangentsSpline(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def thumbnailCaptureComponent(*args, capture=True, capturedFrameCount=True,
                              closeCurrentSession=True, delete=True, endFrame=0,
                              fileDialogCallback="", isSessionOpened=True,
                              launchedFromOptionsBox=True, previewPath=True,
                              removeProjectThumbnail="", save="", startFrame=0, q=True,
                              query=True, **kwargs):
    """
    This command is used to generate a thumbnail/playblast sequence from the scene
    
    :param capture: (C) Create a new component to capture a sequence of image for the current
    scene
    :type capture: boolean
    :param capturedFrameCount: (Q) Query only  Return the number of frames that have been
    captured
    :type capturedFrameCount: boolean
    :param closeCurrentSession: (C) Delete the current thumbnail component (preview image will
    be destroyed)
    :type closeCurrentSession: boolean
    :param delete: (C) Delete the generated image sequence and preview for the current capture
    session
    :type delete: boolean
    :param endFrame: (C Q) Set the end captured frame  Only valid when the -c/capture flag is
    set  If -sf/startFrame is set and not -ef/endFrame, or if endFrame is smaller than
    :type endFrame: int
    :param fileDialogCallback: (C) MEL only  Set the callback file dialog which is called after
    the capture component window has been closed  Only valid when the -c/capture flag is set
    :type fileDialogCallback: string
    :param isSessionOpened: (Q) Returns true if a thumbnail/playblast capture session is
    currently running (already opened and still not cancelled/saved)
    :type isSessionOpened: boolean
    :param launchedFromOptionsBox: (Q) Returns true if the thumbnail capture component was
    launched through the options dialog box, else false
    :type launchedFromOptionsBox: boolean
    :param previewPath: (Q) Returns the generated preview path (the first frame of generated
    sequence resized to 100x100 px)
    :type previewPath: boolean
    :param removeProjectThumbnail: (C) Remove all captured thumbnail/playblast from the given
    project file path
    :type removeProjectThumbnail: string
    :param save: (C) Save the generated image sequence for the given file to disk  The file
    path must be an absolute path
    :type save: string
    :param startFrame: (C Q) Set the start captured frame  Only valid when -c/capture flag is
    set
    :type startFrame: int
    
    :returns: 
    :rtype: None
    """
    pass


def xgmExportToP3D(*args, **kwargs):
    """
    
    """
    pass


def OffsetEdgeLoopTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeRemoveTab(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PruneSculpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BendCurves(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreatePolygonSphere(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def agFormatOut(*args, **kwargs):
    """
    
    """
    pass


def SubdivProxy(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def transformLimits(*args, enableRotationX=None, enableRotationY=None, enableRotationZ=None,
                    enableScaleX=None, enableScaleY=None, enableScaleZ=None,
                    enableTranslationX=None, enableTranslationY=None, enableTranslationZ=None,
                    remove=True, rotationX=None, rotationY=None, rotationZ=None, scaleX=None,
                    scaleY=None, scaleZ=None, translationX=None, translationY=None,
                    translationZ=None, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The transformLimits command allows us to set, edit, or query the limits of the
    transformation that can be applied to objects   We can also turn any limits off which may
    have been previously set  When an object is first created, all the transformation limits
    are off by default.  Transformation limits allow us to control how much an object can be
    tra
    
    :param enableRotationX: (Q) enable/disable the lower and upper x-rotation limits When
    queried, it returns boolean boolean
    :type enableRotationX: [boolean, boolean]
    :param enableRotationY: (Q) enable/disable the lower and upper y-rotation limits When
    queried, it returns boolean boolean
    :type enableRotationY: [boolean, boolean]
    :param enableRotationZ: (Q) enable/disable the lower and upper z-rotation limits When
    queried, it returns boolean boolean
    :type enableRotationZ: [boolean, boolean]
    :param enableScaleX: (Q) enable/disable the lower and upper x-scale limits When queried, it
    returns boolean boolean
    :type enableScaleX: [boolean, boolean]
    :param enableScaleY: (Q) enable/disable the lower and upper y-scale limits When queried, it
    returns boolean boolean
    :type enableScaleY: [boolean, boolean]
    :param enableScaleZ: (Q) enable/disable the lower and upper z-scale limits When queried, it
    returns boolean boolean
    :type enableScaleZ: [boolean, boolean]
    :param enableTranslationX: (Q) enable/disable the ower and upper x-translation limits When
    queried, it returns boolean boolean
    :type enableTranslationX: [boolean, boolean]
    :param enableTranslationY: (Q) enable/disable the lower and upper y-translation limits When
    queried, it returns boolean boolean
    :type enableTranslationY: [boolean, boolean]
    :param enableTranslationZ: (Q) enable/disable the lower and upper z-translation limits When
    queried, it returns boolean boolean
    :type enableTranslationZ: [boolean, boolean]
    :param remove: (C) turn all the limits off and reset them to their default values
    :type remove: boolean
    :param rotationX: (Q) set the lower and upper x-rotation limits When queried, it returns
    angle angle
    :type rotationX: [float, float]
    :param rotationY: (Q) set the lower and upper y-rotation limits When queried, it returns
    angle angle
    :type rotationY: [float, float]
    :param rotationZ: (Q) set the lower and upper z-rotation limits When queried, it returns
    angle angle
    :type rotationZ: [float, float]
    :param scaleX: (Q) set the lower and upper x-scale limits When queried, it returns float
    float
    :type scaleX: [float, float]
    :param scaleY: (Q) set the lower and upper y-scale limits When queried, it returns float
    float
    :type scaleY: [float, float]
    :param scaleZ: (Q) set the lower and upper z-scale limits When queried, it returns float
    float
    :type scaleZ: [float, float]
    :param translationX: (Q) set the lower and upper x-translation limits When queried, it
    returns linear linear
    :type translationX: [float, float]
    :param translationY: (Q) set the lower and upper y-translation limits When queried, it
    returns linear linear
    :type translationY: [float, float]
    :param translationZ: (Q) set the lower and upper z-translation limits When queried, it
    returns linear linear
    :type translationZ: [float, float]
    
    :returns: 
    :rtype: None
    """
    pass


def SetMeshWaxTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolyEditEdgeFlowOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def viewFit(*args, allObjects=True, animate=True, center=True, fitFactor=0.0, namespace="",
            **kwargs):
    """
    The viewFit command positions the specified camera so its point-of-view contains all
    selected objects other than itself  If no objects are selected, everything is fit to the
    view (excepting cameras, lights, and sketching plannes)  The fit-factor, if specified,
    determines how much of the view should be filled  If a camera is not specified, the camer
    
    :param allObjects: (C) Specifies that all objects are to be fit regardless of the active
    list
    :type allObjects: boolean
    :param animate: (C) Specifies that the transition between camera positions should be
    animated
    :type animate: boolean
    :param center: (C) Specifies that the camera moves to the center of the selected object,
    but does not move the camera closer
    :type center: boolean
    :param fitFactor: (C) Specifies how much of the view should be filled with the "fitted"
    items
    :type fitFactor: float
    :param namespace: (C) Specifies a namespace that should be excluded  All objects in the
    specified namespace will be excluded from the fit process
    :type namespace: string
    
    :returns: 
    :rtype: None
    """
    pass


def AddInBetweenTargetShape(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MirrorCutPolygonGeometryOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowAllComponents(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def pasteKey(*args, animLayer="", animation="keysOrObjects.", attribute="", clipboard="",
             connect=False, copies=0, float=None, floatOffset=0.0, includeUpperBound=True,
             index=0, matchByName=False, option="", time=None, timeOffset=None, valueOffset=0.0,
             q=True, query=True, e=True, edit=True, **kwargs):
    """
    The pasteKey command pastes curve segment hierarchies from the clipboard onto other objects
    or curves  If the object hierarchy from which the curve segments were copied or cut does
    not match the object hierarchy being pasted to, pasteKey will paste as much as it can match
    in the hierarchy  If animation from only one object is on the clipboard, it w
    
    :param animLayer: (C) Specifies that the keys getting pasted should be pasted onto curves
    on the specified animation layer.If that layer doesn't exist for the specified ob
    :type animLayer: string
    :param animation: (C) Where this command should get the animation to act on  Valid values
    are "objects," "keys," and "keysOrObjects" Default: "keysOrObjects." (See Descrip
    :type animation: string
    :param attribute: (C M) List of attributes to select In query mode, this flag needs a
    value
    :type attribute: string
    :param clipboard: (C) Specifies the clipboard from which animation is pasted  Valid
    clipboards are "api" and "anim"  The default clipboard is: anim
    :type clipboard: string
    :param connect: (C) When true, connect the source curve with the destination curve's value
    at the paste time  (This has the effect of shifting the clipboard curve in val
    :type connect: boolean
    :param copies: (C) The number of times to paste the source curve
    :type copies: int
    :param float: (C) value uniquely representing a non-time-based key (or key range) on a
    time-based animCurve  Valid floatRange include single values (-f 10) or a string
    :type float: floatrange
    :param floatOffset: (C) How much to offset the pasted keys in time (for non-time-input
    animation curves)
    :type floatOffset: float
    :param includeUpperBound: (C) When the -t/time or -f/float flags represent a range of keys,
    this flag determines whether the keys at the upper bound of the range are included in t
    :type includeUpperBound: boolean
    :param index: (C) index of a key on an animCurve In query mode, this flag needs a value
    :type index: int
    :param matchByName: (C) When true, we will only paste onto items in the scene whose node
    and attribute names match up exactly with a corresponding item in the clipboard  No
    :type matchByName: boolean
    :param option: (C) Valid values are "insert", "replace", "replaceCompletely", "merge",
    "scaleInsert," "scaleReplace", "scaleMerge", "fitInsert", "fitReplace", and "fitM
    :type option: string
    :param time: (C) time uniquely representing a key (or key range) on a time-based animCurve 
    See the code examples below on how to format for a single frame or frame r
    :type time: timerange
    :param timeOffset: (C) How much to offset the pasted keys in time (for time-input animation
    curves)
    :type timeOffset: time
    :param valueOffset: (C) How much to offset the pasted keys in value
    :type valueOffset: float
    
    :returns: The number of curves pasted
    :rtype: int
    """
    pass


def TrackTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ClusterCurve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportShowUI(*args, **kwargs):
    """
    
    """
    pass


def RenderPassSetEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeSelectTextures(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PointConstraintOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AlignSurfaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def removeJoint(*args, **kwargs):
    """
    This command will remove the selected joint or the joint given at the command line from the
    skeleton   The given (or selected) joint should not be the root joint of the skeleton, and
    not have skin attached  The command works on the given (or selected) joint  No options or
    flags are necessary
    
    
    :returns: 
    :rtype: None
    """
    pass


def IncreaseManipulatorSize(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectVertexMask(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideFollicles(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ArtPaintAttrToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PublishAttributesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetMeshRelaxTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CurveFillet(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExport(*args, **kwargs):
    """
    
    """
    pass


def DeactivateGlobalScreenSliderModeMarkingMenu(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def renderGlobalsNode(*args, name="", parent="", renderQuality="", renderResolution="",
                      shared=True, skipSelect=True, **kwargs):
    """
    This command creates a new node in the dependency graph of the specified type   The
    renderGlobalsNode creates a render globals node and registers it with the model  The
    createNode command will not register nodes of this type correctly
    
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param parent: (C) Specifies the parent in the DAG under which the new node belongs
    :type parent: string
    :param renderQuality: (C) Set the quality to be the renderQuality node with the given name
    :type renderQuality: string
    :param renderResolution: (C) Set the resolution to be the resolution node with the given
    name
    :type renderResolution: string
    :param shared: (C) This node is shared across multiple files, so only create it if it does
    not already exist
    :type shared: boolean
    :param skipSelect: (C) This node is not to be selected after creation, the original
    selection will be preserved
    :type skipSelect: boolean
    
    :returns: The name of the new node.
    :rtype: string
    """
    pass


def multiProfileBirailSurface(*args, caching=True, nodeState=0, tangentContinuityProfile1=False,
                              tangentContinuityProfile2=False, transformMode=0,
                              constructionHistory=True, name="", object=True, polygon=0, q=True,
                              query=True, e=True, edit=True, **kwargs):
    """
    The cmd creates a railed surface by sweeping the profiles using two rail curves  The two
    rails are the last two arguments  For examples, if 5 curves are specified, they will
    correspond to "curve1" "curve2" "curve3" "rail1" "rail2"   In this case, the cmd creates a
    railed surface by sweeping the profile "curve1" to profile "curve2", profile "curve2"
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param tangentContinuityProfile1: (C Q E) Tangent continuous across the first profile  The
    profile must be a surface curve  Default: false
    :type tangentContinuityProfile1: boolean
    :param tangentContinuityProfile2: (C Q E) Tangent continuous across the last profile  The
    profile must be a surface curve  Default: false
    :type tangentContinuityProfile2: boolean
    :param transformMode: (C Q E) transform mode ( Non proportional, proportional )  Non
    proportional is default value  Default: 0
    :type transformMode: int
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param polygon: (C) The value of this argument controls the type of the object created by
    this operation 0: nurbs surface 1: polygon (use nurbsToPolygonsPref to set the
    :type polygon: int
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def objectTypeUI(*args, isType="", listAll=True, superClasses=True, **kwargs):
    """
    This command returns the type of UI element such as button, sliders, etc
    
    :param isType: (C) Returns true|false if the object is of the specified type
    :type isType: string
    :param listAll: (C) Returns a list of all known UI commands and their respective types 
    Each entry contains three strings which are the command name, ui type and class n
    :type listAll: boolean
    :param superClasses: (C) Returns a list of the names of all super classes for the given
    object  Note that all class names are internal and are subject to change
    :type superClasses: boolean
    
    :returns: The type of the specified object.
    :rtype: string
    """
    pass


def gridLayout(*args, allowEmptyCells=True, annotation="", autoGrow=True, backgroundColor=None,
               cellHeight=0, cellWidth=0, cellWidthHeight=None, childArray=True,
               columnsResizable=False, defineTemplate="", docTag="", dragCallback=None,
               dropCallback=None, enable=True, enableBackground=True, enableKeyboardFocus=True,
               exists=True, fullPathName=True, gridOrder=True, height=0, highlightColor=None,
               isObscured=True, manage=True, noBackground=True, numberOfChildren=True,
               numberOfColumns=0, numberOfPopupMenus=True, numberOfRows=0,
               numberOfRowsColumns=None, parent="", popupMenuArray=True, position=None,
               preventOverride=True, statusBarMessage="", useTemplate="", visible=True,
               visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
               **kwargs):
    """
    This layout arranges children in a grid fashion where every cell in the grid is the same
    size  You may specify the number of rows and columns as well as the width and height of the
    grid cells
    
    :param allowEmptyCells: (C Q) Specify true if you want free positioning of the children in
    the layout and potentially leaving empty cells between children  Set to false if you wan
    :type allowEmptyCells: boolean
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param autoGrow: (C Q) Specify true if you want the grid layout size to grow as children
    are added  For example, if the grid layout has 2 columns and 2 rows then adding a f
    :type autoGrow: boolean
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param cellHeight: (C Q E) A positive non-zero integer value indicating the height of cells
    in the grid layout
    :type cellHeight: int
    :param cellWidth: (C Q E) A positive non-zero integer value indicating the width of cells
    in the grid layout
    :type cellWidth: int
    :param cellWidthHeight: (C E) Two positive non-zero integer values for indicating the width
    and height, respectively, of the cells in the grid layout
    :type cellWidthHeight: [int, int]
    :param childArray: (Q) Returns a string array of the names of the layout's immediate
    children
    :type childArray: boolean
    :param columnsResizable: (C Q) Specify true if you want the number of columns to adjust
    according to the width of the layout  Set to false if you want the number of columns to
    rema
    :type columnsResizable: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param gridOrder: (Q) As opposed to the childArray flag, the gridOrder flag returns the
    children of the grid Layout in the order they are diplayed in the window
    :type gridOrder: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfChildren: (Q) Returns in an int the number of immediate children of the
    layout
    :type numberOfChildren: boolean
    :param numberOfColumns: (C Q E) A positive non-zero integer value indicating the number of
    columns in the grid layout
    :type numberOfColumns: int
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param numberOfRows: (C Q E) A positive non-zero integer value indicating the number of
    rows in the grid layout
    :type numberOfRows: int
    :param numberOfRowsColumns: (C E) Two positive non-zero integer values for the number of
    rows and columns, respectively, in the grid layout
    :type numberOfRowsColumns: [int, int]
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param position: (C E M) Specify the name of a child control in the grid layout along with
    a 1-based integer value indicating the desired position of the child  Positions inc
    :type position: [string, int]
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def ExtractFaceOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TogglePolyNonPlanarFaceDisplay(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ModifyUpperRadiusPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PerPointEmissionRates(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sbs_GetEnumCount(*args, **kwargs):
    """
    
    """
    pass


def parent(*args, absolute=True, addObject=True, noConnections=True, noInvScale=True,
           relative=True, removeObject=True, shape=True, world=True, **kwargs):
    """
    This command parents (moves) objects under a new group, removes objects from an existing
    group, or adds/removes parents   If the -w flag is specified all the selected or specified
    objects are parented to the world (unparented first)   If the -rm flag is specified then
    all the selected or specified instances are removed   If there are more than two 
    
    :param absolute: (C) preserve existing world object transformations (overall object
    transformation is preserved by modifying the objects local transformation) If the obje
    :type absolute: boolean
    :param addObject: (C) preserve existing local object transformations but don't reparent,
    just add the object(s) under the parent  Use -world to add the world as a parent o
    :type addObject: boolean
    :param noConnections: (C) The parent command will normally generate new instanced set
    connections when adding instances  (ie  make a connection to the shading engine for new i
    :type noConnections: boolean
    :param noInvScale: (C) The parent command will normally connect inverseScale to its parent
    scale on joints  This is used to compensate scale on joint  The connection of inv
    :type noInvScale: boolean
    :param relative: (C) preserve existing local object transformations (relative to the parent
    node)
    :type relative: boolean
    :param removeObject: (C) Remove the immediate parent of every object specified  To remove
    only a single instance of a shape from a parent, the path to the shape should be spe
    :type removeObject: boolean
    :param shape: (C) The parent command usually only operates on transforms  Using this flags
    allows a shape that is specified to be directly parented under the given tra
    :type shape: boolean
    :param world: (C) unparent given object(s) (parent to world)
    :type world: boolean
    
    :returns: Names of the objects parented (possibly renamed)
    :rtype: string[]
    """
    pass


def showManipCtx(*args, currentNodeName=True, exists=True, history=True, image1="", image2="",
                 image3="", incSnap=None, incSnapRelative=None, incSnapUI=True,
                 incSnapValue=None, lockSelection=True, name="", toggleIncSnap=True,
                 toolFinish=None, toolStart=None, q=True, query=True, e=True, edit=True,
                 **kwargs):
    """
    This command can be used to create a show manip context  The show manip context will
    display manips for all selected objects that have valid manips defined for them
    
    :param currentNodeName: (Q) Returns the name of the first node that the context is attached
    to
    :type currentNodeName: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param incSnap: (C Q E M) If true, the manipulator owned by the context will use
    incremental snapping for specified mode
    :type incSnap: [int, boolean]
    :param incSnapRelative: (C Q E M) If true, the manipulator owned by the context will use
    relative incremental snapping for specified mode
    :type incSnapRelative: [int, boolean]
    :param incSnapUI: (Q) Returns an array of elements indicating what kind of incremental snap
    UI is required by the manipulator owned by the context  If no UI is required, t
    :type incSnapUI: boolean
    :param incSnapValue: (C Q E M) Supply the step value which the manipulator owned by the
    context will use for specified mode
    :type incSnapValue: [int, float]
    :param lockSelection: (C Q E) If true, this context will never change the current selection
     By default this is set to false
    :type lockSelection: boolean
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param toggleIncSnap: (C E) Toggles (enables/disables) snapping for all modes
    :type toggleIncSnap: boolean
    :param toolFinish: (C Q E) Supply the script that will be run when the user exits the
    script
    :type toolFinish: script
    :param toolStart: (C Q E) Supply the script that will be run when the user first enters the
    script
    :type toolStart: script
    
    :returns: The name of the newly created context.
    :rtype: string
    """
    pass


def dgfilter(*args, attribute="", list=True, logicalAnd=None, logicalNot="", logicalOr=None,
             name="", node="", nodeType="", plug="", **kwargs):
    """
    The dgfilter command is used to define Dependency Graph filters that select DG objects
    based on certain criteria  The command itself can be used to filter objects or it can be
    attached to a dbtrace object to selectively filter what output is traced  If objects are
    specified then apply the filter to those objects and return a boolean indicating whet
    
    :param attribute: (C) Select objects whose attribute names match the pattern
    :type attribute: string
    :param list: (C) List the available filters  If used in conjunction with the -name flag it
    will show a description of what the filter is
    :type list: boolean
    :param logicalAnd: (C) Logical AND of two filters
    :type logicalAnd: [string, string]
    :param logicalNot: (C) Logical inverse of filter
    :type logicalNot: string
    :param logicalOr: (C) Logical OR of two filters
    :type logicalOr: [string, string]
    :param name: (C) Use filter named FILTER (or create new filter with that name)  If no
    objects are specified then the name given to the filter will be returned
    :type name: string
    :param node: (C) Select objects whose node names match the pattern
    :type node: string
    :param nodeType: (C) Select objects whose node type names match the pattern
    :type nodeType: string
    :param plug: (C) Select objects whose plug names match the pattern
    :type plug: string
    
    :returns: if creating filter or getting filter info
    :rtype: string
    """
    pass


def BoundaryOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PickWalkDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SculptSurfacesToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyTorus(*args, axis=None, caching=True, constructionHistory=True, createUVs=True, name="",
              nodeState=0, object=True, radius=1.0, sectionRadius=0.50, subdivisionsAxis=20,
              subdivisionsHeight=20, subdivisionsX=20, subdivisionsY=20, texture=True,
              twist=0.0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The torus command creates a new polygonal torus
    
    :param axis: (C Q E) This flag specifies the primitive axis used to build the torus  Q:
    When queried, this flag returns a vector
    :type axis: [float, float, float]
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param createUVs: (C Q E) Create UVs or not  Default: true
    :type createUVs: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param object: (C) Create the result, or just the dependency node (where applicable)
    :type object: boolean
    :param radius: (C Q E) Radius of the torus  Default: 1.0
    :type radius: float
    :param sectionRadius: (C Q E) Section of the torus  Default: 0.50
    :type sectionRadius: float
    :param subdivisionsAxis: (C Q E) Subdivisions about the vertical axis  Default: 20
    :type subdivisionsAxis: int
    :param subdivisionsHeight: (C Q E) Subdivisions along the height  Default: 20
    :type subdivisionsHeight: int
    :param subdivisionsX: (C Q E) This specifies the number of subdivisions in the X direction
    for the torus (number of sections)  C: Default is 20  Q: When queried, this flag returns
    :type subdivisionsX: int
    :param subdivisionsY: (C Q E) This flag specifies the number of subdivisions in the Y
    direction for the torus (number of segments per section)  C: Default is 20  Q: When queried,:type subdivisionsY: int
    :param texture: (C Q E) Apply texture or not  this is an old attribute  This is unsupported
    and would be removed in a future release  Default: true
    :type texture: boolean
    :param twist: (C Q E) Twist angle of the torus  Default: 0.0
    :type twist: float
    
    :returns: Object name and node name.
    :rtype: string[]
    """
    pass


def paramDimContext(*args, exists=True, history=True, image1="", image2="", image3="", name="",
                    q=True, query=True, e=True, edit=True, **kwargs):
    """
    Command used to register the paramDimCtx tool
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: - name of the context created
    :rtype: string
    """
    pass


def connectControl(*args, fileName=True, index=0, preventContextualMenu=True,
                   preventOverride=True, **kwargs):
    """
    This command attaches a UI widget, specified as the first argument, to one or more
    dependency node attributes  The attributes/nodes don't have to exist yet, they will get
    looked up as needed  With no flag specified, this command works on these kinds of controls:
    floatField, floatScrollBar, floatSlider, intField, intScrollBar, intSlider, floatFieldG
    
    :param fileName: (C) This flag causes the connection to be treated as a filename, and the
    conversion from internal to external filename representation is made as the data
    :type fileName: boolean
    :param index: (C) This flag enables you to pick out a sub-control from a group that
    contains a number of different controls  For example, you can connect one field of
    :type index: int
    :param preventContextualMenu: (C) If true, this flag will block the right mouse button menu
    of the associated control attribute
    :type preventContextualMenu: boolean
    :param preventOverride: (C) If true, this flag disallows overriding the control's attribute
    via the control's right mouse button menu
    :type preventOverride: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def xgmSculptLayerInit(*args, **kwargs):
    """
    
    """
    pass


def SelectPolygonToolMarkingMenu(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateAnnotateNode(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HidePlanes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SlideEdgeToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OutlinerToggleAssignedMaterials(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeToggleNodeSwatchSize(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def attachCurve(*args, blendBias=0.5, blendKnotInsertion=False, caching=True,
                keepMultipleKnots=True, method=0, nodeState=0, parameter=0.1, reverse1=False,
                reverse2=False, constructionHistory=True, name="", object=True,
                replaceOriginal=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This attach command is used to attach curves  Once the curves are attached, there will be
    multiple knots at the joined point(s)  These can be kept or removed if the user wishes   If
    there are two curves, the end of the first curve is attached to the start of the second
    curve  If there are more than two curves, closest endpoints are joined   Note: i
    
    :param blendBias: (C Q E) Skew the result toward the first or the second curve depending on
    the blend factory being smaller or larger than 0.5  Default: 0.5
    :type blendBias: float
    :param blendKnotInsertion: (C Q E) If set to true, insert a knot in one of the original
    curves (relative position given by the parameter attribute below) in order to produce a
    slightly
    :type blendKnotInsertion: boolean
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param keepMultipleKnots: (C Q E) If true, keep multiple knots at the join parameter 
    Otherwise remove them  Default: true
    :type keepMultipleKnots: boolean
    :param method: (C Q E) Attach method (connect-0, blend-1) Default: 0
    :type method: int
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param parameter: (C Q E) The parameter value for the positioning of the newly inserted
    knot  Default: 0.1
    :type parameter: float
    :param reverse1: (C Q E) If true, reverse the first input curve before doing attach 
    Otherwise, do nothing to the first input curve before attaching  NOTE: setting this attri
    :type reverse1: boolean
    :param reverse2: (C Q E) If true, reverse the second input curve before doing attach 
    Otherwise, do nothing to the second input curve before attaching  NOTE: setting this att
    :type reverse2: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def keyTangent(*args, absolute=True, animation="keysOrObjects.", attribute="",
               controlPoints=False, float=None, g=True, hierarchy="", inAngle=0.0,
               inTangentType="", inWeight=0.0, includeUpperBound=True, index=0, ix=0.0, iy=0.0,
               lock=True, outAngle=0.0, outTangentType="", outWeight=0.0, ox=0.0, oy=0.0,
               pluginTangentTypes="", relative=True, shape=True, stepAttributes=True, time=None,
               unify=True, weightLock=True, weightedTangents=True, q=True, query=True, e=True,
               edit=True, **kwargs):
    """
    This command operates on a keyset  A keyset is defined as a group of keys within a
    specified time range on one or more animation curves   The animation curves comprising a
    keyset depend on the value of the "-animation" flag:  keysOrObjects: Any active keys, when
    no target objects or -attribute flags appear on the command line, or All animation curv
    
    :param absolute: (C E) Changes to tangent positions are NOT relative to the current
    position
    :type absolute: boolean
    :param animation: (C) Where this command should get the animation to act on  Valid values
    are "objects," "keys," and "keysOrObjects" Default: "keysOrObjects." (See Descrip
    :type animation: string
    :param attribute: (C M) List of attributes to select In query mode, this flag needs a
    value
    :type attribute: string
    :param controlPoints: (C) This flag explicitly specifies whether or not to include the
    control points of a shape (see "-s" flag) in the list of attributes  Default: false  (No
    :type controlPoints: boolean
    :param float: (C M) value uniquely representing a non-time-based key (or key range) on a
    time-based animCurve  Valid floatRange include single values (-f 10) or a string
    :type float: floatrange
    :param g: (C) Required for all operations on the global tangent type  The global tangent
    type is used by the setKeyframe command when tangent types have not been s
    :type g: boolean
    :param hierarchy: (C) Hierarchy expansion options  Valid values are "above," "below," "both,
    " and "none." (Not valid for "pasteKey" cmd.) In query mode, this flag needs a
    :type hierarchy: string
    :param inAngle: (C Q E) New value for the angle of the in-tangent  Returns a float[] when
    queried
    :type inAngle: float
    :param inTangentType: (C Q E) Specify the in-tangent type  Valid values are "spline,"
    "linear," "fast," "slow," "flat," "step," "stepnext," "fixed," "clamped," "plateau" and
    "auto
    :type inTangentType: string
    :param inWeight: (C Q E) New value for the weight of the in-tangent  Returns a float[] when
    queried
    :type inWeight: float
    :param includeUpperBound: (C) When the -t/time or -f/float flags represent a range of keys,
    this flag determines whether the keys at the upper bound of the range are included in t
    :type includeUpperBound: boolean
    :param index: (C M) index of a key on an animCurve In query mode, this flag needs a value
    :type index: int
    :param ix: (C Q E) New value for the x-component of the in-tangent  This is a unit
    independent representation of the tangent component  Returns a float[] when queried
    :type ix: float
    :param iy: (C Q E) New value for the y-component of the in-tangent  This is a unit
    independent representation of the tangent component  Returns a float[] when queried
    :type iy: float
    :param lock: (C Q E) Lock a tangent so in and out tangents move together  Returns an int[]
    when queried
    :type lock: boolean
    :param outAngle: (C Q E) New value for the angle of the out-tangent  Returns a float[] when
    queried
    :type outAngle: float
    :param outTangentType: (C Q E) Specify the out-tangent type  Valid values are "spline,"
    "linear," "fast," "slow," "flat," "step," "stepnext," "fixed," "clamped," "plateau" and
    "aut
    :type outTangentType: string
    :param outWeight: (C Q E) New value for the weight of the out-tangent  Returns a float[]
    when queried
    :type outWeight: float
    :param ox: (C Q E) New value for the x-component of the out-tangent  This is a unit
    independent representation of the tangent component  Returns a float[] when queried
    :type ox: float
    :param oy: (C Q E) New value for the y-component of the out-tangent  This is a unit
    independent representation of the tangent component  Returns a float[] when queried
    :type oy: float
    :param pluginTangentTypes: (Q) Returns a list of the plug-in tangent types that have been
    loaded  Return type is a string array
    :type pluginTangentTypes: string
    :param relative: (C E) Changes to tangent positions are relative to the current position
    :type relative: boolean
    :param shape: (C) Consider attributes of shapes below transforms as well, except
    "controlPoints"  Default: true  (Not valid for "pasteKey" cmd.) In query mode, this fl
    :type shape: boolean
    :param stepAttributes: (C E) The setKeyframe command will automatically set tangents for
    boolean and enumerated attributes to step  This flag mirrors this behavior for the keyTan
    :type stepAttributes: boolean
    :param time: (C M) time uniquely representing a key (or key range) on a time-based
    animCurve  See the code examples below on how to format for a single frame or frame r
    :type time: timerange
    :param unify: (C E) Unify a tangent so in and out tangents are equal and move together
    :type unify: boolean
    :param weightLock: (C Q E) Lock the weight of a tangent so it is fixed  Returns an int[]
    when queried  Note: weightLock is only obeyed within the graph editor  It is not obeyed
    :type weightLock: boolean
    :param weightedTangents: (C Q E) Specify whether or not the tangents on the animCurve are
    weighted Note: switching a curve from weightedTangents true to false and back to true
    again
    :type weightedTangents: boolean
    
    :returns: Number of curves on which tangents were modified.
    :rtype: int
    """
    pass


def fluidAppendOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def VolumeAxisOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def geometryExportCacheOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def displayRGBColor(*args, create=True, hueSaturationValue=True, list=True, resetToFactory=True,
                    resetToSaved=True, q=True, query=True, **kwargs):
    """
    This command changes or queries the display color for anything in the application that
    allows the user to set its color  These colors are part of the UI and not part of the saved
    data for a model  This command is not undoable
    
    :param create: (C) Creates a new RGB display color which can be queried or set  If is used
    only when saving color preferences  name Specifies the name of color to chang
    :type create: boolean
    :param hueSaturationValue: (C Q) Indicates that rgb values are really hsv values  Upon
    query, returns the HSV valuses as an array of 3 floats  r g b The RGB values for the color 
    (Be
    :type hueSaturationValue: boolean
    :param list: (C) Writes out a list of all RGB color names and their value
    :type list: boolean
    :param resetToFactory: (C) Resets all the RGB display colors to their factory defaults
    :type resetToFactory: boolean
    :param resetToSaved: (C) Resets all the RGB display colors to their saved values
    :type resetToSaved: boolean
    
    :returns: when the list flag is used, none otherwise
    :rtype: string
    """
    pass


def keyframe(*args, absolute=True, adjustBreakdown=True, animation="keysOrObjects.",
             attribute="", breakdown=False, clipTime=None, controlPoints=False, eval=True,
             float=None, floatChange=0.0, hierarchy="", includeUpperBound=True, index=0,
             indexValue=True, keyframeCount=True, lastSelected=True, name=True, option="",
             relative=True, selected=True, shape=True, tickDrawSpecial=True, time=None,
             timeChange=None, valueChange=0.0, q=True, query=True, e=True, edit=True,
             **kwargs):
    """
    This command operates on a keyset  A keyset is defined as a group of keys within a
    specified time range on one or more animation curves   The animation curves comprising a
    keyset depend on the value of the "-animation" flag:  keysOrObjects: Any active keys, when
    no target objects or -attribute flags appear on the command line, or All animation curv
    
    :param absolute: (C) Move amounts are absolute
    :type absolute: boolean
    :param adjustBreakdown: (C) When false, moving keys will not preserve breakdown timing,
    when true (the default) breakdowns will be adjusted to preserve their timing relationship
    :type adjustBreakdown: boolean
    :param animation: (C) Where this command should get the animation to act on  Valid values
    are "objects," "keys," and "keysOrObjects" Default: "keysOrObjects." (See Descrip
    :type animation: string
    :param attribute: (C M) List of attributes to select In query mode, this flag needs a
    value
    :type attribute: string
    :param breakdown: (C Q E) Sets the breakdown state for the key  Returns an integer  Default
    is false  The breakdown state of a key cannot be set in the same command as it is m
    :type breakdown: boolean
    :param clipTime: (C) Modifies the final time where a key is inserted using an offset, pivot,
    and scale
    :type clipTime: [time, time, float]
    :param controlPoints: (C) This flag explicitly specifies whether or not to include the
    control points of a shape (see "-s" flag) in the list of attributes  Default: false  (No
    :type controlPoints: boolean
    :param eval: (C Q) Returns the value(s) of the animCurves when evaluated (without regard to
    input connections) at the times given by the -t/time or -f/float flags  Cann
    :type eval: boolean
    :param float: (C M) value uniquely representing a non-time-based key (or key range) on a
    time-based animCurve  Valid floatRange include single values (-f 10) or a string
    :type float: floatrange
    :param floatChange: (C Q E) How much (with -relative) or where (with -absolute) to move
    keys (on non-time-input animation curves) along the x (float) axis  Returns float[] when
    :type floatChange: float
    :param hierarchy: (C) Hierarchy expansion options  Valid values are "above," "below," "both,
    " and "none." (Not valid for "pasteKey" cmd.) In query mode, this flag needs a
    :type hierarchy: string
    :param includeUpperBound: (C) When the -t/time or -f/float flags represent a range of keys,
    this flag determines whether the keys at the upper bound of the range are included in t
    :type includeUpperBound: boolean
    :param index: (C M) index of a key on an animCurve In query mode, this flag needs a value
    :type index: int
    :param indexValue: (C Q) Query-only flag that returns an int for the key's index
    :type indexValue: boolean
    :param keyframeCount: (C Q) Returns an int for the number of keys found for the targets
    :type keyframeCount: boolean
    :param lastSelected: (C Q) When used in queries, this flag returns requested values for the
    last selected key
    :type lastSelected: boolean
    :param name: (C Q) Returns the names of animCurves of specified nodes, attributes or keys
    :type name: boolean
    :param option: (C E) Valid values are "move," "insert," "over," and "segmentOver." When you
    "move" a key, the key will not cross over (in time) any keys before or after i
    :type option: string
    :param relative: (C) Move amounts are relative to a key's current position
    :type relative: boolean
    :param selected: (C Q) When used in queries, this flag returns requested values for any
    active keys
    :type selected: boolean
    :param shape: (C) Consider attributes of shapes below transforms as well, except
    "controlPoints"  Default: true  (Not valid for "pasteKey" cmd.) In query mode, this fl
    :type shape: boolean
    :param tickDrawSpecial: (C E) Sets the special drawing state for this key when it is drawn
    as a tick in the timeline
    :type tickDrawSpecial: boolean
    :param time: (C M) time uniquely representing a key (or key range) on a time-based
    animCurve  See the code examples below on how to format for a single frame or frame r
    :type time: timerange
    :param timeChange: (C Q E) How much (with -relative) or where (with -absolute) to move keys
    (on time-input animation curves) along the x (time) axis  Returns float[] when queri
    :type timeChange: time
    :param valueChange: (C Q E) How much (with -relative) or where (with -absolute) to move
    keys along the y (value) axis  Returns float[] when queried
    :type valueChange: float
    
    :returns: (except where noted below)
    Number of curves on which keys were modified.
    In
    -query mode, the command can return a variety of things,
    as described with each queryable
    flag below.
    :rtype: int
    """
    pass


def toolPropertyWindow(*args, field="", helpButton="", icon="", inMainWindow=True, location="",
                       noviceMode=True, resetButton="", restore=True, selectCommand="",
                       showCommand="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    End users should only call this command as 1  a query (in the custom tool property sheet
    code) or 2  with no arguments to create the default tool property sheet  The more complex
    uses of it are internal
    
    :param field: (Q E) Sets/returns the name of the text field used to store the tool name in
    the property sheet
    :type field: string
    :param helpButton: (Q E) Sets/returns the name of the button used to show help on the tool
    in the property sheet
    :type helpButton: string
    :param icon: (Q E) Sets/returns the name of the static picture object (used to display the
    tool icon in the property sheet)
    :type icon: string
    :param inMainWindow: (C) Specify true if you want the tool settings to appear in the main
    window rather than a separate window
    :type inMainWindow: boolean
    :param location: (Q E) Sets/returns the location of the current tool property sheet, or an
    empty string if there is none
    :type location: string
    :param noviceMode: (Q E) Sets/returns the 'novice mode' flag.(unused at the moment)
    :type noviceMode: boolean
    :param resetButton: (Q E) Sets/returns the name of the button used to restore the tool
    settings in the property sheet
    :type resetButton: string
    :param restore: (C) Reopens the tool settings window  This flag can be used with the flag
    inMainWindow for the fall back location if the tool settings can't be restored
    :type restore: boolean
    :param selectCommand: (Q E) Sets/returns the property sheet's select command
    :type selectCommand: string
    :param showCommand: (Q E) Sets/returns the property sheet's display command
    :type showCommand: string
    
    :returns: 
    :rtype: None
    """
    pass


def PFXUVSetLinkingEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def delete(*args, all=True, attribute="", channels=True, constraints=True,
           constructionHistory=True, controlPoints=False, expressions=True, hierarchy="",
           inputConnectionsAndNodes=True, motionPaths=True, shape=True, staticChannels=True,
           timeAnimationCurves=True, unitlessAnimationCurves=True, **kwargs):
    """
    This command is used to delete selected objects, or all objects, or objects specified along
    with the command  Flags are available to filter the type of objects that the command acts
    on   At times, more than just specified items will be deleted  For example, deleting two
    CVs in the same "row" on a NURBS surface will delete the whole row
    
    :param all: (C) Remove all objects of specified kind, in the scene  This flag is to be used
    in conjunction with the following flags
    :type all: boolean
    :param attribute: (C M) List of attributes to select In query mode, this flag needs a
    value
    :type attribute: string
    :param channels: (C) Remove animation channels in the scene  Either all channels can be
    removed, or the scope can be narrowed down by specifying some of the above mention
    :type channels: boolean
    :param constraints: (C) Remove selected constraints and constraints attached to the
    selected nodes, or remove all constraints in the scene
    :type constraints: boolean
    :param constructionHistory: (C) Remove the construction history on the objects specified or
    selected
    :type constructionHistory: boolean
    :param controlPoints: (C) This flag explicitly specifies whether or not to include the
    control points of a shape (see "-s" flag) in the list of attributes  Default: false  (No
    :type controlPoints: boolean
    :param expressions: (C) Remove expressions in the scene  Either all expressions can be
    removed, or the scope can be narrowed down by specifying some of the above mentioned o
    :type expressions: boolean
    :param hierarchy: (C) Hierarchy expansion options  Valid values are "above," "below," "both,
    " and "none." (Not valid for "pasteKey" cmd.) In query mode, this flag needs a
    :type hierarchy: string
    :param inputConnectionsAndNodes: (C) Break input connection to specified attribute and
    delete all unconnected nodes that are left behind  The graph will be traversed until a node
    that ca
    :type inputConnectionsAndNodes: boolean
    :param motionPaths: (C) Remove motion paths in the scene  Either all motion paths can be
    removed, or the scope can be narrowed down by specifying some of the above mentioned
    :type motionPaths: boolean
    :param shape: (C) Consider attributes of shapes below transforms as well, except
    "controlPoints"  Default: true  (Not valid for "pasteKey" cmd.) In query mode, this fl
    :type shape: boolean
    :param staticChannels: (C) Remove static animation channels in the scene  Either all static
    channels can be removed, or the scope can be narrowed down by specifying some of the
    :type staticChannels: boolean
    :param timeAnimationCurves: (C) Modifies the -c/channels and -sc/staticChannels flags  When
    true, only channels connected to time-input animation curves (for instance, those created
    :type timeAnimationCurves: boolean
    :param unitlessAnimationCurves: (C) Modifies the -c/channels and -sc/staticChannels flags 
    When true, only channels connected to unitless-input animation curves (for instance, those
    cre
    :type unitlessAnimationCurves: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def expression(*args, alwaysEvaluate=0, animated=0, attribute="", name="", object="", safe=True,
               shortNames=True, string="", timeDependent=True, unitConversion="all.", q=True,
               query=True, e=True, edit=True, **kwargs):
    """
    This command describes an expression that belongs to the current scene  The expression is a
    block of code of unlimited length with a C-like syntax that can perform conversions,
    mathematical operations, and logical decision making on any numeric attribute(s) in the
    scene  One expression can read and alter any number of numeric attributes  Theoretica
    
    :param alwaysEvaluate: (C Q E) If this is TRUE (the default), then the expression will be
    evaluated whenever time changes regardless of whether the other inputs have changed, and a
    :type alwaysEvaluate: int
    :param animated: (C Q E) Sets the animation mode on the expression node: 0 = Not Animated,
    1 = Animated, 2 = Animated with No Callback
    :type animated: int
    :param attribute: (C Q E) Sets the name of the attribute to use for the expression
    :type attribute: string
    :param name: (C Q E) Sets the name of the dependency graph node to use for the expression
    :type name: string
    :param object: (C Q E) Sets the "default" object for the expression  This allows the
    expression writer to not type the object name for frequently-used objects  See the exam
    :type object: string
    :param safe: (Q) Returns true if no potential side effect can occurs running that
    expression  Safe expression will be optimized to evaluate only when needed even if f
    :type safe: boolean
    :param shortNames: (C Q E) When used with the -q/query flag, tells the command to return
    the expression with attribute names as short as possible  The default is to return the
    :type shortNames: boolean
    :param string: (C Q E) Set the expression string
    :type string: string
    :param timeDependent: (Q) Returns true if expression is evaluated when time change  An
    expression can be time-dependent for the following reasons: - The expression refers to '
    :type timeDependent: boolean
    :param unitConversion: (Q E) Insert specified unit conversion nodes at creation: "all",
    "none," or "angularOnly." Default is "all." For angularOnly, will insert unit conversion n
    :type unitConversion: string
    
    :returns: The name of the expression
    :rtype: string
    """
    pass


def DeleteAllNParticles(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PreloadReferenceEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def IKSplineHandleTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CurveSmoothnessMedium(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ProportionalModificationTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def connectionInfo(*args, destinationFromSource=True, getExactDestination=True,
                   getExactSource=True, getLockedAncestor=True, isDestination=True,
                   isExactDestination=True, isExactSource=True, isLocked=True, isSource=True,
                   sourceFromDestination=True, **kwargs):
    """
    The connectionInfo command is used to get information about connection sources and
    destinations  Unlike the isConnected command, this command needs only one end of the
    connection
    
    :param destinationFromSource: (C) If the specified plug (or its ancestor) is a source, this
    flag returns the list of destinations connected from the source  (array of strings, empty
    a
    :type destinationFromSource: boolean
    :param getExactDestination: (C) If the plug or its ancestor is connection destination, this
    returns the name of the plug that is the exact destination  (empty string if there is no
    :type getExactDestination: boolean
    :param getExactSource: (C) If the plug or its ancestor is a connection source, this returns
    the name of the plug that is the exact source  (empty string if there is no such con
    :type getExactSource: boolean
    :param getLockedAncestor: (C) If the specified plug is locked, its name is returned  If an
    ancestor of the plug is locked, its name is returned  If more than one ancestor is locke
    :type getLockedAncestor: boolean
    :param isDestination: (C) Returns true if the plug (or its ancestor) is the destination of
    a connection, false otherwise
    :type isDestination: boolean
    :param isExactDestination: (C) Returns true if the plug is the exact destination of a
    connection, false otherwise
    :type isExactDestination: boolean
    :param isExactSource: (C) Returns true if the plug is the exact source of a connection,
    false otherwise
    :type isExactSource: boolean
    :param isLocked: (C) Returns true if this plug (or its ancestor) is locked
    :type isLocked: boolean
    :param isSource: (C) Returns true if the plug (or its ancestor) is the source of a
    connection, false otherwise
    :type isSource: boolean
    :param sourceFromDestination: (C) If the specified plug (or its ancestor) is a destination,
    this flag returns the source of the connection  (string, empty if none)
    :type sourceFromDestination: boolean
    
    :returns: When asking for a property, depending on the flags used.
    :rtype: boolean
    """
    pass


def PaintEffectsPanel(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def color(*args, rgbColor=None, userDefined=0, **kwargs):
    """
    This command sets the dormant wireframe color of the specified objects to be their class
    color or if the -ud/userDefined flag is specified, one of the user defined colors  The
    -rgb/rgbColor flags can be specified if the user requires floating point RGB colors
    
    :param rgbColor: (C) Specifies and rgb color to set the selected object to
    :type rgbColor: [float, float, float]
    :param userDefined: (C) Specifies the user defined color index to set selected object to 
    The valid range of numbers is [1-8]
    :type userDefined: int
    
    :returns: 
    :rtype: None
    """
    pass


def dR_hypergraphTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyHelix(*args, caching=True, coils=3, constructionHistory=True, createUVs=2, direction=1,
              height=2.0, name="", nodeState=0, object=True, radius=0.4, roundCap=False,
              subdivisionsAxis=8, subdivisionsCaps=0, subdivisionsCoil=50, texture=2,
              useOldInitBehaviour=False, width=2.0, q=True, query=True, e=True, edit=True,
              **kwargs):
    """
    The polyHelix command creates a new polygonal helix
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param coils: (C Q E) Number of coils  Default: 3
    :type coils: float
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param createUVs: (C Q E) Create UVs or not  0: No UVs 1: No Normalization 2: Normalize 3:
    Normalize and Preserve Aspect Ratio Default: 2
    :type createUVs: int
    :param direction: (C Q E) What should be the direction of the coil  0=Clockwise;
    1=Counterclockwise Default: 1
    :type direction: int
    :param height: (C Q E) Height of the helix  Default: 2.0
    :type height: float
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param object: (C) Create the result, or just the dependency node (where applicable)
    :type object: boolean
    :param radius: (C Q E) Radius of tube  Default: 0.4
    :type radius: float
    :param roundCap: (C Q E) To indicate whether we need a round cap Default: false
    :type roundCap: boolean
    :param subdivisionsAxis: (C Q E) Subdivisions around the axis  Default: 8
    :type subdivisionsAxis: int
    :param subdivisionsCaps: (C Q E) Subdivisions along the thickness caps  Default: 0
    :type subdivisionsCaps: int
    :param subdivisionsCoil: (C Q E) Subdivisions along the coil  Default: 50
    :type subdivisionsCoil: int
    :param texture: (C Q E) What texture mechanism to be applied 0=No textures; 1=Object;
    2=Faces Default: 2
    :type texture: int
    :param useOldInitBehaviour: (C Q E) Create the helix with base on the origin as in Maya
    V8.0 and below Otherwise create helix centred at origin Default: false
    :type useOldInitBehaviour: boolean
    :param width: (C Q E) Width of the helix  Default: 2.0
    :type width: float
    
    :returns: Object name and node name.
    :rtype: string[]
    """
    pass


def bakeClip(*args, blend=None, clipIndex=0, keepOriginals=True, name="", **kwargs):
    """
    This command is used to bake clips and blends into a single clip
    
    :param blend: (C) Specify the indices of the clips being blended
    :type blend: [int, int]
    :param clipIndex: (C M) Specify the index of the clip to bake
    :type clipIndex: int
    :param keepOriginals: (C) Keep original clips in the trax editor and place the merged clip
    into the visor  The default is to schedule the merged clip, and to keep the original
    :type keepOriginals: boolean
    :param name: (C) Specify the name of the new clip to create
    :type name: string
    
    :returns: clip name
    :rtype: string
    """
    pass


def HIKToggleReleasePinning(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dgtimer(*args, combineType=True, hide="", hierarchy=True, maxDisplay=0, name="",
            noHeader=True, outputFile="", overhead=True, rangeLower=0.0, rangeUpper=0.0,
            reset=True, returnCode="", returnType="", show="", sortMetric="", sortType="",
            threshold=0.0, timerOff=True, timerOn=True, trace=True, type="", uniqueName=True,
            updateHeatMap=0, q=True, query=True, **kwargs):
    """
    This command measures dependency graph node performance by managing timers on a per-node
    basis  Logically, each DG node has a timer associated with it which records the amount of
    real time spent in various operations on its plugs  The time measurement includes the cost
    of copying data to the node on behalf of the operation, MEL commands executed by
    
    :param combineType: (Q) Causes all nodes of the same type (e.g  animCurveTA) to be combined
    in the output display
    :type combineType: boolean
    :param hide: (C Q M) This flag is the converse of -show  As with -show, it is a query-only
    flag which can be specified multiple times  If you do specify -hide, we display
    :type hide: string
    :param hierarchy: (C Q) Used to specify that a hierarchy of the dependency graph be
    affected, thus "-reset -hierarchy -name ball" will reset the timers on the node named "ba
    :type hierarchy: boolean
    :param maxDisplay: (Q) Truncates the display so that only the most expenive "n" entries are
    printed in the output display
    :type maxDisplay: int
    :param name: (C Q) Used in conjunction with -reset or -query to specify the name of the
    node to reset or print timer values for  When querying a single timer, only a si
    :type name: string
    :param noHeader: (C Q) Used in conjunction with -query to prevent any header or footer
    information from being printed  All that will be output is the per-node timing data
    :type noHeader: boolean
    :param outputFile: (Q) Specifies where the output of timing or tracing is displayed  The
    flag takes a string argument which accepts three possible values: The name of a fil
    :type outputFile: string
    :param overhead: (C Q) Turns on and off the measurement of timing overhead  Under ordinary
    circumstances the amount of timing overhead is minimal compared with the events b
    :type overhead: boolean
    :param rangeLower: (C) This flag can be specified to limit the range of nodes which are
    displayed in a query, or the limits of the heat map with -updateHeatMap  The value i
    :type rangeLower: float
    :param rangeUpper: (C) This flag can be specified to limit the range of nodes which are
    displayed in a query, or the limits of the heat map with -updateHeatMap  The value i
    :type rangeUpper: float
    :param reset: (C) Resets the node timers to zero  By default, the timers on all nodes as
    well as the global timers are reset, but if specified with the -name or -type
    :type reset: boolean
    :param returnCode: (C Q) This flag has been replaced by the more general -returnType flag 
    The -returnCode flag was unfortunately specific to the compute metric only  It exis
    :type returnCode: string
    :param returnType: (Q) This flag specifies what the double value returned by the dgtimer
    command represents  By default, the value returned is the global total as displayed
    :type returnType: string
    :param show: (C Q M) Used in conjunction with -query to specify which columns are to be
    displayed in the per-node section of the output  -show takes an argument, which ca
    :type show: string
    :param sortMetric: (C Q) Used in conjunction with -query to specify which metric is to be
    sorted on when the per-node section of the output is generated, for example "draw" t
    :type sortMetric: string
    :param sortType: (C Q) Used in conjunction with -query to specify which timer is to be
    sorted on when the per-node section of the output is generated, for example "self" ti
    :type sortType: string
    :param threshold: (Q) Truncates the display once the value falls below the threshold value 
    The threshold applies to whatever timer is being used for sorting  For example,
    :type threshold: float
    :param timerOff: (C Q) Turns off node timing  By default, the timers on all nodes are
    turned off, but if specified with the -name or -type flags, only the timers on specifi
    :type timerOff: boolean
    :param timerOn: (C Q) Turns on node timing  By default, the timers on all nodes are turned
    on, but if specified with the -name or -type flags, only the timers on specified
    :type timerOn: boolean
    :param trace: (C) Turns on or off detailed execution tracing  By default, tracing is off 
    If enabled, each timeable operation is logged when it starts and again when i
    :type trace: boolean
    :param type: (C Q) Used in conjunction with -reset or -query to specify the type of the
    node(s) (e.g  animCurveTA) to reset or print timer values for  When querying, us
    :type type: string
    :param uniqueName: (C Q) Used to specify that the DAG nodes listed in the output should be
    listed by their unique names  The full DAG path to the object will be printed out i
    :type uniqueName: boolean
    :param updateHeatMap: (C) Forces Maya's heat map to rebuild based on the specified
    parameters  The heat map is an internal dgtimer structure used in mapping intensity values
    t
    :type updateHeatMap: int
    
    :returns: By default, the total of self-compute time for all nodes. Can be modified via the
    -returnType, -sortMetric and -sortType flags.
    :rtype: float
    """
    pass


def hwRender(*args, acceleratedMultiSampleSupport=True, activeTextureCount=True, camera="",
             currentFrame=True, currentView=True, edgeAntiAliasing=None,
             fixFileNameNumberPattern=True, frame=0.0, fullRenderSupport=True, height=0,
             imageFileName=True, layer=None, limitedRenderSupport=True, lowQualityLighting=True,
             noRenderView=True, notWriteToFile=True, printGeometry=True,
             renderHardwareName=True, renderRegion=None, renderSelected=True,
             textureResolution=0, width=0, writeAlpha=True, writeDepth=True, q=True, query=True,
             **kwargs):
    """
    Renders an image or a sequence using the hardware rendering engine
    
    :param acceleratedMultiSampleSupport: (Q) This flag when used with query will return
    whether the graphics supports hardware accelerated multi-sampling
    :type acceleratedMultiSampleSupport: boolean
    :param activeTextureCount: (Q) This flag when used with query will return the number of
    textures that have been bound to the graphics by the hardware renderer
    :type activeTextureCount: boolean
    :param camera: (C Q) Specify the camera to use  Use the first available camera if the
    camera given is not found
    :type camera: string
    :param currentFrame: (C Q) Render the current frame
    :type currentFrame: boolean
    :param currentView: (C Q) When turned on, only the current view will be rendered
    :type currentView: boolean
    :param edgeAntiAliasing: (C Q) Enables multipass rendering  Controls for the number of
    exposures rendered per frame are provided in the form of two associated flag arguments  The
    f
    :type edgeAntiAliasing: [int, int]
    :param fixFileNameNumberPattern: (C Q) This flag allows the user to take the
    hardwareRenderGlobals filename as the initial filename pattern, fix the frame number
    pattern in the filename in
    :type fixFileNameNumberPattern: boolean
    :param frame: (C) Specify the frame to render
    :type frame: float
    :param fullRenderSupport: (C Q) This flag may be used in the create or query context  In
    the create context, it will force the renderer to abort and not render any frames if the
    har
    :type fullRenderSupport: boolean
    :param height: (C Q) Height  If not used, the height is taken from the render globals
    settings
    :type height: int
    :param imageFileName: (C Q) This flag let people query the image name for a specified frame
     The frame can be specified using the "-frame" flag  When no "-frame" is used, the cu
    :type imageFileName: boolean
    :param layer: (C Q) Render the specified render layer  Only this render layer will be
    rendered, regardless of the renderable attribute value of the render layer  The lay
    :type layer: name
    :param limitedRenderSupport: (Q) This flag when used with query will return whether limited
    rendering is supported on the current graphics system  Please see the graphics card qualif
    :type limitedRenderSupport: boolean
    :param lowQualityLighting: (C Q) Disable lighting evaluation per pixel (fragment)  Note:
    The values passed via the command will override settings stored in the hardware render
    global
    :type lowQualityLighting: boolean
    :param noRenderView: (C Q) When turned on, the render view is not updated after image
    computation
    :type noRenderView: boolean
    :param notWriteToFile: (C Q) This flag is set to true if the user does not want to write
    the image to a file  It is set to false, otherwise  The default value of the flag is "fal
    :type notWriteToFile: boolean
    :param printGeometry: (C Q) Print the geomety objects as they get translated
    :type printGeometry: boolean
    :param renderHardwareName: (Q) This flag will create a graphics context and return the name
    of the graphics hardware being used  The graphics hardware is determined by creating an
    :type renderHardwareName: boolean
    :param renderRegion: (C Q) Render region  The parameters are 4 integers, indicating left
    right bottom top of the region
    :type renderRegion: [int, int, int, int]
    :param renderSelected: (C Q) Only renders the selected objects
    :type renderSelected: boolean
    :param textureResolution: (C Q) Specify the desired resolution of baked textures
    :type textureResolution: int
    :param width: (C Q) Width  If not used, the width is taken from the render globals
    settings
    :type width: int
    :param writeAlpha: (C Q) Read the alpha channel of color buffer and return as tif file
    :type writeAlpha: boolean
    :param writeDepth: (C Q) Read the depth buffer and return as tif file
    :type writeDepth: boolean
    
    :returns: Command result
    :rtype: boolean
    """
    pass


def HypershadeGraphDownstream(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowMeshSmoothTargetToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GpuCacheRefreshAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectSimilar(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def mtkQuadDrawPoint(*args, **kwargs):
    """
    
    """
    pass


def TimeEditorKeepTransitionsToggleRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sysFile(*args, copy="", delete=True, makeDir=True, move="", removeEmptyDir=True, rename="",
            **kwargs):
    """
    This command provides a system independent way to create a directory or to rename or delete
    a file
    
    :param copy: (C) Copy the file to the name given by the newFileName paramter
    :type copy: string
    :param delete: (C) Deletes the file
    :type delete: boolean
    :param makeDir: (C) Create the directory path given in the parameter  This will create the
    entire path if more than one directory needs to be created
    :type makeDir: boolean
    :param move: (C) Behaves identically to the -rename flag and remains for compatibility with
    old scripts
    :type move: string
    :param removeEmptyDir: (C) Delete the directory path given in the parameter if the
    directory is empty  The command will not delete a directory which is not empty
    :type removeEmptyDir: boolean
    :param rename: (C) Rename the file to the name given by the newFileName parameter
    :type rename: string
    
    :returns: True if successful, false otherwise.
    :rtype: boolean
    """
    pass


def UnpinSelection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FreeformFillet(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateActiveRigidBodyOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BevelPlusOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportSmoothingGroups(*args, **kwargs):
    """
    
    """
    pass


def NURBSSmoothnessRough(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SculptMeshDeactivateBrushSize(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def vnnCompound(*args, **kwargs):
    """
    
    """
    pass


def emitter(*args, alongAxis=0.0, aroundAxis=0.0, awayFromAxis=0.0, awayFromCenter=0.0,
            cycleEmission="", cycleInterval=0, directionX=0.0, directionY=0.0, directionZ=0.0,
            directionalSpeed=0.0, maxDistance=0.0, minDistance=0.0, name="", needParentUV=True,
            normalSpeed=0.0, position=None, randomDirection=0.0, rate=0.0,
            scaleRateByObjectSize=True, scaleSpeedBySize=True, speed=0.0, speedRandom=0.0,
            spread=0.0, tangentSpeed=0.0, torusSectionRadius=0.0, type="", volumeOffset=None,
            volumeShape="", volumeSweep=0.0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Creates, edits or queries an auxiliary dynamics object (for example, a field or emitter) 
    Creates an emitter object  If object names are provided or if objects are selected, applies
    the emitter to the named/selected object(s)in the scene  Particles will then be emitted
    from each  If no objects are named or selected, or if the -pos option is specifi
    
    :param alongAxis: (Q E) Initial velocity multiplier in the direction along the central axis
    of the volume  See the diagrams in the documentation  Applies only to volume emit
    :type alongAxis: float
    :param aroundAxis: (Q E) Initial velocity multiplier in the direction around the central
    axis of the volume  See the diagrams in the documentation  Applies only to volume emi
    :type aroundAxis: float
    :param awayFromAxis: (Q E) Initial velocity multiplier in the direction away from the
    central axis of the volume  See the diagrams in the documentation  Used only with the cyli
    :type awayFromAxis: float
    :param awayFromCenter: (Q E) Initial velocity multiplier in the direction away from the
    center point of a cube or sphere volume emitter  Used only with the cube and sphere volume
    :type awayFromCenter: float
    :param cycleEmission: (Q E) Possible values are "none" and "frame." Cycling emission
    restarts the random number stream after a specified interval  This can either be a number
    of
    :type cycleEmission: string
    :param cycleInterval: (Q E) Specifies the number of frames or particles between restarts of
    the random number stream  See cycleEmission  Has no effect if cycleEmission is set to
    :type cycleInterval: int
    :param directionX: (Q E) x-component of emission direction  Used for directional emitters,
    and for volume emitters with directionalSpeed
    :type directionX: float
    :param directionY: (Q E) y-component of emission direction  Used for directional emitters,
    and for volume emitters with directionalSpeed
    :type directionY: float
    :param directionZ: (Q E) z-component of emission direction  Used for directional emitters,
    and for volume emitters with directionalSpeed
    :type directionZ: float
    :param directionalSpeed: (Q E) For volume emitters only, adds a component of speed in the
    direction specified by the directionX, Y, and Z attributes  Applies only to volume emitter
    :type directionalSpeed: float
    :param maxDistance: (Q E) Maximum distance at which emission ends
    :type maxDistance: float
    :param minDistance: (Q E) Minimum distance at which emission starts
    :type minDistance: float
    :param name: (C Q E) Object name
    :type name: string
    :param needParentUV: (Q E) If aNeedParentUV is true, compute parentUV value from each
    triangle or each line segment, then send out to the target particle object  You also need
    :type needParentUV: boolean
    :param normalSpeed: (Q E) Normal speed multiple for point emission  For each emitted
    particle, multiplies the component of the velocity normal to the surface or curve by this
    :type normalSpeed: float
    :param position: (C Q E M) world-space position
    :type position: [float, float, float]
    :param randomDirection: (Q E) Magnitude of a random component of the speed from volume
    emission
    :type randomDirection: float
    :param rate: (Q E) Rate at which particles emitted (can be non-integer)  For point emission
    this is rate per point per unit time  For surface emission it is rate per sq
    :type rate: float
    :param scaleRateByObjectSize: (Q E) Applies to curve and surface emitters, only  If true,
    number of particles is determined by object size (area or length) times rate value  If
    false, o
    :type scaleRateByObjectSize: boolean
    :param scaleSpeedBySize: (Q E) Indicates whether the scale of a volume emitter affects its
    velocity
    :type scaleSpeedBySize: boolean
    :param speed: (Q E) Speed multiple  Multiplies the velocity of the emitted particles by
    this amount  Does not apply to volume emitters  For that emitter type, use direct
    :type speed: float
    :param speedRandom: (Q E) Identifies a range of random variation for the speed of each
    generated particle  If set to a non-zero value, speed becomes the mean value of the gene
    :type speedRandom: float
    :param spread: (Q E) Random spread (0-1), as a fraction of 90 degrees, along specified
    direction  Directional emitters only
    :type spread: float
    :param tangentSpeed: (Q E) Tangent speed multiple for point emission  For each emitted
    particle, multiplies the component of the velocity tangent to the surface or curve by thi
    :type tangentSpeed: float
    :param torusSectionRadius: (Q E) Section radius for a torus volume  Applies only to torus 
    Similar to the section radius in the torus modelling primitive
    :type torusSectionRadius: float
    :param type: (Q E) Type of emitter  The choices are omni | dir | direction | surf | surface
    | curve | curv  The default is omni  The full definition of these types are:
    :type type: string
    :param volumeOffset: (Q E) Volume offset of the emitter  Volume offset translates the
    emission volume by the specified amount from the actual emitter location  This is in the e
    :type volumeOffset: [float, float, float]
    :param volumeShape: (Q E) Volume shape of the emitter  Sets/edits/queries the field's
    volume shape attribute  If set to any value other than "none", determines a 3-D volume wi
    :type volumeShape: string
    :param volumeSweep: (Q E) Volume sweep of the emitter  Applies only to sphere, cone,
    cylinder, and torus  Similar effect to the sweep attribute in modelling
    :type volumeSweep: float
    
    :returns: Command result
    :rtype: string
    """
    pass


def EnterEditModePress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeRefreshFileListing(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def render(*args, abortMissingTexture=True, batch=True, keepPreImage=True, layer="",
           nglowpass=True, nshadows=True, replace=True, xresolution=0, yresolution=0,
           **kwargs):
    """
    The render command is used to start off a MayaSoftware rendering session of the currently
    active camera  If a rendering is already in progress, then this command stops the rendering
     This command is not undoable
    
    :param abortMissingTexture: (C) Abort renderer when encountered missing texture  Only
    available when -batch is set
    :type abortMissingTexture: boolean
    :param batch: (C) Run in batch mode  Compute the images for all renderable cameras  This is
    the mel equivalent of running maya in batch mode with the -render flag set
    :type batch: boolean
    :param keepPreImage: (C) Keep the renderings prior to post-process around  Only available
    when -batch is set
    :type keepPreImage: boolean
    :param layer: (C) Render the specified render layer  Only this render layer will be
    rendered, regardless of the renderable attribute value of the render layer  The lay
    :type layer: string
    :param nglowpass: (C) Overwrite glow pass capabilities (can turn off glow pass globally by
    setting this value to false)
    :type nglowpass: boolean
    :param nshadows: (C) Shadowing capabilities (can turn off shadow globally by setting this
    value to false)
    :type nshadows: boolean
    :param replace: (C) Replace the rendered image if it already exists  Only available when
    -batch is set
    :type replace: boolean
    :param xresolution: (C) Overwrite x resolution
    :type xresolution: int
    :param yresolution: (C) Overwrite y resolution
    :type yresolution: int
    
    :returns: The name of the rendered image.
    :rtype: string
    """
    pass


def fileInfo(*args, referenceNode="", remove="", q=True, query=True, **kwargs):
    """
    fileInfo provides a mechanism for keeping information related to a Maya scene file  Each
    invocation of the command consists of a keyword/value pair, where both the keyword and the
    associated value are strings  The command may be invoked multiple times with different
    keywords  Maya emits this command several times into each file it creates, primaril
    
    :param referenceNode: (Q) Specify the name of a referenceNode to indicate the scene file to
    query  This flag is only valid during query  In query mode, this flag needs a value
    :type referenceNode: string
    :param remove: (C Q) If the remove flag is specified, the string following it is a keyword
    to remove from the list of fileInfo to be saved with the scene file
    :type remove: string
    
    :returns: Command result
    :rtype: string[]
    """
    pass


def Create2DContainerOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowLights(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleSelectDetails(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AttachSurfaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PaintReduceWeightsToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PickWalkIn(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_bevelPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetMeshGrabUVTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MakeFluidCollide(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_viewGridTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def colorManagementConvert(*args, toDisplaySpace=None, **kwargs):
    """
    This command can be used to convert rendering (a.k.a  working) space color values to
    display space color values  This is useful if you create custom UI with colors painted to
    screen, where you need to handle color management yourself  The current view transform set
    in the Color Management user preferences will be used
    
    :param toDisplaySpace: (C) Converts the given RGB value to display space
    :type toDisplaySpace: [float, float, float]
    
    :returns: 
    :rtype: None
    """
    pass


def SelectAllGeometry(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def floatSliderButtonGrp(*args, adjustableColumn=0, adjustableColumn2=0, adjustableColumn3=0,
                         adjustableColumn4=0, adjustableColumn5=0, adjustableColumn6=0,
                         annotation="", backgroundColor=None, buttonCommand=None,
                         buttonLabel="", changeCommand=None, columnAlign=None,
                         columnAlign2=None, columnAlign3=None, columnAlign4=None,
                         columnAlign5=None, columnAlign6=None, columnAttach=None,
                         columnAttach2=None, columnAttach3=None, columnAttach4=None,
                         columnAttach5=None, columnAttach6=None, columnOffset2=None,
                         columnOffset3=None, columnOffset4=None, columnOffset5=None,
                         columnOffset6=None, columnWidth=None, columnWidth1=0,
                         columnWidth2=None, columnWidth3=None, columnWidth4=None,
                         columnWidth5=None, columnWidth6=None, defineTemplate="", docTag="",
                         dragCallback=None, dragCommand=None, dropCallback=None, enable=True,
                         enableBackground=True, enableKeyboardFocus=True, exists=True,
                         extraLabel="", field=True, fieldMaxValue=0.0, fieldMinValue=0.0,
                         fieldStep=0.0, fullPathName=True, height=0, highlightColor=None,
                         image="", isObscured=True, label="", manage=True, maxValue=0.0,
                         minValue=0.0, noBackground=True, numberOfPopupMenus=True, parent="",
                         popupMenuArray=True, precision=0, preventOverride=True, rowAttach=None,
                         sliderStep=0.0, statusBarMessage="", step=0.0,
                         symbolButtonCommand=None, symbolButtonDisplay=True, useTemplate="",
                         value=0.0, visible=True, visibleChangeCommand=None, width=0, q=True,
                         query=True, e=True, edit=True, **kwargs):
    """
    All of the group commands position their individual controls in columns starting at column
    1  The layout of each control (ie  column) can be customized using the -cw/columnWidth,
    -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumn flags  By
    default, columns are left aligned with no offset and are 100 pixels wide  Only o
    
    :param adjustableColumn: (C E) Specifies which column has an adjustable size that changes
    with the sizing of the layout  The column value is a 1-based index  Passing 0 as argument
    :type adjustableColumn: int
    :param adjustableColumn2: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly two columns
    :type adjustableColumn2: int
    :param adjustableColumn3: (C E) Specifies that the column has an adjustable size that
    changes with the size of the parent layout  Ignored if there are not exactly three columns
    :type adjustableColumn3: int
    :param adjustableColumn4: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly four columns
    :type adjustableColumn4: int
    :param adjustableColumn5: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly five columns
    :type adjustableColumn5: int
    :param adjustableColumn6: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly six columns
    :type adjustableColumn6: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param buttonCommand: (C E) Command string to be executed when the button is pressed
    :type buttonCommand: script
    :param buttonLabel: (C Q E) The button text
    :type buttonLabel: string
    :param changeCommand: (C E) Command string executed when the value of the slider changes 
    It will be executed only once after a drag of the slider
    :type changeCommand: script
    :param columnAlign: (C E M) Arguments are : column number, alignment type  Possible
    alignments are: left | right | center  Specifies alignment type for the specified column
    :type columnAlign: [int, string]
    :param columnAlign2: (C E) Sets the text alignment of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "center"
    :type columnAlign2: [string, string]
    :param columnAlign3: (C E) Sets the text alignment for all three columns  Ignored if there
    are not exactly three columns  Valid values are "left", "right", and "center"
    :type columnAlign3: [string, string, string]
    :param columnAlign4: (C E) Sets the text alignment for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "center"
    :type columnAlign4: [string, string, string, string]
    :param columnAlign5: (C E) Sets the text alignment for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "center"
    :type columnAlign5: [string, string, string, string, string]
    :param columnAlign6: (C E) Sets the text alignment for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "center"
    :type columnAlign6: [string, string, string, string, string, string]
    :param columnAttach: (C E M) Arguments are : column number, attachment type, and offset 
    Possible attachments are: left | right | both  Specifies column attachment types and offe
    :type columnAttach: [int, string, int]
    :param columnAttach2: (C E) Sets the attachment type of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "both"
    :type columnAttach2: [string, string]
    :param columnAttach3: (C E) Sets the attachment type for all three columns  Ignored if
    there are not exactly three columns  Valid values are "left", "right", and "both"
    :type columnAttach3: [string, string, string]
    :param columnAttach4: (C E) Sets the attachment type for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "both"
    :type columnAttach4: [string, string, string, string]
    :param columnAttach5: (C E) Sets the attachment type for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "both"
    :type columnAttach5: [string, string, string, string, string]
    :param columnAttach6: (C E) Sets the attachment type for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "both"
    :type columnAttach6: [string, string, string, string, string, string]
    :param columnOffset2: (C E) This flag is used in conjunction with the -columnAttach2 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the tw
    :type columnOffset2: [int, int]
    :param columnOffset3: (C E) This flag is used in conjunction with the -columnAttach3 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the th
    :type columnOffset3: [int, int, int]
    :param columnOffset4: (C E) This flag is used in conjunction with the -columnAttach4 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fo
    :type columnOffset4: [int, int, int, int]
    :param columnOffset5: (C E) This flag is used in conjunction with the -columnAttach5 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fi
    :type columnOffset5: [int, int, int, int, int]
    :param columnOffset6: (C E) This flag is used in conjunction with the -columnAttach6 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the si
    :type columnOffset6: [int, int, int, int, int, int]
    :param columnWidth: (C E M) Arguments are : column number, column width  Sets the width of
    the specified column where the first parameter specifies the column (1 based index) an
    :type columnWidth: [int, int]
    :param columnWidth1: (C E) Sets the width of the first column  Ignored if there is not
    exactly one column
    :type columnWidth1: int
    :param columnWidth2: (C E) Sets the column widths of both columns  Ignored if there are not
    exactly two columns
    :type columnWidth2: [int, int]
    :param columnWidth3: (C E) Sets the column widths for all 3 columns  Ignored if there are
    not exactly 3 columns
    :type columnWidth3: [int, int, int]
    :param columnWidth4: (C E) Sets the column widths for all 4 columns  Ignored if there are
    not exactly 4 columns
    :type columnWidth4: [int, int, int, int]
    :param columnWidth5: (C E) Sets the column widths for all 5 columns  Ignored if there are
    not exactly 5 columns
    :type columnWidth5: [int, int, int, int, int]
    :param columnWidth6: (C E) Sets the column widths for all 6 columns  Ignored if there are
    not exactly 6 columns
    :type columnWidth6: [int, int, int, int, int, int]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dragCommand: (C E) Command string executed repeatedly during a drag of the slider
    :type dragCommand: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param extraLabel: (C Q E) If present on creation this specifies that there will be an
    extra label appearing after the slider  Sets the string to be the text for the extra labe
    :type extraLabel: string
    :param field: (C) Indicates whether the group will have an editable float field present
    that reflects the value of the slider
    :type field: boolean
    :param fieldMaxValue: (C Q E) Maximum value that may be entered in the field  This value
    may be set to any value greater than the -max/maxValue flag  By default, it is equal to th
    :type fieldMaxValue: float
    :param fieldMinValue: (C Q E) Minimum value that may be entered in the field  This value
    may be set to any value less than the -min/minValue flag  By default, it is equal to the -
    :type fieldMinValue: float
    :param fieldStep: (C Q E) Increment for the field
    :type fieldStep: float
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param image: (C Q E) Image displayed on the symbol button
    :type image: string
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) If present on creation the group will have static text
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param maxValue: (C Q E) Maximum value for both the slider and the field
    :type maxValue: float
    :param minValue: (C Q E) Minimum value for both the slider and the field
    :type minValue: float
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param precision: (C E) Number of digits to the right of the decimal
    :type precision: int
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rowAttach: (C E M) Arguments are : column, attachment type, offset  Possible
    attachments are: top | bottom | both  Specifies attachment types and offsets for the
    entire
    :type rowAttach: [int, string, int]
    :param sliderStep: (C Q E) The slider step value represents the amount the value will
    increase or decrease when you click either side of the slider
    :type sliderStep: float
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param step: (C Q E) Increment for both the slider and field
    :type step: float
    :param symbolButtonCommand: (C E) Command string executed when the symbol button is
    pressed
    :type symbolButtonCommand: script
    :param symbolButtonDisplay: (C Q E) Visibility of the symbol button
    :type symbolButtonDisplay: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param value: (C Q E) Value of the group
    :type value: float
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def GetToonExample(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def jointDisplayScale(*args, absolute=True, ikfk=0.0, q=True, query=True, e=True, edit=True,
                      **kwargs):
    """
    This action modifies and queries the current display size of skeleton joints  The joint
    display size is controlled by a scale factor; a scale factor of 1 sets the display size to
    its default, which is 1 in diameter  With the plain format, the float argument is the
    factor with respect to the default size  When -a/absolute is used, the float argument
    
    :param absolute: (C Q E) Interpret the float argument as the display size as opposed to the
    scale factor
    :type absolute: boolean
    :param ikfk: (C Q E) Set the display size of ik/fk skeleton joints
    :type ikfk: float
    
    :returns: Returns current display size of skeleton joints.
    :rtype: float
    """
    pass


def OptimizeSceneOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_selConstraintAngle(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def componentBox(*args, annotation="", backgroundColor=None, defineTemplate="", docTag="",
                 dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
                 enableKeyboardFocus=True, execute=None, exists=True, fullPathName=True,
                 height=0, highlightColor=None, isObscured=True, labelWidth=0, manage=True,
                 maxHeight=0, maxWidth=0, noBackground=True, numberOfPopupMenus=True, parent="",
                 popupMenuArray=True, precision=3, preventOverride=True, rowHeight=0,
                 selectedAttr=True, statusBarMessage="", useTemplate="", visible=True,
                 visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
                 **kwargs):
    """
    This command creates a component box, which is sensitive to the active list  It displays
    certain components of the last node on the active list, and provides a two-way connection
    to keep the widget up to date
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param execute: (E) Immediately executes the command string once for every cell (or every
    selected cell, if the boolean argument is TRUE) in the component box, for every
    :type execute: [string, boolean]
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param labelWidth: (Q E) An optional flag which is used to modify the width assigned to
    labels appearing in the componentBox
    :type labelWidth: int
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param maxHeight: (Q E) An optional flag which is used to limit the height of the
    componentBox
    :type maxHeight: int
    :param maxWidth: (Q E) An optional flag which is used to limit the width of the
    componentBox
    :type maxWidth: int
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param precision: (Q E) Controls the number of digits to the right of the decimal point
    that will be displayed for float-valued components  Default is 3  Queried, returns an
    :type precision: int
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rowHeight: (E) An optional flag which is used to set the height of all rows in the
    componentBox
    :type rowHeight: int
    :param selectedAttr: (Q) Returns a list of names of all the attributes that are selected 
    This flag is ignored when not being queried
    :type selectedAttr: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: (the name of the new component box)
    :rtype: string
    """
    pass


def sound(*args, endTime=None, file="", length=True, mute=True, name="", offset=None,
          sourceEnd=None, sourceStart=None, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Creates an audio node which can be used with UI commands such as soundControl or
    timeControl which support sound scrubbing and sound during playback
    
    :param endTime: (C Q E) Time at which to end the sound
    :type endTime: time
    :param file: (C Q E) Name of sound file
    :type file: string
    :param length: (Q) Query the length (in the current time unit) of the sound
    :type length: boolean
    :param mute: (C Q E) Mute the audio clip
    :type mute: boolean
    :param name: (C Q E) Name to give the resulting audio node
    :type name: string
    :param offset: (C Q E) Time at which to start the sound
    :type offset: time
    :param sourceEnd: (C Q E) Time offset from the start of the sound file at which to end the
    sound
    :type sourceEnd: time
    :param sourceStart: (C Q E) Time offset from the start of the sound file at which to start
    the sound
    :type sourceStart: time
    
    :returns: Name of resulting audio node
    :rtype: string
    """
    pass


def DetachSkinOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorToggleSoloSelectedTracks(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_movePress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmFindAttachment(*args, **kwargs):
    """
    
    """
    pass


def insertJointCtx(*args, exists=True, image1="", image2="", image3="", q=True, query=True,
                   e=True, edit=True, **kwargs):
    """
    The command will create an insert joint context  The insert joint tool inserts joints into
    an existing chain of joints
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    
    :returns: The name of the context.
    :rtype: string
    """
    pass


def xgmParticleRender(*args, **kwargs):
    """
    
    """
    pass


def CreateCreaseSet(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AlembicReplace(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SquashOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dataStructure(*args, asFile="", asString="", dataType=True, format="", listMemberNames="",
                  name="", remove=True, removeAll=True, q=True, query=True, **kwargs):
    """
    Takes in a description of the structure and creates it, adding it to the list of available
    data structures  The structure definition can either be supplied in the asString flag or
    exist in a file that is referenced by the asFile flag   If the remove flag is specified
    with a name flag then the data structure will be removed  This is to keep all stru
    
    :param asFile: (C Q) Specify a file that contains the serialized data which describes the
    structure  The format of the data is specified by the 'format' flag
    :type asFile: string
    :param asString: (C Q) Specify the string containing the serialized data which describes
    the structure  The format of the data is specified by the 'format' flag
    :type asString: string
    :param dataType: (C Q) Used with the flag 'listMemberNames' to query the type of the member
     The type is appended after each relative member in the array  For example, if t
    :type dataType: boolean
    :param format: (C Q) Format of data to expect in the structure description  "raw" is
    supported natively and will be assumed if the format type is omitted  Others are avai
    :type format: string
    :param listMemberNames: (C Q) Query the member names in the dataStructure  The member names
    will be returned in an array  The name of the data structure will not be returned  To g
    :type listMemberNames: string
    :param name: (Q) Query mode only  Name of the data structure to be queried, or set to list
    the available names  In query mode, this flag can accept a value
    :type name: string
    :param remove: (C) Remove the named data structure  It's an error if it doesn't exist
    :type remove: boolean
    :param removeAll: (C) Remove all metadata structures  This flag can not be used in
    conjunction with any other flags
    :type removeAll: boolean
    
    :returns: Name of the resulting structure, should match the name defined in the structure
    description
    :rtype: string
    """
    pass


def DeleteAllCameras(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def profiler(*args, addCategory="", allCategories=True, bufferSize=0, categoryIndex=0,
             categoryIndexToName=0, categoryInfo="", categoryName="", categoryNameToIndex="",
             categoryRecording=True, clearAllMelInstrumentation=True, colorIndex=0,
             eventCPUId=True, eventCategory=True, eventColor=True, eventCount=True,
             eventDescription=True, eventDuration=True, eventIndex=0, eventName=True,
             eventStartTime=True, eventThreadId=True, instrumentMel=True, load="", output="",
             procedureDescription="", procedureName="", removeCategory="", reset=True,
             sampling=True, signalEvent=True, signalMelEvent=True, q=True, query=True,
             **kwargs):
    """
    The profiler is used to record timing information from key events within Maya, as an aid in
    tuning the performance of scenes, scripts and plug-ins  User written plug-ins and Python
    scripts can also generate profiling information for their own code through the
    MProfilingScope (C++), MProfilingContextManager (Python) and MProfiler classes in the API 
    
    :param addCategory: (C) Add a new category for the profiler  Returns the index of the new
    category
    :type addCategory: string
    :param allCategories: (Q) Query the names of all categories  If the categoryInfo flag is
    set then alternate the name of the category with the description of the category
    :type allCategories: boolean
    :param bufferSize: (C Q) Toggled : change the buffer size to fit the specified number of
    events (requires that sampling is off) Query : return the current buffer size The new
    :type bufferSize: int
    :param categoryIndex: (C Q) Used in conjunction with other flags, to indicate the index of
    the category  In query mode, this flag needs a value
    :type categoryIndex: int
    :param categoryIndexToName: (C Q) Returns the name of the category with a given index  In
    query mode, this flag needs a value
    :type categoryIndexToName: int
    :param categoryInfo: (C Q) When used with the addCategory flag set the description of the
    added profiler category  In query mode return the description of the category referenc
    :type categoryInfo: string
    :param categoryName: (Q) Used in conjunction with other flags, to indicate the name of the
    category  In query mode, this flag needs a value
    :type categoryName: string
    :param categoryNameToIndex: (C Q) Returns the index of the category with a given name  In
    query mode, this flag needs a value
    :type categoryNameToIndex: string
    :param categoryRecording: (C Q) Toggled : Enable/disable the recording of the category 
    Query : return if the recording of the category is On  Requires the -categoryIndex or
    -catego
    :type categoryRecording: boolean
    :param clearAllMelInstrumentation: (C) Clear all MEL command or procedure instrumentation
    :type clearAllMelInstrumentation: boolean
    :param colorIndex: (C) Used with "-instrumentMel true" to specify the color index to show
    the profiling result
    :type colorIndex: int
    :param eventCPUId: (Q) Query the CPU ID of the event at the given index  Requires the
    -eventIndex flag to specify the event to be queried
    :type eventCPUId: boolean
    :param eventCategory: (Q) Query the category index the event at the given index belongs to 
    Requires the -eventIndex flag to specify the event to be queried
    :type eventCategory: boolean
    :param eventColor: (Q) Query the color of the event at the given index  Requires the
    -eventIndex flag to specify the event to be queried
    :type eventColor: boolean
    :param eventCount: (Q) Query the number of events in the buffer
    :type eventCount: boolean
    :param eventDescription: (Q) Query the description of the event at the given index 
    Requires the -eventIndex flag to specify the event to be queried
    :type eventDescription: boolean
    :param eventDuration: (Q) Query the duration of the event at the given index, the time unit
    is microsecond  Note that a signal event has a 0 duration  Requires the -eventIndex
    :type eventDuration: boolean
    :param eventIndex: (Q) Used usually in conjunction with other flags, to indicate the index
    of the event  In query mode, this flag needs a value
    :type eventIndex: int
    :param eventName: (Q) Query the name of the event at the given index  Requires the
    -eventIndex flag to specify the event to be queried
    :type eventName: boolean
    :param eventStartTime: (Q) Query the time of the event at the given index, the time unit is
    microsecond  Requires the -eventIndex flag to specify the event to be queried
    :type eventStartTime: boolean
    :param eventThreadId: (Q) Query the thread ID of the event at the given index  Requires the
    -eventIndex flag to specify the event to be queried
    :type eventThreadId: boolean
    :param instrumentMel: (C) Enable/Diable the instrumentation of a MEL command or procedure 
    When the instrumentation is enabled, the execution of MEL command or procedure can b
    :type instrumentMel: boolean
    :param load: (C Q) Read the recorded events from the specified file
    :type load: string
    :param output: (C Q) Output the recorded events to the specified file
    :type output: string
    :param procedureDescription: (C) Used with "-instrumentMel true" to provide a description
    of the MEL command or procedure being instrumented  This description can be viewed in the
    Pr
    :type procedureDescription: string
    :param procedureName: (C) Used with -instrumentMel to specify the name of the procedure to
    be enabled/disabled the instrumentation
    :type procedureName: string
    :param removeCategory: (C) Remove an existing category for the profiler  Returns the index
    of the removed category
    :type removeCategory: string
    :param reset: (C Q) reset the profiler's data (requires that sampling is off)
    :type reset: boolean
    :param sampling: (C Q) Toggled : Enable/disable the recording of events Query : return if
    the recording of events is On
    :type sampling: boolean
    :param signalEvent: (Q) Query if the event at the given index is a signal event  Requires
    the -eventIndex flag to specify the event to be queried  A Signal Event only rememb
    :type signalEvent: boolean
    :param signalMelEvent: (C) Used with "-instrumentMel true", inform profiler that this
    instrumented MEL command or procedure will be taken as a signal event during profiling  A
    :type signalMelEvent: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def columnLayout(*args, adjustableColumn=True, annotation="", backgroundColor=None,
                 childArray=True, columnAlign="", columnAttach=None, columnOffset=None,
                 columnWidth=0, defineTemplate="", docTag="", dragCallback=None,
                 dropCallback=None, enable=True, enableBackground=True,
                 enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
                 highlightColor=None, isObscured=True, manage=True, noBackground=True,
                 numberOfChildren=True, numberOfPopupMenus=True, parent="", popupMenuArray=True,
                 preventOverride=True, rowSpacing=0, statusBarMessage="", useTemplate="",
                 visible=True, visibleChangeCommand=None, width=0, q=True, query=True, e=True,
                 edit=True, **kwargs):
    """
    This command creates a layout that arranges its children in a single column
    
    :param adjustableColumn: (C E) Sets the children of the layout to be attached on both sides
     They will stretch or shrink with the layout
    :type adjustableColumn: boolean
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param childArray: (Q) Returns a string array of the names of the layout's immediate
    children
    :type childArray: boolean
    :param columnAlign: (C E) Sets the alignment of children containing text or pixmaps  Align
    values: "left" | "right" | "center"
    :type columnAlign: string
    :param columnAttach: (C E) Sets the attachment and offsets for the children of the layout 
    Side values: "left" | "right" | "both"  Left or both is recommended
    :type columnAttach: [string, int]
    :param columnOffset: (C E) Sets the offsets for children of the layout  Side values: "left"
    | "right" | "both"
    :type columnOffset: [string, int]
    :param columnWidth: (C Q E) Sets the width of the column  Unless the children are attached
    to both sides of the column, the width cannot be enforced  Larger children will expand
    :type columnWidth: int
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfChildren: (Q) Returns in an int the number of immediate children of the
    layout
    :type numberOfChildren: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rowSpacing: (C Q E) Sets the space between children
    :type rowSpacing: int
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def dR_selectModeHybrid(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypergraphWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def LightningOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def u3dAutoSeam(*args, **kwargs):
    """
    
    """
    pass


def HideManipulators(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ReducePolygon(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def texLatticeDeformContext(*args, envelope=0.0, exists=True, history=True, image1="",
                            image2="", image3="", latticeColumns=0, latticeRows=0, name="",
                            showMoveManipulator=True, snapPixelMode=True, useBoundingRect=True,
                            q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a context which may be used to deform UV maps with lattice manipulator
     This context only works in the texture UV editor
    
    :param envelope: (C Q E) Specifies the influence of the lattice
    :type envelope: float
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param latticeColumns: (C Q E) Specifies the number column points the lattice contains  The
    maximum size lattice is restricted to 8 columns
    :type latticeColumns: int
    :param latticeRows: (C Q E) Specifies the number of rows the lattice contains  The maximum
    size lattice is restricted to 8 rows
    :type latticeRows: int
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param showMoveManipulator: (C Q E) Specifies whether show move manipulator in UV Editor
    :type showMoveManipulator: boolean
    :param snapPixelMode: (C Q E) Specifies the influenced uv points should be snapped to a
    pixel center or corner
    :type snapPixelMode: boolean
    :param useBoundingRect: (C Q E) When constructing the lattice use the bounding box of the
    selected UVs for the extents of the lattice  When this is disabled the extents of the
    marqu
    :type useBoundingRect: boolean
    
    :returns: Number of column divisions, when querying the latticeColumns flag.
    :rtype: int
    """
    pass


def RepeatLast(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmUISelectionSync(*args, **kwargs):
    """
    
    """
    pass


def CreateBifrostAero(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmGuideSculptContext(*args, **kwargs):
    """
    
    """
    pass


def skinBindCtx(*args, about="", axis="", colorRamp="", currentInfluence="",
                displayInactiveMode=0, displayNormalized=True, exists=True, falloffCurve="",
                history=True, image1="", image2="", image3="", name="", symmetry=True,
                tolerance=0.0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a tool that can be used to edit volumes from an interactive bind
    
    :param about: (C Q E) The space in which the axis should be mirrored  Valid values are:
    "world" and "object"
    :type about: string
    :param axis: (C Q E) The mirror axis  Valid values are: "x","y", and "z"
    :type axis: string
    :param colorRamp: (C Q E) Set the values on the color ramp used to display the weight
    values
    :type colorRamp: string
    :param currentInfluence: (C Q E) Set the index of the current influence or volume to be
    adjusted by the manipulator
    :type currentInfluence: string
    :param displayInactiveMode: (C Q E) Determines the display mode for drawing volumes that
    are not selected, in particular which volume cages if any are displayed  0 - None 1 -
    Nearby vol
    :type displayInactiveMode: int
    :param displayNormalized: (C Q E) Display raw select weights (false) or finalized
    normalized weights (true)
    :type displayNormalized: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param falloffCurve: (C Q E) Set the values on the falloff curve control
    :type falloffCurve: string
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param symmetry: (C Q E) Controls whether or not the tool operates in symmetric (mirrored)
    mode
    :type symmetry: boolean
    :param tolerance: (C Q E) The tolerance setting for determining whether another influence
    is symmetric to the the current influence
    :type tolerance: float
    
    :returns: The name of the context created
    :rtype: string
    """
    pass


def assignCommand(*args, addDivider="", altModifier=True, annotation="", command=None,
                  commandModifier=True, ctrlModifier=True, data1="", data2="", data3="",
                  delete=0, dividerString="", enableCommandRepeat=True, factorySettings=True,
                  index=0, keyArray=True, keyString="", keyUp=True, name=True,
                  numDividersPreceding=0, numElements=True, optionModifier=True, sortByKey=True,
                  sourceUserCommands=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command allows the user to assign hotkeys and manipulate the internal array of named
    command objects  Each object in the array has an 1-based index which is used for
    referencing  Under expected usage you should not need to use this command directly as the
    Hotkey Editor may be used to assign hotkeys   This command is obsolete for setting new
    ho
    
    :param addDivider: (E) Appends an "annotated divider" item to the end of the list of
    commands
    :type addDivider: string
    :param altModifier: (E) This flag specifies if an alt modifier is used for the key
    :type altModifier: boolean
    :param annotation: (Q E) The string is the english name describing the command
    :type annotation: string
    :param command: (Q E) This is the command that is executed when this object is mapped to a
    key or menuItem
    :type command: script
    :param commandModifier: (E) This flag specifies if a command modifier is used for the key 
    This is only available on systems which support a separate command key
    :type commandModifier: boolean
    :param ctrlModifier: (E) This flag specifies if a ctrl modifier is used for the key
    :type ctrlModifier: boolean
    :param data1: (Q E) Optional, user-defined data strings may be attached to the nameCommand
    objects
    :type data1: string
    :param data2: (Q E) Optional, user-defined data strings may be attached to the nameCommand
    objects
    :type data2: string
    :param data3: (Q E) Optional, user-defined data strings may be attached to the nameCommand
    objects
    :type data3: string
    :param delete: (E) This tells the Manager to delete the object at position index
    :type delete: int
    :param dividerString: (Q) If the passed index corresponds to a "divider" item, then the
    divider's annotation is returned  Otherwise, a null string is returned
    :type dividerString: string
    :param enableCommandRepeat: (E) This flag specifies whether command repeat is enabled
    :type enableCommandRepeat: boolean
    :param factorySettings: (E) This flag sets the manager back to factory settings
    :type factorySettings: boolean
    :param index: (E) The index of the object to operate on  The index value ranges from 1 to
    the number of name command objects
    :type index: int
    :param keyArray: (Q) This flag returns all of the hotkeys on the command
    :type keyArray: boolean
    :param keyString: (Q E) This specifies a key to assign a command to in edit mode  In query
    mode this flag returns the key string, modifiers and indicates if the command is m
    :type keyString: string
    :param keyUp: (E) This flag specifies if the command is executed on keyUp or keyDown
    :type keyUp: boolean
    :param name: (Q) The name of the command object
    :type name: boolean
    :param numDividersPreceding: (Q) If the index of a namedCommand object C is passed in, then
    this flag returns the number of "divider" items preceding C when the namedCommands are sor
    :type numDividersPreceding: int
    :param numElements: (Q) This command returns the number of namedCommands in the system 
    This flag doesn't require the index to be specified
    :type numElements: boolean
    :param optionModifier: (E) This flag specifies if an option modifier is used for the key
    :type optionModifier: boolean
    :param sortByKey: (Q E) This key tells the manager to sort by key or by order of creation
    :type sortByKey: boolean
    :param sourceUserCommands: (E) This command sources the user named command file
    :type sourceUserCommands: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def keyframeRegionSetKeyCtx(*args, breakdown=True, exists=True, history=True, image1="",
                            image2="", image3="", name="", q=True, query=True, e=True,
                            edit=True, **kwargs):
    """
    This command creates a context which may be used to set keys within the keyframe region of
    the dope sheet editor
    
    :param breakdown: (Q E) Specifies whether or not to create breakdown keys
    :type breakdown: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: Context name
    :rtype: string
    """
    pass


def FillHole(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ConvertSelectionToShellBorder(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def LayoutUVOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def cluster(*args, after=True, afterReference=True, before=True, bindState=True,
            deformerTools=True, envelope=1.0, exclusive="", frontOfChain=True, geometry="",
            geometryIndices=True, ignoreSelected=True, includeHiddenSelections=False, name="",
            parallel=True, prune=True, relative=True, remove=True, resetGeometry=True,
            split=True, weightedNode=None, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The cluster command creates a cluster or edits the membership of an existing cluster  The
    command returns the name of the cluster node upon creation of a new cluster   After
    creating a cluster, the cluster's weights can be modified using the percent command or the
    set editor window
    
    :param after: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type after: boolean
    :param afterReference: (C E) The -afterReference flag is used to specify deformer ordering
    in a hybrid way that choses between -before and -after automatically  If the geometry b
    :type afterReference: boolean
    :param before: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type before: boolean
    :param bindState: (C) When turned on, this flag adds in a compensation to ensure the
    clustered objects preserve their spatial position when clustered  This is required to
    :type bindState: boolean
    :param deformerTools: (Q) Returns the name of the deformer tool objects (if any) as string
    string ..
    :type deformerTools: boolean
    :param envelope: (C Q E) Set the envelope value for the deformer  Default is 1.0
    :type envelope: float
    :param exclusive: (C Q) Puts the deformation set in a deform partition
    :type exclusive: string
    :param frontOfChain: (C E) This command is used to specify that the new deformer node
    should be placed ahead (upstream) of existing deformer and skin nodes in the shape's histo
    :type frontOfChain: boolean
    :param geometry: (Q E M) The specified object will be added to the list of objects being
    deformed by this deformer object, unless the -rm flag is also specified  When queried
    :type geometry: string
    :param geometryIndices: (Q) Complements the -geometry flag in query mode  Returns the multi
    index of each geometry
    :type geometryIndices: boolean
    :param ignoreSelected: (C) Tells the command to not deform objects on the current selection
    list
    :type ignoreSelected: boolean
    :param includeHiddenSelections: (C) Apply the deformer to any visible and hidden objects in
    the selection list  Default is false
    :type includeHiddenSelections: boolean
    :param name: (C) Used to specify the name of the node being created
    :type name: string
    :param parallel: (C E) Inserts the new deformer in a parallel chain to any existing
    deformers in the history of the object  A blendShape is inserted to blend the parallel r
    :type parallel: boolean
    :param prune: (E) Removes any points not being deformed by the deformer in its current
    configuration from the deformer set
    :type prune: boolean
    :param relative: (C) Enable relative mode for the cluster  In relative mode, Only the
    transformations directly above the cluster are used by the cluster  Default is off
    :type relative: boolean
    :param remove: (E M) Specifies that objects listed after the -g flag should be removed from
    this deformer
    :type remove: boolean
    :param resetGeometry: (E) Reset the geometry matrices for the objects being deformed by the
    cluster  This flag is used to get rid of undesirable effects that happen if you sca
    :type resetGeometry: boolean
    :param split: (C E) Branches off a new chain in the dependency graph instead of
    inserting/appending the deformer into/onto an existing chain  Works in create mode (and e
    :type split: boolean
    :param weightedNode: (C Q E) Transform node in the DAG above the cluster to which all
    percents are applied  The second DAGobject specifies the descendent of the first DAGobject
    f
    :type weightedNode: [string, string]
    
    :returns: (the cluster node name and the cluster handle name)
    :rtype: string[]
    """
    pass


def RemoveMaterialSoloing(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def displayStats(*args, **kwargs):
    """
    
    """
    pass


def evalNoSelectNotify(*args, **kwargs):
    """
    
    """
    pass


def FBXImportShapes(*args, **kwargs):
    """
    
    """
    pass


def texSculptCacheContext(*args, adjustSize=True, adjustStrength=True, direction=0,
                          falloffType=0, floodPin=0.0, grabTwist=True, inverted=True, mode="",
                          sculptFalloffCurve="", showBrushRingDuringStroke=True, size=0.0,
                          strength=0.0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This is a tool context command for uv cache sculpting tool
    
    :param adjustSize: (E) If true, puts the tool into the mode where dragging the mouse will
    edit the brush size  If false, puts the tool back into the previous sculpt mode
    :type adjustSize: boolean
    :param adjustStrength: (E) If true, puts the tool into the mode where dragging the mouse
    will edit the brush strength  If false, puts the tool back into the previous sculpt mod
    :type adjustStrength: boolean
    :param direction: (Q E) Specifies how the brush determines where the uvs go
    :type direction: int
    :param falloffType: (Q E) Specifies how the brush determines which uvs to affect
    :type falloffType: int
    :param floodPin: (C E) Sets the pin value for each UV to the given value
    :type floodPin: float
    :param grabTwist: (C Q E) If true, the grab brush twists the UVs
    :type grabTwist: boolean
    :param inverted: (C Q E) If true, inverts the effect of the brush
    :type inverted: boolean
    :param mode: (Q E) Specifies the type of sculpting effect the brush will perform
    :type mode: string
    :param sculptFalloffCurve: (Q E) Specifies the falloff curve that affects the brush
    :type sculptFalloffCurve: string
    :param showBrushRingDuringStroke: (Q E) Specifies whether or not to show the brush ring
    during stroke
    :type showBrushRingDuringStroke: boolean
    :param size: (Q E) Specifies the world-space size of the current brush
    :type size: float
    :param strength: (Q E) Specifies the world-space strength of the current brush
    :type strength: float
    
    :returns: 
    :rtype: None
    """
    pass


def NextManipulatorHandle(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ModifyLowerRadiusRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RandomizeShells(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteFBIKBodyPartKeys(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmWidthBrushContext(*args, **kwargs):
    """
    
    """
    pass


def subdivCrease(*args, sharpness=True, **kwargs):
    """
    Set the creasing on subdivision mesh edges or mesh points that are on the selection list
    
    :param sharpness: (C) Specifies the sharpness value to set the crease to
    :type sharpness: boolean
    
    :returns: Command result
    :rtype: boolean
    """
    pass


def TimeEditorCreateGroupFromSelection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddBifrostAccelerator(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeShowConnectedAttrs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def listConnections(*args, connections=False, destination=True, exactType=True, plugs=False,
                    shapes=False, skipConversionNodes=False, source=True, type="", **kwargs):
    """
    This command returns a list of all attributes/objects of a specified type that are
    connected to the given object(s)  If no objects are specified then the command lists the
    connections on selected nodes
    
    :param connections: (C) If true, return both attributes involved in the connection  The one
    on the specified object is given first  Default false
    :type connections: boolean
    :param destination: (C) Give the attributes/objects that are on the "destination" side of
    connection to the given object  Default true
    :type destination: boolean
    :param exactType: (C) When set to true, -t/type only considers node of this exact type 
    Otherwise, derived types are also taken into account
    :type exactType: boolean
    :param plugs: (C) If true, return the connected attribute names; if false, return the
    connected object names only  Default false;
    :type plugs: boolean
    :param shapes: (C) Actually return the shape name instead of the transform when the shape
    is "selected"  Default false
    :type shapes: boolean
    :param skipConversionNodes: (C) If true, skip over unit conversion nodes and return the
    node connected to the conversion node on the other side  Default false
    :type skipConversionNodes: boolean
    :param source: (C) Give the attributes/objects that are on the "source" side of connection
    to the given object  Default true
    :type source: boolean
    :param type: (C) If specified, only take objects of a specified type
    :type type: string
    
    :returns: List of connection plugs/nodes
    :rtype: string[]
    """
    pass


def u3dLayout(*args, **kwargs):
    """
    
    """
    pass


def ThreeTopSplitViewArrangement(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def fluidReplaceCacheOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def debug(*args, **kwargs):
    """
    
    """
    pass


def LoopBrushAnimationOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def posePanel(*args, control=True, copy="", createString=True, defineTemplate="", docTag="",
              editString=True, exists=True, init=True, isUnique=True, label="",
              menuBarRepeatLast=True, menuBarVisible=True, needsInit=True, parent="",
              popupMenuProcedure=None, poseEditor=True, replacePanel="", tearOff=True,
              tearOffCopy="", tearOffRestore=True, unParent=True, useTemplate="", q=True,
              query=True, e=True, edit=True, **kwargs):
    """
    This command creates a panel that derives from the base panel class that houses a
    poseEditor
    
    :param control: (Q) Returns the top level control for this panel  Usually used for getting
    a parent to attach popup menus  CAUTION: panels may not have controls at times
    :type control: boolean
    :param copy: (E) Makes this panel a copy of the specified panel  Both panels must be of the
    same type
    :type copy: string
    :param createString: (E) Command string used to create a panel
    :type createString: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Attaches a tag to the Maya panel
    :type docTag: string
    :param editString: (E) Command string used to edit a panel
    :type editString: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param init: (C E) Initializes the panel's default state  This is usually done
    automatically on file -new and file -open
    :type init: boolean
    :param isUnique: (Q) Returns true if only one instance of this panel type is allowed
    :type isUnique: boolean
    :param label: (Q E) Specifies the user readable label for the panel
    :type label: string
    :param menuBarRepeatLast: (C Q E) Controls whether clicking on the menu header with the
    middle mouse button would repeat the last selected menu item
    :type menuBarRepeatLast: boolean
    :param menuBarVisible: (C Q E) Controls whether the menu bar for the panel is displayed
    :type menuBarVisible: boolean
    :param needsInit: (Q E) (Internal) On Edit will mark the panel as requiring initialization 
    Query will return whether the panel is marked for initialization  Used during fil
    :type needsInit: boolean
    :param parent: (C) Specifies the parent layout for this panel
    :type parent: string
    :param popupMenuProcedure: (Q E) Specifies the procedure called for building the panel's
    popup menu(s)  The default value is "buildPanelPopupMenu"  The procedure should take one
    stri
    :type popupMenuProcedure: script
    :param poseEditor: (Q) Query only flag that returns the name of an editor to be associated
    with the panel
    :type poseEditor: boolean
    :param replacePanel: (E) Will replace the specified panel with this panel  If the target
    panel is within the same layout it will perform a swap
    :type replacePanel: string
    :param tearOff: (Q E) Will tear off this panel into a separate window with a paneLayout as
    the parent of the panel  When queried this flag will return if the panel has bee
    :type tearOff: boolean
    :param tearOffCopy: (C) Will create this panel as a torn of copy of the specified source
    panel
    :type tearOffCopy: string
    :param tearOffRestore: (C E) Restores panel if it is torn off and focus is given to it  If
    docked, becomes the active panel in the docked window  This should be the default flag
    :type tearOffRestore: boolean
    :param unParent: (E) Specifies that the panel should be removed from its layout  This
    (obviously) cannot be used with query
    :type unParent: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: The name of the panel
    :rtype: string
    """
    pass


def ShowRenderingUI(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ActivateGlobalScreenSlider(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorGraphAllShapes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HidePolygonSurfaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateEmptyUVSet(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeCreatePSDFile(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def menuSet(*args, addMenu="", allMenuSets=True, currentMenuSet="", exists="",
            hotBoxVisible=True, insertMenu=None, label="", menuArray=None, moveMenu=None,
            moveMenuSet=None, numberOfMenuSets=True, numberOfMenus=True, permanent=True,
            removeMenu="", removeMenuSet="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    Create a menu set which is used to logically order menus for display in the main menu bar 
    Such menu sets can be edited and reordered dynamically
    
    :param addMenu: (C) Appends a menu onto the end of the current menu set
    :type addMenu: string
    :param allMenuSets: (Q) Returns an array of the all the menu set object names in use  Query
    returns string array
    :type allMenuSets: boolean
    :param currentMenuSet: (C Q) The currently active menu set under which all operations
    affect (append, insert, remove, etc.)  Query returns string
    :type currentMenuSet: string
    :param exists: (Q) Returns whether the specified menu set exists  This query flag supports
    string arguments  ie  menuSet -q -exists animationMenuSet; In query mode, thi
    :type exists: string
    :param hotBoxVisible: (C Q E) Whether this menu set should be displayed in the hotbox as
    well as in the main menubar
    :type hotBoxVisible: boolean
    :param insertMenu: (C) Inserts a menu into a specified index in the current menu set
    :type insertMenu: [string, int]
    :param label: (C Q) The label of the current menu set  Query returns string
    :type label: string
    :param menuArray: (C Q) An array of menu names (strings) in the current menu set  Query
    returns string array
    :type menuArray: string[]
    :param moveMenu: (C) Moves a specified menu from the current menu set to a new position
    :type moveMenu: [string, int]
    :param moveMenuSet: (C) Moves a specified menu set to another index
    :type moveMenuSet: [string, int]
    :param numberOfMenuSets: (Q) Number of menuSets in total  Query returns int
    :type numberOfMenuSets: boolean
    :param numberOfMenus: (Q) The mumber of menus in the current menu set  Query returns int
    :type numberOfMenus: boolean
    :param permanent: (C Q E) Whether this menu set can be removed
    :type permanent: boolean
    :param removeMenu: (C) Removes a specified menu from the current menu set
    :type removeMenu: string
    :param removeMenuSet: (C) Removes the specified menu set object from the list of all menu
    sets
    :type removeMenuSet: string
    
    :returns: Name of resulting menu set.  (If there are no menu sets left, an empty string is
    returned)
    :rtype: string
    """
    pass


def workspace(*args, active=True, baseWorkspace="", create="", directory="", expandName="",
              fileRule=None, fileRuleEntry="", fileRuleList=True, filter=True, fullName=True,
              list=True, listFullWorkspaces=True, listWorkspaces=True, newWorkspace=True,
              objectType=None, objectTypeEntry="", objectTypeList=True, openWorkspace=True,
              projectPath="", removeFileRuleEntry="", removeVariableEntry="", renderType=None,
              renderTypeEntry="", renderTypeList=True, rootDirectory=True, saveWorkspace=True,
              shortName=True, update=True, updateAll=True, variable=None, variableEntry="",
              variableList=True, q=True, query=True, **kwargs):
    """
    Create, open, or edit a workspace associated with a given workspace file   The string
    argument represents the workspace  If no workspace is specified then the current workspace
    is assumed   A workspace provides the underlying definition of a Maya Project  Each project
    has an associated workspace file, named workspace.mel, which is stored in the pro
    
    :param active: (C Q) This flag is a synonym for -o/openWorkspace
    :type active: boolean
    :param baseWorkspace: (Q) A workspace may be based on another workspace  This means that
    all the file rules and variables in the base workspace apply to this workspace unless
    :type baseWorkspace: string
    :param create: (C) Create a new directory  If the directory name is not a full path name,
    it will be created as a subdirectory of the "current" directory set with the -
    :type create: string
    :param directory: (C Q) This option will set the current workspace directory to the path
    specified  When queried it will return the current workspace directory  This directo
    :type directory: string
    :param expandName: (C Q) Query for the full path location of a filename using the current
    workspace definition  The path may be a project relative file name, a full path name
    :type expandName: string
    :param fileRule: (C Q) Set the default location for a file  The first parameter is the
    fileRule name(scenes, images, etc) and the second is the location  When queried, it r
    :type fileRule: [string, string]
    :param fileRuleEntry: (C Q) Return the location for the given fileRule
    :type fileRuleEntry: string
    :param fileRuleList: (C Q) Returns a list of the currently defined file rules
    :type fileRuleList: boolean
    :param filter: () This flag is obsolete
    :type filter: boolean
    :param fullName: (C Q) Return the full name of the workspace
    :type fullName: boolean
    :param list: (C Q) This option will list the current workspace directory  If a path is
    specified for the "workspaceFile" then the contents of that directory will be lis
    :type list: boolean
    :param listFullWorkspaces: (C Q) Returns a list of the full path names of all the currently
    defined workspaces
    :type listFullWorkspaces: boolean
    :param listWorkspaces: (C Q) Returns a list of all the currently defined workspace names
    :type listWorkspaces: boolean
    :param newWorkspace: (C) This specifies that a new workspace is being created with a given
    path (full path or relative to "current" directory)  If a workspace with this path
    :type newWorkspace: boolean
    :param objectType: (C Q) This flag is obsolete  All default locations will be added to the
    fileRules going forward
    :type objectType: [string, string]
    :param objectTypeEntry: (C Q) This flag is obsolete  This will now return the same as
    fileRuleEntry
    :type objectTypeEntry: string
    :param objectTypeList: (C Q) This flag is obsolete  This will now return the same results
    as fileRuleList going forward
    :type objectTypeList: boolean
    :param openWorkspace: (C Q) Open the workspace  The workspace becomes the current
    workspace
    :type openWorkspace: boolean
    :param projectPath: (C Q) Convert filePath passed as argument to a filename that is
    relative to the project root directory (if possible) and return it  If the filePath is not
    :type projectPath: string
    :param removeFileRuleEntry: (C) Remove the given file rule from the specified workspace  If
    the workspace name is not specified, the given file rule will be removed from the current
    :type removeFileRuleEntry: string
    :param removeVariableEntry: (C) Remove the given variable from the specified workspace  If
    the workspace name is not specified, the given variable will be removed from the current w
    :type removeVariableEntry: string
    :param renderType: (C Q) This flag is obsolete  All default render types will be added to
    fileRules going forward
    :type renderType: [string, string]
    :param renderTypeEntry: (C Q) This flag is obsolete, use fileRuleEntry going forward
    :type renderTypeEntry: string
    :param renderTypeList: (C Q) This flag is obsolete, use fileRuleList going forward
    :type renderTypeList: boolean
    :param rootDirectory: (Q) Returns the root directory of the workspace
    :type rootDirectory: boolean
    :param saveWorkspace: (C) Save the workspace  Workspaces are normally saved when Maya exits
    but this flag will make sure that the data is flushed to disk
    :type saveWorkspace: boolean
    :param shortName: (C Q) Query the short name of the workspace
    :type shortName: boolean
    :param update: (C) This flag reads all the workspace definitions from the project directory
     It is used by Maya at startup time to find the available workspaces
    :type update: boolean
    :param updateAll: (C) This flag is a synonym for -u/update
    :type updateAll: boolean
    :param variable: (C Q) Set or query the value of a project variable  Project variables are
    used when expanding names  See the -en/expandName flag below
    :type variable: [string, string]
    :param variableEntry: (C Q) Given a variable name, will return its value
    :type variableEntry: string
    :param variableList: (C Q) Return a list of all variables in the workspace
    :type variableList: boolean
    
    :returns: Project short name when querying the 'shortName' flag.
    :rtype: string
    """
    pass


def AddKeyToolDeactivate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DetachSkeletonJoints(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmSplineApplyRenderOverride(*args, **kwargs):
    """
    
    """
    pass


def texSmoothContext(*args, **kwargs):
    """
    
    """
    pass


def dR_objectXrayTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TogglePolyDisplayEdges(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def disconnectJoint(*args, attachHandleMode=True, deleteHandleMode=True, **kwargs):
    """
    This command will break a skeleton at the selected joint and delete any associated handles
    
    :param attachHandleMode: (C) This flag is obsolete and no longer supported
    :type attachHandleMode: boolean
    :param deleteHandleMode: (C) Delete the handle on the associated joint
    :type deleteHandleMode: boolean
    
    :returns: After the joint is disconnected, a new joint will be created. The return value is
    the name of the newly created joint and its ancestor.
    :rtype: string
    """
    pass


def DeleteExpressionsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyClipboard(*args, clear=True, color=True, copy=True, paste=True, shader=True,
                  uvCoordinates=True, **kwargs):
    """
    The command allows the user to copy and paste certain polygonal attributes to a clipboard 
    These attributes are: 1) Shader (shading engine) assignment  2) Texture coordinate (UV)
    assignment  3) Color value assignment  Any combination of attributes can be chosen for the
    copy or paste operation  If the attribute has not been copied to the clipboard, 
    
    :param clear: (C) When used, will mean to clear the specified attribute argument(s)
    :type clear: boolean
    :param color: (C) When used, will be to copy or paste color attributes
    :type color: boolean
    :param copy: (C) When used, will mean to copy the specified attribute argument(s)
    :type copy: boolean
    :param paste: (C) When used, will mean to paste the specified attribute argument(s)
    :type paste: boolean
    :param shader: (C) When used, will be to copy or paste shader attributes
    :type shader: boolean
    :param uvCoordinates: (C) When used, will be to copy or paste texture coordinate
    attributes
    :type uvCoordinates: boolean
    
    :returns: Success or Failure
    :rtype: boolean
    """
    pass


def moduleDetectionLogic(*args, **kwargs):
    """
    
    """
    pass


def PolyExtrudeEdgesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RenderLayerEditorWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SnapToPoint(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OffsetCurveOnSurfaceOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideStrokeControlCurves(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HoldCurrentKeys(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def StitchSurfacePoints(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TwoStackedViewArrangement(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BakeNonDefHistoryOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CustomPolygonDisplayOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateWakeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def EditMembershipTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowNParticles(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Snap2PointsTo2Points(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dynamicLoad(*args, q=True, query=True, **kwargs):
    """
    Dynamically load the DLL passed as argument
    
    
    :returns: 
    :rtype: None
    """
    pass


def DeleteAllJoints(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ConvertSelectionToShell(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TranslateToolMarkingMenu(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeDisplayAsMediumSwatches(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateCameraAimUp(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolyAssignSubdivHoleOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def drawExtrudeFacetCtx(*args, **kwargs):
    """
    
    """
    pass


def directConnectPath(*args, **kwargs):
    """
    
    """
    pass


def shotRipple(*args, deleted=True, endDelta=None, endTime=None, startDelta=None,
               startTime=None, q=True, query=True, e=True, edit=True, **kwargs):
    """
    When Ripple Edit Mode is enabled, neighboring shots to the shot that gets manipulated are
    moved in sequence time to either make way or close up gaps corresponding to that node's
    editing  Given some parameters about the shot edit that just took place, this command will
    choose which other shots to move, and move them the appropriate amounts If no sho
    
    :param deleted: (C Q E) Specify whether this ripple edit is due to a shot deletion
    :type deleted: boolean
    :param endDelta: (C Q E) Specify the change in the end time in frames
    :type endDelta: time
    :param endTime: (C Q E) Specify the initial shot end time in the sequence timeline
    :type endTime: time
    :param startDelta: (C Q E) Specify the change in the start time in frames
    :type startDelta: time
    :param startTime: (C Q E) Specify the initial shot start time in the sequence timeline
    :type startTime: time
    
    :returns: 
    :rtype: None
    """
    pass


def ShowBoundingBox(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def frameLayout(*args, annotation="", backgroundColor=None, backgroundShade=True,
                borderStyle="", borderVisible=True, childArray=True, collapsable=True,
                collapse=True, collapseCommand=None, defineTemplate="", docTag="",
                dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
                enableKeyboardFocus=True, exists=True, expandCommand=None, font="",
                fullPathName=True, height=0, highlightColor=None, isObscured=True, label="",
                labelAlign="top", labelIndent=0, labelVisible=True, labelWidth=0, manage=True,
                marginHeight=0, marginWidth=0, noBackground=True, numberOfChildren=True,
                numberOfPopupMenus=True, parent="", popupMenuArray=True,
                preCollapseCommand=None, preExpandCommand=None, preventOverride=True,
                statusBarMessage="", useTemplate="", visible=True, visibleChangeCommand=None,
                width=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates frame layout control  A frame layout may draw a border around its
    child controls as well as a display a title  Frame layouts may also be collapsable 
    Collapsing a frame layout will make the child of the frame layout invisible and shrink the
    frame layout size  The frame layout may then be expanded to make its child visible  Note
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param backgroundShade: (C Q E) Controls whether the background of the frame layout draws
    with a shaded effect  It is turned off by default
    :type backgroundShade: boolean
    :param borderStyle: (C Q E) This flag is obsolete  The border style is no longer supported 
    Using this flag will return a warning
    :type borderStyle: string
    :param borderVisible: (C Q E) Visibility of the border
    :type borderVisible: boolean
    :param childArray: (Q) Returns a string array of the names of the layout's immediate
    children
    :type childArray: boolean
    :param collapsable: (C Q E) Collapsibility of the frame layout
    :type collapsable: boolean
    :param collapse: (C Q E) Collapse state of the frame layout
    :type collapse: boolean
    :param collapseCommand: (C E) Command executed after the frame is collapsed
    :type collapseCommand: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param expandCommand: (C E) Command executed after the frame is expanded
    :type expandCommand: script
    :param font: (C Q E) The font for the frame label  Valid values are "boldLabelFont",
    "smallBoldLabelFont", "tinyBoldLabelFont", "plainLabelFont", "smallPlainLabelFont", "
    :type font: string
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) Label string for the frame layout
    :type label: string
    :param labelAlign: (C Q E) How to align the label  Default is "top"
    :type labelAlign: string
    :param labelIndent: (C Q E) Indentation for the frame label
    :type labelIndent: int
    :param labelVisible: (C Q E) Visibility of the frame label
    :type labelVisible: boolean
    :param labelWidth: (C Q E) Width of the label
    :type labelWidth: int
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param marginHeight: (C Q E) Vertical distance between the frame and its children
    :type marginHeight: int
    :param marginWidth: (C Q E) Horizontal distance between the frame and its children
    :type marginWidth: int
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfChildren: (Q) Returns in an int the number of immediate children of the
    layout
    :type numberOfChildren: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preCollapseCommand: (C E) Command executed just before the frame is collapsed
    :type preCollapseCommand: script
    :param preExpandCommand: (C E) Command executed just before the frame is expanded
    :type preExpandCommand: script
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def UpdateCurrentSceneMudbox(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def runTimeCommand(*args, **kwargs):
    """
    
    """
    pass


def upAxis(*args, axis="", rotateView=True, q=True, query=True, **kwargs):
    """
    The upAxis command changes the world up direction  Current implementation provides only two
    choices of axis (the Y-axis or the Z-axis) as the world up direction.  By default, the
    ground plane in Maya is on the XY plane  Hence, the default up-direction is the direction
    of the positive Z-axis.  The -ax flag is mandatory  In conjunction with the -ax f
    
    :param axis: (Q) This flag specifies the axis as the world up direction  The valid axis are
    either "y" or "z"  When queried, it returns a string
    :type axis: string
    :param rotateView: (C) This flag specifies to rotate the view as well
    :type rotateView: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def HypershadeFrameAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddCombinationTarget(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Birail3Options(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HIKCharacterControlsTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def viewPlace(*args, animate=True, eyePoint=None, fieldOfView=0.0, lookAt=None, ortho=True,
              perspective=True, upDirection=None, viewDirection=None, **kwargs):
    """
    This command positions the camera as specified  The lookAt and viewDirection flags are
    mutually exclusive, as are the ortho and perspective flags  If this command switches a
    camera from ortho to perspective or the other way around without specifying a new field of
    view, then one is calculated based on a heuristic involving the selected objects    I
    
    :param animate: (C) If set to true then animate the camera transition from current position
    to the final one
    :type animate: boolean
    :param eyePoint: (C) The new eye point in world coordinates
    :type eyePoint: [float, float, float]
    :param fieldOfView: (C) The new field of view (in degrees, for perspective cameras, and in
    world distance for ortho cameras)
    :type fieldOfView: float
    :param lookAt: (C) The new look-at point in world coordinates
    :type lookAt: [float, float, float]
    :param ortho: (C) Sets the camera to be orthgraphic
    :type ortho: boolean
    :param perspective: (C) Sets the camera to be perspective
    :type perspective: boolean
    :param upDirection: (C) The new up direction vector
    :type upDirection: [float, float, float]
    :param viewDirection: (C) The new view direction vector
    :type viewDirection: [float, float, float]
    
    :returns: 
    :rtype: None
    """
    pass


def channelBox(*args, annotation="", attrBgColor=None, attrColor=None, attrFilter="",
               attrRegex="", attributeEditorMode=False, backgroundColor=None,
               containerAtTop=True, defineTemplate="", docTag="", dragCallback=None,
               dropCallback=None, enable=True, enableBackground=True, enableKeyboardFocus=True,
               enableLabelSelection=False, execute=None, exists=True, fieldWidth=0,
               fixedAttrList=None, fullPathName=True, height=0, highlightColor=None,
               historyObjectList=True, hyperbolic=True, inputs=True, isObscured=True,
               labelWidth=0, longNames=True, mainListConnection="", mainObjectList=True,
               manage=True, maxHeight=0, maxWidth=0, niceNames=True, noBackground=True,
               nodeRegex="", numberOfPopupMenus=True, outputObjectList=True, outputs=True,
               parent="", popupMenuArray=True, precision=3, preventOverride=True, select="",
               selectedHistoryAttributes=True, selectedMainAttributes=True,
               selectedOutputAttributes=True, selectedShapeAttributes=True,
               shapeObjectList=True, shapes=True, showNamespace=True, showTransforms=True,
               speed=1.0, statusBarMessage="", takeFocus=True, update=True, useManips="",
               useTemplate="", visible=True, visibleChangeCommand=None, width=0, q=True,
               query=True, e=True, edit=True, **kwargs):
    """
    This command creates a channel box, which is sensitive to the active list  It displays
    certain attributes (channels) of the last node on the active list, and provides a two-way
    connection to keep the widget up to date   Note: when setting the color of attribute names,
    that color is only valid for its current Maya session; each subsequent session wi
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param attrBgColor: (C Q E) Controls the background text color of specific attribute names 
    As with the foreground option, this text coloring also depends on the node name choic
    :type attrBgColor: [float, float, float]
    :param attrColor: (C Q E) Controls the foreground text color of specific attribute names 
    This text coloring also depends on the node name choice for the nodeRegex flag  Argum
    :type attrColor: [float, float, float]
    :param attrFilter: (Q E) Specifies the name of an itemFilter object to be placed on the
    channel box  This filters the attributes displayed  A filter of "0" can be used to res
    :type attrFilter: string
    :param attrRegex: (C Q E) Specifies a valid regular expression to specify which attribute
    names should be selected for foreground text coloring  If attrRegex is unspecified th
    :type attrRegex: string
    :param attributeEditorMode: (Q E) Modifies what appears in the channel box for use in the
    attribute editor  Default is false  Queried, returns a boolean
    :type attributeEditorMode: boolean
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param containerAtTop: (Q E) This flag can be used to specify whether or not the container
    is drawn at the top of the channel box when a node in the container is selected
    :type containerAtTop: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param enableLabelSelection: (Q E) Enables the selection of attributes in the channelBox
    when used in conjunction with -attributeEditorMode  Default is false  Queried, returns a
    boolea
    :type enableLabelSelection: boolean
    :param execute: (E) Immediately executes the command string once for every cell (or every
    selected cell, if the boolean argument is TRUE) in the channel box, for every m
    :type execute: [string, boolean]
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fieldWidth: (Q E) An optional flag which is used to modify the width assigned to
    fields appearing in the channelBox
    :type fieldWidth: int
    :param fixedAttrList: (C Q E) Forces the channel box to only display attributes with the
    specified names, in the order they are specified  If an empty list is specified, then the
    :type fixedAttrList: string[]
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param historyObjectList: (Q) Returns a list of strings, the names of every INPUT node
    associated with an object on the main object list that is of the same type as the node
    displ
    :type historyObjectList: boolean
    :param hyperbolic: (C Q E) Determines whether or not the distance that the mouse has been
    dragged should be interpreted as a linear or hyperbolic function  The default is set t
    :type hyperbolic: boolean
    :param inputs: (Q) Returns the items shown under the 'INPUTS' heading in the channel box
    :type inputs: boolean
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param labelWidth: (Q E) An optional flag which is used to modify the width assigned to
    labels appearing in the channelBox
    :type labelWidth: int
    :param longNames: (Q E) Controls whether long or short attribute names will be used in the
    interface  Note that this flag is ignored if the -niceNames flag is set  Default i
    :type longNames: boolean
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object which
    the editor will use as its source of content  The channel box will only display the (last)
    i
    :type mainListConnection: string
    :param mainObjectList: (Q) Returns a list of strings, the names of every object on the
    active list that is the same type as the object displayed in the top (main) section of th
    :type mainObjectList: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param maxHeight: (Q E) An optional flag which is used to limit the height of the
    channelBox
    :type maxHeight: int
    :param maxWidth: (Q E) An optional flag which is used to limit the width of the channelBox
    :type maxWidth: int
    :param niceNames: (Q E) Controls whether the attribute names will be displayed in a more
    user-friendly, readable way  When this is on, the longNames flag is ignored  When th
    :type niceNames: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param nodeRegex: (C Q E) Specifies a valid regular expression to specify which node names
    should (potentially) have their attributes selected for foreground text coloring  If
    :type nodeRegex: string
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param outputObjectList: (Q) Returns a list of strings, the names of every OUTPUT node
    associated an object on the main object list that is of the same type as the node
    displayed
    :type outputObjectList: boolean
    :param outputs: (Q) Returns the items shown under the 'OUTPUTS' heading in the channel box
    :type outputs: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param precision: (Q E) Controls the number of digits to the right of the decimal point
    that will be displayed for float-valued channels  Default is 3  Queried, returns an i
    :type precision: int
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param select: (E M) Allows programmatic selection of items (nodes or plugs) in the channel
    box  Selection is equivalent to clicking the item with the mouse; therefore on
    :type select: string
    :param selectedHistoryAttributes: (Q) Returns a list of strings, the names of all the
    selected attributes in the INPUT section of the channel box
    :type selectedHistoryAttributes: boolean
    :param selectedMainAttributes: (Q) Returns a list of strings, the names of all the selected
    attributes in the top section of the channel box
    :type selectedMainAttributes: boolean
    :param selectedOutputAttributes: (Q) Returns a list of strings, the names of all the
    selected attributes in the OUTPUT section of the channel box
    :type selectedOutputAttributes: boolean
    :param selectedShapeAttributes: (Q) Returns a list of strings, the names of all the
    selected attributes in the middle (shape) section of the channel box
    :type selectedShapeAttributes: boolean
    :param shapeObjectList: (Q) Returns a list of strings, the names of every shape associated
    with an object on the main object list that is of the same type as the object displaye
    :type shapeObjectList: boolean
    :param shapes: (Q) Returns the items shown under the 'SHAPES' heading in the channel box
    :type shapes: boolean
    :param showNamespace: (C Q E) Controls whether or not the namespace of an object is
    displayed if the object is not in the root namespace
    :type showNamespace: boolean
    :param showTransforms: (Q E) Controls whether this control will display transform
    attributes only, or all other attributes  False by default  Queried, returns a boolean
    :type showTransforms: boolean
    :param speed: (C Q E) Controls the speed at which the attributes are changed based on the
    distance the mouse has been dragged  Common settings for slow/medium/fast are 0.1
    :type speed: float
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param takeFocus: (E) causes the channel box to take over the keyboard focus, if it can
    :type takeFocus: boolean
    :param update: (E) This flag can be used to force an update of the channel box display, for
    example after changing a display preference
    :type update: boolean
    :param useManips: (C Q E) When you click on a field or label in the channel box, the tool
    switches to a manipulator that can change that value if you drag in the 3d view  This
    :type useManips: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: (the name of the new channel box)
    :rtype: string
    """
    pass


def GoToFBIKStancePose(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ImportSkinWeightMaps(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def layeredTexturePort(*args, annotation="", backgroundColor=None, defineTemplate="", docTag="",
                       dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
                       enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
                       highlightColor=None, isObscured=True, manage=True, noBackground=True,
                       node=None, numberOfPopupMenus=True, parent="", popupMenuArray=True,
                       preventOverride=True, selectedAlphaControl="",
                       selectedBlendModeControl="", selectedColorControl="",
                       selectedIsVisibleControl="", statusBarMessage="", useTemplate="",
                       visible=True, visibleChangeCommand=None, width=0, q=True, query=True,
                       e=True, edit=True, **kwargs):
    """
    This command creates a 3dPort that displays an image representing the layered texture node
    specified
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param node: (C) Specifies the name of the newLayeredTexture node this port will represent
    :type node: name
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param selectedAlphaControl: (C) Specifies the name of the UI-control that represents the
    currently selected layer's alpha
    :type selectedAlphaControl: string
    :param selectedBlendModeControl: (C) Specifies the name of the UI-control that represents
    the currently selected layer's blend mode
    :type selectedBlendModeControl: string
    :param selectedColorControl: (C) Specifies the name of the UI-control that represents the
    currently selected layer's color
    :type selectedColorControl: string
    :param selectedIsVisibleControl: (C) Specifies the name of the UI-control that represents
    the currently selected layer's visibility
    :type selectedIsVisibleControl: string
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def cutKey(*args, animation="keysOrObjects.", attribute="", clear=True, controlPoints=False,
           float=None, hierarchy="", includeUpperBound=True, index=0, option="", selectKey=True,
           shape=True, time=None, **kwargs):
    """
    This command operates on a keyset  A keyset is defined as a group of keys within a
    specified time range on one or more animation curves   The animation curves comprising a
    keyset depend on the value of the "-animation" flag:  keysOrObjects: Any active keys, when
    no target objects or -attribute flags appear on the command line, or All animation curv
    
    :param animation: (C) Where this command should get the animation to act on  Valid values
    are "objects," "keys," and "keysOrObjects" Default: "keysOrObjects." (See Descrip
    :type animation: string
    :param attribute: (C M) List of attributes to select In query mode, this flag needs a
    value
    :type attribute: string
    :param clear: (C) Just remove the keyframes (i.e  do not overwrite the clipboard)
    :type clear: boolean
    :param controlPoints: (C) This flag explicitly specifies whether or not to include the
    control points of a shape (see "-s" flag) in the list of attributes  Default: false  (No
    :type controlPoints: boolean
    :param float: (C M) value uniquely representing a non-time-based key (or key range) on a
    time-based animCurve  Valid floatRange include single values (-f 10) or a string
    :type float: floatrange
    :param hierarchy: (C) Hierarchy expansion options  Valid values are "above," "below," "both,
    " and "none." (Not valid for "pasteKey" cmd.) In query mode, this flag needs a
    :type hierarchy: string
    :param includeUpperBound: (C) When the -t/time or -f/float flags represent a range of keys,
    this flag determines whether the keys at the upper bound of the range are included in t
    :type includeUpperBound: boolean
    :param index: (C M) index of a key on an animCurve In query mode, this flag needs a value
    :type index: int
    :param option: (C) Option for how to perform the cutKey operation  Valid values for this
    flag are "keys", "curve", "curveCollapse", "curveConnect", "areaCollapse"  The
    :type option: string
    :param selectKey: (C) Select the keyframes of curves which have had keys removed
    :type selectKey: boolean
    :param shape: (C) Consider attributes of shapes below transforms as well, except
    "controlPoints"  Default: true  (Not valid for "pasteKey" cmd.) In query mode, this fl
    :type shape: boolean
    :param time: (C M) time uniquely representing a key (or key range) on a time-based
    animCurve  See the code examples below on how to format for a single frame or frame r
    :type time: timerange
    
    :returns: Number of animation curves cut.
    :rtype: int
    """
    pass


def polyExtrudeEdge(*args, caching=True, constructionHistory=True, createCurve=True,
                    divisions=1, gain=1.0, inputCurve=None, keepFacesTogether=True,
                    localCenter=0, localDirection=None, localDirectionX=0.0,
                    localDirectionY=0.0, localDirectionZ=0.0, localRotate=None,
                    localRotateX=0.0, localRotateY=0.0, localRotateZ=0.0, localScale=None,
                    localScaleX=0.0, localScaleY=0.0, localScaleZ=0.0, localTranslate=None,
                    localTranslateX=0.0, localTranslateY=0.0, localTranslateZ=0.0, name="",
                    nodeState=0, offset=0.0, pivot=None, pivotX=0.0, pivotY=0.0, pivotZ=0.0,
                    random=0.0, rotate=None, rotateX=0.0, rotateY=0.0, rotateZ=0.0, scale=None,
                    scaleX=0.0, scaleY=0.0, scaleZ=0.0, smoothingAngle=0.0, taper=1.0,
                    taperCurve_FloatValue=0.0, taperCurve_Interp=0, taperCurve_Position=0.0,
                    thickness=0.0, translate=None, translateX=0.0, translateY=0.0,
                    translateZ=0.0, twist=0.0, worldSpace=True, q=True, query=True, e=True,
                    edit=True, **kwargs):
    """
    Extrude edges separately or together
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param createCurve: (C) If true then the operation can create a curve
    :type createCurve: boolean
    :param divisions: (C Q E) How many internal edges are creating when pulling  Default: 1
    :type divisions: int
    :param gain: (C Q E M) Gain factor per component  Can be painted using Artisan  Default:
    1.0
    :type gain: float
    :param inputCurve: (C) This flag specifies the name of the curve to be used as input for
    the operation
    :type inputCurve: name
    :param keepFacesTogether: (C Q E) How to extrude edges  If "on", extruded faces produced
    from the edges being extruded will be kept together  Otherwise they are pulled
    independently
    :type keepFacesTogether: boolean
    :param localCenter: (C Q E) Local center on the edge : 0=Middle point, 1=Start point, 2=End
    point  Default: 0
    :type localCenter: int
    :param localDirection: (C Q E) Direction to determine X axis for local space  Default: 1.0,
    0.0, 0.0
    :type localDirection: [float, float, float]
    :param localDirectionX: (C Q E) X coord of the X axis
    :type localDirectionX: float
    :param localDirectionY: (C Q E) Y coord of the X axis
    :type localDirectionY: float
    :param localDirectionZ: (C Q E) Z coord of the X axis
    :type localDirectionZ: float
    :param localRotate: (C Q E) The local rotations  Default: 0.0, 0.0, 0.0
    :type localRotate: [float, float, float]
    :param localRotateX: (C Q E) Local rotate X coord  The range is [0, 360]
    :type localRotateX: float
    :param localRotateY: (C Q E) Local rotate Y coord  The range is [0, 360]
    :type localRotateY: float
    :param localRotateZ: (C Q E) Local rotate Z coord : Rotation along the normal  The range is
    [0, 360]
    :type localRotateZ: float
    :param localScale: (C Q E) Local Scale  Default: 1.0, 1.0, 1.0
    :type localScale: [float, float, float]
    :param localScaleX: (C Q E) Scale X coord
    :type localScaleX: float
    :param localScaleY: (C Q E) Scale Y coord
    :type localScaleY: float
    :param localScaleZ: (C Q E) Scale Z coord
    :type localScaleZ: float
    :param localTranslate: (C Q E) Local translate  Default: 0.0, 0.0, 0.0
    :type localTranslate: [float, float, float]
    :param localTranslateX: (C Q E) Local translation X coord
    :type localTranslateX: float
    :param localTranslateY: (C Q E) Local translation Y coord
    :type localTranslateY: float
    :param localTranslateZ: (C Q E) Local translation Z coord : Move along the normal
    :type localTranslateZ: float
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param offset: (C Q E) Edges are moved this distance in the opposite direction of the edge 
    Default: 0.0
    :type offset: float
    :param pivot: (C Q E) The pivot for scaling and rotation  Default: 0.0, 0.0, 0.0
    :type pivot: [float, float, float]
    :param pivotX: (C Q E) Pivot X coord
    :type pivotX: float
    :param pivotY: (C Q E) Pivot Y coord
    :type pivotY: float
    :param pivotZ: (C Q E) Pivot Z coord
    :type pivotZ: float
    :param random: (C Q E) Random value for all parameters  Default: 0.0
    :type random: float
    :param rotate: (C Q E) Rotation angles around X, Y, Z  Default: 0.0, 0.0, 0.0
    :type rotate: [float, float, float]
    :param rotateX: (C Q E) Rotation angle around X
    :type rotateX: float
    :param rotateY: (C Q E) Rotation angle around Y
    :type rotateY: float
    :param rotateZ: (C Q E) Rotation angle around Z
    :type rotateZ: float
    :param scale: (C Q E) Scaling vector  Default: 1.0, 1.0, 1.0
    :type scale: [float, float, float]
    :param scaleX: (C Q E) Scale X coord
    :type scaleX: float
    :param scaleY: (C Q E) Scale Y coord
    :type scaleY: float
    :param scaleZ: (C Q E) Scale Z coord
    :type scaleZ: float
    :param smoothingAngle: (C Q E) Angle below which new edges will be smoothed Default:
    kPi/6.0
    :type smoothingAngle: float
    :param taper: (C Q E) Taper or Scale along the extrusion path Default: 1.0
    :type taper: float
    :param taperCurve_FloatValue: (C Q E) ?????
    :type taperCurve_FloatValue: float
    :param taperCurve_Interp: (C Q E) ????? Default: 0
    :type taperCurve_Interp: int
    :param taperCurve_Position: (C Q E) ?????
    :type taperCurve_Position: float
    :param thickness: (C Q E) Edges are moved this distance in the direction of the connected
    face normals  Default: 0.0f
    :type thickness: float
    :param translate: (C Q E) Translation vector  Default: 0.0, 0.0, 0.0
    :type translate: [float, float, float]
    :param translateX: (C Q E) Translation X coord
    :type translateX: float
    :param translateY: (C Q E) Translation Y coord
    :type translateY: float
    :param translateZ: (C Q E) Translation Z coord
    :type translateZ: float
    :param twist: (C Q E) Twist or Rotation along the extrusion path Default: 0.0
    :type twist: float
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def HypershadeSelectShadingGroupsAndMaterials(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyPoke(*args, caching=True, constructionHistory=True, localTranslate=None,
             localTranslateX=0.0, localTranslateY=0.0, localTranslateZ=0.0, name="",
             nodeState=0, translate=None, translateX=0.0, translateY=0.0, translateZ=0.0,
             worldSpace=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Introduces a new vertex in the middle of the selected face, and connects it to the rest of
    the vertices of the face
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param localTranslate: (C) Translate the new vertex in the local face coordinate
    :type localTranslate: [float, float, float]
    :param localTranslateX: (C) Translate the new vertex in the local face coordinate along X
    :type localTranslateX: float
    :param localTranslateY: (C) Translate the new vertex in the local face coordinate along Y
    :type localTranslateY: float
    :param localTranslateZ: (C) Translate the new vertex in the local face coordinate along Z
    :type localTranslateZ: float
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param translate: (C) Translate the new vertex in the world space
    :type translate: [float, float, float]
    :param translateX: (C) Translate the new vertex in the world space along X
    :type translateX: float
    :param translateY: (C) Translate the new vertex in the world space along Y
    :type translateY: float
    :param translateZ: (C) Translate the new vertex in the world space along Z
    :type translateZ: float
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name
    :rtype: string
    """
    pass


def CreateNURBSCircle(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OutlinerToggleIgnoreUseColor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def listRelatives(*args, allDescendents=True, allParents=True, children=True, fullPath=True,
                  noIntermediate=True, parent=True, path=True, shapes=True, type="", **kwargs):
    """
    This command lists parents and children of DAG objects  The flags -c/children,
    -ad/allDescendents, -s/shapes, -p/parent and -ap/allParents are mutually exclusive  Only
    one can be used in a command    When listing parents of objects directly under the world,
    the command will return an empty parent list  Listing parents of objects directly under a
    sh
    
    :param allDescendents: (C) Returns all the children, grand-children etc  of this dag node 
    If a descendent is instanced, it will appear only once on the list returned  Note tha
    :type allDescendents: boolean
    :param allParents: (C) Returns all the parents of this dag node  Normally, this command
    only returns the parent corresponding to the first instance of the object
    :type allParents: boolean
    :param children: (C) List all the children of this dag node (default)
    :type children: boolean
    :param fullPath: (C) Return full pathnames instead of object names
    :type fullPath: boolean
    :param noIntermediate: (C) No intermediate objects
    :type noIntermediate: boolean
    :param parent: (C) Returns the parent of this dag node
    :type parent: boolean
    :param path: (C) Return a proper object name that can be passed to other commands
    :type path: boolean
    :param shapes: (C) List all the children of this dag node that are shapes (ie, not
    transforms)
    :type shapes: boolean
    :param type: (C M) List all relatives of the specified type
    :type type: string
    
    :returns: Command result
    :rtype: string[]
    """
    pass


def GeometryToBoundingBox(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ProfilerToolThreadView(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreatePolygonPrism(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ResetWireOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def keyframeRegionInsertKeyCtx(*args, breakdown=True, exists=True, history=True, image1="",
                               image2="", image3="", name="", q=True, query=True, e=True,
                               edit=True, **kwargs):
    """
    This command creates a context which may be used to insert keys within the keyframe region
    of the dope sheet editor
    
    :param breakdown: (Q E) Specifies whether or not to create breakdown keys
    :type breakdown: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: Context name
    :rtype: string
    """
    pass


def dR_coordSpaceObject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dgControl(*args, **kwargs):
    """
    
    """
    pass


def HighQualityDisplay(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeRevertToDefaultTabs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowFur(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SubstituteGeometry(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GraphEditorDisableCurveSelection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSetPlaceBrushTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSetGrabBrushToolOption(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_activeHandleYZ(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def directionalLight(*args, decayRate=0, discRadius=0.0, exclusive=True, intensity=0.0, name="",
                     position=None, rgb=None, rotation=None, shadowColor=None, shadowDither=0.0,
                     shadowSamples=0, softShadow=True, useRayTraceShadows=True, q=True,
                     query=True, e=True, edit=True, **kwargs):
    """
    TlightCmd is the base class for other light commands  TnonAmbientLightCmd is a class that
    looks like a command but is not  It is a base class for the extended/nonExtended lights 
    TnonExtendedLightCmd is a base class and not a real command  It is inherited by several
    lights: TpointLight, TdirectionalLight, TspotLight etc  The directionalLight comman
    
    :param decayRate: (C) Decay rate of the light (0-no decay, 1-slow, 2-realistic, 3-fast)
    :type decayRate: int
    :param discRadius: (C Q) Radius of shadow disc
    :type discRadius: float
    :param exclusive: (C Q) True if the light is exclusively assigned
    :type exclusive: boolean
    :param intensity: (C Q) Intensity of the light
    :type intensity: float
    :param name: (C Q) Name of the light
    :type name: string
    :param position: (C Q) Position of the light
    :type position: [float, float, float]
    :param rgb: (C Q) RGB colour of the light
    :type rgb: [float, float, float]
    :param rotation: (C Q) Rotation of the light for orientation, where applicable
    :type rotation: [float, float, float]
    :param shadowColor: (C Q) Color of the light's shadow
    :type shadowColor: [float, float, float]
    :param shadowDither: (C Q) Shadow dithering value
    :type shadowDither: float
    :param shadowSamples: (C Q) Numbr of shadow samples to use
    :type shadowSamples: int
    :param softShadow: (C Q) True if soft shadowing is to be enabled
    :type softShadow: boolean
    :param useRayTraceShadows: (C Q) True if ray trace shadows are to be used
    :type useRayTraceShadows: boolean
    
    :returns: when querying the rgb or shadowColor flags
    double when querying the intensity
    flag
    boolean when querying the useRayTraceShadows or exclusive flags
    linear[] when querying
    the position flag
    angle[] when querying the rotation flag
    string when querying the name
    flag
    :rtype: double[]
    """
    pass


def artUserPaintCtx(*args, accopacity=False, activeListChangedProc="", afterStrokeCmd="",
                    alphaclamp="none", alphaclamplower=0.0, alphaclampupper=1.0,
                    attrSelected="", beforeStrokeCmd="", brushalignment=True,
                    brushfeedback=True, chunkCommand="", clamp="none", clamplower=0.0,
                    clampupper=1.0, clear=True, colorAlphaValue=0.0, colorRGBAValue=None,
                    colorRGBValue=None, colorRamp="", colorfeedback=False,
                    colorfeedbackOverride=False, colorrangelower=0.0, colorrangeupper=1.0,
                    dataTypeIndex=0, disablelighting=False, dragSlider="", duringStrokeCmd="",
                    dynclonemode=True, exists=True, expandfilename=True, exportaspectratio=0.0,
                    exportfilemode="luminance/rgb", exportfilesave="", exportfilesizex=0,
                    exportfilesizey=0, exportfiletype="", filterNodes=True, finalizeCmd="",
                    fullpaths=False, getArrayAttrCommand="", getSurfaceCommand="",
                    getValueCommand="", history=True, image1="", image2="", image3="",
                    importfileload="", importfilemode="alpha", importreassign=False,
                    initializeCmd="", interactiveUpdate=True, lastRecorderCmd="",
                    lastStampName="", lowerradius=0.0, makeStroke=0, mappressure="none",
                    maxvalue=1.0, minvalue=0.0, name="", objattrArray="", opacity=1.0,
                    outline=True, outwhilepaint=False, paintNodeArray="", paintattrselected="",
                    paintmode="screen", paintoperationtype="Paint", pickColor=True,
                    pickValue=True, playbackCursor=None, playbackPressure=0.0,
                    preserveclonesource=True, profileShapeFile="", projective=False, radius=1.0,
                    rampMaxColor=None, rampMinColor=None, record=True, reflection=False,
                    reflectionaboutorigin=True, reflectionaxis="x", screenRadius=0.0,
                    selectclonesource=True, selectedattroper="absolute",
                    setArrayValueCommand="", setValueCommand="", showactive=True,
                    stampDepth=0.0, stampProfile="", stampSpacing=1.0, strokesmooth="",
                    surfaceConformedBrushVertices=True, tablet=True, tangentOutline=True,
                    toolCleanupCmd="", toolOffProc="", toolOnProc="", toolSetupCmd="",
                    useColorRamp=True, useMaxMinColor=True, usepressure=False, value=0.0,
                    whichTool="", worldRadius=0.0, q=True, query=True, e=True, edit=True,
                    **kwargs):
    """
    This is a context command to set the flags on the artAttrContext, which is the base context
    for attribute painting operations  All commands require the name of the context as the last
    argument as this provides the name of the context to create, edit or query   This command
    executes a scriptable paint (Maya Artisan)  It allows the user to apply Mel
    
    
    :param accopacity: (C Q E) Sets opacity accumulation on/off  C: Default is false (Except
    for sculpt tool for which it is true by default)  Q: When queried, it returns a boolean
    :type accopacity: boolean
    :param activeListChangedProc: (C Q E) Accepts a string that contains a MEL command that is
    invoked whenever the active list changes  There may be some situations where the UI, for
    example
    :type activeListChangedProc: string
    :param afterStrokeCmd: (C Q E) The passed string is executed as a MEL command immediately
    after the end of a stroke  C: Default is no command  Q: When queried, it returns the curre
    :type afterStrokeCmd: string
    :param alphaclamp: (C Q E) Specifies if the weight value should be alpha clamped to the
    lower and upper bounds  There are four options here: "none" - no clamping is performed,
    :type alphaclamp: string
    :param alphaclamplower: (C Q E) Specifies the lower bound for the alpha values  C: Default
    is 0.0  Q: When queried, it returns a float
    :type alphaclamplower: float
    :param alphaclampupper: (C Q E) Specifies the upper bound for the alpha values  C: Default
    is 1.0  Q: When queried, it returns a float
    :type alphaclampupper: float
    :param attrSelected: (Q) Returns a name of the currently selected attribute  Q: When
    queried, it returns a string
    :type attrSelected: string
    :param beforeStrokeCmd: (C Q E) The passed string is executed as a MEL command immediately
    before the start of a stroke  C: Default is no command  Q: When queried, it returns the cu
    :type beforeStrokeCmd: string
    :param brushalignment: (C Q E) Specifies the path brush alignemnt  If true, the brush will
    align to stroke path, otherwise it will align to up vector  C: Default is true  Q: When q
    :type brushalignment: boolean
    :param brushfeedback: (C Q E) Specifies if the brush additional feedback should be drawn 
    C: Default is TRUE  Q: When queried, it returns a boolean
    :type brushfeedback: boolean
    :param chunkCommand: (C Q E) Specifies th name of the Mel script/procedure that is called
    once for every selected surface when a chunk is received on that surface  Q: When querie
    :type chunkCommand: string
    :param clamp: (C Q E) Specifies if the weight value should be clamped to the lower and
    upper bounds  There are four options here: "none" - no clamping is performed, "lower
    :type clamp: string
    :param clamplower: (C Q E) Specifies the lower bound for the values  C: Default is 0.0  Q:
    When queried, it returns a float
    :type clamplower: float
    :param clampupper: (C Q E) Specifies the upper bound for the values  C: Default is 1.0  Q:
    When queried, it returns a float
    :type clampupper: float
    :param clear: (C E) Floods all cvs/vertices to the current value
    :type clear: boolean
    :param colorAlphaValue: (C Q E) The Alpha value of the color
    :type colorAlphaValue: float
    :param colorRGBAValue: (C Q E) The RGBA value of the color
    :type colorRGBAValue: [float, float, float, float]
    :param colorRGBValue: (C Q E) The RGB value of the color
    :type colorRGBValue: [float, float, float]
    :param colorRamp: (C Q E) Allows a user defined color ramp to be used to map values to
    colors
    :type colorRamp: string
    :param colorfeedback: (C Q E) Sets on/off the color feedback display  C: Default is FALSE 
    Q: When queried, it returns a boolean
    :type colorfeedback: boolean
    :param colorfeedbackOverride: (C Q E) Sets on/off the color feedback override  C: Default
    is FALSE  Q: When queried, it returns a boolean
    :type colorfeedbackOverride: boolean
    :param colorrangelower: (C Q E) Specifies the value that maps to black when color feedback
    mode is on  C: Default is 0.0  Q: When queried, it returns a float
    :type colorrangelower: float
    :param colorrangeupper: (C Q E) Specifies the value that maps to the maximum color when
    color feedback mode is on  C: Default is 1.0  Q: When queried, it returns a float
    :type colorrangeupper: float
    :param dataTypeIndex: (Q E) When the selected paintable attribute is a vectorArray, it
    specifies which field to paint on
    :type dataTypeIndex: int
    :param disablelighting: (C Q E) If color feedback is on, this flag determines whether
    lighting is disabled or not for the surfaces that are affected  C: Default is FALSE  Q:
    When qu
    :type disablelighting: boolean
    :param dragSlider: (C E) Sets the current brush drag state for resizing or offsetting the
    brush (like the 'b' and 'm' default hotkeys)  The string argument is one of: "radius
    :type dragSlider: string
    :param duringStrokeCmd: (C Q E) The passed string is executed as a MEL command during the
    stroke, each time the mouse is dragged  C: Default is no command  Q: When queried, it
    retur
    :type duringStrokeCmd: string
    :param dynclonemode: (C Q E) Enable or disable dynamic clone mode
    :type dynclonemode: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param expandfilename: (C E) If true, it will expand the name of the export file and
    concatenate it with the surface name  Otherwise it will take the name as it is  C: Default
    is
    :type expandfilename: boolean
    :param exportaspectratio: (C Q E) Value of aspect ratio for export
    :type exportaspectratio: float
    :param exportfilemode: (C Q E) Specifies the export channel.The valid entries here are:
    "alpha", "luminance", "rgb", "rgba"  C: Default is "luminance/rgb"  Q: When queried, it
    retu
    :type exportfilemode: string
    :param exportfilesave: (E) Exports the attribute map and saves to a specified file
    :type exportfilesave: string
    :param exportfilesizex: (C Q E) Specifies the width of the attribute map to export  C:
    Default width is 256  Q: When queried, it returns an integer
    :type exportfilesizex: int
    :param exportfilesizey: (C Q E) Specifies the width of the attribute map to export  C:
    Default width is 256  Q: When queried, it returns an integer
    :type exportfilesizey: int
    :param exportfiletype: (C Q E) Specifies the image file format  It can be one of the
    following: "iff", "tiff", "jpeg", "alias", "rgb", "fit" "postScriptEPS", "softimage",
    "wavefron
    :type exportfiletype: string
    :param filterNodes: (E) Sets the node filter
    :type filterNodes: boolean
    :param finalizeCmd: (C Q E) Specifies the name of the Mel script/procedure that is called
    at the end of each stroke  Q: When queried, it returns a string
    :type finalizeCmd: string
    :param fullpaths: (C Q E) Specifies whether full path names should be used when surface
    names are passed to scripts  If false, just the surface name is passed  C: Default is f
    :type fullpaths: boolean
    :param getArrayAttrCommand: (C Q E) Specifies the name of the Mel script/procedure that is
    called once for every surface that is selected for painting  This procedure returns a
    string,
    :type getArrayAttrCommand: string
    :param getSurfaceCommand: (C Q E) Specifies the name of the Mel script/procedure that is
    called once for every dependency node on the selection list, whenever Artisan processes the
    se
    :type getSurfaceCommand: string
    :param getValueCommand: (C Q E) Specifies the name of the Mel script/procedure that is
    called every time a value on the surface is needed by the scriptable paint tool  Q: When
    queri
    :type getValueCommand: string
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param importfileload: (E) Load the attribute map a specified file
    :type importfileload: string
    :param importfilemode: (C Q E) Specifies the channel to import  The valid entries here are:
    "alpha", "luminance", "red", "green", "blue", and "rgb" C: Default is "alpha"  Q: When q
    :type importfilemode: string
    :param importreassign: (C Q E) Specifies if the multiply atrribute maps are to be
    reassigned while importing  Only maps previously exported from within Artisan can be
    reassigned  C
    :type importreassign: boolean
    :param initializeCmd: (C Q E) Specifies the name of the Mel script/procedure that is called
    in the beginning of each stroke  Q: When queried, it returns a string
    :type initializeCmd: string
    :param interactiveUpdate: (C Q E) Specifies how often to transfer the painted values into
    the attribute  TRUE: transfer them "continuously" (many times per stroke) FALSE: transfer
    the
    :type interactiveUpdate: boolean
    :param lastRecorderCmd: (C Q E) Value of last recorded command
    :type lastRecorderCmd: string
    :param lastStampName: (C Q E) Value of the last stamp name
    :type lastStampName: string
    :param lowerradius: (C Q E) Sets the lower size of the brush (only apply on tablet)
    :type lowerradius: float
    :param makeStroke: (C Q E M) Stroke point values
    :type makeStroke: int
    :param mappressure: (C Q E) Sets the tablet pressure mapping when the table is used  There
    are four options: "none" - the pressure has no effect, "opacity" - the pressure is map
    :type mappressure: string
    :param maxvalue: (C Q E) Specifies the maximum value for each attribute  C: Default is 1.0 
    Q: When queried, it returns a float
    :type maxvalue: float
    :param minvalue: (C Q E) Specifies the minimum value for each attribute  C: Default is 0.0 
    Q: When queried, it returns a float
    :type minvalue: float
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param objattrArray: (Q) An array of all paintable attributes  Each element of the array is
    a string with the following information: NodeType.NodeName.AttributeName.MenuType
    :type objattrArray: string
    :param opacity: (C Q E) Sets the brush opacity  C: Default is 1.0  Q: When queried, it
    returns a float
    :type opacity: float
    :param outline: (C Q E) Specifies if the brush should be drawn  C: Default is TRUE  Q: When
    queried, it returns a boolean
    :type outline: boolean
    :param outwhilepaint: (C Q E) Specifies if the brush outline should be drawn while painting
     C: Default is FALSE  Q: When queried, it returns a boolean
    :type outwhilepaint: boolean
    :param paintNodeArray: (Q) An array of paintable nodes  Q: When queried, it returns a
    string
    :type paintNodeArray: string
    :param paintattrselected: (E) An array of selected paintable attributes  Each element of
    the array is a string with the following information: NodeType.NodeName.AttributeName
    :type paintattrselected: string
    :param paintmode: (C Q E) Specifies the paint mode  There are two possibilities: "screen"
    and "tangent"  C: Default is "screen"  Q: When queried, it returns a string
    :type paintmode: string
    :param paintoperationtype: (C Q E) Specifies the operation type used by the Paint Tool 
    Currently, we support the following paint modes: "Paint", "Smear", "Blur", "Erase" and
    "Clone"
    :type paintoperationtype: string
    :param pickColor: (C Q E) Set pick color mode on or off
    :type pickColor: boolean
    :param pickValue: (C Q E) Toggle for picking
    :type pickValue: boolean
    :param playbackCursor: (C Q E M) Values for the playback cursor
    :type playbackCursor: [float, float]
    :param playbackPressure: (C Q E M) Valus for the playback pressure
    :type playbackPressure: float
    :param preserveclonesource: (C Q E) Whether or not to preserve a clone source
    :type preserveclonesource: boolean
    :param profileShapeFile: (Q E) Passes a name of the image file for the stamp shape profile
    :type profileShapeFile: string
    :param projective: (C Q E) Specifies the projective paint mode  C: Default is 'false'  Q:
    When queried, it returns a boolean
    :type projective: boolean
    :param radius: (C Q E) Sets the size of the brush  C: Default is 1.0 cm  Q: When queried,
    it returns a float
    :type radius: float
    :param rampMaxColor: (C Q E) Defines a special color to be used when the value is greater
    than or equal to the maximum value
    :type rampMaxColor: [float, float, float]
    :param rampMinColor: (C Q E) Defines a special color to be used when the value is less than
    or equal to the minimum value
    :type rampMinColor: [float, float, float]
    :param record: (C Q E) Toggle on for recording
    :type record: boolean
    :param reflection: (C Q E) Specifies the reflection mode  C: Default is 'false'  Q: When
    queried, it returns a boolean
    :type reflection: boolean
    :param reflectionaboutorigin: (C Q E) Toggle on to reflect about the origin
    :type reflectionaboutorigin: boolean
    :param reflectionaxis: (C Q E) Specifies the reflection axis  There are three
    possibilities: "x", "y" and "z"  C: Default is "x"  Q: When queried, it returns a string
    :type reflectionaxis: string
    :param screenRadius: (C Q E) Brush radius on the screen
    :type screenRadius: float
    :param selectclonesource: (C Q E) Toggle on to select the clone source
    :type selectclonesource: boolean
    :param selectedattroper: (C Q E) Sets the edit weight operation  Four edit weights
    operations are provided : "absolute" - the value of the weight is replaced by the current
    one, "add
    :type selectedattroper: string
    :param setArrayValueCommand: (C Q E) Specifies the name of the Mel script/procedure that is
    called for each paint stamp  A stamp may affect one or more values on the surface  This
    call r
    :type setArrayValueCommand: string
    :param setValueCommand: (C Q E) Specifies the name of the Mel script/procedure that is
    called every time a value on the surface is changed  Q: When queried, it returns a string
    :type setValueCommand: string
    :param showactive: (C Q E) Sets on/off the display of the surface isoparms  C: Default is
    TRUE  Q: When queried, it returns a boolean
    :type showactive: boolean
    :param stampDepth: (C Q E) Depth of the stamps
    :type stampDepth: float
    :param stampProfile: (C Q E) Sets the brush profile of the current stamp  Currently, the
    following profiles are supported: "gaussian", "poly", "solid" and "square"  C: Default is
    :type stampProfile: string
    :param stampSpacing: (C Q E) Specifies the stamp spacing  Default is 1.0
    :type stampSpacing: float
    :param strokesmooth: (C Q E) Stroke smoothing type name
    :type strokesmooth: string
    :param surfaceConformedBrushVertices: (C Q E) Enables/disables the the display of the
    effective brush area as affected vertices
    :type surfaceConformedBrushVertices: boolean
    :param tablet: (Q) Returns true if the tablet device is present, false if it is absent
    :type tablet: boolean
    :param tangentOutline: (C Q E) Enables/disables the display of the brush circle tangent to
    the surface
    :type tangentOutline: boolean
    :param toolCleanupCmd: (C Q E) Specifies the name of the Mel script/procedure that is
    called when this tool is exited  Q: When queried, it returns a string
    :type toolCleanupCmd: string
    :param toolOffProc: (C Q E) Accepts a strings describing the name of a MEL procedure that
    is invoked whenever the tool is turned off  For example, cloth invokes "clothPaintToolO
    :type toolOffProc: string
    :param toolOnProc: (C Q E) Accepts a strings describing the name of a MEL procedure that is
    invoked whenever the tool is turned on  For example, cloth invokes "clothPaintToolOn
    :type toolOnProc: string
    :param toolSetupCmd: (C Q E) Specifies the name of the Mel script/procedure that is called
    once for every selected surface when an initial click is received on that surface  Q: W
    :type toolSetupCmd: string
    :param useColorRamp: (C Q E) Specifies whether the user defined color ramp should be used
    to map values from to colors  If this is turned off, the default greyscale feedback will
    :type useColorRamp: boolean
    :param useMaxMinColor: (C Q E) Specifies whether the out of range colors should be used 
    See rampMinColor and rampMaxColor flags for further details
    :type useMaxMinColor: boolean
    :param usepressure: (C Q E) Sets the tablet pressure on/off  C: Default is false  Q: When
    queried, it returns a boolean
    :type usepressure: boolean
    :param value: (C Q E) Specifies the value for each attribute  C: Default is 0.0  Q: When
    queried, it returns a float
    :type value: float
    :param whichTool: (C Q E) The string defines the name of the tool to be used for the
    Artisan context  An example is "artClothPaint"  In query mode, the tool name for the given
    :type whichTool: string
    :param worldRadius: (C Q E) Radius in worldspace
    :type worldRadius: float
    
    :returns: The name of the context created.
    :rtype: string
    """
    pass


def CreateCameraFromView(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def mirrorJoint(*args, mirrorBehavior=True, mirrorXY=True, mirrorXZ=True, mirrorYZ=True,
                searchReplace=None, **kwargs):
    """
    This command will duplicate a branch of the skeleton from the selected joint symmetrically
    about a plane in world space  There are three mirroring modes(xy-, yz-, xz-plane)
    
    :param mirrorBehavior: (C) The mirrorBehavior flag is used to specify that when performing
    the mirror, the joint orientation axes should be mirrored such that equal rotations o
    :type mirrorBehavior: boolean
    :param mirrorXY: (C) mirror skeleton from the selected joint about xy-plane in world space
    :type mirrorXY: boolean
    :param mirrorXZ: (C) mirror skeleton from the selected joint about xz-plane in world space
    :type mirrorXZ: boolean
    :param mirrorYZ: (C) mirror skeleton from the selected joint about yz-plane in world space
    :type mirrorYZ: boolean
    :param searchReplace: (C) After performing the mirror, rename the new joints by searching
    the name for the first specified string and replacing it with the second specified st
    :type searchReplace: [string, string]
    
    :returns: Names of the mirrored joints
    :rtype: string[]
    """
    pass


def ParentConstraint(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def colorSliderGrp(*args, adjustableColumn=0, adjustableColumn2=0, adjustableColumn3=0,
                   adjustableColumn4=0, adjustableColumn5=0, adjustableColumn6=0, annotation="",
                   backgroundColor=None, changeCommand=None, columnAlign=None,
                   columnAlign2=None, columnAlign3=None, columnAlign4=None, columnAlign5=None,
                   columnAlign6=None, columnAttach=None, columnAttach2=None, columnAttach3=None,
                   columnAttach4=None, columnAttach5=None, columnAttach6=None,
                   columnOffset2=None, columnOffset3=None, columnOffset4=None,
                   columnOffset5=None, columnOffset6=None, columnWidth=None, columnWidth1=0,
                   columnWidth2=None, columnWidth3=None, columnWidth4=None, columnWidth5=None,
                   columnWidth6=None, defineTemplate="", docTag="", dragCallback=None,
                   dragCommand=None, dropCallback=None, enable=True, enableBackground=True,
                   enableKeyboardFocus=True, exists=True, forceDragRefresh=True,
                   fullPathName=True, height=0, highlightColor=None, hsvValue=None,
                   isObscured=True, label="", manage=True, noBackground=True,
                   numberOfPopupMenus=True, parent="", popupMenuArray=True,
                   preventOverride=True, rgbValue=None, rowAttach=None, statusBarMessage="",
                   useTemplate="", visible=True, visibleChangeCommand=None, width=0, q=True,
                   query=True, e=True, edit=True, **kwargs):
    """
    All of the group commands position their individual controls in columns starting at column
    1  The layout of each control (ie  column) can be customized using the -cw/columnWidth,
    -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumn flags  By
    default, columns are left aligned with no offset and are 100 pixels wide  Only o
    
    :param adjustableColumn: (C E) Specifies which column has an adjustable size that changes
    with the sizing of the layout  The column value is a 1-based index  Passing 0 as argument
    :type adjustableColumn: int
    :param adjustableColumn2: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly two columns
    :type adjustableColumn2: int
    :param adjustableColumn3: (C E) Specifies that the column has an adjustable size that
    changes with the size of the parent layout  Ignored if there are not exactly three columns
    :type adjustableColumn3: int
    :param adjustableColumn4: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly four columns
    :type adjustableColumn4: int
    :param adjustableColumn5: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly five columns
    :type adjustableColumn5: int
    :param adjustableColumn6: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly six columns
    :type adjustableColumn6: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Command string executed when slider value changes
    :type changeCommand: script
    :param columnAlign: (C E M) Arguments are : column number, alignment type  Possible
    alignments are: left | right | center  Specifies alignment type for the specified column
    :type columnAlign: [int, string]
    :param columnAlign2: (C E) Sets the text alignment of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "center"
    :type columnAlign2: [string, string]
    :param columnAlign3: (C E) Sets the text alignment for all three columns  Ignored if there
    are not exactly three columns  Valid values are "left", "right", and "center"
    :type columnAlign3: [string, string, string]
    :param columnAlign4: (C E) Sets the text alignment for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "center"
    :type columnAlign4: [string, string, string, string]
    :param columnAlign5: (C E) Sets the text alignment for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "center"
    :type columnAlign5: [string, string, string, string, string]
    :param columnAlign6: (C E) Sets the text alignment for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "center"
    :type columnAlign6: [string, string, string, string, string, string]
    :param columnAttach: (C E M) Arguments are : column number, attachment type, and offset 
    Possible attachments are: left | right | both  Specifies column attachment types and offe
    :type columnAttach: [int, string, int]
    :param columnAttach2: (C E) Sets the attachment type of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "both"
    :type columnAttach2: [string, string]
    :param columnAttach3: (C E) Sets the attachment type for all three columns  Ignored if
    there are not exactly three columns  Valid values are "left", "right", and "both"
    :type columnAttach3: [string, string, string]
    :param columnAttach4: (C E) Sets the attachment type for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "both"
    :type columnAttach4: [string, string, string, string]
    :param columnAttach5: (C E) Sets the attachment type for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "both"
    :type columnAttach5: [string, string, string, string, string]
    :param columnAttach6: (C E) Sets the attachment type for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "both"
    :type columnAttach6: [string, string, string, string, string, string]
    :param columnOffset2: (C E) This flag is used in conjunction with the -columnAttach2 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the tw
    :type columnOffset2: [int, int]
    :param columnOffset3: (C E) This flag is used in conjunction with the -columnAttach3 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the th
    :type columnOffset3: [int, int, int]
    :param columnOffset4: (C E) This flag is used in conjunction with the -columnAttach4 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fo
    :type columnOffset4: [int, int, int, int]
    :param columnOffset5: (C E) This flag is used in conjunction with the -columnAttach5 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fi
    :type columnOffset5: [int, int, int, int, int]
    :param columnOffset6: (C E) This flag is used in conjunction with the -columnAttach6 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the si
    :type columnOffset6: [int, int, int, int, int, int]
    :param columnWidth: (C E M) Arguments are : column number, column width  Sets the width of
    the specified column where the first parameter specifies the column (1 based index) an
    :type columnWidth: [int, int]
    :param columnWidth1: (C E) Sets the width of the first column  Ignored if there is not
    exactly one column
    :type columnWidth1: int
    :param columnWidth2: (C E) Sets the column widths of both columns  Ignored if there are not
    exactly two columns
    :type columnWidth2: [int, int]
    :param columnWidth3: (C E) Sets the column widths for all 3 columns  Ignored if there are
    not exactly 3 columns
    :type columnWidth3: [int, int, int]
    :param columnWidth4: (C E) Sets the column widths for all 4 columns  Ignored if there are
    not exactly 4 columns
    :type columnWidth4: [int, int, int, int]
    :param columnWidth5: (C E) Sets the column widths for all 5 columns  Ignored if there are
    not exactly 5 columns
    :type columnWidth5: [int, int, int, int, int]
    :param columnWidth6: (C E) Sets the column widths for all 6 columns  Ignored if there are
    not exactly 6 columns
    :type columnWidth6: [int, int, int, int, int, int]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dragCommand: (C E) Command string executed when slider value marker is dragged
    :type dragCommand: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param forceDragRefresh: (C Q E) If used then force refresh on drag
    :type forceDragRefresh: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param hsvValue: (C Q E) Color in hue, saturation, and value format
    :type hsvValue: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) Label text for the group
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rgbValue: (C Q E) Color in red, green, and blue format
    :type rgbValue: [float, float, float]
    :param rowAttach: (C E M) Arguments are : column, attachment type, offset  Possible
    attachments are: top | bottom | both  Specifies attachment types and offsets for the
    entire
    :type rowAttach: [int, string, int]
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def renderSettings(*args, camera="", customTokenString="", firstImageName=True, fullPath=True,
                   fullPathTemp=True, genericFrameImageName="", imageGenericName=True,
                   lastImageName=True, layer="", leaveUnmatchedTokens=True, **kwargs):
    """
    Query interface to the common tab of the render settings
    
    :param camera: (C) Specify a camera that you want to replace the current renderable camera
    :type camera: string
    :param customTokenString: (C) Specify a custom key-value string to use to replace custom
    tokens in the file name  Use with firstImageName or lastImageName  Basic tokens (Scene, La
    :type customTokenString: string
    :param firstImageName: (C) Returns the first image name
    :type firstImageName: boolean
    :param fullPath: (C) Returns the full path for the image using the current project  Use
    with firstImageName, lastImageName, or genericFrameImageName
    :type fullPath: boolean
    :param fullPathTemp: (C) Returns the full path for the preview render of the image using
    the current project  Use with firstImageName, lastImageName, or genericFrameImageName
    :type fullPathTemp: boolean
    :param genericFrameImageName: (C) Returns the generic frame image name with the custom
    specified frame index token
    :type genericFrameImageName: string
    :param imageGenericName: (C) Returns the image generic name
    :type imageGenericName: boolean
    :param lastImageName: (C) Returns the last image name
    :type lastImageName: boolean
    :param layer: (C) Specify a render layer name that you want to replace the current render
    layer
    :type layer: string
    :param leaveUnmatchedTokens: (C) Do not remove unmatched tokens from the name string  Use
    with firstImageName or lastImageName
    :type leaveUnmatchedTokens: boolean
    
    :returns: Command result
    :rtype: string[]
    """
    pass


def DisableFluids(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateNURBSCylinder(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleScalePivots(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def recordAttr(*args, attribute="", delete=True, q=True, query=True, **kwargs):
    """
    This command sets up an attribute to be recorded  When the record command is executed, any
    changes to this attribute are recorded  When recording stops these changes are turned into
    keyframes   If no attributes are specified all attributes of the node are recorded   When
    the query flag is used, a list of the attributes being recorded will be return
    
    :param attribute: (C M) specify the attribute to record
    :type attribute: string
    :param delete: (C) Do not record the specified attributes
    :type delete: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def MoveSkinJointsTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleVertices(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UVOrientShells(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportSplitAnimationIntoTakes(*args, **kwargs):
    """
    
    """
    pass


def CreateBifrostLiquid(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UseSelectedEmitter(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def addAttr(*args, attributeType="", binaryTag="", cachedInternally=True, category="",
            dataType="", defaultValue=0.0, disconnectBehaviour=0, enumName="", exists=True,
            fromPlugin=True, hasMaxValue=True, hasMinValue=True, hasSoftMaxValue=True,
            hasSoftMinValue=True, hidden=True, indexMatters=True, internalSet=True,
            keyable=True, longName="", maxValue=0.0, minValue=0.0, multi=True, niceName="",
            numberOfChildren=0, parent="", proxy="", readable=True, shortName="",
            softMaxValue=0.0, softMinValue=0.0, storable=True, usedAsColor=True,
            usedAsFilename=True, usedAsProxy=True, writable=True, q=True, query=True, e=True,
            edit=True, **kwargs):
    """
    This command is used to add a dynamic attribute to a node or nodes  Either the longName or
    the shortName or both must be specified  If neither a dataType nor an attributeType is
    specified, a double attribute will be added  The dataType flag can be specified more than
    once indicating that any of the supplied types will be accepted (logical-or)   To 
    
    :param attributeType: (C Q) Specifies the attribute type, see above table for more details 
    Note that the attribute types "float", "matrix" and "string" are also MEL keywords an
    :type attributeType: string
    :param binaryTag: (C Q) This flag is obsolete and does not do anything any more
    :type binaryTag: string
    :param cachedInternally: (C Q) Whether or not attribute data is cached internally in the
    node  This flag defaults to true for writable attributes and false for non-writable
    attribu
    :type cachedInternally: boolean
    :param category: (C Q E M) An attribute category is a string associated with the attribute
    to identify it  (e.g  the name of a plugin that created the attribute, version inform
    :type category: string
    :param dataType: (C Q M) Specifies the data type  See "setAttr" for more information on
    data type names
    :type dataType: string
    :param defaultValue: (C Q E) Specifies the default value for the attribute (can only be
    used for numeric attributes)
    :type defaultValue: float
    :param disconnectBehaviour: (C Q) defines the Disconnect Behaviour 2 Nothing, 1 Reset, 0
    Delete
    :type disconnectBehaviour: int
    :param enumName: (C Q E) Flag used to specify the ui names corresponding to the enum values
     The specified string should contain a colon-separated list of the names, with opt
    :type enumName: string
    :param exists: (C Q) Returns true if the attribute queried is a user-added, dynamic
    attribute; false if not
    :type exists: boolean
    :param fromPlugin: (C Q) Was the attribute originally created by a plugin? Normally set
    automatically when the API call is made - only added here to support storing it in a f
    :type fromPlugin: boolean
    :param hasMaxValue: (C Q E) Flag indicating whether an attribute has a maximum value  (can
    only be used for numeric attributes)
    :type hasMaxValue: boolean
    :param hasMinValue: (C Q E) Flag indicating whether an attribute has a minimum value  (can
    only be used for numeric attributes)
    :type hasMinValue: boolean
    :param hasSoftMaxValue: (C Q) Flag indicating whether a numeric attribute has a soft
    maximum
    :type hasSoftMaxValue: boolean
    :param hasSoftMinValue: (C Q) Flag indicating whether a numeric attribute has a soft
    minimum
    :type hasSoftMinValue: boolean
    :param hidden: (C Q) Will this attribute be hidden from the UI?
    :type hidden: boolean
    :param indexMatters: (C Q) Sets whether an index must be used when connecting to this
    multi-attribute  Setting indexMatters to false forces the attribute to non-readable
    :type indexMatters: boolean
    :param internalSet: (C Q) Whether or not the internal cached value is set when this
    attribute value is changed  This is an internal flag used for updating UI elements
    :type internalSet: boolean
    :param keyable: (C Q) Is the attribute keyable by default?
    :type keyable: boolean
    :param longName: (C Q) Sets the long name of the attribute
    :type longName: string
    :param maxValue: (C Q E) Specifies the maximum value for the attribute (can only be used
    for numeric attributes)
    :type maxValue: float
    :param minValue: (C Q E) Specifies the minimum value for the attribute (can only be used
    for numeric attributes)
    :type minValue: float
    :param multi: (C Q) Makes the new attribute a multi-attribute
    :type multi: boolean
    :param niceName: (C Q E) Sets the nice name of the attribute for display in the UI  Setting
    the attribute's nice name to a non-empty string overrides the default behaviour of
    :type niceName: string
    :param numberOfChildren: (C Q) How many children will the new attribute have?
    :type numberOfChildren: int
    :param parent: (C Q) Attribute that is to be the new attribute's parent
    :type parent: string
    :param proxy: (C Q) Proxy another node's attribute  Proxied plug will be connected as
    source  The UsedAsProxy flag is automatically set in this case
    :type proxy: string
    :param readable: (C Q) Can outgoing connections be made from this attribute?
    :type readable: boolean
    :param shortName: (C Q) Sets the short name of the attribute
    :type shortName: string
    :param softMaxValue: (C Q E) Soft maximum, valid for numeric attributes only  Specifies the
    upper default limit used in sliders for this attribute
    :type softMaxValue: float
    :param softMinValue: (C Q E) Soft minimum, valid for numeric attributes only  Specifies the
    upper default limit used in sliders for this attribute
    :type softMinValue: float
    :param storable: (C Q) Can the attribute be stored out to a file?
    :type storable: boolean
    :param usedAsColor: (C Q) Is the attribute to be used as a color definition? Must have 3
    DOUBLE or 3 FLOAT children to use this flag  The attribute type "-at" should be "doubl
    :type usedAsColor: boolean
    :param usedAsFilename: (C Q) Is the attribute to be treated as a filename definition? This
    flag is only supported on attributes with data type "-dt" of "string"
    :type usedAsFilename: boolean
    :param usedAsProxy: (C Q) Set if the specified attribute should be treated as a proxy to
    another attributes
    :type usedAsProxy: boolean
    :param writable: (C Q) Can incoming connections be made to this attribute?
    :type writable: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def CurlCurves(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetFullBodyIKKeys(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dbtrace(*args, filter="", info=True, keyword="", mark=True, output="", timed=True, title="",
            verbose=True, q=True, query=True, **kwargs):
    """
    The dbtrace command is used to manipulate trace objects  The keyword is the only mandatory
    argument, indicating which trace object is to be altered   Trace Objects to affect (keyword
    KEY) Optional filtering criteria (filter FILTER) Function (off, output FILE, mark, title
    TITLE, timed : default operation is to enable traces)  You can use the query m
    
    :param filter: (C Q) Set the filter object for these trace objects (see 'dgfilter')
    :type filter: string
    :param info: (Q) In query mode return a brief description of the trace object
    :type info: boolean
    :param keyword: (C Q M) Keyword of the trace objects to affect In query mode, this flag can
    accept a value
    :type keyword: string
    :param mark: (C) Display a mark for all outputs of defined trace objects
    :type mark: boolean
    :param output: (C Q) Destination file of the affected trace objects  Use the special names
    stdout and stderr to redirect to your command window  The special name msdev is
    :type output: string
    :param timed: (C Q) Turn on/off timing information in the output of the specified trace
    objects
    :type timed: boolean
    :param title: (C) Display a title mark for all outputs of defined trace objects
    :type title: string
    :param verbose: (C) Include all traces in output and filter queries, not just those turned
    on
    :type verbose: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def expressionEditorListen(*args, listenFile="", listenForAttr="", listenForExpression="",
                           listenForName="", stopListenForAttr="", stopListenForExpression="",
                           stopListenForName="", **kwargs):
    """
    Listens for messages for the Expression Editor, at its request, and communicates them to it
     This action is for internal use only and should not be called by users  This action should
    be called only by the Expression Editor
    
    :param listenFile: (C) Listen for changes to the file argument
    :type listenFile: string
    :param listenForAttr: (C) Listen for changes to the attributes of the node argument
    :type listenForAttr: string
    :param listenForExpression: (C) Listen for changes to the named expression
    :type listenForExpression: string
    :param listenForName: (C) Listen for name changes for the node argument
    :type listenForName: string
    :param stopListenForAttr: (C) Stop listening for changes to the attributes of the node
    argument
    :type stopListenForAttr: string
    :param stopListenForExpression: (C) Stop listening for changes to the named expression
    :type stopListenForExpression: string
    :param stopListenForName: (C) Stop listening for name changes for the node argument
    :type stopListenForName: string
    
    :returns: 
    :rtype: None
    """
    pass


def xgmPointRender(*args, **kwargs):
    """
    
    """
    pass


def ProfilerToolCategoryView(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def artBuildPaintMenu(*args, **kwargs):
    """
    ??
    
    
    :returns: 
    :rtype: None
    """
    pass


def sbs_GetChannelsNamesFromSubstanceNode(*args, **kwargs):
    """
    
    """
    pass


def particle(*args, attribute="", cache=True, conserve=0.0, count=True, deleteCache=True,
             dynamicAttrList=True, floatValue=0.0, gridSpacing=0.0, inherit=0.0,
             jitterBasePoint=None, jitterRadius=0.0, lowerLeft=None, name="", numJitters=0,
             order=0, particleId=0, perParticleDouble=True, perParticleVector=True,
             position=None, shapeName="", upperRight=None, vectorValue=None, q=True, query=True,
             e=True, edit=True, **kwargs):
    """
    The particle command creates a new particle object from a list of world space points  If a
    particle object is created, the command returns the names of the new particle shape and its
    associated particle object dependency node  If an object was queried, the results of the
    query are returned  Per particle attributes can be queried using the particleI
    
    :param attribute: (Q E) Used in per particle attribute query and edit  Specifies the name
    of the attribute being queried or edited  In query mode, this flag needs a value
    :type attribute: string
    :param cache: (C Q E) Turns caching on/off for the particle shape
    :type cache: boolean
    :param conserve: (Q E) Conservation of momentum control (between 0 and 1)  Specifies the
    fraction of the particle shape's existing momentum which is conserved from frame to
    :type conserve: float
    :param count: (Q) Returns the number of particles in the object
    :type count: boolean
    :param deleteCache: (C) Deletes the particle shapes cache  This command is not undoable
    :type deleteCache: boolean
    :param dynamicAttrList: (Q) Returns a list of the dynamic attributes in the object
    :type dynamicAttrList: boolean
    :param floatValue: (E) Used only in per particle attribute edit  Specifies that the edit is
    of a float attribute and must be followed by the new float value
    :type floatValue: float
    :param gridSpacing: (C Q M) Spacing between particles in the grid
    :type gridSpacing: float
    :param inherit: (Q E) Inherit this fraction (0-1) of emitting object's velocity
    :type inherit: float
    :param jitterBasePoint: (C Q M) Base point (center point) for jitters  The command will
    create one swatch of jitters for each base point  It will pair up other flags with base
    point
    :type jitterBasePoint: [float, float, float]
    :param jitterRadius: (C Q M) Max radius from the center to place the particle instances
    :type jitterRadius: float
    :param lowerLeft: (C Q M) Lower left point of grid
    :type lowerLeft: [float, float, float]
    :param name: (Q E) name of particle object
    :type name: string
    :param numJitters: (C Q M) Number of jitters (instances) per particle
    :type numJitters: int
    :param order: (Q E) Used in per particle attribute query and edit  Specifies the zero-based
    order (index) of the particle whose attribute is being queried or edited in t
    :type order: int
    :param particleId: (Q E) Used in per particle attribute query and edit  Specifies the id of
    the particle whose attribute is being queried or edited  Querying the value of a p
    :type particleId: int
    :param perParticleDouble: (Q) Returns a list of the per-particle double attributes,
    excluding initial-state, cache, and information-only attributes
    :type perParticleDouble: boolean
    :param perParticleVector: (Q) Returns a list of the per-particle vector attributes,
    excluding initial-state, cache, and information-only attributes
    :type perParticleVector: boolean
    :param position: (M) World-space position of each particle
    :type position: [float, float, float]
    :param shapeName: (Q E) Specify the shape name used for geometry instancing  DO not confuse
    this with the -n flag which names the particle object
    :type shapeName: string
    :param upperRight: (C Q M) Upper right point of grid
    :type upperRight: [float, float, float]
    :param vectorValue: (E) Used only in per particle attribute edit  Specifies that the edit
    is of a vector attribute and must be followed by all three float values for the vec
    :type vectorValue: [float, float, float]
    
    :returns: The name of the particle object created
    :rtype: string
    """
    pass


def CreateLocator(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateBindingSet(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FlowPathObject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def plane(*args, length=0.0, name="", position=None, rotation=None, size=0.0, width=0.0,
          **kwargs):
    """
    The command creates a sketch plane (also known as a "construction plane") in space  To
    create an object (such as a NURBS curve, joint chain or polygon) on a construction plane,
    you need to first make the plane live  See also the makeLive command
    
    :param length: (C) The length of plane  "linear" means that this flag can handle values
    with units
    :type length: float
    :param name: (C) Name the resulting object
    :type name: string
    :param position: (C) 3D position where the centre of the plane is positioned  "linear"
    means that this flag can handle values with units
    :type position: [float, float, float]
    :param rotation: (C) The rotation of plane  "angle" means that this flag can handle values
    with units
    :type rotation: [float, float, float]
    :param size: (C) The combined size (size x size) of plane  "linear" means that this flag
    can handle values with units
    :type size: float
    :param width: (C) The width of plane  "linear" means that this flag can handle values with
    units
    :type width: float
    
    :returns: (name of the new plane)
    :rtype: string
    """
    pass


def meshRemapContext(*args, **kwargs):
    """
    
    """
    pass


def DeleteAllLattices(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ogsdebug(*args, **kwargs):
    """
    
    """
    pass


def IncreaseExposureFine(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GraphEditorEnableCurveSelection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nexQuadDrawCtx(*args, **kwargs):
    """
    
    """
    pass


def PoleVectorConstraint(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetActiveKey(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ModifyConstraintAxis(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ComponentEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UnpublishChildAnchor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SnapToMeshCenter(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GeometryToBoundingBoxOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorShowAllAttrs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BreakRigidBodyConnection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def picture(*args, annotation="", backgroundColor=None, defineTemplate="", docTag="",
            dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
            enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
            highlightColor=None, image="", isObscured=True, manage=True, noBackground=True,
            numberOfPopupMenus=True, parent="", popupMenuArray=True, preventOverride=True,
            statusBarMessage="", tile=True, useTemplate="", visible=True,
            visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
            **kwargs):
    """
    This command creates a static image
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param image: (C Q E) Sets the image given the .xpm file name
    :type image: string
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param tile: (C Q E) If true, the picture is tiled to fill the picture area  False by
    default  (Windows only flag)
    :type tile: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the picture control created.
    :rtype: string
    """
    pass


def SelectAllNRigids(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def windowPref(*args, enableAll=True, exists=True, height=0, leftEdge=0, loadAll=True,
               maximized=True, parentMain=True, remove=True, removeAll=True,
               restoreMainWindowState="", saveAll=True, saveMainWindowState="", topEdge=0,
               topLeftCorner=None, width=0, widthHeight=None, q=True, query=True, e=True,
               edit=True, **kwargs):
    """
    Create or modify preferred window attributes  The size and position of a window is retained
    during and between application sessions  A default window preference is created when a
    window is closed  Window preferences must be named and, consequently, only affect the
    window with a matching name   Note that window preferences are not applied to the mai
    
    :param enableAll: (C Q) Enable/disable all window preferences  Preferences are enabled by
    default  Set this flag to false and window's will ignore all preference values
    :type enableAll: boolean
    :param exists: (C) Returns true|false depending upon whether the specified object exists 
    Other flags are ignored
    :type exists: boolean
    :param height: (C Q E) Height of the window
    :type height: int
    :param leftEdge: (C Q E) Left edge position of the window
    :type leftEdge: int
    :param loadAll: (C) Reads in file with window attributes from disk
    :type loadAll: boolean
    :param maximized: (C Q E) Maximize the window
    :type maximized: boolean
    :param parentMain: (C Q) Set whether window is parented to main application window  Windows
    only
    :type parentMain: boolean
    :param remove: (C) Remove a window preference
    :type remove: boolean
    :param removeAll: (C) Remove all window preferences
    :type removeAll: boolean
    :param restoreMainWindowState: (C) Reads in file with main window state (positions of
    toolbars and dock controls)
    :type restoreMainWindowState: string
    :param saveAll: (C) Writes out file with window attributes
    :type saveAll: boolean
    :param saveMainWindowState: (C) Writes out file with main window state (positions of
    toolbars and dock controls)
    :type saveMainWindowState: string
    :param topEdge: (C Q E) Top edge position of the window
    :type topEdge: int
    :param topLeftCorner: (C Q E) Top and left edge position of the window
    :type topLeftCorner: [int, int]
    :param width: (C Q E) Width of the window
    :type width: int
    :param widthHeight: (C Q E) Width and height of the window
    :type widthHeight: [int, int]
    
    :returns: 
    :rtype: None
    """
    pass


def dR_selConstraintEdgeRing(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def editRenderLayerAdjustment(*args, attributeLog=True, layer=None, nodeLog=True, remove=True,
                              q=True, query=True, **kwargs):
    """
    This command is used to create, edit, and query adjustments to render layers  An adjustment
    allows different attribute values or connections to be used depending on the active render
    layer
    
    :param attributeLog: (Q) Output all adjustments for the specified layer sorted by attribute
    name
    :type attributeLog: boolean
    :param layer: (C Q) Specified layer in which the adjustments will be modified  If not
    specified the active render layer will be used
    :type layer: name
    :param nodeLog: (Q) Output all adjustments for the specified layer sorted by node name
    :type nodeLog: boolean
    :param remove: (C) Remove the specified adjustments from the render layer  If an adjustment
    is removed from the current layer, the specified plug will revert back to it
    :type remove: boolean
    
    :returns: Number of adjustments applied
    :rtype: int
    """
    pass


def RemoveFromContainer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmRebuildSplineDescription(*args, **kwargs):
    """
    
    """
    pass


def refresh(*args, currentView=True, fileExtension="", filename="", force=True, suspend=True,
            **kwargs):
    """
    This command is used to force a redraw during script execution  Normally, redraw is
    suspended while scripts are executing but sometimes it is useful to show intermediate
    results for purposes such as capturing images from the screen   If the -cv flag is
    specified, then only the current active view is redrawn
    
    :param currentView: (C) Redraw only the current view (default redraws all views)
    :type currentView: boolean
    :param fileExtension: (C) Specify the type of file to save using the filename flag
    :type fileExtension: string
    :param filename: (C) Specify the name of a file in which to save a snapshot of the
    viewports, or just the current one if the currentView flag is set
    :type filename: string
    :param force: (C) Force the refresh regardless of the state of the model
    :type force: boolean
    :param suspend: (C) Suspends or resumes Maya's handling of refresh events  Specify "on" to
    suspend refreshing, and "off" to resume refreshing  Note that resuming refresh
    :type suspend: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def DisplayLayerEditorWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolygonCollapseEdges(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def optionMenuGrp(*args, adjustableColumn=0, adjustableColumn2=0, adjustableColumn3=0,
                  adjustableColumn4=0, adjustableColumn5=0, adjustableColumn6=0, annotation="",
                  backgroundColor=None, changeCommand=None, columnAlign=None, columnAlign2=None,
                  columnAlign3=None, columnAlign4=None, columnAlign5=None, columnAlign6=None,
                  columnAttach=None, columnAttach2=None, columnAttach3=None, columnAttach4=None,
                  columnAttach5=None, columnAttach6=None, columnOffset2=None,
                  columnOffset3=None, columnOffset4=None, columnOffset5=None,
                  columnOffset6=None, columnWidth=None, columnWidth1=0, columnWidth2=None,
                  columnWidth3=None, columnWidth4=None, columnWidth5=None, columnWidth6=None,
                  defineTemplate="", docTag="", dragCallback=None, dropCallback=None,
                  enable=True, enableBackground=True, enableKeyboardFocus=True, exists=True,
                  extraLabel="", fullPathName=True, height=0, highlightColor=None,
                  isObscured=True, itemListLong=True, itemListShort=True, label="", manage=True,
                  noBackground=True, numberOfItems=True, numberOfPopupMenus=True, parent="",
                  popupMenuArray=True, preventOverride=True, rowAttach=None, select=0,
                  statusBarMessage="", useTemplate="", value="", visible=True,
                  visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
                  **kwargs):
    """
    All of the group commands position their individual controls in columns starting at column
    1  The layout of each control (ie  column) can be customized using the -cw/columnWidth,
    -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumn flags  By
    default, columns are left aligned with no offset and are 100 pixels wide  Only o
    
    :param adjustableColumn: (C E) Specifies which column has an adjustable size that changes
    with the sizing of the layout  The column value is a 1-based index  Passing 0 as argument
    :type adjustableColumn: int
    :param adjustableColumn2: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly two columns
    :type adjustableColumn2: int
    :param adjustableColumn3: (C E) Specifies that the column has an adjustable size that
    changes with the size of the parent layout  Ignored if there are not exactly three columns
    :type adjustableColumn3: int
    :param adjustableColumn4: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly four columns
    :type adjustableColumn4: int
    :param adjustableColumn5: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly five columns
    :type adjustableColumn5: int
    :param adjustableColumn6: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly six columns
    :type adjustableColumn6: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Command executed when a new item is selected
    :type changeCommand: script
    :param columnAlign: (C E M) Arguments are : column number, alignment type  Possible
    alignments are: left | right | center  Specifies alignment type for the specified column
    :type columnAlign: [int, string]
    :param columnAlign2: (C E) Sets the text alignment of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "center"
    :type columnAlign2: [string, string]
    :param columnAlign3: (C E) Sets the text alignment for all three columns  Ignored if there
    are not exactly three columns  Valid values are "left", "right", and "center"
    :type columnAlign3: [string, string, string]
    :param columnAlign4: (C E) Sets the text alignment for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "center"
    :type columnAlign4: [string, string, string, string]
    :param columnAlign5: (C E) Sets the text alignment for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "center"
    :type columnAlign5: [string, string, string, string, string]
    :param columnAlign6: (C E) Sets the text alignment for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "center"
    :type columnAlign6: [string, string, string, string, string, string]
    :param columnAttach: (C E M) Arguments are : column number, attachment type, and offset 
    Possible attachments are: left | right | both  Specifies column attachment types and offe
    :type columnAttach: [int, string, int]
    :param columnAttach2: (C E) Sets the attachment type of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "both"
    :type columnAttach2: [string, string]
    :param columnAttach3: (C E) Sets the attachment type for all three columns  Ignored if
    there are not exactly three columns  Valid values are "left", "right", and "both"
    :type columnAttach3: [string, string, string]
    :param columnAttach4: (C E) Sets the attachment type for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "both"
    :type columnAttach4: [string, string, string, string]
    :param columnAttach5: (C E) Sets the attachment type for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "both"
    :type columnAttach5: [string, string, string, string, string]
    :param columnAttach6: (C E) Sets the attachment type for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "both"
    :type columnAttach6: [string, string, string, string, string, string]
    :param columnOffset2: (C E) This flag is used in conjunction with the -columnAttach2 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the tw
    :type columnOffset2: [int, int]
    :param columnOffset3: (C E) This flag is used in conjunction with the -columnAttach3 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the th
    :type columnOffset3: [int, int, int]
    :param columnOffset4: (C E) This flag is used in conjunction with the -columnAttach4 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fo
    :type columnOffset4: [int, int, int, int]
    :param columnOffset5: (C E) This flag is used in conjunction with the -columnAttach5 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fi
    :type columnOffset5: [int, int, int, int, int]
    :param columnOffset6: (C E) This flag is used in conjunction with the -columnAttach6 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the si
    :type columnOffset6: [int, int, int, int, int, int]
    :param columnWidth: (C E M) Arguments are : column number, column width  Sets the width of
    the specified column where the first parameter specifies the column (1 based index) an
    :type columnWidth: [int, int]
    :param columnWidth1: (C E) Sets the width of the first column  Ignored if there is not
    exactly one column
    :type columnWidth1: int
    :param columnWidth2: (C E) Sets the column widths of both columns  Ignored if there are not
    exactly two columns
    :type columnWidth2: [int, int]
    :param columnWidth3: (C E) Sets the column widths for all 3 columns  Ignored if there are
    not exactly 3 columns
    :type columnWidth3: [int, int, int]
    :param columnWidth4: (C E) Sets the column widths for all 4 columns  Ignored if there are
    not exactly 4 columns
    :type columnWidth4: [int, int, int, int]
    :param columnWidth5: (C E) Sets the column widths for all 5 columns  Ignored if there are
    not exactly 5 columns
    :type columnWidth5: [int, int, int, int, int]
    :param columnWidth6: (C E) Sets the column widths for all 6 columns  Ignored if there are
    not exactly 6 columns
    :type columnWidth6: [int, int, int, int, int, int]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param extraLabel: (C Q E) If present on creation this specifies that there will be an
    extra label to the right of the option menu  Sets the string to be the extra label text
    :type extraLabel: string
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param itemListLong: (Q) Returns the long names of the items
    :type itemListLong: boolean
    :param itemListShort: (Q) Returns the short names of the items
    :type itemListShort: boolean
    :param label: (C Q E) If present on creation this specifies that there will be a label to
    the left of the option menu  Sets the string to be the label text
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfItems: (Q) Returns the number of items
    :type numberOfItems: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rowAttach: (C E M) Arguments are : column, attachment type, offset  Possible
    attachments are: top | bottom | both  Specifies attachment types and offsets for the
    entire
    :type rowAttach: [int, string, int]
    :param select: (C Q E) Selects an item by index  The first item is 1
    :type select: int
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param value: (C Q E) Select an item by value  Also, returns the text of the currently
    selected item
    :type value: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The full name of the control on creation.
    :rtype: string
    """
    pass


def polyUnite(*args, caching=True, mergeUVSets=1, nodeState=0, centerPivot=True,
              objectPivot=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a new poly as an union of a list of polys If no objects are specified
    in the command line, then the objects from the active list are used
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param mergeUVSets: (C) Specify how UV sets will be merged on the output mesh  The choices
    are 0 | 1 | 2  0 = Do not merge  Each UV set on each mesh will become a new UV set
    :type mergeUVSets: int
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param centerPivot: (C) Set the resulting object's pivot to the center of the selected
    objects bounding box
    :type centerPivot: boolean
    :param objectPivot: (C) Set the resulting object's pivot to last selected object's pivot
    :type objectPivot: boolean
    
    :returns: Object name and node name.
    :rtype: string[]
    """
    pass


def SubdivSmoothnessRough(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def animCurveEditor(*args, areCurvesSelected=True, autoFit="", autoFitTime="", classicMode=True,
                    clipTime="", constrainDrag=0, control=True, curvesShown=True,
                    curvesShownForceUpdate=True, defineTemplate="", denormalizeCurvesCommand="",
                    displayActiveKeyTangents="", displayActiveKeys="", displayInfinities="",
                    displayKeys="", displayNormalized=True, displayTangents="",
                    displayValues="", docTag="", exists=True, filter="", forceMainConnection="",
                    highlightConnection="", keyingTime="", lockMainConnection=True, lookAt="",
                    mainListConnection="", menu=None, normalizeCurvesCommand="", outliner="",
                    panel="", parent="", preSelectionHighlight=True, renormalizeCurves=True,
                    resultSamples=None, resultScreenSamples=0, resultUpdate="",
                    selectionConnection="", showActiveCurveNames=True, showBufferCurves="",
                    showCurveNames=True, showResults="", showUpstreamCurves=True, smoothness="",
                    snapTime="", snapValue="", stackedCurves=True, stackedCurvesMax=0.0,
                    stackedCurvesMin=0.0, stackedCurvesSpace=0.0, stateString=True,
                    unParent=True, unlockMainConnection=True, updateMainConnection=True,
                    useTemplate="", valueLinesToggle="", q=True, query=True, e=True, edit=True,
                    **kwargs):
    """
    Edit a characteristic of a graph editor
    
    :param areCurvesSelected: (Q) Returns a boolean to know if at least one curve is selected
    in the graph editor
    :type areCurvesSelected: boolean
    :param autoFit: (Q E) on | off | tgl Auto fit-to-view
    :type autoFit: string
    :param autoFitTime: (Q E) on | off | tgl Auto fit-to-view along the time axis, as well
    :type autoFitTime: string
    :param classicMode: (Q E) When on, the graph editor is displayed in "Classic Mode",
    otherwise "Suites Mode" is used
    :type classicMode: boolean
    :param clipTime: (Q E) Valid values: "on" "off" Display the clips with their offset and
    scale applied to the anim curves in the clip
    :type clipTime: string
    :param constrainDrag: (C Q E) Constrains all Graph Editor animation curve drag operations
    to either the X-axis, the Y-axis, or to neither of those axes  Values to supply are: 0 fo
    :type constrainDrag: int
    :param control: (Q) Query only  Returns the top level control for this editor  Usually used
    for getting a parent to attach popup menus  Caution: It is possible for an ed
    :type control: boolean
    :param curvesShown: (Q) Returns a string array containing the names of the animCurve nodes
    currently displayed in the graph editor
    :type curvesShown: boolean
    :param curvesShownForceUpdate: (Q) Returns a string array containing the names of the
    animCurve nodes currently displayed in the graph editor  Unlike the curvesShown flag, this
    will fo
    :type curvesShownForceUpdate: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param denormalizeCurvesCommand: (C E) Sets the script that is run to denormalize curves in
    the graph editor  This is intended for internal use only
    :type denormalizeCurvesCommand: string
    :param displayActiveKeyTangents: (E) on | off | tgl Display active key tangents in the
    editor
    :type displayActiveKeyTangents: string
    :param displayActiveKeys: (E) on | off | tgl Display active keys in the editor
    :type displayActiveKeys: string
    :param displayInfinities: (E) on | off | tgl Display infinities in the editor
    :type displayInfinities: string
    :param displayKeys: (E) on | off | tgl Display keyframes in the editor
    :type displayKeys: string
    :param displayNormalized: (Q E) When on, display all curves normalized to the range -1 to
    +1
    :type displayNormalized: boolean
    :param displayTangents: (E) on | off | tgl Display tangents in the editor
    :type displayTangents: string
    :param displayValues: (E) on | off | tgl Display active keys and tangents values in the
    editor
    :type displayValues: string
    :param docTag: (C Q E) Attaches a tag to the editor
    :type docTag: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param filter: (C Q E) Specifies the name of an itemFilter object to be used with this
    editor  This filters the information coming onto the main list of the editor
    :type filter: string
    :param forceMainConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type forceMainConnection: string
    :param highlightConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its highlight list  Not all editors have a highlight list 
    F
    :type highlightConnection: string
    :param keyingTime: (Q) The current time in the given curve to be keyed in the graph editor
    :type keyingTime: string
    :param lockMainConnection: (C E) Locks the current list of objects within the
    mainConnection, so that only those objects are displayed within the editor  Further changes
    to the origi
    :type lockMainConnection: boolean
    :param lookAt: (E) all | selected | currentTime FitView helpers
    :type lookAt: string
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type mainListConnection: string
    :param menu: (C) Specify a script to be run when the editor is created  The function will
    be passed one string argument which is the new editor's name
    :type menu: script
    :param normalizeCurvesCommand: (C E) Sets the script that is run to normalize curves in the
    graph editor  This is intended for internal use only
    :type normalizeCurvesCommand: string
    :param outliner: (Q E) The name of the outliner that is associated with the graph editor
    :type outliner: string
    :param panel: (C Q) Specifies the panel for this editor  By default if an editor is created
    in the create callback of a scripted panel it will belong to that panel  If a
    :type panel: string
    :param parent: (C Q E) Specifies the parent layout for this editor  This flag will only
    have an effect if the editor is currently un-parented
    :type parent: string
    :param preSelectionHighlight: (Q E) When on, the curve/key/tangent under the mouse pointer
    is highlighted to ease selection
    :type preSelectionHighlight: boolean
    :param renormalizeCurves: (E) This flag causes the curve normalization factors to be
    recalculated
    :type renormalizeCurves: boolean
    :param resultSamples: (Q E) Specify the sampling for result curves Note: the smaller this
    number is, the longer it will take to update the display
    :type resultSamples: time
    :param resultScreenSamples: (Q E) Specify the screen base result sampling for result curves
     If 0, then results are sampled in time
    :type resultScreenSamples: int
    :param resultUpdate: (Q E) Valid values: "interactive" "delayed" Controls how changes to
    animCurves are reflected in the result curves (if results are being shown)  If resultUp
    :type resultUpdate: string
    :param selectionConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its own selection list  As the user selects things in this
    e
    :type selectionConnection: string
    :param showActiveCurveNames: (Q E) Display the active curve(s)'s name
    :type showActiveCurveNames: boolean
    :param showBufferCurves: (Q E) Valid values: "on" "off" "tgl" Display buffer curves
    :type showBufferCurves: string
    :param showCurveNames: (Q E) Display the curves's name
    :type showCurveNames: boolean
    :param showResults: (Q E) Valid values: "on" "off" "tgl" Display result curves from
    expression or other non-keyed action
    :type showResults: string
    :param showUpstreamCurves: (Q E) If true, the dependency graph is searched upstream for all
    curves that drive the selected plugs (showing multiple curves for example in a typical dri
    :type showUpstreamCurves: boolean
    :param smoothness: (Q E) Valid values: "coarse" "rough" "medium" "fine" Specify the display
    smoothness of animation curves
    :type smoothness: string
    :param snapTime: (Q E) none | integer | keyframe Keyframe move snap in time
    :type snapTime: string
    :param snapValue: (Q E) none | integer | keyframe Keyframe move snap in values
    :type snapValue: string
    :param stackedCurves: (Q E) Switches the display mode between normal (all curves sharing
    one set of axes) to stacked (each curve on its own value axis, stacked vertically)
    :type stackedCurves: boolean
    :param stackedCurvesMax: (Q E) Sets the maximum value on the per-curve value axis when in
    stacked mode
    :type stackedCurvesMax: float
    :param stackedCurvesMin: (Q E) Sets the minimum value on the per-curve value axis when in
    stacked mode
    :type stackedCurvesMin: float
    :param stackedCurvesSpace: (Q E) Sets the spacing between curves when in stacked mode
    :type stackedCurvesSpace: float
    :param stateString: (Q) Query only flag  Returns the MEL command that will create an editor
    to match the current editor state  The returned command string uses the string va
    :type stateString: boolean
    :param unParent: (C E) Specifies that the editor should be removed from its layout  This
    cannot be used in query mode
    :type unParent: boolean
    :param unlockMainConnection: (C E) Unlocks the mainConnection, effectively restoring the
    original mainConnection (if it is still available), and dynamic updates
    :type unlockMainConnection: boolean
    :param updateMainConnection: (C E) Causes a locked mainConnection to be updated from the
    orginal mainConnection, but preserves the lock state
    :type updateMainConnection: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param valueLinesToggle: (E) on | off | tgl Display the value lines for high/low/zero of
    selected curves in the editor
    :type valueLinesToggle: string
    
    :returns: Editor name
    :rtype: string
    """
    pass


def NodeEditorGraphUpDownstream(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSetCombBrushToolOption(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ReverseSurfaceDirectionOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def contentBrowser(*args, addContentPath="", context=None, control=True, defineTemplate="",
                   docTag="", exists=True, filter="", forceMainConnection="",
                   highlightConnection="", location="", lockMainConnection=True,
                   mainListConnection="", panel="", parent="", preview=True,
                   refreshTreeView=True, removeContentPath="", saveCurrentContext=True,
                   selectionConnection="", stateString=True, thumbnailView=True, treeView=True,
                   unParent=True, unlockMainConnection=True, updateMainConnection=True,
                   useTemplate="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command is used to edit and query a Content Browser  The Content Browser is a unique
    panel, so only one instance of it can exist at a given time  The optional argument is the
    name of the control
    
    :param addContentPath: (E) Adds the given path(s) to the libraries displayed on the
    Examples tab  Also updates the corresponding MAYA_CONTENT_PATH environment variable
    :type addContentPath: string
    :param context: (Q E) Sets the default location for the given context  The two optional
    arguments (Python only) are the category (tab) and location  To clear the content u
    :type context: [string, [, string, ], [, string, ]]
    :param control: (Q) Query only  Returns the top level control for this editor  Usually used
    for getting a parent to attach popup menus  Caution: It is possible for an ed
    :type control: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Attaches a tag to the editor
    :type docTag: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param filter: (C Q E) Specifies the name of an itemFilter object to be used with this
    editor  This filters the information coming onto the main list of the editor
    :type filter: string
    :param forceMainConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type forceMainConnection: string
    :param highlightConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its highlight list  Not all editors have a highlight list 
    F
    :type highlightConnection: string
    :param location: (E) Switches to the Examples tab and selects the given library location
    :type location: string
    :param lockMainConnection: (C E) Locks the current list of objects within the
    mainConnection, so that only those objects are displayed within the editor  Further changes
    to the origi
    :type lockMainConnection: boolean
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type mainListConnection: string
    :param panel: (C Q) Specifies the panel for this editor  By default if an editor is created
    in the create callback of a scripted panel it will belong to that panel  If a
    :type panel: string
    :param parent: (C Q E) Specifies the parent layout for this editor  This flag will only
    have an effect if the editor is currently un-parented
    :type parent: string
    :param preview: (E) Shows / hides the preview panel  Note: this flag will not affect the
    currently opened Content Browser, but only any subsequently opened ones
    :type preview: boolean
    :param refreshTreeView: (E) Forces a refresh of the Examples tab tree view pane
    :type refreshTreeView: boolean
    :param removeContentPath: (E) Removes the given path(s) from the libraries displayed on the
    Examples tab  Also updates the corresponding MAYA_CONTENT_PATH environment variable
    :type removeContentPath: string
    :param saveCurrentContext: (E) Saves the context for the current Content Browser tab
    :type saveCurrentContext: boolean
    :param selectionConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its own selection list  As the user selects things in this
    e
    :type selectionConnection: string
    :param stateString: (Q) Query only flag  Returns the MEL command that will create an editor
    to match the current editor state  The returned command string uses the string va
    :type stateString: boolean
    :param thumbnailView: (E) Shows / hides the thumbnail panel  Note: this flag will not
    affect the currently opened Content Browser, but only any subsequently opened ones
    :type thumbnailView: boolean
    :param treeView: (E) Shows / hides the tree view panel  Note: this flag will not affect the
    currently opened Content Browser, but only any subsequently opened ones
    :type treeView: boolean
    :param unParent: (C E) Specifies that the editor should be removed from its layout  This
    cannot be used in query mode
    :type unParent: boolean
    :param unlockMainConnection: (C E) Unlocks the mainConnection, effectively restoring the
    original mainConnection (if it is still available), and dynamic updates
    :type unlockMainConnection: boolean
    :param updateMainConnection: (C E) Causes a locked mainConnection to be updated from the
    orginal mainConnection, but preserves the lock state
    :type updateMainConnection: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: The name of the panel
    :rtype: string
    """
    pass


def Birail2(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Birail3(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Birail1(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportInstances(*args, **kwargs):
    """
    
    """
    pass


def frameBufferName(*args, autoTruncate=True, camera="", renderLayer="", renderPass="",
                    **kwargs):
    """
    Returns the frame buffer name for a given renderPass renderLayer and camera combination 
    Optionally, this command can apply a name truncation algorithm so that the frameBuffer name
    will respect the maximum length imposed by the destination file format, if applicable
    
    :param autoTruncate: (C) use this flag to apply a name truncation algorithm so that the
    frameBuffer name will respect the maximum length imposed by the destination file forma
    :type autoTruncate: boolean
    :param camera: (C) Specify a camera
    :type camera: string
    :param renderLayer: (C) Specify a renderer layer
    :type renderLayer: string
    :param renderPass: (C) Specify a renderer pass
    :type renderPass: string
    
    :returns: Command result
    :rtype: string
    """
    pass


def SequenceEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HIKPinRotate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nClothDeleteHistoryOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_gridSnapRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UVStraightenOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectVertexFaceMask(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def notifyPostUndo(*args, **kwargs):
    """
    
    """
    pass


def PaintReduceWeightsTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyMoveFacet(*args, attraction=0.0, caching=True, constructionHistory=True, gain=1.0,
                  gravity=None, gravityX=0.0, gravityY=0.0, gravityZ=0.0, localCenter=0,
                  localDirection=None, localDirectionX=0.0, localDirectionY=0.0,
                  localDirectionZ=0.0, localRotate=None, localRotateX=0.0, localRotateY=0.0,
                  localRotateZ=0.0, localScale=None, localScaleX=0.0, localScaleY=0.0,
                  localScaleZ=0.0, localTranslate=None, localTranslateX=0.0,
                  localTranslateY=0.0, localTranslateZ=0.0, magnX=0.0, magnY=0.0, magnZ=0.0,
                  magnet=None, name="", nodeState=0, offset=0.0, pivot=None, pivotX=0.0,
                  pivotY=0.0, pivotZ=0.0, random=0.0, rotate=None, rotateX=0.0, rotateY=0.0,
                  rotateZ=0.0, scale=None, scaleX=0.0, scaleY=0.0, scaleZ=0.0, translate=None,
                  translateX=0.0, translateY=0.0, translateZ=0.0, weight=0.0, worldSpace=True,
                  q=True, query=True, e=True, edit=True, **kwargs):
    """
    Modifies facet of a polygonal object  Translate, move, rotate or scale facets
    
    :param attraction: (C Q E) Attraction, related to magnet  The range is [-2.0, 2.0] 
    Default: 0.0
    :type attraction: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param gain: (C Q E M) Gain factor per component  Can be painted using Artisan  Default:
    1.0
    :type gain: float
    :param gravity: (C Q E) The gravity vector  Default: 0.0, -1.0, 0.0
    :type gravity: [float, float, float]
    :param gravityX: (C Q E) Gravity X coord
    :type gravityX: float
    :param gravityY: (C Q E) Gravity Y coord
    :type gravityY: float
    :param gravityZ: (C Q E) Gravity Z coord
    :type gravityZ: float
    :param localCenter: (C Q E) Local center on the edge : 0=Middle point, 1=Start point, 2=End
    point  Default: 0
    :type localCenter: int
    :param localDirection: (C Q E) Direction to determine X axis for local space  Default: 1.0,
    0.0, 0.0
    :type localDirection: [float, float, float]
    :param localDirectionX: (C Q E) X coord of the X axis
    :type localDirectionX: float
    :param localDirectionY: (C Q E) Y coord of the X axis
    :type localDirectionY: float
    :param localDirectionZ: (C Q E) Z coord of the X axis
    :type localDirectionZ: float
    :param localRotate: (C Q E) The local rotations  Default: 0.0, 0.0, 0.0
    :type localRotate: [float, float, float]
    :param localRotateX: (C Q E) Local rotate X coord  The range is [0, 360]
    :type localRotateX: float
    :param localRotateY: (C Q E) Local rotate Y coord  The range is [0, 360]
    :type localRotateY: float
    :param localRotateZ: (C Q E) Local rotate Z coord : Rotation along the normal  The range is
    [0, 360]
    :type localRotateZ: float
    :param localScale: (C Q E) Local Scale  Default: 1.0, 1.0, 1.0
    :type localScale: [float, float, float]
    :param localScaleX: (C Q E) Scale X coord
    :type localScaleX: float
    :param localScaleY: (C Q E) Scale Y coord
    :type localScaleY: float
    :param localScaleZ: (C Q E) Scale Z coord
    :type localScaleZ: float
    :param localTranslate: (C Q E) Local translate  Default: 0.0, 0.0, 0.0
    :type localTranslate: [float, float, float]
    :param localTranslateX: (C Q E) Local translation X coord
    :type localTranslateX: float
    :param localTranslateY: (C Q E) Local translation Y coord
    :type localTranslateY: float
    :param localTranslateZ: (C Q E) Local translation Z coord : Move along the normal
    :type localTranslateZ: float
    :param magnX: (C Q E) Magnet X coord
    :type magnX: float
    :param magnY: (C Q E) Magnet Y coord
    :type magnY: float
    :param magnZ: (C Q E) Magnet Z coord
    :type magnZ: float
    :param magnet: (C Q E) The magnet vector  Default: 0.0, 0.0, 0.0
    :type magnet: [float, float, float]
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param offset: (C Q E) Local offset  Faces are moved this distance towards the inside of
    the face  Default: 0.0
    :type offset: float
    :param pivot: (C Q E) The pivot for scaling and rotation  Default: 0.0, 0.0, 0.0
    :type pivot: [float, float, float]
    :param pivotX: (C Q E) Pivot X coord
    :type pivotX: float
    :param pivotY: (C Q E) Pivot Y coord
    :type pivotY: float
    :param pivotZ: (C Q E) Pivot Z coord
    :type pivotZ: float
    :param random: (C Q E) Random value for all parameters  Default: 0.0
    :type random: float
    :param rotate: (C Q E) Rotation angles around X, Y, Z  Default: 0.0, 0.0, 0.0
    :type rotate: [float, float, float]
    :param rotateX: (C Q E) Rotation angle around X
    :type rotateX: float
    :param rotateY: (C Q E) Rotation angle around Y
    :type rotateY: float
    :param rotateZ: (C Q E) Rotation angle around Z
    :type rotateZ: float
    :param scale: (C Q E) Scaling vector  Default: 1.0, 1.0, 1.0
    :type scale: [float, float, float]
    :param scaleX: (C Q E) Scale X coord
    :type scaleX: float
    :param scaleY: (C Q E) Scale Y coord
    :type scaleY: float
    :param scaleZ: (C Q E) Scale Z coord
    :type scaleZ: float
    :param translate: (C Q E) Translation vector  Default: 0.0, 0.0, 0.0
    :type translate: [float, float, float]
    :param translateX: (C Q E) Translation X coord
    :type translateX: float
    :param translateY: (C Q E) Translation Y coord
    :type translateY: float
    :param translateZ: (C Q E) Translation Z coord
    :type translateZ: float
    :param weight: (C Q E) The weight, related to gravity  Default: 0.0
    :type weight: float
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def getModulePath(*args, moduleName="", **kwargs):
    """
    Returns the module path for a given module name
    
    :param moduleName: (C) The name of the module whose path you want to retrieve
    :type moduleName: string
    
    :returns: Command result
    :rtype: string
    """
    pass


def SplitUV(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DisplayLight(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_customPivotToolRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DuplicateNURBSPatches(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeFrameSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def panelHistory(*args, back=True, clear=True, defineTemplate="", exists=True, forward=True,
                 historyDepth=0, isEmpty=True, suspend=True, targetPane="", useTemplate="",
                 wrap=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a panel history object  The object is targeted on a particular
    paneLayout and thereafter notes changes in panel configurations within that paneLayout,
    building up a history list  The list can be stepped through backwards or forwards
    
    :param back: (E) Go back one level on the history list
    :type back: boolean
    :param clear: (E) Clear the history stack
    :type clear: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param forward: (E) Go forward one level on the history list
    :type forward: boolean
    :param historyDepth: (Q E) Specifies how many levels of history are maintained
    :type historyDepth: int
    :param isEmpty: (Q) Returns true if there is currently no panel history
    :type isEmpty: boolean
    :param suspend: (E) Specifies whether to suspend or resume updates to the panel history 
    Useful for chunking a number of changes into one history event
    :type suspend: boolean
    :param targetPane: (C Q) Specifies which paneLayout the history will be maintained for
    :type targetPane: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param wrap: (Q E) Specifies whether the history will wrap at the end and beginning  This
    value is true by default
    :type wrap: boolean
    
    :returns: The name of the panelHistory object created.
    :rtype: string
    """
    pass


def HypershadeShapeMenuStateAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def boxDollyCtx(*args, alternateContext=True, exists=True, history=True, image1="", image2="",
                image3="", name="", toolName="", q=True, query=True, e=True, edit=True,
                **kwargs):
    """
    This command can be used to create, edit, or query a dolly context
    
    :param alternateContext: (C Q) Set the ALT+MMB and ALT+SHIFT+MMB to refer to this context
    :type alternateContext: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param toolName: (C Q) Name of the specific tool to which this command refers
    :type toolName: string
    
    :returns: The name of the context
    :rtype: string
    """
    pass


def NodeEditorTransforms(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetCurrentColorSet(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeConvertToFileTexture(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PaintCacheToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeCreateNewTab(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def createPolyPlatonicSolidCtx(*args, **kwargs):
    """
    
    """
    pass


def polySplitVertex(*args, caching=True, constructionHistory=True, name="", nodeState=0,
                    worldSpace=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Use this command to split one or more vertices. A mesh is made up of one or more faces  The
    faces are defined by edges which connect vertices together  Typically a face will share
    vertices and edges with adjacent faces in the same mesh  Sharing vertices and edges helps
    reduce the amount of memory used by a mesh  It also ensures that when a face is 
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The polySplitVert node name.
    :rtype: string
    """
    pass


def dR_visorTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreatePolygonPlane(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UVCreateSnapshot(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AutoProjection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetKeyOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PrefixHierarchyNames(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MirrorJoint(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmCombBrushToolCmd(*args, **kwargs):
    """
    
    """
    pass


def SetKeyScale(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXImportHardEdges(*args, **kwargs):
    """
    
    """
    pass


def EvaluationToolkit(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateNodeWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateWake(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmGuideContext(*args, **kwargs):
    """
    
    """
    pass


def NonWeightedTangents(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def shadingNetworkCompare(*args, byName=False, byValue=True, delete=True, equivalent=True,
                          network1=True, network2=True, upstreamOnly=False, q=True, query=True,
                          **kwargs):
    """
    This command allows you to compare two shading networks
    
    :param byName: (C) Indicates whether the comparison should consider node names  If true,
    two shading networks will be considered equivalent only if the names of corresp
    :type byName: boolean
    :param byValue: (C) Indicates whether the comparison should consider the values of
    unconnected attributes  If true, two shading networks will be considered equivalent on
    :type byValue: boolean
    :param delete: (C) Deletes the specified comparison from memory
    :type delete: boolean
    :param equivalent: (Q) Returns an int  1 if the shading networks in the specified
    comparison are equivalent  0 otherwise
    :type equivalent: boolean
    :param network1: (Q) Returns a string[]  Returns an empty string array if the shading
    networks in the specified comparison are not equivalent  Otherwise returns the nodes
    :type network1: boolean
    :param network2: (Q) Returns a string[]  Returns an empty string array if the shading
    networks in the specified comparison are not equivalent  Otherwise returns the nodes
    :type network2: boolean
    :param upstreamOnly: (C) Indicates whether the comparison should consider nodes which are
    connected downstream from shading network nodes  If true, only those nodes which are
    :type upstreamOnly: boolean
    
    :returns: Command result
    :rtype: string[]|string|int
    """
    pass


def FBXResetExport(*args, **kwargs):
    """
    
    """
    pass


def dR_setExtendLoop(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def renderQualityNode(*args, name="", parent="", shared=True, skipSelect=True, **kwargs):
    """
    This command creates a new node in the dependency graph of the specified type   The
    renderQualityNode creates a render quality node and registers it with the model  The
    createNode command will not register nodes of this type correctly
    
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param parent: (C) Specifies the parent in the DAG under which the new node belongs
    :type parent: string
    :param shared: (C) This node is shared across multiple files, so only create it if it does
    not already exist
    :type shared: boolean
    :param skipSelect: (C) This node is not to be selected after creation, the original
    selection will be preserved
    :type skipSelect: boolean
    
    :returns: The name of the new node.
    :rtype: string
    """
    pass


def ShowSurfaceCVs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_symmetryFlip(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def lightlink(*args, b=True, hierarchy=True, light=None, make=True, object=None, sets=True,
              shadow=True, shapes=True, transforms=True, useActiveLights=True,
              useActiveObjects=True, q=True, query=True, **kwargs):
    """
    This command is used to make, break and query light linking relationships between
    lights/sets of lights and objects/sets of objects   If no make, break or query flag is
    specified and both lights and objects flags are present, the make flag is assumed to be
    specified   If no make, break or query flag is specified and only one of the lights and
    objec
    
    :param b: (C) The presence of this flag on the command indicates that the command is being
    invoked to break links between lights and renderable objects
    :type b: boolean
    :param hierarchy: (C) When querying, specifies whether the result should include the
    hierarchy of transforms above shapes linked to the queried light/object  The transform
    :type hierarchy: boolean
    :param light: (C M) The argument to the light flag specifies a node to be used by the
    command in performing the action as if the node is a light  This is a multiuse flag
    :type light: name
    :param make: (C) The presence of this flag on the command indicates that the command is
    being invoked to make links between lights and renderable objects
    :type make: boolean
    :param object: (C M) The argument to the object flag specifies a node to be used by the
    command in performing the action as if the node is an object  This is a multiuse f
    :type object: name
    :param sets: (C) When querying, specifies whether the result should include sets linked to
    the queried light/object  Default is true
    :type sets: boolean
    :param shadow: (C) Specify that shadows are to be linked
    :type shadow: boolean
    :param shapes: (C) When querying, specifies whether the result should include shapes linked
    to the queried light/object  Default is true
    :type shapes: boolean
    :param transforms: (C) When querying, specifies whether the result should include
    transforms immediately above shapes linked to the queried light/object  Default is true
    :type transforms: boolean
    :param useActiveLights: (C) Specify that active lights are to be used
    :type useActiveLights: boolean
    :param useActiveObjects: (C) Specify that active objects are to be used
    :type useActiveObjects: boolean
    
    :returns: Single element command result
    :rtype: string
    """
    pass


def ProjectCurveOnSurface(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def EnableTimeChangeUndoConsolidation(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RotateUVTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SymmetrizeUVUpdateCommand(*args, **kwargs):
    """
    
    """
    pass


def NodeEditorPickWalkRight(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MirrorSkinWeightsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_selectAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_selConstraintEdgeLoop(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeIncreaseTraversalDepth(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def eval(*args, **kwargs):
    """
    This function takes a string which contains MEL code and evaluates it using the MEL
    interpreter  The result is converted into a Python data type and is returned  If an error
    occurs during the execution of the MEL script, a Python exception is raised with the
    appropriate error message
    
    
    :returns: depending on input.
    :rtype: Any
    """
    pass


def syncSculptCache(*args, **kwargs):
    """
    
    """
    pass


def exactWorldBoundingBox(*args, calculateExactly=True, ignoreInvisible=True, **kwargs):
    """
    This command figures out an exact-fit bounding box for the specified objects (or selected
    objects if none are specified) This bounding box is always in world space
    
    :param calculateExactly: (C) Should the bounding box calculation be exact?
    :type calculateExactly: boolean
    :param ignoreInvisible: (C) Should the bounding box calculation include or exclude
    invisible objects?
    :type ignoreInvisible: boolean
    
    :returns: xmin, ymin, zmin, xmax, ymax, zmax.
    :rtype: float[]
    """
    pass


def Shatter(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorShowCustomAttrs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_selConstraintBorder(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteStaticChannels(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ParticleTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TruncateHairCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Duplicate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyContourProjection(*args, caching=True, constructionHistory=True, createNewMap=True,
                          flipRails=True, insertBeforeDeformers=True, method=0, name="",
                          nodeState=0, offset0=0.0, offset1=0.0, offset2=0.0, offset3=0.0,
                          reduceShear=0.0, smoothness0=0.0, smoothness1=0.0, smoothness2=0.0,
                          smoothness3=0.0, userDefinedCorners=True, uvSetName="",
                          worldSpace=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Performs a contour stretch UV projection onto an object
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param createNewMap: (C) Set to true if a new map should be created
    :type createNewMap: boolean
    :param flipRails: (C Q E) If true, flip which curves are the rails of the birail surface
    :type flipRails: boolean
    :param insertBeforeDeformers: (C) Set to true if the new node created should inserted
    before any deformer nodes
    :type insertBeforeDeformers: boolean
    :param method: (C Q E) Sets which projection method to use  Valid values are 0: Walk
    Contours 1: NURBS Projection
    :type method: int
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param offset0: (C Q E) Sets the offset on edge 0 of the NURBS surface
    :type offset0: float
    :param offset1: (C Q E) Sets the offset on edge 1 of the NURBS surface
    :type offset1: float
    :param offset2: (C Q E) Sets the offset on edge 2 of the NURBS surface
    :type offset2: float
    :param offset3: (C Q E) Sets the offset on edge 3 of the NURBS surface
    :type offset3: float
    :param reduceShear: (C Q E) Sets the 'reduce shear' parameter of the projection
    :type reduceShear: float
    :param smoothness0: (C Q E) Sets the smoothness of edge 0 of the NURBS surface
    :type smoothness0: float
    :param smoothness1: (C Q E) Sets the smoothness of edge 1 of the NURBS surface
    :type smoothness1: float
    :param smoothness2: (C Q E) Sets the smoothness of edge 2 of the NURBS surface
    :type smoothness2: float
    :param smoothness3: (C Q E) Sets the smoothness of edge 3 of the NURBS surface
    :type smoothness3: float
    :param userDefinedCorners: (C Q E) If true, the four vertices specified by user will be
    taken as corners to do the projection
    :type userDefinedCorners: boolean
    :param uvSetName: (C) Name of the UV set to be created
    :type uvSetName: string
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def NodeEditorCreateNodePopup(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportSkeletonDefinitions(*args, **kwargs):
    """
    
    """
    pass


def SetKeyRotate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExtrudeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def fcheck(*args, **kwargs):
    """
    Invokes the fcheck program to display images in a separate window
    
    
    :returns: 
    :rtype: None
    """
    pass


def ActivateViewport20(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def tabLayout(*args, annotation="", backgroundColor=None, borderStyle="", changeCommand=None,
              childArray=True, childResizable=True, defineTemplate="", docTag="",
              doubleClickCommand=None, dragCallback=None, dropCallback=None, enable=True,
              enableBackground=True, enableKeyboardFocus=True, exists=True, fullPathName=True,
              height=0, highlightColor=None, horizontalScrollBarThickness=0, image="",
              imageVisible=True, innerMarginHeight=0, innerMarginWidth=0, isObscured=True,
              manage=True, minChildWidth=0, moveTab=None, newTabCommand=None, noBackground=True,
              numberOfChildren=True, numberOfPopupMenus=True, parent="", popupMenuArray=True,
              preSelectCommand=None, preventOverride=True, scrollable=True, scrollableTabs=True,
              selectCommand=None, selectTab="", selectTabIndex=0, showNewTab=True,
              statusBarMessage="", tabLabel=None, tabLabelIndex=None, tabPosition="",
              tabTooltip=None, tabTooltipIndex=None, tabsClosable=True, tabsVisible=True,
              useTemplate="", verticalScrollBarThickness=0, visible=True,
              visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
              **kwargs):
    """
    This command creates a tab group  Tab groups are a specialized form of control layouts that
    contain only control layouts  Whenever a control layout is added to a tab group it will
    have a tab provided for it that allows selection of that group from amongst other tabbed
    control groups  Only one child of a tab layout is visible at a time
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param borderStyle: (C Q E) Specify the style of the border for tab layout  Valid values
    are: "none", "top", "notop" and "full"  By default, it will use "full" to draw a simple
    :type borderStyle: string
    :param changeCommand: (C E) Command executed when a tab is selected interactively  This
    command is only invoked when the selected tab changes  Re-selecting the current tab will
    :type changeCommand: script
    :param childArray: (Q) Returns a string array of the names of the layout's immediate
    children
    :type childArray: boolean
    :param childResizable: (C Q) Set to true if you want the child of the control layout to be
    as wide as the scroll area  You may also indicate a minimum width for the child using t
    :type childResizable: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param doubleClickCommand: (C E) Command executed when a tab is double clicked on  Note
    that the first click will select the tab and the second click will execute the double click
    co
    :type doubleClickCommand: script
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param horizontalScrollBarThickness: (C E) Thickness of the horizontal scroll bar  Specify
    an integer value greater than or equal to zero  This flag has no effect on Windows systems
    :type horizontalScrollBarThickness: int
    :param image: (C Q E) Image appearing in top right corner of tab layout
    :type image: string
    :param imageVisible: (C Q E) Visibility of tab image
    :type imageVisible: boolean
    :param innerMarginHeight: (C Q) Margin height for all tab children
    :type innerMarginHeight: int
    :param innerMarginWidth: (C Q) Margin width for all tab children
    :type innerMarginWidth: int
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param minChildWidth: (C Q) Specify a positive non-zero integer value indicating the
    minimum width the tab layout's children  This flag only has meaning when the
    -cr/childResiza
    :type minChildWidth: int
    :param moveTab: (C E) Move the tab from the current index to a new index
    :type moveTab: [int, int]
    :param newTabCommand: (C E) Command executed when the 'New Tab' button (on the tab bar) is
    clicked  Note: in order to show the new tab button use the -snt/showNewTab flag  Using
    :type newTabCommand: script
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfChildren: (Q) Returns in an int the number of immediate children of the
    layout
    :type numberOfChildren: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preSelectCommand: (C E) Command executed when a tab is selected but before it's
    contents become visible  Re-selecting the current tab will not invoke this command  Note
    that
    :type preSelectCommand: script
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param scrollable: (C Q) Puts all children of this layout within a scroll area
    :type scrollable: boolean
    :param scrollableTabs: (C Q E) If true, the active tab in the layout can be scrolled
    through with the mouse wheel  Default is true
    :type scrollableTabs: boolean
    :param selectCommand: (C Q E) Command executed when a tab is selected interactively This
    command will be invoked whenever a tab is selected, ie  re-selecting the current tab will
    :type selectCommand: script
    :param selectTab: (C Q E) The name, in short form, of the selected tab  An empty string is
    returned on query if there are no child tabs
    :type selectTab: string
    :param selectTabIndex: (C Q E) Identical to the -st/selectTab flag except this flag takes a
    1-based index to identify the selected tab  A value of 0 is returned on query if there a
    :type selectTabIndex: int
    :param showNewTab: (C Q E) Set to true if you want to have a 'New Tab' button shown at the
    end of the tab bar  Note: use the -ntc/newTabCommand flag to set the command executed
    :type showNewTab: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param tabLabel: (C Q E M) Set a tab label  The first argument is the name of a control
    that must be a child of the tab layout  The second argument is the label for the tab ass
    :type tabLabel: [string, string]
    :param tabLabelIndex: (C Q E M) Identical to the -tl/tabLabel flag except this flag takes a
    1-based index to identify the tab you want to set the label for  If this flag is queried
    :type tabLabelIndex: [int, string]
    :param tabPosition: (C Q E) Changes the tab position  The possible values are: "north",
    "east" and "west"
    :type tabPosition: string
    :param tabTooltip: (C Q E M) Set a tab tooltip  The first argument is the name of a control
    that must be a child of the tab layout  The second argument is the tooltip for the tab
    :type tabTooltip: [string, string]
    :param tabTooltipIndex: (C Q E M) Identical to the -tt/tabTooltip flag except this flag
    takes a 1-based index to identify the tab you want to set the tooltip for  If this flag is
    quer
    :type tabTooltipIndex: [int, string]
    :param tabsClosable: (C Q) Set to true if you want to have a close button icon on all
    created tabs
    :type tabsClosable: boolean
    :param tabsVisible: (C Q E) Visibility of the tab labels
    :type tabsVisible: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param verticalScrollBarThickness: (C E) Thickness of the vertical scroll bar  Specify an
    integer value greater than or equal to zero  This flag has no effect on Windows systems
    :type verticalScrollBarThickness: int
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def AttachSubdivSurface(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleCreaseVertices(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_multiCutRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ChangeFullBodyPivotPlacement(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ConvertToFrozen(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PerspGraphLayout(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def selectContext(*args, exists=True, history=True, image1="", image2="", image3="", name="",
                  q=True, query=True, e=True, edit=True, **kwargs):
    """
    Creates a context to perform selection
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: Name of the context created
    :rtype: string
    """
    pass


def DeleteSurfaceFlowOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyMergeEdgeCtx(*args, activeNodes=True, exists=True, image1="", image2="", image3="",
                     immediate=True, name="", previous=True, reset=True, toolNode=True,
                     caching=True, constructionHistory=True, firstEdge=0, mergeMode=1,
                     mergeTexture=False, nodeState=0, secondEdge=0, q=True, query=True, e=True,
                     edit=True, **kwargs):
    """
    Sews two border edges together.
    
    :param activeNodes: (Q) Return the active nodes in the tool
    :type activeNodes: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param immediate: (E) Acts on the object not the tool defaults
    :type immediate: boolean
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param previous: (E) Reset to previously stored values
    :type previous: boolean
    :param reset: (E) Reset to default values
    :type reset: boolean
    :param toolNode: (Q) Return the node used for tool defaults
    :type toolNode: boolean
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param firstEdge: (C Q E) First edge to merge  Invalid default value to force the value to
    be set  Default: -1
    :type firstEdge: int
    :param mergeMode: (C Q E) Merge mode : 0=first, 1=halfway between both edges, 2=second 
    Default: 1
    :type mergeMode: int
    :param mergeTexture: (C Q E) Boolean which is used to decide if uv coordinates should be
    merged or not - along with the geometry  Default: false
    :type mergeTexture: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param secondEdge: (C Q E) Second edge to merge  Invalid default value to force the value
    to be set  Default: -1
    :type secondEdge: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def NodeEditorGraphAllShapesExceptShading(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def listInputDeviceButtons(*args, **kwargs):
    """
    This command lists all of the buttons of the specified input device specified as an
    argument
    
    
    :returns: Command result
    :rtype: string[]
    """
    pass


def SubdividePolygonOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ConnectJointOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowMeshPinchToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def EnableNCloths(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportCacheFile(*args, **kwargs):
    """
    
    """
    pass


def sceneUIReplacement(*args, clear=True, deleteRemaining=True, getNextFilter=None,
                       getNextPanel=None, getNextScriptedPanel=None, update="", **kwargs):
    """
    This command returns existing scene based UI that can be utilized by the scene that is
    being loaded  It can also delete any such UI that is not used by the loading scene
    
    :param clear: (C) Frees any resources allocated by the command
    :type clear: boolean
    :param deleteRemaining: (C) Delete any UI that is scene dependent and has not been
    referenced by this command since the last update
    :type deleteRemaining: boolean
    :param getNextFilter: (C) Returns the next filter of the specified type with the specified
    name
    :type getNextFilter: [string, string]
    :param getNextPanel: (C) Returns the next panel of the specified type, preferably with the
    specified label
    :type getNextPanel: [string, string]
    :param getNextScriptedPanel: (C) Returns the next scripted panel of the specified scripted
    panel type, preferably with the specified label
    :type getNextScriptedPanel: [string, string]
    :param update: (C) Updates the state of the command to reflect the current state of the
    application  The string argument is the name of the main window pane layout hold
    :type update: string
    
    :returns: When used with getNextScriptedPanel, getNextPanel, or getNextFilter
    :rtype: string
    """
    pass


def singleProfileBirailSurface(*args, caching=True, nodeState=0,
                               tangentContinuityProfile1=False, transformMode=0,
                               constructionHistory=True, name="", object=True, polygon=0,
                               q=True, query=True, e=True, edit=True, **kwargs):
    """
    This cmd creates a railed surface by sweeping the profile curve along the two rail curves 
    One of the requirements for surface creation is the profile curve must intersect the two
    rail curves  If the profile is a surface curve i.e  isoparm, curve on surface or trimmed
    edge then tangent continuity across the surface underlying the profile may be ena
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param tangentContinuityProfile1: (C Q E) Need to be tangent continuous across the profile 
    The profile must be a surface curve  Default: false
    :type tangentContinuityProfile1: boolean
    :param transformMode: (C Q E) transform mode ( Non proportional, proportional )  Non
    proportional is default value  Default: 0
    :type transformMode: int
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param polygon: (C) The value of this argument controls the type of the object created by
    this operation 0: nurbs surface 1: polygon (use nurbsToPolygonsPref to set the
    :type polygon: int
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def ViewAlongAxisNegativeY(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorRenderSwatches(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CurveSmoothnessCoarse(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def selectKeyCtx(*args, exists=True, history=True, image1="", image2="", image3="", name="",
                 q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a context which may be used to select keyframes within the graph
    editor
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: 
    :rtype: None
    """
    pass


def EnableSnapshots(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowManipulatorTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MoveNearestPickedKeyToolDeactivate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def objectCenter(*args, gl=True, local=True, x=True, y=True, z=True, **kwargs):
    """
    This command returns the coordinates of the center of the bounding box of the specified
    object  If one coordinate only is specified, it will be returned as a float  If no
    coordinates are specified, an array of floats is returned, containing x, y, and z  If you
    specify multiple coordinates, only one will be returned
    
    :param gl: (C) Return positional values in global coordinates (default)
    :type gl: boolean
    :param local: (C) Return positional values in local coordinates
    :type local: boolean
    :param x: (C) Return X value only
    :type x: boolean
    :param y: (C) Return Y value only
    :type y: boolean
    :param z: (C) Return Z value only
    :type z: boolean
    
    :returns: When the asking for the center (default).
    :rtype: float[]
    """
    pass


def NodeEditorAutoSizeNodes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorCloseActiveTab(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorDeleteClips(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MakePondBoatsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleUseDefaultMaterial(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportInputConnections(*args, **kwargs):
    """
    
    """
    pass


def cacheFileMerge(*args, endTime=None, geometry=True, startTime=None, q=True, query=True,
                   e=True, edit=True, **kwargs):
    """
    If selected/specified caches can be successfully merged, will return the start/end frames
    of the new cache followed by the start/end frames of any gaps in the merged cache for which
    no data should be written to file  In query mode, will return the names of geometry
    associated with the specified cache file nodes
    
    :param endTime: (C) Specifies the end frame of the merge range  If not specified, will
    figure out range from times of caches being merged
    :type endTime: time
    :param geometry: (Q) Query-only flag used to find the geometry nodes associated with the
    specified cache files
    :type geometry: boolean
    :param startTime: (C) Specifies the start frame of the merge range  If not specified, will
    figure out range from the times of the caches being merged
    :type startTime: time
    
    :returns: The start and end times of merged cache followed by start/end of any gaps
    :rtype: float[]
    """
    pass


def closeCurve(*args, blendBias=0.5, blendKnotInsertion=False, caching=True, nodeState=0,
               parameter=0.1, preserveShape=1, constructionHistory=True, curveOnSurface=True,
               name="", object=True, replaceOriginal=True, q=True, query=True, e=True,
               edit=True, **kwargs):
    """
    The closeCurve command closes a curve, making it periodic  The pathname to the newly closed
    curve and the name of the resulting dependency node are returned  If a curve is not
    specified in the command, then the first active curve will be used
    
    :param blendBias: (C Q E) Skew the result toward the first or the second curve depending on
    the blend value being smaller or larger than 0.5  Default: 0.5
    :type blendBias: float
    :param blendKnotInsertion: (C Q E) If set to true, insert a knot in one of the original
    curves (relative position given by the parameter attribute below) in order to produce a
    slightly
    :type blendKnotInsertion: boolean
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param parameter: (C Q E) The parameter value for the positioning of the newly inserted
    knot  Default: 0.1
    :type parameter: float
    :param preserveShape: (C Q E) 0 - without preserving the shape 1 - preserve shape 2 - blend
    Default: 1
    :type preserveShape: int
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param curveOnSurface: (C) If possible, create 2D curve as a result
    :type curveOnSurface: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def setDynamic(*args, allOnWhenRun=True, disableAllOnWhenRun=True, setAll=True, setOff=True,
               setOn=True, **kwargs):
    """
    setDynamic sets the isDynamic attribute of particle objects on or off  If no objects are
    specified, it sets the attribute for any selected objects  If -all is thrown, it sets the
    attribute for all particle objects in the scene  By default it sets the attribute true
    (on); if the -off flag is thrown, it sets the attribute false (off)   WARNING: setDy
    
    :param allOnWhenRun: (C) Obsolete, no longer suppported or necessary
    :type allOnWhenRun: boolean
    :param disableAllOnWhenRun: (C) Obsolete, no longer suppported or necessary
    :type disableAllOnWhenRun: boolean
    :param setAll: (C) Set for all objects
    :type setAll: boolean
    :param setOff: (C) Sets isDynamic false
    :type setOff: boolean
    :param setOn: (C) Sets isDynamic true  This flag is set by default
    :type setOn: boolean
    
    :returns: array
    :rtype: string
    """
    pass


def LayoutUVRectangle(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateOceanOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def EmitFluidFromObject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ViewSequence(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def volumeBind(*args, influence="", name="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    Command for creating and editing volume binding nodes  The node is use for storing volume
    data to define skin weighting data
    
    :param influence: (Q E) Edit or Query the list of influences connected to the skin cluster
    :type influence: string
    :param name: (C) Used to specify the name of the node being created
    :type name: string
    
    :returns: List of queried influences
    :rtype: string[]
    """
    pass


def animLayer(*args, addRelatedKG=True, addSelectedObjects=True, affectedLayers=True,
              animCurves=True, attribute="", baseAnimCurves=True, bestAnimLayer=True,
              bestLayer=True, blendNodes=True, children="", collapse=True, copy="",
              copyAnimation="", copyNoAnimation="", excludeBoolean=True, excludeDynamic=True,
              excludeEnum=True, excludeRotate=True, excludeScale=True, excludeTranslate=True,
              excludeVisibility=True, exists=True, extractAnimation="", findCurveForPlug="",
              forceUIRebuild=True, forceUIRefresh=True, layeredPlug="", lock=False,
              maxLayers=True, moveLayerAfter="", moveLayerBefore="", mute=False, override=False,
              parent="", passthrough=True, preferred=True, removeAllAttributes=True,
              removeAttribute="", root="", selected=True, solo=False, weight=1,
              writeBlendnodeDestinations=True, q=True, query=True, e=True, edit=True,
              **kwargs):
    """
    This command creates and edits animation layers
    
    :param addRelatedKG: (C Q E) Used adding attributes to a layer  Determines if associated
    keying groups should be added or not to the layer
    :type addRelatedKG: boolean
    :param addSelectedObjects: (C Q E) Adds selected object(s) to the layer
    :type addSelectedObjects: boolean
    :param affectedLayers: (Q) Return the layers that the currently selected object(s) are
    members of
    :type affectedLayers: boolean
    :param animCurves: (C Q E) In query mode returns the anim curves associated with this
    layer
    :type animCurves: boolean
    :param attribute: (C Q E M) Adds a specific attribute on a object to the layer
    :type attribute: string
    :param baseAnimCurves: (C Q E) In query mode returns the base layer anim curves associated
    with this layer, if any
    :type baseAnimCurves: boolean
    :param bestAnimLayer: (C Q E) In query mode returns the best anim layers for keying for the
    selected objects  If used in conjunction with -at, will return the best anim layers for
    :type bestAnimLayer: boolean
    :param bestLayer: (Q) Return the layer that will be keyed for specified attribute
    :type bestLayer: boolean
    :param blendNodes: (C Q E) In query mode returns the blend nodes associated with this
    layer
    :type blendNodes: boolean
    :param children: (Q) Get the list of children layers  Return value is a string array
    :type children: string
    :param collapse: (C Q E) Determine if a layer is collapse in the layer editor
    :type collapse: boolean
    :param copy: (E) Copy from layer
    :type copy: string
    :param copyAnimation: (C E) Copy animation from specified layer to destination layer, only
    animation that are on attribute layered by both layer that are concerned
    :type copyAnimation: string
    :param copyNoAnimation: (E) Copy from layer without the animation curves
    :type copyNoAnimation: string
    :param excludeBoolean: (C Q E) When adding selected object(s) to the layer, excludes any
    boolean attributes
    :type excludeBoolean: boolean
    :param excludeDynamic: (C Q E) When adding selected object(s) to the layer, excludes any
    dynamic attributes
    :type excludeDynamic: boolean
    :param excludeEnum: (C Q E) When adding selected object(s) to the layer, excludes any enum
    attributes
    :type excludeEnum: boolean
    :param excludeRotate: (C Q E) When adding selected object(s) to the layer, exclude the
    rotate attribute
    :type excludeRotate: boolean
    :param excludeScale: (C Q E) When adding selected object(s) to the layer, exclude the scale
    attribute
    :type excludeScale: boolean
    :param excludeTranslate: (C Q E) When adding selected object(s) to the layer, excludes the
    translate attribute
    :type excludeTranslate: boolean
    :param excludeVisibility: (C Q E) When adding selected object(s) to the layer, exclude the
    visibility attribute
    :type excludeVisibility: boolean
    :param exists: (Q) Determine if an layer exists
    :type exists: boolean
    :param extractAnimation: (C E) Transfer animation from specified layer to destination layer,
    only animation that are on attribute layered by both layer that are concerned
    :type extractAnimation: string
    :param findCurveForPlug: (Q E) Finds the parameter curve containing the animation data for
    the specified plug on the given layer  In query mode, this flag needs a value
    :type findCurveForPlug: string
    :param forceUIRebuild: (C) Rebuilds the animation layers user interface
    :type forceUIRebuild: boolean
    :param forceUIRefresh: (C) Refreshes the animation layers user interface
    :type forceUIRefresh: boolean
    :param layeredPlug: (Q) Returns the plug on the blend node corresponding to the specified
    layer In query mode, this flag needs a value
    :type layeredPlug: string
    :param lock: (C Q E) Set the lock state of the specified layer  A locked layer cannot
    receive key  Default is false
    :type lock: boolean
    :param maxLayers: (Q) Returns the maximum number of anim layers supported by this product
    :type maxLayers: boolean
    :param moveLayerAfter: (E) Move layer after the specified layer
    :type moveLayerAfter: string
    :param moveLayerBefore: (E) Move layer before the specified layer
    :type moveLayerBefore: string
    :param mute: (C Q E) Set the mute state of the specified layer  Default is false
    :type mute: boolean
    :param override: (C Q E) Set the overide state of the specified layer  Default is false
    :type override: boolean
    :param parent: (C Q E) Set the parent of the specified layer  Default is the animation
    layer root
    :type parent: string
    :param passthrough: (C Q E) Set the passthrough state of the specified layer  Default is
    true
    :type passthrough: boolean
    :param preferred: (C Q E) Determine if a layer is a preferred layer, the best layer
    algorithm will try to set keyframe in preferred layer first
    :type preferred: boolean
    :param removeAllAttributes: (E) Remove all objects from layer
    :type removeAllAttributes: boolean
    :param removeAttribute: (E M) Remove object from layer
    :type removeAttribute: string
    :param root: (Q) Return the base layer if it exist
    :type root: string
    :param selected: (C Q E) Determine if a layer is selected, a selected layer will be show in
    the timecontrol, graph editor
    :type selected: boolean
    :param solo: (C Q E) Set the solo state of the specified layer  Default is false
    :type solo: boolean
    :param weight: (C Q E) Set the weight of the specified layer between 0.0 and 1.0  Default
    is 1
    :type weight: float
    :param writeBlendnodeDestinations: (E) In edit mode writes the destination plugs of the
    blend nodes that belong to the layer into the blend node  This is used for layer
    import/export purpo
    :type writeBlendnodeDestinations: boolean
    
    :returns: Return values currently not documented.
    :rtype: string
    """
    pass


def HypershadeSelectBakeSets(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleUIElements(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXImportCacheFile(*args, **kwargs):
    """
    
    """
    pass


def projectionManip(*args, fitBBox=True, projType=0, switchType=True, q=True, query=True,
                    **kwargs):
    """
    Various commands to set the manipulator to interesting positions
    
    :param fitBBox: (C) Fit the projection manipulator size and position to the shading group
    bounding box  The orientation is not modified
    :type fitBBox: boolean
    :param projType: (C) Set the projection type to the given value  Projection type values
    are: 1 = planar  2 = spherical  3 = cylindrical  4 = ball  5 = cubic  6 = triplana
    :type projType: int
    :param switchType: (C) Loop over the allowed types  If the hardware shading is on, it loops
    over the hardware shadeable types (planar, cylindrical, spherical), otherwise, i
    :type switchType: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def texScaleContext(*args, editPivotMode=True, exists=True, image1="", image2="", image3="",
                    position=True, preventNegativeScale=True, snap=True, snapRelative=True,
                    snapValue=0.0, tweakMode=True, q=True, query=True, e=True, edit=True,
                    **kwargs):
    """
    This command can be used to create, edit, or query a scale context for the UV Editor  Note
    that the above flag controls the global behaviour of all texture editor scale contexts 
    Changing one context independently is not allowed  Changing a context's behaviour using the
    above flag, will change all existing texture editor scale contexts
    
    :param editPivotMode: (Q) Returns true when manipulator is in edit pivot mode
    :type editPivotMode: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param position: (Q) Returns the current position of the manipulator
    :type position: boolean
    :param preventNegativeScale: (Q E) Prevent negative scale for components
    :type preventNegativeScale: boolean
    :param snap: (Q E) Sets or queries whether snapping is to be used
    :type snap: boolean
    :param snapRelative: (Q E) Sets or queries whether snapping is relative
    :type snapRelative: boolean
    :param snapValue: (Q E) Sets or queries the size of the snapping increment
    :type snapValue: float
    :param tweakMode: (Q E) When true, the manipulator is hidden and highlighted components can
    be selected and scaled in one step using a click-drag interaction
    :type tweakMode: boolean
    
    :returns: : name of the context created
    :rtype: string
    """
    pass


def evalContinue(*args, **kwargs):
    """
    
    """
    pass


def volumeAxis(*args, alongAxis=0.0, aroundAxis=0.0, attenuation=0.0, awayFromAxis=0.0,
               awayFromCenter=0.0, detailTurbulence=0.0, directionX=0.0, directionY=0.0,
               directionZ=0.0, directionalSpeed=0.0, invertAttenuation=True, magnitude=0.0,
               maxDistance=0.0, name="", perVertex=True, position=None, torusSectionRadius=0.0,
               turbulence=0.0, turbulenceFrequencyX=0.0, turbulenceFrequencyY=0.0,
               turbulenceFrequencyZ=0.0, turbulenceOffsetX=0.0, turbulenceOffsetY=0.0,
               turbulenceOffsetZ=0.0, turbulenceSpeed=0.0, volumeExclusion=True,
               volumeOffset=None, volumeShape="", volumeSweep=0.0, q=True, query=True, e=True,
               edit=True, **kwargs):
    """
    For each listed object, the command creates a new field  The field has a shape which lives
    in the DAG and it has an associated dependency node  The field is added to the list of
    fields owned by the object  Use connectDynamic to cause the field to affect a dynamic
    object  Note that if more than one object is listed, a separate field is created for e
    
    :param alongAxis: (Q E) Initial velocity multiplier in the direction along the central axis
    of the volume  See the diagrams in the documentation
    :type alongAxis: float
    :param aroundAxis: (Q E) Initial velocity multiplier in the direction around the central
    axis of the volume  See the diagrams in the documentation
    :type aroundAxis: float
    :param attenuation: (Q E) Attentuation rate of field
    :type attenuation: float
    :param awayFromAxis: (Q E) Initial velocity multiplier in the direction away from the
    central axis of the volume  See the diagrams in the documentation  Used only with the cyli
    :type awayFromAxis: float
    :param awayFromCenter: (Q E) Initial velocity multiplier in the direction away from the
    center point of a cube or sphere volume  Used only with the cube and sphere volumes
    :type awayFromCenter: float
    :param detailTurbulence: (Q E) The relative intensity of a second higher frequency
    turbulence  This can be used to create fine features in large scale flows  Both the speed
    and the
    :type detailTurbulence: float
    :param directionX: (Q E) x-component of force direction  Used with directional speed
    :type directionX: float
    :param directionY: (Q E) y-component of force direction  Used with directional speed
    :type directionY: float
    :param directionZ: (Q E) z-component of force direction  Used with directional speed
    :type directionZ: float
    :param directionalSpeed: (Q E) Adds a component of speed in the direction specified by the
    directionX, Y, and Z attributes
    :type directionalSpeed: float
    :param invertAttenuation: (Q E) If this attribute is FALSE, the default, then the
    attenuation makes the field's effect decrease as the affected point is further from the
    volume's ax
    :type invertAttenuation: boolean
    :param magnitude: (Q E) Strength of field
    :type magnitude: float
    :param maxDistance: (Q E) Maximum distance at which field is exerted  -1 indicates that the
    field has no maximum distance
    :type maxDistance: float
    :param name: (Q E) name of field
    :type name: string
    :param perVertex: (Q E) Per-vertex application  If this flag is set true, then each
    individual point (CV, particle, vertex,etc.) of the chosen object exerts an identical cop
    :type perVertex: boolean
    :param position: (Q E M) Position in space (x,y,z) where you want to place a gravity field 
    The gravity then emanates from this position in space rather than from an object
    :type position: [float, float, float]
    :param torusSectionRadius: (Q E) Section radius for a torus volume  Applies only to torus 
    Similar to the section radius in the torus modelling primitive
    :type torusSectionRadius: float
    :param turbulence: (Q E) Adds a force simulating a turbulent wind that evolves over time
    :type turbulence: float
    :param turbulenceFrequencyX: (Q E) The repeats of the turbulence function in X
    :type turbulenceFrequencyX: float
    :param turbulenceFrequencyY: (Q E) The repeats of the turbulence function in Y
    :type turbulenceFrequencyY: float
    :param turbulenceFrequencyZ: (Q E) The repeats of the turbulence function in Z
    :type turbulenceFrequencyZ: float
    :param turbulenceOffsetX: (Q E) The translation of the turbulence function in X
    :type turbulenceOffsetX: float
    :param turbulenceOffsetY: (Q E) The translation of the turbulence function in Y
    :type turbulenceOffsetY: float
    :param turbulenceOffsetZ: (Q E) The translation of the turbulence function in Z
    :type turbulenceOffsetZ: float
    :param turbulenceSpeed: (Q E) The rate of change of the turbulence over time  The
    turbulence loops seamlessly every 1.0/turbulenceSpeed seconds  To animate this rate attach
    a new
    :type turbulenceSpeed: float
    :param volumeExclusion: (Q E) Volume exclusion of the field  If true, points outside the
    volume (defined by the volume shape attribute) are affected, If false, points inside the v
    :type volumeExclusion: boolean
    :param volumeOffset: (Q E) Volume offset of the field  Volume offset translates the field's
    volume by the specified amount from the actual field location  This is in the field'
    :type volumeOffset: [float, float, float]
    :param volumeShape: (Q E) Volume shape of the field  Sets/edits/queries the field's volume
    shape attribute  If set to any value other than "none", determines a 3-D volume with
    :type volumeShape: string
    :param volumeSweep: (Q E) Volume sweep of the field  Applies only to sphere, cone, cylinder,
    and torus  Similar effect to the sweep attribute in modelling
    :type volumeSweep: float
    
    :returns: Command result
    :rtype: string
    """
    pass


def IncrementAndSave(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RemoveShrinkWrapTarget(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def character(*args, addElement=None, addOffsetObject="", characterPlug=True, clear=None,
              empty=True, excludeDynamic=True, excludeRotate=True, excludeScale=True,
              excludeTranslate=True, excludeVisibility=True, flatten=None, forceElement=None,
              include=None, intersection=None, isIntersecting=None, isMember=None, library=True,
              memberIndex=0, name="", noWarnings=True, nodesOnly=True, offsetNode=True,
              remove=None, removeOffsetObject="", root="", scheduler=True, split=None,
              subtract=None, text="", union=None, userAlias=None, q=True, query=True, e=True,
              edit=True, **kwargs):
    """
    This command is used to manage the membership of a character  Characters are a type of set
    that gathers together the attributes of a node or nodes that a user wishes to animate as a
    single entity
    
    :param addElement: (E) Adds the list of items to the given character  If some of the items
    cannot be added to the character because they are in another character, the comma
    :type addElement: name
    :param addOffsetObject: (Q E) Indicates that the selected character member objects should
    be used when calculating and applying offsets  The flag argument is used to specify the c
    :type addOffsetObject: string
    :param characterPlug: (Q) Returns the plug on the character that corresponds to the
    specified character member
    :type characterPlug: boolean
    :param clear: (E) An operation which removes all items from the given character
    :type clear: name
    :param empty: (C) Indicates that the character to be created should be empty  (i.e  it
    ignores any arguments identifying objects to be added to the character
    :type empty: boolean
    :param excludeDynamic: (C) When creating the character, exclude dynamic attributes
    :type excludeDynamic: boolean
    :param excludeRotate: (C) When creating the character, exclude rotate attributes from
    transform-type nodes
    :type excludeRotate: boolean
    :param excludeScale: (C) When creating the character, exclude scale attributes from
    transform-type nodes
    :type excludeScale: boolean
    :param excludeTranslate: (C) When creating the character, exclude translate attributes from
    transform-type nodes  For example, if your character contains joints only, perhaps you
    :type excludeTranslate: boolean
    :param excludeVisibility: (C) When creating the character, exclude visibility attribute
    from transform-type nodes
    :type excludeVisibility: boolean
    :param flatten: (E) An operation that flattens the structure of the given character  That
    is, any characters contained by the given character will be replaced by its mem
    :type flatten: name
    :param forceElement: (E) For use in edit mode only  Forces addition of the items to the
    character  If the items are in another character which is in the character partition,
    :type forceElement: name
    :param include: (E) Adds the list of items to the given character  If some of the items
    cannot be added to the character, a warning will be issued  This is a less strict
    :type include: name
    :param intersection: (Q) An operation that returns a list of items which are members of all
    the character in the list  In general, characters should be mutually exclusive
    :type intersection: name
    :param isIntersecting: (Q) An operation which tests whether or not the characters in the
    list have common members  In general, characters should be mutually exclusive, so this
    :type isIntersecting: name
    :param isMember: (Q) An operation which tests whether or not all the given items are
    members of the given character
    :type isMember: name
    :param library: (Q) Returns the clip library associated with this character, if there is
    one  A clip library will only exist if you have created clips on your character
    :type library: boolean
    :param memberIndex: (Q) Returns the memberIndex of the specified character member if used
    after the query flag  Or if used before the query flag, returns the member that cor
    :type memberIndex: int
    :param name: (C) Assigns string as the name for a new character  Valid for operations that
    create a new character
    :type name: string
    :param noWarnings: (C) Indicates that warning messages should not be reported such as when
    trying to add an invalid item to a character  (used by UI)
    :type noWarnings: boolean
    :param nodesOnly: (Q) This flag modifies the results of character membership queries  When
    listing the attributes (e.g  sphere1.tx) contained in the character, list only t
    :type nodesOnly: boolean
    :param offsetNode: (Q) Returns the name of the characterOffset node used to add offsets to
    the root of the character
    :type offsetNode: boolean
    :param remove: (E) Removes the list of items from the given character
    :type remove: name
    :param removeOffsetObject: (E) Indicates that the selected character offset objects should
    be removed as offsets  The flag argument is used to specify the character
    :type removeOffsetObject: string
    :param root: (C) Specifies the transform node which will act as the root of the character
    being created  This creates a characterOffset node in addition to the charac
    :type root: string
    :param scheduler: (Q) Returns the scheduler associated with this character, if there is one
     A scheduler will only exist if you have created clips on your character
    :type scheduler: boolean
    :param split: (C) Produces a new set with the list of items and removes each item in the
    list of items from the given set
    :type split: name
    :param subtract: (Q) An operation between two characters which returns the members of the
    first character that are not in the second character  In general, characters sho
    :type subtract: name
    :param text: (C Q E) Defines an annotation string to be stored with the character
    :type text: string
    :param union: (Q) An operation that returns a list of all the members of all characters
    listed
    :type union: name
    :param userAlias: (Q) Returns the user defined alias for the given attribute on the
    character or and empty string if there is not one  Characters automatically alias the a
    :type userAlias: name
    
    :returns: For creation operations (name of the character that was created or edited)
    :rtype: string
    """
    pass


def SelectAllStrokes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def timeWarp(*args, deleteFrame=0, frame=0.0, g=True, interpType=None, moveFrame=None, q=True,
             query=True, e=True, edit=True, **kwargs):
    """
    This command is used to create a time warp input to a set of animation curves
    
    :param deleteFrame: (E) The flag value indicates the 0-based index of the warp frame to
    delete  This flag can only be used in edit mode
    :type deleteFrame: int
    :param frame: (C Q E M) In create and edit mode, this flag can be used to specify warp
    frames added to the warp operation  In query mode, this flag returns a list of the fra
    :type frame: float
    :param g: (C Q E) In create mode, creates a global time warp node which impacts every
    animated object in the scene  In query mode, returns the global time warp node  N
    :type g: boolean
    :param interpType: (C Q E) This flag can be used to set the interpolation type for a given
    span  Valid interpolation types are linear, easeIn and easeOut  When queried, it retu
    :type interpType: [int, string]
    :param moveFrame: (Q E) This flag can be used to move a singular warp frame  The first
    value specified indicates the 0-based index of the warp frame to move  The second valu
    :type moveFrame: [int, float]
    
    :returns: timeWarp name
    :rtype: string
    """
    pass


def containerTemplate(*args, addBindingSet="", addNames=True, addView="", allKeyable=True,
                      attribute="", attributeList="", baseName="", bindingSetList="",
                      childAnchor=True, delete=True, expandCompounds=True, fromContainer="",
                      fromSelection=True, layoutMode=0, matchName="", parentAnchor=True,
                      publishedNodeList="", removeBindingSet="", removeView="",
                      rootTransform=True, save=True, searchPath="", templateList="",
                      updateBindingSet="", useHierarchy=True, exists=True, fileName="",
                      force=True, load=True, matchFile="", silent=True, unload=True,
                      viewList="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    A container template is a description of a container's published interface  This command
    provides the ability to create and save a template file for a container or load an existing
    template file  Once a template exists, the user can query the template information
    
    :param addBindingSet: (C E) This argument is used to add a new binding set with the given
    name to a template  A default binding set will be created  If the binding set already e
    :type addBindingSet: string
    :param addNames: (E) In edit mode, when used with the fromContainer flag, any published
    name on the container not present as an attribute on the template will be added to
    :type addNames: boolean
    :param addView: (C E) This argument is used to add a new view with the given name to a
    template  By default a view containing a flat list of all template attributes will b
    :type addView: string
    :param allKeyable: (C E) Used when the fromSelection flag is true and fromContainer is
    false  If true we will use all keyable attributes to define the template or the view, i
    :type allKeyable: boolean
    :param attribute: (C E M) If fromSelection is true and allKeyable is false, this attribute
    name will be used to create an attribute item in the template file
    :type attribute: string
    :param attributeList: (C Q E) Used in query mode, returns a list of attributes contained in
    the template definition
    :type attributeList: string
    :param baseName: (C Q) Used in query mode, returns the base name of the template  The
    basename is the template name with any package qualifiers stripped off
    :type baseName: string
    :param bindingSetList: (C Q) Used in query mode, returns a list of all binding sets defined
    on the template
    :type bindingSetList: string
    :param childAnchor: (C Q) This flag can be optionally specified when querying the
    publishedNodeList  The resulting list will contain only childAnchor published nodes
    :type childAnchor: boolean
    :param delete: (C) Delete the specified template and its file  All objects that are
    associated with this template or contained in the same template file will be deleted
    :type delete: boolean
    :param expandCompounds: (C E) This argument is used to determine how compound parent
    attributes and their children will be added to generated views when both are published to
    the
    :type expandCompounds: boolean
    :param fromContainer: (C) This argument is used in create or edit mode to specify a
    container node to be used for generating the template contents  In template creation mode,
    :type fromContainer: string
    :param fromSelection: (C E) If true, we will use the active selection list to create the
    template or the view  If allKeyable is also true then we will create the template from a
    :type fromSelection: boolean
    :param layoutMode: (C) This argument is used to specify the layout mode when creating a
    view  Values correspond as follows: 0: layout in flat list (default when not creatin
    :type layoutMode: int
    :param matchName: (Q) Used in query mode in conjunction with other flags this flag
    specifies an optional template name that is to be matched as part of the query operation
    :type matchName: string
    :param parentAnchor: (C Q) This flag can be optionally specified when querying the
    publishedNodeList  The resulting list will contain only parentAnchor published nodes
    :type parentAnchor: boolean
    :param publishedNodeList: (C Q E) Used in query mode, returns a list of published nodes
    contained in the template definition  By default all published nodes on the template will
    be re
    :type publishedNodeList: string
    :param removeBindingSet: (C E) This argument is used to remove the named binding set from
    the template  The template must be saved before the binding set is permanently removed fro
    :type removeBindingSet: string
    :param removeView: (C E) This argument is used to remove the named view from the template 
    The template must be saved before the view is permanently removed from the template
    :type removeView: string
    :param rootTransform: (C Q) This flag can be optionally specified when querying the
    publishedNodeList  The resulting list will contain only rootTransform published nodes
    :type rootTransform: boolean
    :param save: (C) Save the specified template to a file  If a filename is specified for the
    template, the entire file (and all templates associated with it) will be sa
    :type save: boolean
    :param searchPath: (Q E) The template searchPath is an ordered list of all locations that
    are being searched to locate template files (first location searched to last locatio
    :type searchPath: string
    :param templateList: (Q) Used in query mode, returns a list of all loaded templates  This
    query can be used with optional matchFile and matchName flags  When used with the ma
    :type templateList: string
    :param updateBindingSet: (C E) This argument is used to update an existing binding set with
    new bindings  When used with the fromContainer argument binding set entries with be repl
    :type updateBindingSet: string
    :param useHierarchy: (C E) If true, and the fromSelection flag is set, the selection list
    will expand to include it's hierarchy also
    :type useHierarchy: boolean
    :param exists: (Q) Returns true or false depending upon whether the specified template
    exists  When used with the matchFile argument, the query will return true if the
    :type exists: boolean
    :param fileName: (C Q) Specifies the filename associated with the template  This argument
    can be used in conjunction with load, save or query modes  If no filename is assoc
    :type fileName: string
    :param force: (C) This flag is used with some actions to allow them to proceed with an
    overwrite or destructive operation  When used with load, it will allow an existi
    :type force: boolean
    :param load: () Load an existing template from a file  If a filename is specified for the
    template, the entire file (and all templates in it) will be loaded  If no f
    :type load: boolean
    :param matchFile: (Q) Used in query mode in conjunction with other flags this flag
    specifies an optional file name that is to be matched as part of the query operation  In
    :type matchFile: string
    :param silent: (C Q E) Silent mode will suppress any error or warning messages that would
    normally be reported from the command execution  The return values are unaffected
    :type silent: boolean
    :param unload: (C) Unload the specified template  This action will not delete the
    associated template file if one exists, it merely removes the template definition from
    :type unload: boolean
    :param viewList: (C Q) Used in query mode, returns a list of all views defined on the
    template
    :type viewList: string
    
    :returns: 
    :rtype: None
    """
    pass


def FBXImportSetLockedAttribute(*args, **kwargs):
    """
    
    """
    pass


def CutSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorGraphUpstream(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXImportScaleFactor(*args, **kwargs):
    """
    
    """
    pass


def ToggleTangentDisplay(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dbcount(*args, enabled=True, file="", keyword="", list=True, maxdepth=0, quick=True,
            reset=True, spreadsheet=True, **kwargs):
    """
    The dbcount command is used to print and manage a list of statistics collected for counting
    operations  These statistics are displayed as a list of hits on a particular location in
    code, with added reference information for pointers/strings/whatever  If -reset is not
    specified then statistics are printed
    
    :param enabled: (C) Set the enabled state of the counters ('on' to enable, 'off' to
    disable)  Returns the list of all counters affected
    :type enabled: boolean
    :param file: (C) Destination file of the enabled count objects  Use the special names
    stdout and stderr to redirect to your command window  As well, the special name
    :type file: string
    :param keyword: (C) Print only the counters whose name matches this keyword (default is
    all)
    :type keyword: string
    :param list: (C) List all available counters and their current enabled status  (The only
    thing you can do when counters are disabled.)
    :type list: boolean
    :param maxdepth: (C) Maximum number of levels down to traverse and report  0 is the default
    and it means continue recursing as many times as are requested
    :type maxdepth: int
    :param quick: (C) Display only a summary for each counter type instead of the full details
    :type quick: boolean
    :param reset: (C) Reset all counters back to 0 and remove all but the top level counters 
    Returns the list of all counters affected
    :type reset: boolean
    :param spreadsheet: (C) Display in spreadsheet format instead of the usual nested braces 
    This will include a header row that contains 'Count Level1 Level2 Level3...', makin
    :type spreadsheet: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def PolyExtrudeEdges(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RandomizeFollicles(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def bakePartialHistory(*args, allShapes=True, postSmooth=False, preCache=True,
                       preDeformers=True, prePostDeformers=True, q=True, query=True, e=True,
                       edit=True, **kwargs):
    """
    This command is used to bake sections of the construction history of a shape node when
    possible  A typical usage would be on a shape that has both modelling operations and
    deformers in its history  Using this command with the -prePostDeformers flag will bake the
    modeling portions of the graph, so that only the deformers remain   Note that not all
    m
    
    :param allShapes: (C Q) Specifies that the bake operation should be performed on all shapes
    in the entire scene  By default, only selected objects are baked  If this option
    :type allShapes: boolean
    :param postSmooth: (C Q) Specifies whether or not a smoothing operation should be done on
    skin vertices  This smoothing is only done on vertices that are found to deviate lar
    :type postSmooth: boolean
    :param preCache: (C Q) Specifies baking of any history operations that occur before the
    caching operation, including deformers  In query mode, returns a list of the nodes t
    :type preCache: boolean
    :param preDeformers: (C Q) Specifies baking of any modeling operations in the history that
    occur before the deformers  In query mode, returns a list of the nodes that will be b
    :type preDeformers: boolean
    :param prePostDeformers: (C Q) Specifies baking of all modeling operations in the history
    whether they are before or after the deformers in the history  If neither the -prePostDefo
    :type prePostDeformers: boolean
    
    :returns: name of shapes that were baked
    :rtype: string
    """
    pass


def hotkeyEditor(*args, **kwargs):
    """
    
    """
    pass


def file(*args, absoluteName=True, activate=True, activeProxy=True, add=True, anyModified=True,
         applyTo="", buildLoadSettings=True, channels=True, cleanReference="", command=None,
         compress=True, constraints=True, constructionHistory=True, copyNumberList=True,
         defaultExtensions=True, defaultNamespace=True, deferReference=False, editCommand="",
         errorStatus=True, executeScriptNodes=True, exists=True, expandName=True,
         exportAll=True, exportAnim=True, exportAnimFromReference=True, exportAsReference=True,
         exportAsSegment=True, exportSelected=True, exportSelectedAnim=True,
         exportSelectedAnimFromReference=True, exportSelectedNoReference=True,
         exportSelectedStrict=True, exportSnapshotCallback=None, exportUnloadedReferences=True,
         expressions=True, fileMetaData=True, flushReference="", force=True, groupLocator=True,
         groupName="", groupReference=True, ignoreVersion=True, i=True, importFrameRate=True,
         importReference=True, importTimeRange="", lastFileOption=True, lastTempFile=True,
         list=True, loadAllDeferred=True, loadAllReferences=True, loadNoReferences=True,
         loadReference="", loadReferenceDepth="", loadReferencePreview="", loadSettings="",
         location=True, lockContainerUnpublished=True, lockFile=True, lockReference=True,
         mapPlaceHolderNamespace=None, mergeNamespaceWithParent=True,
         mergeNamespaceWithRoot=True, mergeNamespacesOnClash=True, modified=True,
         moveSelected=True, namespace="", newFile=True, open=True, options="",
         parentNamespace=True, postSaveScript="", preSaveScript="", preserveName=True,
         preserveReferences=True, preview=True, prompt=True, proxyManager="", proxyTag="",
         reference=True, referenceDepthInfo=0, referenceNode="", relativeNamespace="",
         removeDuplicateNetworks=True, removeReference=True, rename="", renameAll=True,
         renameToSave=False, renamingPrefix="", renamingPrefixList=True, replaceName=None,
         resetError=True, returnNewNodes=True, save=True, saveDiskCache="always",
         saveReference=True, saveReferencesUnloaded=True, saveTextures="unlessRef",
         sceneName=True, segment="", selectAll=True, shader=True, sharedNodes="",
         sharedReferenceFile=True, shortName=True, strict=True, swapNamespace=None, type="",
         uiConfiguration=True, unloadReference="", unresolvedName=True, usingNamespaces=True,
         withoutCopyNumber=True, writable=True, q=True, query=True, e=True, edit=True,
         **kwargs):
    """
    Opening, importing, exporting, referencing, saving, or renaming a file   This command needs
    a single main flag that specifies the action to take  Some of the main flags also take
    optional secondary flags to modify that action    The main flags are: cr ea ean ear eas er
    esa es esn ex fr i ir l lr lrp loc ltf mf new o op ot pmt r rdi rn rr rts s sa s
    
    :param absoluteName: (C Q) This is a general flag which can be used to specify the desired
    format for the namespace(s) returned by the command  The absolute name of the namespa
    :type absoluteName: boolean
    :param activate: () This flag is obsolete
    :type activate: boolean
    :param activeProxy: (C) This flag is intended for internal use by Maya during file
    referencing  It specifes which file is the active proxy when the file is loaded when used
    :type activeProxy: boolean
    :param add: (C) When used with selectAll it indicates that the specified items should be
    added to the active list without removing existing items from the active lis
    :type add: boolean
    :param anyModified: (Q) This flag is obsolete  Please use file -q -modified instead
    :type anyModified: boolean
    :param applyTo: (C) When importing or referencing an offline edit file, apply it to to the
    given reference (i.e., determine what <main> gets mapped to)  Specify the refe
    :type applyTo: string
    :param buildLoadSettings: (C) When used with the "o/open" flag it indicates that the
    specified file should be read for reference hierarchy information only  This information
    will
    :type buildLoadSettings: boolean
    :param channels: (C Q) For use with exportSelected to specify whether attached channels
    should be included in the export
    :type channels: boolean
    :param cleanReference: (C) Remove edits from the passed in reference node  The reference
    must be in an unloaded state  To remove a particular type of edit, use the editCommand
    :type cleanReference: string
    :param command: (C Q) Specifies the callback to execute before any file operation  This is
    an internal flag used only in the file format
    :type command: [string, string]
    :param compress: (C) When used with save, it will compress (gzip) the file on output
    :type compress: boolean
    :param constraints: (C Q) For use with exportSelected to specify whether attached
    constraints should be included in the export
    :type constraints: boolean
    :param constructionHistory: (C Q) For use with exportSelected to specify whether attached
    construction history should be included in the export
    :type constructionHistory: boolean
    :param copyNumberList: (Q) When queried, this flag returns a string array containing a
    number that uniquely identifies each instance the file is used
    :type copyNumberList: boolean
    :param defaultExtensions: (C Q) Use the default extensions to rename the files  This
    defaults to true, but is a persistent setting within a given session of Maya, meaning that
    if yo
    :type defaultExtensions: boolean
    :param defaultNamespace: (C) Use the default name space for import and referencing  This is
    an advanced option  If set, then on import or reference, Maya will attempt to place al
    :type defaultNamespace: boolean
    :param deferReference: (C Q) When used in conjunction with the -reference flag, this flag
    determines if the reference is loaded, or if loading is deferred  C: The default is fals
    :type deferReference: boolean
    :param editCommand: (C) For use with cleanReference  Remove only this type of edit 
    Supported edits are: setAttr addAttr deleteAttr connectAttr disconnectAttr and parent
    :type editCommand: string
    :param errorStatus: (Q) Query the error status of the last file read  Returns true if and
    error occurred during the last file read
    :type errorStatus: boolean
    :param executeScriptNodes: (C) If true, allow the appropriate script nodes to execute  If
    false, do not allow any script node scripts to run  For more information, see the document
    :type executeScriptNodes: boolean
    :param exists: (Q) Query if the file exists  Returns true if the file exists
    :type exists: boolean
    :param expandName: (Q) This is a query only flag that can be used to query for the file
    path name of the file
    :type expandName: boolean
    :param exportAll: (C) Export everything into a single file  Returns the name of the
    exported file
    :type exportAll: boolean
    :param exportAnim: (C) Export all animation nodes and animation helper nodes from all
    objects in the scene  The resulting animation export file will contain connections to
    :type exportAnim: boolean
    :param exportAnimFromReference: (C) Export the main scene animation nodes and animation
    helper nodes from all referenced objects  This flag, when used in conjunction with the
    -rfn/refer
    :type exportAnimFromReference: boolean
    :param exportAsReference: (C) Export the selected objects into a reference file with the
    given name  The file is saved on disk during the process  Returns the name of the referenc
    :type exportAsReference: boolean
    :param exportAsSegment: () This flag is obsolete
    :type exportAsSegment: boolean
    :param exportSelected: (C) Export the selected items into the specified file  Returns the
    name of the exported file
    :type exportSelected: boolean
    :param exportSelectedAnim: (C) Export all animation nodes and animation helper nodes from
    the selected objects in the scene  See -ean/exportAnim flag description for details on usa
    :type exportSelectedAnim: boolean
    :param exportSelectedAnimFromReference: (C) Export the main scene animation nodes and
    animation helper nodes from the selected referenced objects  This flag, when used in
    conjunction with the -
    :type exportSelectedAnimFromReference: boolean
    :param exportSelectedNoReference: () This flag is obsolete
    :type exportSelectedNoReference: boolean
    :param exportSelectedStrict: (C) Export the selected items into the specified file  This
    flag differs from exportSelected in that it will only export the nodes that are explicitly
    on
    :type exportSelectedStrict: boolean
    :param exportSnapshotCallback: (C) When specified alongside -ea/exportAll,
    es/exportSelected and -ess/exportSelectedStrict, this flag enables Maya to temporarily
    duplicate the export t
    :type exportSnapshotCallback: [script, string]
    :param exportUnloadedReferences: (C) Only effective when preserveReferences is used  When
    used with the exportAll flag, tells the exporter to include all unloaded references in the
    expor
    :type exportUnloadedReferences: boolean
    :param expressions: (C Q) For use with exportSelected to specify whether attached
    expressions should be included in the export
    :type expressions: boolean
    :param fileMetaData: (Q) This is a query only flag to get the file metadata for audio files
     It returns the referenceTime  This field is only extracted from BWAVE files, for
    :type fileMetaData: boolean
    :param flushReference: (C) This flag will unload the reference file associated with the
    passed reference node, retaining all associated reference nodes and scene files  ** This
    :type flushReference: string
    :param force: (C) Force an action to take place  (new, open, save, remove reference, unload
    reference) Used with removeReference to force remove reference namespace ev
    :type force: boolean
    :param groupLocator: (C) Used only with the -r and the -gr flag  Used to group the output
    of groupReference under a locator
    :type groupLocator: boolean
    :param groupName: (C) Used only with the -gr flag  Optionally used to set the name of the
    transform node that the imported/referenced items will be grouped under
    :type groupName: string
    :param groupReference: (C) Used only with the -r or the -i flag  Used to group all the
    imported/referenced items under a single transform
    :type groupReference: boolean
    :param ignoreVersion: (C) Used to open files with version greater or less than those
    officially supported  Data loss, data corruption or failure to open altogether are all pos
    :type ignoreVersion: boolean
    :param i: (C) Import the specified file  Returns the name of the imported file
    :type i: boolean
    :param importFrameRate: (C) Used only with the -i flag  Used to import the frame rate and
    set it as Maya's frame rate
    :type importFrameRate: boolean
    :param importReference: (C) Remove the encapsulation of the reference around the data
    within the specified file  This makes the contents of the specified file part of the
    curren
    :type importReference: boolean
    :param importTimeRange: (C) Used only with the -i flag  Used to import the time range and
    apply it to Maya's playback range in one of three different ways as specified by the st
    :type importTimeRange: string
    :param lastFileOption: (Q) On query, returns the last option string used by the file
    command
    :type lastFileOption: boolean
    :param lastTempFile: (Q) When queried, this flag returns the temp file name used during
    file save  The temp file will be left in the same directory as the intended file name
    :type lastTempFile: boolean
    :param list: (Q) List all files  Returns a string array of the names of all
    segment/reference files  Duplicates will be removed  So if a file is referenced more than
    :type list: boolean
    :param loadAllDeferred: (C) This flag is obsolete, and has been replaced by the
    loadReferenceDepth flag  When used with the -open flag, determines if the -deferReference
    flag is
    :type loadAllDeferred: boolean
    :param loadAllReferences: (C) This flag is obsolete and has been replaced with the
    loadReferenceDepth flag  When used with the -open flag, this will cause all references to
    be loa
    :type loadAllReferences: boolean
    :param loadNoReferences: (C) This flag is obsolete and has been replaced witht the
    loadReferenceDepth flag  When used with the -open flag, no references will be loaded  When
    used
    :type loadNoReferences: boolean
    :param loadReference: (C Q) This flag loads a file and associates it with the passed
    reference node  If the reference node does not exist, the command will fail  If the file
    is
    :type loadReference: string
    :param loadReferenceDepth: (C) Used to specify which references should be loaded  Valid
    types are "all", "none" and "topOnly", which will load all references, no references and
    top
    :type loadReferenceDepth: string
    :param loadReferencePreview: (C) This flag will perform a special preview-only load of a
    reference file  A preview-only reference file is not completely loaded, but instead is
    partia
    :type loadReferencePreview: string
    :param loadSettings: (C) When used with the "o/open" flag this flag specifies which
    reference load settings should be used  Reference load settings specify which references s
    :type loadSettings: string
    :param location: (Q) Query the location of the given file name
    :type location: boolean
    :param lockContainerUnpublished: (C) Set the unpublised lock state for all containers in
    this file  This will not lock the attributes in the main scene directly, but any file that
    refere
    :type lockContainerUnpublished: boolean
    :param lockFile: (C) Lock or unlock the main scene  Any file referencing this scene will
    automatically lock all attributes and nodes  Also prevents reference edits from b
    :type lockFile: boolean
    :param lockReference: (C) Locks attributes and nodes from the referenced file
    :type lockReference: boolean
    :param mapPlaceHolderNamespace: (C Q E M) Map a placeHolderNamespace to the given reference
     Must be used with the file -i/import, -r/reference flags in create mode  The first string
    is the p
    :type mapPlaceHolderNamespace: [string, string]
    :param mergeNamespaceWithParent: (C) Used with the removeReference flag  When removing a
    file reference and its namespace, move the rest of the namespace content to parent
    namespace  Can
    :type mergeNamespaceWithParent: boolean
    :param mergeNamespaceWithRoot: (C) Used with the removeReference flag  When removing a file
    reference and its namespace, move the rest of the namespace content to root namespace 
    Canno
    :type mergeNamespaceWithRoot: boolean
    :param mergeNamespacesOnClash: (C) Used with the import, reference or edit flags, this
    option will prevent new namespaces from being created when namespaces of the same name
    already ex
    :type mergeNamespacesOnClash: boolean
    :param modified: (C Q) Set the modified state of the entire scene  If the scene is modified
    it will need to be saved before a new file is opened or created  Normally there
    :type modified: boolean
    :param moveSelected: (E) This flag is obsolete
    :type moveSelected: boolean
    :param namespace: (E) The namespace name to use that will group all objects during
    importing and referencing  Change the namespace used to group all the objects from the s
    :type namespace: string
    :param newFile: (C) Initialize the scene  Returns untitled scene with default location
    :type newFile: boolean
    :param open: (C) Open the specified file  Returns the name of the opened file
    :type open: boolean
    :param options: (C Q) Set/query the currently set file options  file options are used while
    saving a maya file  Two file option flags supported in current file command are
    :type options: string
    :param parentNamespace: (Q) Returns the name(s) of a referenced file's parent namespaces
    :type parentNamespace: boolean
    :param postSaveScript: (C) When used with the save flag, the specified script will be
    executed after the file is saved
    :type postSaveScript: string
    :param preSaveScript: (C) When used with the save flag, the specified script will be
    executed before the file is saved
    :type preSaveScript: string
    :param preserveName: (C) When used with compress, it will retain the regular extension
    rather than appending .gz
    :type preserveName: boolean
    :param preserveReferences: (C) Modifies the various import/export flags such that
    references are imported/exported as actual references rather than copies of those
    references
    :type preserveReferences: boolean
    :param preview: (C) Used in conjunction with any of the -exportXXX flags, causes Maya to
    return a list of the nodes that would be exported, without actually writing the
    :type preview: boolean
    :param prompt: (C Q) This flag controls the display of file prompting dialogs  Some
    examples of file prompting dialogs include error messages that require user confirmati
    :type prompt: boolean
    :param proxyManager: (C) When a one or more proxy references are added to an existing file
    reference, the proxy manage node is used to define the proxies associated with that
    :type proxyManager: string
    :param proxyTag: (C) This flag is intended for internal use only during file load or
    preload  Proxy tags are names you assign to proxy references to more easily manage th
    :type proxyTag: string
    :param reference: (Q) Create a reference to the specified file  Returns the name of the
    file referenced  Query all file references from the specified file
    :type reference: boolean
    :param referenceDepthInfo: (C) This flag is used to store reference loading preferences
    associated with a Maya ascii file (.ma)  This flag is only useful during file I/O so users
    s
    :type referenceDepthInfo: int
    :param referenceNode: (Q) This flag is only used during queries  In MEL, if it appears
    before -query then it must be followed by the name of one of the scene's reference nodes
    :type referenceNode: string
    :param relativeNamespace: (C) This flag can be used with the exportSelected,
    exportSelectedStrict and exportAll operations to specify that the nodes in the exported
    file are to be
    :type relativeNamespace: string
    :param removeDuplicateNetworks: (C) When set, Maya will remove imported networks if the
    same network is also detected in the current scene  You can explicitly specify that certain
    types
    :type removeDuplicateNetworks: boolean
    :param removeReference: (C) Remove the given file reference from its parent  This will also
    Remove everything this file references  Returns the name of the file removed  If the
    :type removeReference: boolean
    :param rename: (C) Rename the scene  Used mostly during save to set the saveAs name 
    Returns the new name of the scene
    :type rename: string
    :param renameAll: (C) If true, rename all newly-created nodes, not just those whose names
    clash with existing nodes  Only available with -i/import
    :type renameAll: boolean
    :param renameToSave: (C Q) If true, the scene will need to be renamed before it can be
    saved  When queried this flag returns true if the scene must be renamed before it can be
    :type renameToSave: boolean
    :param renamingPrefix: (C Q) The string to use as a prefix for all objects from this file 
    This flag has been replaced by -ns/namespace
    :type renamingPrefix: string
    :param renamingPrefixList: (Q) This flag returns a list of all of the renaming prefixes
    used by the file
    :type renamingPrefixList: boolean
    :param replaceName: (C Q E M) Define a search and replace string  Will apply search and
    replace to leaf node names  The search string can include namespaces and wild-cards, but
    wi
    :type replaceName: [string, string]
    :param resetError: (C) Turn off any pre-existing global file errors
    :type resetError: boolean
    :param returnNewNodes: (C) Used to control the return value in open, import, loadReference,
    and reference operations  It will force the file command to return a list of new nod
    :type returnNewNodes: boolean
    :param save: (C) Save the specified file  Returns the name of the saved file
    :type save: boolean
    :param saveDiskCache: (C Q) This flag sets the saveAs option for Jiggle disk caches  The
    valid inputs are "always" - always copy a file texture to a new location, "never" - do n
    :type saveDiskCache: string
    :param saveReference: (C) Save reference node edits and connections to reference file  This
    includes newly added history and animation, provided that these do not apply to any
    :type saveReference: boolean
    :param saveReferencesUnloaded: (C) This flag can only be used in conjunction with the save
    flag  It specifies that the saved file will be saved with all references unloaded
    :type saveReferencesUnloaded: boolean
    :param saveTextures: (C Q) This flag sets the saveAs option for 3d Paint file textures  The
    valid inputs are "always" - always copy a file texture to a new location, "unlessRef
    :type saveTextures: string
    :param sceneName: (Q) return the name of the current scene
    :type sceneName: boolean
    :param segment: () This flag is obsolete
    :type segment: string
    :param selectAll: (C) Select all the components of this file as well as its child files 
    Note that the file specified must be one that is already opened in this Maya sessi
    :type selectAll: boolean
    :param shader: (C Q) For use with exportSelected to specify whether attached shaders should
    be included in the export
    :type shader: boolean
    :param sharedNodes: (C M) This flag modifies the '-r/reference' flag to indicate that
    certain types of nodes within that reference should be treated as shared nodes  All share
    :type sharedNodes: string
    :param sharedReferenceFile: (C) Can only be used in conjunction with the -r/reference flag
    and the -ns/namespace flag (there is no prefix support)  This flag modifies the '-r/refere
    :type sharedReferenceFile: boolean
    :param shortName: (Q) When used with a main query flag it indicates that the file name
    returned will be the short name (i.e., just a file name without any directory paths)
    :type shortName: boolean
    :param strict: (C) Set strict file path resolution  If true, all paths will be matched
    exactly, both relative and absolute  Relative paths will be considered relative t
    :type strict: boolean
    :param swapNamespace: (C M) Can only be used in conjunction with the -r/reference or
    -i/import flags  This flag will replace any occurrences of a given namespace to an
    alternate
    :type swapNamespace: [string, string]
    :param type: (C Q) Set the type of this file  By default this can be any one of:
    "mayaAscii", "mayaBinary", "mel", "OBJ", "directory", "plug-in", "audio", "move", "EPS"
    :type type: string
    :param uiConfiguration: (C Q) Save the ui configuration with the scene in a uiConfiguration
    script node  (eg  panes, etc.) The current default is on and is set in initialStartup.m
    :type uiConfiguration: boolean
    :param unloadReference: (C) This flag will unload the reference file associated with the
    passed reference node
    :type unloadReference: string
    :param unresolvedName: (Q) When used with a main query flag it indicates that the file name
    returned will be unresolved (i.e., it will be the path originally specified when the
    :type unresolvedName: boolean
    :param usingNamespaces: (Q) Returns boolean  Queries whether the specified reference file
    uses namespaces or renaming prefixes
    :type usingNamespaces: boolean
    :param withoutCopyNumber: (Q) When used with a main query flag it indicates that the file
    name returned will not have a copy number appended to the end  If this flag is not presen
    :type withoutCopyNumber: boolean
    :param writable: (Q) Query whether the given file is writable in the current scene  For
    main scene files this indicates writable to the file system by the current user  F
    :type writable: boolean
    
    :returns: The name of the specified file for most actions. When the returnNewNodes flag is
    used, an array of strings will be returned indicating the names of the nodes that were
    read.
    :rtype: string
    """
    pass


def polyRemesh(*args, caching=True, constructionHistory=True, interpolationType=0, name="",
               nodeState=0, reduceThreshold=0.0, refineThreshold=0.0, smoothStrength=0.0,
               tessellateBorders=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Triangulates, then remeshes the given mesh through edge splitting and collapsing  Edges
    longer than the specified refinement threshold are split, and edges shorter than the
    reduction threshold are collapsed
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param interpolationType: (C Q E) Algorithm used for interpolating new vertices
    :type interpolationType: int
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param reduceThreshold: (C Q E) A percentage of the refineThreshold  Edges shorter than
    this percentage will be reduced to a single vertex
    :type reduceThreshold: float
    :param refineThreshold: (C Q E) Triangle edges longer than this value will be split into
    two edges
    :type refineThreshold: float
    :param smoothStrength: (C Q E) Amount of smoothing applied to the vertices after remeshing
    :type smoothStrength: float
    :param tessellateBorders: (C Q E) Specifies if the borders of the selected region are
    allowed to be remeshed
    :type tessellateBorders: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def BevelOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AffectSelectedObject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def QuadrangulateOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def inViewEditor(*args, visible=True, q=True, query=True, **kwargs):
    """
    Mel access to the In-View Editor  In-View Editors display a customizable subset of a node's
    attributes, letting you adjust attributes directly in a scene instead of opening the
    Channel Box or Attribute Editor
    
    :param visible: (C Q) Shows/hides the In-View Editor outside the Show Manips context
    :type visible: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def poseInterpolator(*args, **kwargs):
    """
    
    """
    pass


def lockNode(*args, ignoreComponents=True, lock=True, lockName=True, lockUnpublished=True,
             q=True, query=True, **kwargs):
    """
    Locks or unlocks one or more dependency nodes  A locked node is restricted in the following
    ways:  It may not be deleted  It may not be renamed  Its parenting may not be changed 
    Attributes may not be added to or removed from it  Locked attributes may not be unlocked 
    Unlocked attributes may not be locked    Note that an unlocked attribute of a loc
    
    :param ignoreComponents: (C Q) Normally, the presence of a component in the list of objects
    to be locked will cause the command to fail with an error  But if this flag is supplied
    :type ignoreComponents: boolean
    :param lock: (C Q) Specifies the new lock state for the node  The default is true
    :type lock: boolean
    :param lockName: (C Q) Specifies the new lock state for the node's name
    :type lockName: boolean
    :param lockUnpublished: (C Q) Used in conjunction with the lock flag  On a container, lock
    or unlock all unpublished attributes on the members of the container  For non-containers
    :type lockUnpublished: boolean
    
    :returns: For query execution.
    :rtype: boolean[]
    """
    pass


def dgInfo(*args, allNodes=True, connections=True, dirty=True, nodes=True, nonDeletable=True,
           outputFile="", propagation=True, short=True, size=True, subgraph=True, type="",
           **kwargs):
    """
    This command prints information about the DG in plain text  The scope of the information
    printed is the entire graph if the all flag is used, the nodes/plugs on the command line if
    they were specified, and the selection list, in that order  Each plug on a connection will
    have two pieces of state information displayed together at the end of the line
    
    :param allNodes: (C) Use the entire graph as the context
    :type allNodes: boolean
    :param connections: (C) Print the connection information
    :type connections: boolean
    :param dirty: (C) Only print dirty/clean nodes/plugs/connections  Default is both
    :type dirty: boolean
    :param nodes: (C) Print the specified nodes (or the entire graph if -all is used)
    :type nodes: boolean
    :param nonDeletable: (C) Include non-deletable nodes as well (normally not of interest)
    :type nonDeletable: boolean
    :param outputFile: (C) Send the output to the file FILE instead of STDERR
    :type outputFile: string
    :param propagation: (C) Only print propagating/not propagating nodes/plugs/connections 
    Default is both
    :type propagation: boolean
    :param short: (C) Print using short format instead of long
    :type short: boolean
    :param size: (C) Show datablock sizes for all specified nodes  Return value is tuple of all
    selected nodes (NumberOfNodes, NumberOfDatablocks, TotalDatablockMemory)
    :type size: boolean
    :param subgraph: (C) Print the subgraph affected by the node or plugs (or all nodes in the
    graph grouped in subgraphs if -all is used)
    :type subgraph: boolean
    :param type: (C) Filter output to only show nodes of type NODETYPE
    :type type: string
    
    :returns: 
    :rtype: None
    """
    pass


def UnpublishParentAnchor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OpenSceneOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_slideEdge(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def cMuscleQuery(*args, **kwargs):
    """
    
    """
    pass


def headsUpMessage(*args, horizontalOffset=0, object="", selection=True, time=0.0,
                   uvTextureEditor=True, verticalOffset=0, viewport=True, **kwargs):
    """
    This command draws a message in the 3d view  The message is automatically erased at the
    next screen refresh
    
    :param horizontalOffset: (C) If this flag is specified, the message will appear the
    specified distance (in pixels) to the right of the point  Otherwise, a default horizontal
    offs
    :type horizontalOffset: int
    :param object: (C) If an object is specified, then the message is drawn just above the
    object's bounding-box centre point  If this flag is not specified, or the object
    :type object: string
    :param selection: (C) If this flag is specified, the message will be centred among the
    currently selected objects  This flag does nothing if the object flag is also specif
    :type selection: boolean
    :param time: (C) If this flag is specified, the message will be displayed for a minimum of
    the given amount of time (in seconds)  Otherwise a default time of 1.0 seco
    :type time: float
    :param uvTextureEditor: (C) Should the HUD be shown in the UV Texture Editor?
    :type uvTextureEditor: boolean
    :param verticalOffset: (C) If this flag is specified, the message will appear the specified
    distance (in pixels) above the point  Otherwise, a default vertical offset of 0 pixe
    :type verticalOffset: int
    :param viewport: (C) Should the HUD be shown in the viewport?
    :type viewport: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def MakeBrushSpring(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MatchScaling(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Art3dPaintToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def InTangentLinear(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def keyframeRegionCurrentTimeCtx(*args, exists=True, history=True, image1="", image2="",
                                 image3="", name="", q=True, query=True, e=True, edit=True,
                                 **kwargs):
    """
    This command creates a context which may be used to change current time within the keyframe
    region of the dope sheet editor
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: Context name
    :rtype: string
    """
    pass


def FBXExportTriangulate(*args, **kwargs):
    """
    
    """
    pass


def keyframeRegionMoveKeyCtx(*args, exists=True, history=True, image1="", image2="", image3="",
                             name="", option="", q=True, query=True, e=True, edit=True,
                             **kwargs):
    """
    This command creates a context which may be used to move keyframes within the keyframe
    region of the dope sheet editor
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param option: (C Q E) Valid values are "move," "insert," "over," and "segmentOver" 
    Specifies the keyframe -option to use  When you "move" a key, the key will not cross ov
    :type option: string
    
    :returns: Context name
    :rtype: string
    """
    pass


def RadialOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AlembicHelp(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UpdateCurrentSceneMotionBuilder(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PaintEffectsMeshQuality(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyToCurve(*args, **kwargs):
    """
    
    """
    pass


def ptexBake(*args, **kwargs):
    """
    
    """
    pass


def xgmInterpSetup(*args, **kwargs):
    """
    
    """
    pass


def showSelectionInTitle(*args, **kwargs):
    """
    This command causes the title of the window specified as an argument to be linked to the
    current file and selection  When selection changes, the window title will change to show
    the current file name and the name of the last selected object
    
    
    :returns: 
    :rtype: None
    """
    pass


def DeleteAllNRigids(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HIKGetRemoteCharacterList(*args, **kwargs):
    """
    
    """
    pass


def BatchRender(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectContiguousEdgesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmPointsContext(*args, **kwargs):
    """
    
    """
    pass


def TransferAttributes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateSubCharacterOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_vertSelectLocked(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def currentCtx(*args, **kwargs):
    """
    This command returns the currently selected tool context
    
    
    :returns: : The name of the currently selected tool context.
    :rtype: string
    """
    pass


def polySelectConstraintMonitor(*args, changeCommand=None, create=True, delete=True, **kwargs):
    """
    Manage the window to display/edit the polygonal selection constraint parameters
    
    :param changeCommand: (C) Specifies the mel callback to refresh the window  First argument
    is the callback, second is the window name
    :type changeCommand: [string, string]
    :param create: (C) Specifies the Monitor should be created
    :type create: boolean
    :param delete: (C) Specifies that the Monitor should be removed
    :type delete: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def texSmudgeUVContext(*args, dragSlider="", effectType="", exists=True, functionType="",
                       history=True, image1="", image2="", image3="", name="", pressure=0.0,
                       radius=0.0, smudgeIsMiddle=True, q=True, query=True, e=True, edit=True,
                       **kwargs):
    """
    This command creates a context for smudge UV tool  This context only works in the texture
    UV editor
    
    :param dragSlider: (Q E) radius | none Enables the drag slider mode  This is to support
    brush resizing while holding the 'b' or 'B' button
    :type dragSlider: string
    :param effectType: (Q E) fixed | smudge Specifies the effect of the tool  In fixed mode,
    the UVs move as if they are attached by a rubber band  In smudge mode the UVs are mov
    :type effectType: string
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param functionType: (Q E) exponential | linear | constant  Specifies how UVs fall off from
    the center of influence
    :type functionType: string
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param pressure: (Q E) Pressure value when effect type is set to smudge
    :type pressure: float
    :param radius: (Q E) Radius of the smudge tool  All UVs within this radius are affected by
    the tool
    :type radius: float
    :param smudgeIsMiddle: (Q E) By default, the left mouse button initiates the smudge 
    However, this conflicts with selection  When smudgeIsMiddle is on, smudge mode is activated
    b
    :type smudgeIsMiddle: boolean
    
    :returns: Name of the effect type created.
    :rtype: string
    """
    pass


def PoseInterpolatorNewGroup(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_disableTexturesTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def arnoldBakeGeo(*args, **kwargs):
    """
    
    """
    pass


def curve(*args, append=True, bezier=True, degree=3, editPoint=None, knot=0.0, name="",
          objectSpace=True, periodic=True, point=None, pointWeight=None, replace=True,
          worldSpace=True, **kwargs):
    """
    The curve command creates a new curve from a list of control vertices (CVs)  A string is
    returned containing the pathname to the newly created curve  You can create a curve from
    points either in world space or object (local) space, either with weights or without  You
    can replace an existing curve by using the "-r/replace" flag  You can append a poi
    
    :param append: (C) Appends point(s) to the end of an existing curve  If you use this flag,
    you must specify the name of the curve to append to, at the end of the comman
    :type append: boolean
    :param bezier: (C) The created curve will be a bezier curve
    :type bezier: boolean
    :param degree: (C) The degree of the new curve  Default is 3  Note that you need (degree+1)
    curve points to create a visible curve span  eg  you must place 4 points for
    :type degree: float
    :param editPoint: (C M) The x, y, z position of an edit point  "linear" means that this
    flag can take values with units  This flag can not be used with the -point or the -po
    :type editPoint: [float, float, float]
    :param knot: (C M) A knot value in a knot vector  One flag per knot value  There must be
    (numberOfPoints + degree - 1) knots and the knot vector must be non-decreasing
    :type knot: float
    :param name: (C) Name of the curve
    :type name: string
    :param objectSpace: (C) Points are in object, or "local" space  This is the default  You
    cannot specify both "-os" and "-ws" in the same command
    :type objectSpace: boolean
    :param periodic: (C) If on, creates a curve that is periodic  Default is off
    :type periodic: boolean
    :param point: (C M) The x, y, z position of a point  "linear" means that this flag can take
    values with units
    :type point: [float, float, float]
    :param pointWeight: (C M) The x,y,z and w values of a point, where the w is a weight value 
    A rational curve will be created if this flag is used  "linear" means that this fla
    :type pointWeight: [float, float, float, float]
    :param replace: (C) Replaces an entire existing curve  If you use this flag, you must
    specify the name of the curve to replace, at the end of the command  (See examples
    :type replace: boolean
    :param worldSpace: (C) Points are in world space  The default is "-os"  You cannot specify
    both "-os" and "-ws" in the same command
    :type worldSpace: boolean
    
    :returns: The path to the new curve or the replaced curve
    :rtype: string
    """
    pass


def HypershadeDisplayAsIcons(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SplitEdge(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def LayoutUVAlongOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CleanupPolygonOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dollyCtx(*args, alternateContext=True, boxDollyType="", centerOfInterestDolly=True,
             dollyTowardsCenter=True, exists=True, history=True, image1="", image2="",
             image3="", localDolly=True, name="", orthoZoom=True, scale=0.0, toolName="",
             q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command can be used to create, edit, or query a dolly context
    
    :param alternateContext: (C Q) Set the ALT+MMB and ALT+SHIFT+MMB to refer to this context
    :type alternateContext: boolean
    :param boxDollyType: (C Q E) Set the behavior of where the camera's center of interest is
    set to after the box dolly  In surface mode, the center of interest will be snapped to t
    :type boxDollyType: string
    :param centerOfInterestDolly: (C Q E) Set the translate the camera's center of interest 
    Left and right drag movements with the mouse will translate the center of interest towards
    or away
    :type centerOfInterestDolly: boolean
    :param dollyTowardsCenter: (C Q E) Dolly towards center (if true), else dolly towards point
    where user clicks in the view
    :type dollyTowardsCenter: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param localDolly: (C Q E) Dolly with respect to the camera's center of interest  The
    camera will not pass through the center of interest  Local dolly only applies to perspecti
    :type localDolly: boolean
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param orthoZoom: (C Q E) Zoom orthographic view (if true), else dolly orthographic camera 
    Default value is true
    :type orthoZoom: boolean
    :param scale: (C Q E) The sensitivity for dollying the camera
    :type scale: float
    :param toolName: (C Q) Name of the specific tool to which this command refers
    :type toolName: string
    
    :returns: The name of the context
    :rtype: string
    """
    pass


def DisplayShaded(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSplineCacheImportOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def buildKeyframeMenu(*args, **kwargs):
    """
    This command handles building the "dynamic" Keyframe menu, to show attributes of currently
    selected objects, filtered by the current manipulator   menuName is the string returned by
    the "menu" command  The target menu will entries appended to it (and deleted from it) to
    always show what's currently keyframable
    
    
    :returns: 
    :rtype: None
    """
    pass


def OrientConstraint(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def renderSetupSwitchVisibleRenderLayer(*args, **kwargs):
    """
    
    """
    pass


def dR_viewTop(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HairUVSetLinkingEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def saveAllShelves(*args, **kwargs):
    """
    This command writes all shelves that are immediate children of the specified control layout
    to the prefs directory
    
    
    :returns: True if successful, otherwise issues an error message and returns false.
    :rtype: boolean
    """
    pass


def TexSculptDeactivateBrushStrength(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DistributeShells(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteAllNonLinearDeformers(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SavePreferences(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreatePolygonHelixOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RemoveWrapInfluence(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PickWalkLeft(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MakeCurvesDynamic(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dbPeek(*args, **kwargs):
    """
    
    """
    pass


def SelectAllSculptObjects(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateParticleDiskCacheOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectCurveCVsFirst(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ChannelControlEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateDagContainer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddMissingFBIKEffectorsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ConvertToKey(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectAllIKHandles(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def deleteHistoryAheadOfGeomCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ResetWire(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def pointConstraint(*args, layer="", maintainOffset=True, name="", offset=None, remove=True,
                    skip="", targetList=True, weight=0.0, weightAliasList=True, q=True,
                    query=True, e=True, edit=True, **kwargs):
    """
    Constrain an object's position to the position of the target object or to the average
    position of a number of targets   A pointConstraint takes as input one or more "target" DAG
    transform nodes at which to position the single "constraint object" DAG transform node  The
    pointConstraint positions the constrained object at the weighted average of the 
    
    :param layer: (C E) Specify the name of the animation layer where the constraint should be
    added
    :type layer: string
    :param maintainOffset: (C) The offset necessary to preserve the constrained object's
    initial position will be calculated and used as the offset
    :type maintainOffset: boolean
    :param name: (C Q E) Sets the name of the constraint node to the specified name  Default
    name is constrainedObjectName_constraintType
    :type name: string
    :param offset: (C Q E) Sets or queries the value of the offset  Default is 0,0,0
    :type offset: [float, float, float]
    :param remove: (E) removes the listed target(s) from the constraint
    :type remove: boolean
    :param skip: (C E M) Specify the axis to be skipped  Valid values are "x", "y", "z" and
    "none"  During creation, "none" is the default  This flag is multi-use
    :type skip: string
    :param targetList: (Q) Return the list of target objects
    :type targetList: boolean
    :param weight: (C Q E) Sets the weight value for the specified target(s)  If not given at
    creation time, the default value of 1.0 is used
    :type weight: float
    :param weightAliasList: (Q) Returns the names of the attributes that control the weight of
    the target objects  Aliases are returned in the same order as the targets are returned
    :type weightAliasList: boolean
    
    :returns: Name of the created constraint node
    :rtype: string[]
    """
    pass


def dR_quadDrawClearDots(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SculptMeshFrame(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BaseLevelComponentDisplay(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateDagContainerOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def testPassContribution(*args, **kwargs):
    """
    
    """
    pass


def SetMeshMaskTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def showShadingGroupAttrEditor(*args, q=True, query=True, **kwargs):
    """
    The showShadingGroupAttrEditor command opens up the attribute editor for the current
    object's shading-group information
    
    
    :returns: true if a shading group is displayed, otherwise false.
    :rtype: boolean
    """
    pass


def createPtexUV(*args, **kwargs):
    """
    
    """
    pass


def selectedNodes(*args, **kwargs):
    """
    
    """
    pass


def HideUIElements(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PaintEffectsWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def createMeshFromPoints(*args, **kwargs):
    """
    
    """
    pass


def FourViewLayout(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RemoveBifrostKillplane(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UVEditorFrameSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeTransferAttributeValues(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateLatticeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Unfold3DContext(*args, **kwargs):
    """
    
    """
    pass


def PolyConvertToLoopAndDuplicate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSetClumpBrushToolOption(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GraphCopy(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GetHIKChildCount(*args, **kwargs):
    """
    
    """
    pass


def AddBlendShapeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OneClickGetState(*args, **kwargs):
    """
    
    """
    pass


def dR_mtkPanelTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OutlinerToggleAttributes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def EditCharacterAttributes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SimplifyCurveOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolySpinEdgeBackward(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSplineCacheImport(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddDynamicBuoyOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExtrudeFace(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def resolutionNode(*args, name="", parent="", shared=True, skipSelect=True, **kwargs):
    """
    This command creates a new node in the dependency graph of the specified type   The
    resolutionNode creates a render resolution node and registers it with the model  The
    createNode command will not register nodes of this type correctly
    
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param parent: (C) Specifies the parent in the DAG under which the new node belongs
    :type parent: string
    :param shared: (C) This node is shared across multiple files, so only create it if it does
    not already exist
    :type shared: boolean
    :param skipSelect: (C) This node is not to be selected after creation, the original
    selection will be preserved
    :type skipSelect: boolean
    
    :returns: The name of the new node.
    :rtype: string
    """
    pass


def polyCutCtx(*args, deleteFaces=False, exists=True, extractFaces=False, extractOffset=None,
               image1="", image2="", image3="", q=True, query=True, e=True, edit=True,
               **kwargs):
    """
    Create a new context to cut facets on polygonal objects
    
    :param deleteFaces: (C Q E) whether to delete the one-half of the cut-faces of the poly  If
    true, they are deleted  Default: false
    :type deleteFaces: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param extractFaces: (C Q E) whether to extract the cut-faces of the poly into a separate
    shell  If true, they are extracted  Default: false
    :type extractFaces: boolean
    :param extractOffset: (C Q E) The displacement offset of the cut faces  Default: 0.5, 0.5,
    0.5
    :type extractOffset: [float, float, float]
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    
    :returns: 
    :rtype: None
    """
    pass


def SelectAllParticles(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleFaceIDs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyAverageNormal(*args, allowZeroNormal=True, distance=0.0, postnormalize=True,
                      prenormalize=True, replaceNormalXYZ=None, **kwargs):
    """
    Set normals of vertices or vertex-faces to an average value when the vertices within a
    given threshold  First, it sorts out the containing edges, and set them to be soft, if it
    is possible, so to let the normals appear to be "merged"  The remained components then are
    sorted into lumps where vertices in each lump are within the given threshold  For 
    
    :param allowZeroNormal: (C) Specifies whether to allow zero normals to be created  By
    default it is false  If it is false, replaceNormal is needed
    :type allowZeroNormal: boolean
    :param distance: (C) Specifies the distance threshold  All vertices within the threshold
    are considered when computing an average normal  By default it is 0.0
    :type distance: float
    :param postnormalize: (C) Specifies whether to normalize the resulting normals  By default
    it is true
    :type postnormalize: boolean
    :param prenormalize: (C) Specifies whether to normalize the normals before averaging  By
    default it is true
    :type prenormalize: boolean
    :param replaceNormalXYZ: (C) If the allowZeroNormal is false, this value is used to replace
    the zero normals  By default it is (1, 0, 0)
    :type replaceNormalXYZ: [float, float, float]
    
    :returns: of the node name.
    :rtype: string
    """
    pass


def MirrorSkinWeights(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmPromoteRender(*args, **kwargs):
    """
    
    """
    pass


def RemoveBifrostEmissionRegion(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleMaterialLoadingDetailsVisibility(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AutoPaintMarkingMenu(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def overrideModifier(*args, clear=True, press="", release="", **kwargs):
    """
    This command allows you to assign modifier key behaviour to other parts of the system  For
    example you can use a hotkey or input device instead of a modifer key to perform the same
    action   Note that the original modifier key behaviour is not altered in anyway  For
    example, if you've assigned "Ctrl" key behaviour to the "c" key then the "Ctrl" key 
    
    :param clear: (C) Don't force any modifier keys
    :type clear: boolean
    :param press: (C M) Force the following modifier to be pressed  Valid values are "Alt",
    "Ctrl", "Shift"
    :type press: string
    :param release: (C M) Force the following modifier to be released  Valid values are "Alt",
    "Ctrl", "Shift"
    :type release: string
    
    :returns: 
    :rtype: None
    """
    pass


def FBXExportBakeResampleAnimation(*args, **kwargs):
    """
    
    """
    pass


def SelectAllFollicles(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GpuCacheImportOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PositionAlongCurve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def movOut(*args, comment=False, file="", precision=6, time=None, **kwargs):
    """
    Exports a .mov file from the listed attributes  Valid attribute types are numeric
    attributes; time attributes; linear attributes; angular attributes; compound attributes
    made of the types listed previously; and multi attributes composed of the types listed
    previously   Length, angle, and time values will be written to the file in the user units  
    I
    
    :param comment: (C) If true, the attributes written to the .mov file will be listed in a
    commented section at the top of the .mov file  The default is false
    :type comment: boolean
    :param file: (C) The name of the .mov file  If no extension is used, a .mov will be added
    :type file: string
    :param precision: (C) Sets the number of digits to the right of the decimal place in the
    .mov file  C: The default is 6
    :type precision: int
    :param time: (C) The time range to save as a .mov file  The default is the current time
    range
    :type time: timerange
    
    :returns: 
    :rtype: None
    """
    pass


def align(*args, alignToLead=False, coordinateSystem=None, xAxis="", yAxis="", zAxis="",
          **kwargs):
    """
    Align or spread objects along X Y and Z axis
    
    :param alignToLead: (C) When set, the min, center or max values are computed from the lead
    object  Otherwise, the values are averaged for all objects  Default is false
    :type alignToLead: boolean
    :param coordinateSystem: (C) Defines the X, Y, and Z coordinates  Default is the world
    coordinates
    :type coordinateSystem: name
    :param xAxis: (C) Any of none, min, mid, max, dist, stack  This defines the kind of
    alignment to perfom, default is none
    :type xAxis: string
    :param yAxis: (C) Any of none, min, mid, max, dist, stack  This defines the kind of
    alignment to perfom, default is none
    :type yAxis: string
    :param zAxis: (C) Any of none, min, mid, max, dist, stack  This defines the kind of
    alignment to perfom, default is none
    :type zAxis: string
    
    :returns: true/false
    :rtype: boolean
    """
    pass


def blendShape(*args, after=True, afterReference=True, automatic=True, before=True,
               copyDelta=None, copyInBetweenDelta=None, deformerTools=True, envelope=1.0,
               exclusive="", export="", exportTarget=None, flipTarget=None, frontOfChain=True,
               geometry="", geometryIndices=True, ignoreSelected=True, ip="", inBetween=True,
               inBetweenIndex=0, inBetweenType="", includeHiddenSelections=False, mergeSource=0,
               mergeTarget=0, mirrorDirection=0, mirrorTarget=None, name="",
               normalizationGroups=True, origin="", parallel=True, prune=True, remove=True,
               resetTargetDelta=None, split=True, suppressDialog=True, symmetryAxis="",
               symmetryEdge="", symmetrySpace=0, tangentSpace=True, target=None,
               topologyCheck=True, transform="", weight=None, weightCount=0, q=True, query=True,
               e=True, edit=True, **kwargs):
    """
    This command creates a blendShape deformer, which blends in specified amounts of each
    target shape to the initial base shape  Each base shape is deformed by its own set of
    target shapes  Every target shape has an index that associates it with one of the shape
    weight values.
    
    :param after: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type after: boolean
    :param afterReference: (C E) The -afterReference flag is used to specify deformer ordering
    in a hybrid way that choses between -before and -after automatically  If the geometry b
    :type afterReference: boolean
    :param automatic: (C E) The -automatic flag is used to specify deformer ordering in a way
    that choses between -frontOfChain and -before automatically  If the geometry being
    :type automatic: boolean
    :param before: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type before: boolean
    :param copyDelta: (E) Set the base, source, and destination delta index values
    :type copyDelta: [int, int, int]
    :param copyInBetweenDelta: (E) Set the base, target, source, and destination delta index
    values
    :type copyInBetweenDelta: [int, int, int, int]
    :param deformerTools: (Q) Returns the name of the deformer tool objects (if any) as string
    string ..
    :type deformerTools: boolean
    :param envelope: (C Q E) Set the envelope value for the deformer, controlling how much of
    the total deformation gets applied  Default is 1.0
    :type envelope: float
    :param exclusive: (C Q) Puts the deformation set in a deform partition
    :type exclusive: string
    :param export: (E) Export the shapes to the named file path
    :type export: string
    :param exportTarget: (E M) Specify the base and target index pairs for the export
    :type exportTarget: [int, int]
    :param flipTarget: (E M) Flip the list of base and target pairs
    :type flipTarget: [int, int]
    :param frontOfChain: (C E) This command is used to specify that the new deformer node
    should be placed ahead (upstream) of existing deformer and skin nodes in the shape's histo
    :type frontOfChain: boolean
    :param geometry: (Q E M) The specified object will be added to the list of objects being
    deformed by this deformer object, unless the -rm flag is also specified  When queried
    :type geometry: string
    :param geometryIndices: (Q) Complements the -geometry flag in query mode  Returns the multi
    index of each geometry
    :type geometryIndices: boolean
    :param ignoreSelected: (C) Tells the command to not deform objects on the current selection
    list
    :type ignoreSelected: boolean
    :param ip: (E) Import the shapes from the named file path
    :type ip: string
    :param inBetween: (C E) Indicate that the specified target should serve as an inbetween  An
    inbetween target is one that serves as an intermediate target between the base sh
    :type inBetween: boolean
    :param inBetweenIndex: (E) Only used with the -rtd/-resetTargetDelta flag to remove delta
    values for points in the inbetween target geometry defined by this index
    :type inBetweenIndex: int
    :param inBetweenType: (C E) Specify if the in-between target to be created is relative to
    the hero target or if it is absolute  If it is relative to hero targets, the in-between
    :type inBetweenType: string
    :param includeHiddenSelections: (C) Apply the deformer to any visible and hidden objects in
    the selection list  Default is false
    :type includeHiddenSelections: boolean
    :param mergeSource: (E M) List of source indexes for a merge
    :type mergeSource: int
    :param mergeTarget: (E) Target index of a merge
    :type mergeTarget: int
    :param mirrorDirection: (E) Mirror direction; 0 = negative, 1 = positive
    :type mirrorDirection: int
    :param mirrorTarget: (E M) Mirror the list of base and target pairs
    :type mirrorTarget: [int, int]
    :param name: (C) Used to specify the name of the node being created
    :type name: string
    :param normalizationGroups: (Q) Returns a list of the used normalization group IDs
    :type normalizationGroups: boolean
    :param origin: (C) blendShape will be performed with respect to the world by default  Valid
    values are "world" and "local"  The local flag will cause the blend shape to
    :type origin: string
    :param parallel: (C E) Inserts the new deformer in a parallel chain to any existing
    deformers in the history of the object  A blendShape is inserted to blend the parallel r
    :type parallel: boolean
    :param prune: (E) Removes any points not being deformed by the deformer in its current
    configuration from the deformer set
    :type prune: boolean
    :param remove: (E M) Specifies that objects listed after the -g flag should be removed from
    this deformer
    :type remove: boolean
    :param resetTargetDelta: (E M) Remove all delta values for points in the target geometry,
    including all sequential targets defined by target index  Parameter list: uint: the base o
    :type resetTargetDelta: [int, int]
    :param split: (C E) Branches off a new chain in the dependency graph instead of
    inserting/appending the deformer into/onto an existing chain  Works in create mode (and e
    :type split: boolean
    :param suppressDialog: (C E) Suppress dialog box and run the command as defined by the
    user
    :type suppressDialog: boolean
    :param symmetryAxis: (Q E) Axis for symmetry  Valid values are "X", "Y", and "Z"
    :type symmetryAxis: string
    :param symmetryEdge: (Q E M) One or two symmetry edge names, separated by a "."  See the
    blendShape node's symmetryEdge attribute for legal values
    :type symmetryEdge: string
    :param symmetrySpace: (Q E) Space for symmetry  0 = Topological, 1 = Object, 2 = UV
    :type symmetrySpace: int
    :param tangentSpace: (C E) Indicate that the delta of the specified target should be
    relative to the tangent space of the surface
    :type tangentSpace: boolean
    :param target: (C Q E M) Set target object as the index target shape for the base shape
    base object  The full influence of target shape takes effect when its shape weight is
    :type target: [string, int, string, float]
    :param topologyCheck: (C) Set the state of checking for a topology match between the shapes
    being blended  Default is on
    :type topologyCheck: boolean
    :param transform: (Q E) Set transform for target, then the deltas will become relative to a
    post transform  Typically the best workflow for this option is to choose a joint
    :type transform: string
    :param weight: (C Q E M) Set the weight value (second parameter) at index (first
    parameter)
    :type weight: [int, float]
    :param weightCount: (C Q E) Set the number of shape weight values
    :type weightCount: int
    
    :returns: (the blendShape node name)
    :rtype: string[]
    """
    pass


def ToggleHelpLine(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeDeleteAllTextures(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NURBSToPolygons(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def containerProxy(*args, fromTemplate="", type="", q=True, query=True, e=True, edit=True,
                   **kwargs):
    """
    Creates a new container with the same published interface, dynamic attributes and attribute
    values as the specified container but with fewer container members  This proxy container
    can be used as a reference proxy so that values can be set on container attributes without
    loading in the full container  The proxy container will contain one or more lo
    
    :param fromTemplate: (C) Specifies the name of a template file which will be used to create
    the new container proxy  Stand-in attributes will be created and published for all
    :type fromTemplate: string
    :param type: (C) Specifies the type of container node to use for the proxy  This flag is
    only valid in conjunction with the fromTemplate flag  When creating a proxy f
    :type type: string
    
    :returns: 
    :rtype: None
    """
    pass


def ParentConstraintOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmLengthBrushToolCmd(*args, **kwargs):
    """
    
    """
    pass


def timeEditorClipLayer(*args, addAttribute="", addLayer="", addObject="", allLayers=True,
                        attribute="", attributeKeyable="", clipId=0, index=0, keySiblings=True,
                        layerId=0, layerName="", mode=0, mute=True, name=True, path="",
                        removeAttribute="", removeLayer=True, removeObject="", resetSolo=True,
                        setKeyframe=True, solo=True, zeroKeying=True, q=True, query=True,
                        e=True, edit=True, **kwargs):
    """
    Time Editor clip layers commands
    
    :param addAttribute: (E) Add given plug to a layer with a supplied layerId
    :type addAttribute: string
    :param addLayer: (E) Add a new layer with a given name
    :type addLayer: string
    :param addObject: (E) Add given object with all its attributes in the clip to a layer with
    a supplied layerId
    :type addObject: string
    :param allLayers: (Q) Return all layers given clip ID
    :type allLayers: boolean
    :param attribute: (E M) The attribute path to key
    :type attribute: string
    :param attributeKeyable: (Q) Return whether specified attribute is keyable
    :type attributeKeyable: string
    :param clipId: (E) ID of the clip this layer command operates on  In query mode, this flag
    can accept a value
    :type clipId: int
    :param index: (E) Layer index, used when adding new layer at specific location in the
    stack
    :type index: int
    :param keySiblings: (E) If set to true, additional attributes might be keyed while keying
    to achieve desired result
    :type keySiblings: boolean
    :param layerId: (E) Layer ID used in conjunction with other edit flags  In query mode, this
    flag can accept a value
    :type layerId: int
    :param layerName: (Q E) Edit layer name  In query mode, return the layer name given its
    layer ID and clip ID
    :type layerName: string
    :param mode: (E) To control the playback speed of the clip by animation curve: 0 : additive
    1 : additive override 2 : override 3 : override passthrough
    :type mode: int
    :param mute: (E) Mute/unmute a layer given its layer ID and clip ID
    :type mute: boolean
    :param name: (Q) Query the attribute name of a layer given its layer ID and clip ID
    :type name: boolean
    :param path: (E) Full path of a layer or a clip on which to operate  For example:
    composition1|track1|clip1|layer1; composition1|track1|group|track1|clip1  In query m
    :type path: string
    :param removeAttribute: (E) Remove given plug from a layer with a supplied layerId
    :type removeAttribute: string
    :param removeLayer: (E) Remove layer with an ID
    :type removeLayer: boolean
    :param removeObject: (E) Remove given object with all its attributes in the clip to a layer
    with a supplied layerId
    :type removeObject: string
    :param resetSolo: (E) Unsolo all soloed layers in a given clip ID
    :type resetSolo: boolean
    :param setKeyframe: (E) Set keyframe on specified attributes on specified layer of a clip 
    Use -clipId to indicate the specified clip  Use -layerId to indicate the specified
    :type setKeyframe: boolean
    :param solo: (E) Solo/unsolo a layer given its layers ID and clip ID
    :type solo: boolean
    :param zeroKeying: (E) Indicate if the key to set should be zero offset from original
    animation
    :type zeroKeying: boolean
    
    :returns: Command result
    :rtype: string
    """
    pass


def vnnNode(*args, **kwargs):
    """
    
    """
    pass


def OrientConstraintOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ResetTransformationsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def cacheAppend(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def latticeDeformKeyCtx(*args, envelope=0.0, exists=True, history=True, image1="", image2="",
                        image3="", latticeColumns=0, latticeRows=0, name="",
                        scaleLatticePts=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a context which may be used to deform key frames with lattice
    manipulator  This context only works in the graph editor
    
    :param envelope: (Q E) Specifies the influence of the lattice
    :type envelope: float
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param latticeColumns: (Q E) Specifies the number column points the lattice contains
    :type latticeColumns: int
    :param latticeRows: (Q E) Specifies the number of rows the lattice contains
    :type latticeRows: int
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param scaleLatticePts: (Q E) Specifies if the selected lattice points should scale around
    the pick point  If this value is false the the default operation is 'move'
    :type scaleLatticePts: boolean
    
    :returns: Context name
    :rtype: string
    """
    pass


def ExportOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeGridToggleSnap(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GetHIKEffectorCount(*args, **kwargs):
    """
    
    """
    pass


def UVUnstackShellsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def filterCurve(*args, cutoffFrequency=0.0, endTime=None, filter="", keepKeysOnFrame=True,
                kernel="", keySync=True, maxTimeStep=0.0, minTimeStep=0.0, period=0.0,
                precision=0.0, precisionMode=0, preserveKeyTangent="", samplingRate=0.0,
                selectedKeys=True, startTime=None, timeTolerance=0.0, tolerance=0.0, **kwargs):
    """
    The filterCurve command takes a list of anim curve and filters them using a specified
    filter  The following filters are supported: butterworth euler keyReducer keySync resample
    simplify
    
    :param cutoffFrequency: (C) Defines the cutoff frequency (in Hz) for the Butterworth
    filter
    :type cutoffFrequency: float
    :param endTime: (C) Specify the end time of the section to filter  If not specified, the
    last key of the animation curve is used to define the end time
    :type endTime: time
    :param filter: (C) Specifies the filter type to use  The avalible filters are: butterworth
    euler (default) keyReducer keySync resample simplify
    :type filter: string
    :param keepKeysOnFrame: (C) When specified, a secondary filter pass is applied to position
    keys on whole frames  This flag is only supported by the Butterworth filter
    :type keepKeysOnFrame: boolean
    :param kernel: (C) Gaussian4 Filter: (2^(-4x*x)) weighted moving average
    :type kernel: string
    :param keySync: (C) When specified, a secondary filter pass is applied that adds a key to
    sibling curves (X,Y,Z) for each key that is encountered  This flag is only supp
    :type keySync: boolean
    :param maxTimeStep: (C) Simplify filter
    :type maxTimeStep: float
    :param minTimeStep: (C) Simplify filter
    :type minTimeStep: float
    :param period: (C) Resample filter
    :type period: float
    :param precision: (C) Defines the precision parameter  For the Key Reducer filter, this
    parameter specifies the error limit between the source and output curves  Greater v
    :type precision: float
    :param precisionMode: (C) Defines whether the precision value should be treated as: 0: An
    absolute value 1: A percentage
    :type precisionMode: int
    :param preserveKeyTangent: (C M) When specified, keys whose in or out tangent type match
    the specified type are preserved  Supported tangent types: fixed linear flat smooth step
    clam
    :type preserveKeyTangent: string
    :param samplingRate: (C) Defines the rate at which keys are added to the Butterworth
    filtered curve in frames per second (FPS)
    :type samplingRate: float
    :param selectedKeys: (C) When specified, the filter is only applied to selected keys  This
    flag supercedes the startTime/endTime specification
    :type selectedKeys: boolean
    :param startTime: (C) Specify the start time to filter  If not specified, then the first
    key in the animation curve is used to get the start time
    :type startTime: time
    :param timeTolerance: (C) Simplify filter
    :type timeTolerance: float
    :param tolerance: (C) Simplify filter
    :type tolerance: float
    
    :returns: The number of filtered curves
    :rtype: int
    """
    pass


def VisorWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nexTRSContext(*args, **kwargs):
    """
    
    """
    pass


def getDefaultBrush(*args, **kwargs):
    """
    The command returns the name of the default Paint Effects brush
    
    
    :returns: Name of the default brush node
    :rtype: string
    """
    pass


def shelfButton(*args, align="", annotation="", backgroundColor=None, command=None,
                commandRepeatable=True, defineTemplate="", disabledImage="", docTag="",
                doubleClickCommand=None, dragCallback=None, dropCallback=None, enable=True,
                enableBackground=True, enableCommandRepeat=True, enableKeyboardFocus=True,
                exists=True, flat=True, flexibleWidthType=0, flexibleWidthValue=0, flipX=True,
                flipY=True, font="", fullPathName=True, handleNodeDropCallback=None, height=0,
                highlightColor=None, highlightImage="", image="", image1="", image2="",
                image3="", imageOverlayLabel="", isObscured=True, label="",
                labelEditingCallback=None, labelOffset=0, ltVersion="", manage=True,
                marginHeight=0, marginWidth=0, menuItem=None, menuItemPython=0,
                noBackground=True, noDefaultPopup=True, numberOfPopupMenus=True,
                overlayLabelBackColor=None, overlayLabelColor=None, parent="",
                popupMenuArray=True, preventOverride=True, rotation=0.0, scaleIcon=True,
                selectionImage="", sourceType="", statusBarMessage="", style="", useAlpha=True,
                useTemplate="", version="", visible=True, visibleChangeCommand=None, width=0,
                q=True, query=True, e=True, edit=True, **kwargs):
    """
    This control supports up to 3 icon images and 4 different display styles  The icon image
    displayed is the one that best fits the current size of the control given its current style
      This command creates an iconTextButton that is designed to be on the shelf  The button
    contains a command that can be drag'n'dropped
    
    :param align: (C Q E) The label alignment  Alignment values are "left", "right", and
    "center"  By default, the label is aligned "center"  Currently only available when -st
    :type align: string
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param command: (C Q E) Command executed when the control is pressed
    :type command: script
    :param commandRepeatable: (C Q E) Set if the MEL command specified in the command flag
    should be repeatable or not  The "g" key, by default, is the shortcut to repeat the last
    execute
    :type commandRepeatable: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param disabledImage: (C Q E) Image used when the button is disabled  Image size must be
    the same as the image specified with the i/image flag  This is a Windows only flag
    :type disabledImage: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param doubleClickCommand: (C Q E) Command executed when the control is double clicked
    :type doubleClickCommand: script
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableCommandRepeat: (C Q E) This flag only affects menu items to which a command
    can be attached  Specify true and the command may be repeated by executing the command
    repeatLas
    :type enableCommandRepeat: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param flat: (C Q E) Sets whether the control will be a flat button (0 false, 1 true)
    :type flat: boolean
    :param flexibleWidthType: (C Q E) This flag is used to have the shelf button have a wider
    or thinner width  The valid values are: Standard = 1, Custom = 2, Automatic = 3  The
    Standard
    :type flexibleWidthType: int
    :param flexibleWidthValue: (C Q E) This flag is only useful when the Custom
    flexibleWidthType is chosen  The value is a width in pixels
    :type flexibleWidthValue: int
    :param flipX: (C Q E) Is the image flipped horizontally?
    :type flipX: boolean
    :param flipY: (C Q E) Is the image flipped vertically?
    :type flipY: boolean
    :param font: (C Q E) The font for the text  Valid values are "boldLabelFont",
    "smallBoldLabelFont", "tinyBoldLabelFont", "plainLabelFont", "smallPlainLabelFont",
    "oblique
    :type font: string
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param handleNodeDropCallback: (C E) Specify a script callback which is called when a node
    is dropped on the control  The name of the node being dropped will be passed to the
    function (p
    :type handleNodeDropCallback: script
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param highlightImage: (C Q E) Highlight image displayed while the cursor is over the
    control  Image size must be the same as the image specified with the -i/image flag  This is
    a
    :type highlightImage: string
    :param image: (C Q E) If you are not providing images with different sizes then you may use
    this flag for the control's image  If the "iconOnly" style is set, the icon wil
    :type image: string
    :param image1: (C Q E) First of three possible icons  The icon that best fits the current
    size of the control will be displayed
    :type image1: string
    :param image2: (C Q E) Second of three possible icons  The icon that best fits the current
    size of the control will be displayed
    :type image2: string
    :param image3: (C Q E) Third of three possible icons  The icon that best fits the current
    size of the control will be displayed
    :type image3: string
    :param imageOverlayLabel: (C Q E) A short string, up to 6 characters, representing a label
    that will be displayed on top of the image
    :type imageOverlayLabel: string
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) The text that appears in the control
    :type label: string
    :param labelEditingCallback: (C E) Specify a callback which is called after the user double
    clicks the label of the control to give it a new label  The new label string will be
    passed
    :type labelEditingCallback: script
    :param labelOffset: (C Q E) The label offset  Default is 0  Currently only available when
    -st/style is set to "iconAndTextCentered"
    :type labelOffset: int
    :param ltVersion: (C Q E) This flag is used to specify the Maya LT version that this
    control feature was introduced, if the version flag is not specified, or if the version fl
    :type ltVersion: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param marginHeight: (C Q E) The number of pixels above and below the control content  The
    default value is 1 pixel
    :type marginHeight: int
    :param marginWidth: (C Q E) The number of pixels on either side of the control content  The
    default value is 1 pixel
    :type marginWidth: int
    :param menuItem: (C E M) Creates menu items for this button by passing in arguments for the
    menu item label and command for each item  These should be passed as strings: "lab
    :type menuItem: [string, string]
    :param menuItemPython: (C E M) This flag is used to specify that a menu item is in Python 
    The integer value is the index of the menuItem that is modified by this flag  This is 0 b
    :type menuItemPython: int
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param noDefaultPopup: (C) Disable the default popup menus
    :type noDefaultPopup: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param overlayLabelBackColor: (C Q E) The RGBA color of the shadow behind the label defined
    by imageOverlayLabel  Default is 50% transparent black: 0 0 0 .5
    :type overlayLabelBackColor: [float, float, float, float]
    :param overlayLabelColor: (C Q E) The RGB color of the label defined by imageOverlayLabel 
    Default is a light grey: .8 .8 .8
    :type overlayLabelColor: [float, float, float]
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rotation: (C Q E) The rotation value of the image in radians
    :type rotation: float
    :param scaleIcon: (C E) For "textOnly" and "iconOnly" style, this flag has no effect  For
    other styles, if the flag is specified, the icon will be scaled to the size of the
    :type scaleIcon: boolean
    :param selectionImage: (C Q E) Image displayed while the control is selected  Image size
    must be the same as the image specified with the -i/image flag  This is a Windows only
    flag
    :type selectionImage: string
    :param sourceType: (C Q E) Sets the language type for the command script  Can only be used
    in conjunction with the c/command or dcc/doubleClickCommand flags  Valid values are "
    :type sourceType: string
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param style: (C Q E) The draw style of the control  Valid styles are "iconOnly",
    "textOnly", "iconAndTextHorizontal", "iconAndTextVertical", and "iconAndTextCentered"  (N
    :type style: string
    :param useAlpha: (C Q E) Is the image using alpha channel?
    :type useAlpha: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param version: (C Q E) Specify the version that this control feature was introduced  The
    argument should be given as a string of the version number (e.g  "2013", "2014")  C
    :type version: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The full name of the button.
    :rtype: string
    """
    pass


def FBXGetTakeCount(*args, **kwargs):
    """
    
    """
    pass


def listNodesWithIncorrectNames(*args, **kwargs):
    """
    List all nodes with incorrect names in the Script Editor
    
    
    :returns: 
    :rtype: None
    """
    pass


def polySelect(*args, add=True, addFirst=True, asSelectString=True, deselect=True, edgeBorder=0,
               edgeBorderPath=None, edgeBorderPattern=None, edgeLoop=0, edgeLoopOrBorder=0,
               edgeLoopOrBorderPattern=None, edgeLoopPath=None, edgeLoopPattern=None,
               edgeRing=0, edgeRingPath=None, edgeRingPattern=None, edgeUVLoopOrBorder=0,
               everyN=0, extendToShell=0, noSelection=True, replace=True, shortestEdgePath=None,
               shortestEdgePathUV=None, shortestFacePath=None, toggle=True, q=True, query=True,
               **kwargs):
    """
    This command makes different types of poly component selections  The return value is an
    integer array containing the id's of the components in the selection in order  If a given
    type of selection loops back on itself then this is indicated by the start id appearing
    twice, once at the start and once at the end
    
    :param add: (C Q) Indicates that the specified items should be added to the active list
    without removing existing items from the active list
    :type add: boolean
    :param addFirst: (C Q) Indicates that the specified items should be added to the front of
    the active list without removing existing items from the active list
    :type addFirst: boolean
    :param asSelectString: (C Q) Changes the return type from an integer array to a string
    array which can be used as a selection string
    :type asSelectString: boolean
    :param deselect: (C Q) Indicates that the specified items should be removed from the active
    list if they are on the active list
    :type deselect: boolean
    :param edgeBorder: (C Q M) Select all conected border edges starting at the given edge  In
    query mode, this flag needs a value
    :type edgeBorder: int
    :param edgeBorderPath: (C Q M) Given two edges on the same border, this will select the
    edges on the border in the path between them  In query mode, this flag needs a value
    :type edgeBorderPath: [int, int]
    :param edgeBorderPattern: (C Q M) Given two edges on the same border, this will check how
    many edges there are between the given edges and then continue that pattern of selection
    arou
    :type edgeBorderPattern: [int, int]
    :param edgeLoop: (C Q M) Select an edge loop starting at the given edge  In query mode,
    this flag needs a value
    :type edgeLoop: int
    :param edgeLoopOrBorder: (C Q M) Select an edge loop or all conected border edges,
    depending on whether the edge is on a border or not, starting at the given edge  In query
    mode, thi
    :type edgeLoopOrBorder: int
    :param edgeLoopOrBorderPattern: (C Q M) Given two edges either on the same edge loop or on
    the same edge border, this will check how many edges there are between the given edges and
    then co
    :type edgeLoopOrBorderPattern: [int, int]
    :param edgeLoopPath: (C Q M) Given two edges that are on the same edge loop, this will
    select the shortest path between them on the loop  In query mode, this flag needs a value
    :type edgeLoopPath: [int, int]
    :param edgeLoopPattern: (C Q M) Given two edges on the same edge loop, this will check how
    many edges there are between the given edges and then continue that pattern of selection a
    :type edgeLoopPattern: [int, int]
    :param edgeRing: (C Q M) Select an edge ring starting at the given edge  In query mode,
    this flag needs a value
    :type edgeRing: int
    :param edgeRingPath: (C Q M) Given two edges that are on the same edge ring, this will
    select the shortest path between them on the ring  In query mode, this flag needs a value
    :type edgeRingPath: [int, int]
    :param edgeRingPattern: (C Q M) Given two edges on the same edge ring, this will check how
    many edges there are between the given edges and then continue that pattern of selection a
    :type edgeRingPattern: [int, int]
    :param edgeUVLoopOrBorder: (C Q M) Select an edge loop or border, terminating at UV borders
     In query mode, this flag needs a value
    :type edgeUVLoopOrBorder: int
    :param everyN: (C) Number of elements to stride over  If less than 1 then use 1, meaning
    every element  2 means every second one, etc
    :type everyN: int
    :param extendToShell: (C Q M) Select the poly shell given a face id  In query mode, this
    flag needs a value
    :type extendToShell: int
    :param noSelection: (C Q) If this flag is used then the selection is not changed at all
    :type noSelection: boolean
    :param replace: (C Q) Indicates that the specified items should replace the existing items
    on the active list
    :type replace: boolean
    :param shortestEdgePath: (C Q M) Given two vertices, this will select the shortest path
    between them in the 3d object space  In query mode, this flag needs a value
    :type shortestEdgePath: [int, int]
    :param shortestEdgePathUV: (C Q M) Given two UVs, this will select the shortest path
    between them in the 2d texture space  In query mode, this flag needs a value
    :type shortestEdgePathUV: [int, int]
    :param shortestFacePath: (C Q M) Given two faces, this will select the shortest path
    between them in the 3d object space  In query mode, this flag needs a value
    :type shortestFacePath: [int, int]
    :param toggle: (C Q) Indicates that those items on the given list which are on the active
    list should be removed from the active list and those items on the given list wh
    :type toggle: boolean
    
    :returns: List of selected components.
    :rtype: int[]
    """
    pass


def setParent(*args, defineTemplate="", menu=True, topLevel=True, upLevel=True, useTemplate="",
              q=True, query=True, **kwargs):
    """
    This command changes the default parent to be the specified parent  Two special parents are
    "|" which indicates the top level layout of the window hierarchy, or ".." which indicates
    one level up in the hierarchy  Trying to move above the top level has no effect    A
    control must be parented to a control layout  A control layout may be parented to a
    
    :param defineTemplate: (C) Put a command in a mode where any other flags and args are
    parsed and added to the command template with the given name  They will be used as default
    :type defineTemplate: string
    :param menu: (C Q) Parent menu for menu items
    :type menu: boolean
    :param topLevel: (C) Move to the top level layout in the hierarchy  Equivalent to use "|"
    :type topLevel: boolean
    :param upLevel: (C) Move up one level in the hierarchy  Equivalent to use ".."
    :type upLevel: boolean
    :param useTemplate: (C) Will force the command to use a command template given by the name
    other than the current one
    :type useTemplate: string
    
    :returns: Name of the parent if the parent changes. Empty string if the parent
    doesn't
    change.
    :rtype: string
    """
    pass


def renderSetupFindCollections(*args, **kwargs):
    """
    unknown
    """
    pass


def CutKeys(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ClearCurrentCharacterList(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ModifyStampDepthPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorToggleConsistentNodeNameSize(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeOutlinerPerspLayout(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polySlideEdgeCtx(*args, **kwargs):
    """
    
    """
    pass


def testPa(*args, **kwargs):
    """
    
    """
    pass


def ImportAnimOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportConvert2Tif(*args, **kwargs):
    """
    
    """
    pass


def OutlinerExpandAllItems(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def intersect(*args, caching=True, firstSurface=True, nodeState=0, tolerance=0.01,
              constructionHistory=True, curveOnSurface=True, name="", object=True, q=True,
              query=True, e=True, edit=True, **kwargs):
    """
    The intersect command creates a curve on surface where all surfaces intersect with each
    other  By default, the curve on surface is created for both surfaces  However, by using the
    -fs flag, only the first surface will have a curve on surface  Also, the intersection curve
    can be created as a 3D curve rather than a curve on surface
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param firstSurface: (Q E) Creates a curve-on-surface on the first surface only or on all
    surfaces (default)
    :type firstSurface: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param tolerance: (C Q E) Tolerance to fit to  Default: 0.01
    :type tolerance: float
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param curveOnSurface: (C) If possible, create 2D curve as a result
    :type curveOnSurface: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def DeleteStaticChannelsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def createPolyPyramidCtx(*args, **kwargs):
    """
    
    """
    pass


def shapeCompare(*args, **kwargs):
    """
    Compares two shapes  If no shapes are specified in the command line, then the shapes from
    the active list are used
    
    
    :returns: 0 if successful, 1 if both shapes are not determined to be equal
    based on
    requested flags.
    :rtype: int
    """
    pass


def ScaleToolMarkingMenu(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def snapshotModifyKeyCtx(*args, exists=True, history=True, image1="", image2="", image3="",
                         name="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    Creates a context for inserting/delete keys on an editable motion trail
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: (name of the new context)
    :rtype: string
    """
    pass


def HypershadeConnectSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nodeType(*args, apiType=True, derived=True, inherited=True, isTypeName=True, **kwargs):
    """
    This command returns a string which identifies the given node's type   When no flags are
    used, the unique type name is returned  This can be useful for seeing if two nodes are of
    the same type   When the api flag is used, the MFn::Type of the node is returned  This can
    be useful for seeing if a plug-in node belongs to a given class  The api flag ca
    
    :param apiType: (C) Return the MFn::Type value (as a string) corresponding to the given
    node  This is particularly useful when the given node is defined by a plug-in, si
    :type apiType: boolean
    :param derived: (C) Return a string array containing the names of all the currently known
    node types which derive from the type of the specified node
    :type derived: boolean
    :param inherited: (C) Return a string array containing the names of all the base node types
    inherited by the specified node
    :type inherited: boolean
    :param isTypeName: (C) If this flag is present, then the argument provided to the command
    is the name of a node type rather than the name of a specific node
    :type isTypeName: boolean
    
    :returns: Single command result
    :rtype: string
    """
    pass


def FBXExportSkins(*args, **kwargs):
    """
    
    """
    pass


def HypershadePickWalkRight(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def canCreateManip(*args, **kwargs):
    """
    This command returns true if there can be a manipulator made for the specified selection,
    false otherwise
    
    
    :returns: Command result
    :rtype: boolean
    """
    pass


def UnfoldPackUVs3DInEmptyTile(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolySelectToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def multiTouch(*args, gestures=True, trackpad=0, q=True, query=True, **kwargs):
    """
    Used to interact with the Gestura (multi-touch) library
    
    :param gestures: (C Q) Enables/Disables multi touch gestures
    :type gestures: boolean
    :param trackpad: (C Q) Sets the trackpad mode  Values can be: 1 - Cursor Control only 2 -
    Multi-touch Gestures Only 3 - Cursor and Multi-touch Note: this is a "Mac" only fl
    :type trackpad: int
    
    :returns: 
    :rtype: None
    """
    pass


def canvas(*args, annotation="", backgroundColor=None, defineTemplate="", docTag="",
           dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
           enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
           highlightColor=None, hsvValue=None, isObscured=True, manage=True, noBackground=True,
           numberOfPopupMenus=True, parent="", popupMenuArray=True, pressCommand=None,
           preventOverride=True, rgbValue=None, statusBarMessage="", useTemplate="",
           visible=True, visibleChangeCommand=None, width=0, q=True, query=True, e=True,
           edit=True, **kwargs):
    """
    Creates a control capable of displaying a color swatch  This control can also accept a
    command to be called when the colour swatch is pressed by the user   Note: The
    -dgc/dragCallback and -dpc/dropCallback are not available for this control
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param hsvValue: (C Q E) Three float values corresponding to the hue, saturation, and value
    color components, where the hue value ranges from 0.0 to 360.0 and the saturation
    :type hsvValue: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param pressCommand: (C E) Command to be executed when there is a mouse press
    :type pressCommand: script
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rgbValue: (C Q E) Three float values corresponding to the red, green, and blue color
    components, all of which range from 0.0 to 1.0
    :type rgbValue: [float, float, float]
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The full name of the canvas.
    :rtype: string
    """
    pass


def ShowAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowMeshSmearToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetMeshSculptTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nClothDeleteCacheFrames(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetNClothStartFromMesh(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RemoveBifrostAccelerator(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolyMergeVertices(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nodeTreeLister(*args, addFavorite="", addItem=None, addVnnItem=None, annotation="",
                   backgroundColor=None, clearContents=True, collapsePath="", defineTemplate="",
                   docTag="", dragCallback=None, dropCallback=None, enable=True,
                   enableBackground=True, enableKeyboardFocus=True, executeItem="", exists=True,
                   expandPath="", expandToDepth=0, favoritesCallback=None, favoritesList=True,
                   fullPathName=True, height=0, highlightColor=None, isObscured=True,
                   itemScript="", manage=True, noBackground=True, nodeLibrary="",
                   numberOfPopupMenus=True, parent="", popupMenuArray=True,
                   preventOverride=True, refreshCommand=None, removeFavorite="", removeItem="",
                   resultsPathUnderCursor=True, selectPath="", statusBarMessage="",
                   useTemplate="", visible=True, visibleChangeCommand=None, vnnString=True,
                   width=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates/edits/queries the node tree lister control  nodeTreeLister is a
    treeLister, but items are assumed to have commands which return dependency node names 
    Dragging from the results pane is supported   The optional argument is the name of the
    control
    
    :param addFavorite: (C E M) Add an item path to the favorites folder  The item path does
    not have to actually be in the tree
    :type addFavorite: string
    :param addItem: (C E M) Add an item to the control  The arguments are item-path,icon path,
    command where item-path is the path from the root of the tree to the item's name ic
    :type addItem: [string, string, script]
    :param addVnnItem: (C E M) Add a VNN (Virtual Node Network) item to the control  The
    arguments are: item-path, icon-path, vnn-string, vnn-action  Where item-path is the path
    fr
    :type addVnnItem: [string, string, string, string]
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param clearContents: (E) Clears the contents of the control
    :type clearContents: boolean
    :param collapsePath: (E M) Collapse a path in the tree
    :type collapsePath: string
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param executeItem: (E) Execute the command associated with an item
    :type executeItem: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param expandPath: (E M) Expand a path in the tree
    :type expandPath: string
    :param expandToDepth: (E) Expand the tree to the given depth
    :type expandToDepth: int
    :param favoritesCallback: (C E) This script is called whenever a favorite is added or
    removed  It is passed two arguments: The item's path and a boolean indicating if it is
    being ad
    :type favoritesCallback: script
    :param favoritesList: (Q) Returns the list of favorite items
    :type favoritesList: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param itemScript: (Q) Returns the language and script command of the passed item path as a
    two-element list, the first element is the string "MEL" or "Python" and the seco
    :type itemScript: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param nodeLibrary: (C Q E) The node library that this tree lister is currently displaying
    :type nodeLibrary: string
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param refreshCommand: (C Q E) Command executed when the refresh button is pressed  Note:
    by default the refresh button is hidden and will be shown automatically when this command
    :type refreshCommand: script
    :param removeFavorite: (E M) Remove an item from favorites  Accepts the full favorite path
    or the tail of the full path
    :type removeFavorite: string
    :param removeItem: (E M) Remove an item path
    :type removeItem: string
    :param resultsPathUnderCursor: (Q) Returns the path to the result (right-pane) item under
    the mouse cursor  Returns an empty string if there is no such item
    :type resultsPathUnderCursor: boolean
    :param selectPath: (E M) Select a path in the tree
    :type selectPath: string
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param vnnString: (Q) Returns the VNN (Virtual Node Network) string of the passed item
    path
    :type vnnString: boolean
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the created control.
    :rtype: string
    """
    pass


def ContentBrowserWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeSelectUpStream(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmGuideRender(*args, **kwargs):
    """
    
    """
    pass


def subdDisplayMode(*args, **kwargs):
    """
    
    """
    pass


def SelectMaskToolMarkingMenu(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def untangleUV(*args, mapBorder="", maxRelaxIterations=0, pinBorder=True, pinSelected=True,
               pinUnselected=True, relax="", relaxTolerance=0.0, shapeDetail=0.0, **kwargs):
    """
    This command will aid in the creation of non-overlapping regions (i.e  polygons) in texture
    space by untangling texture UVs  This is done in two stages:
    
    :param mapBorder: (C) Map the border containing the selected UV into a variety of shapes
    that may be more amenable to UV relaxation operations  There are various types of
    :type mapBorder: string
    :param maxRelaxIterations: (C) The relaxation process is an iterative algorithm  Using this
    flag will put an upper limit on the number of iterations that will be performed
    :type maxRelaxIterations: int
    :param pinBorder: (C) If this is true, then the relevant texture borders are pinned in
    place during any relaxation
    :type pinBorder: boolean
    :param pinSelected: (C) If this is true, then then any selected UVs are pinned in place
    during any relaxation
    :type pinSelected: boolean
    :param pinUnselected: (C) If this is true, then all unselected UVs in each mesh are pinned
    in place during any relaxation
    :type pinUnselected: boolean
    :param relax: (C) Relax all UVs in the shell of the selected UV's  The relaxation is done
    by simulating a spring system where each UV edge is treated as a spring  Ther
    :type relax: string
    :param relaxTolerance: (C) This sets the tolerance which is used to determine when the
    relaxation process can stop  Smaller tolerances yield better results but can take much lo
    :type relaxTolerance: float
    :param shapeDetail: (C) If the mapBorder flag is set to circular or square, then this flag
    will control how much of the border's corresponding surface shape should be retain
    :type shapeDetail: float
    
    :returns: the number of relaxation iterations carried out
    :rtype: int
    """
    pass


def MakeHoleToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreatePolygonHelix(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleToolSettings(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmClumpBrushContext(*args, **kwargs):
    """
    
    """
    pass


def spBirailCtx(*args, **kwargs):
    """
    
    """
    pass


def keyframeRegionScaleKeyCtx(*args, exists=True, history=True, image1="", image2="", image3="",
                              name="", scaleSpecifiedKeys=True, type="", q=True, query=True,
                              e=True, edit=True, **kwargs):
    """
    This command creates a context which may be used to scale keyframes within the keyframe
    region of the dope sheet editor
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param scaleSpecifiedKeys: (Q E) Determines if only the specified keys should be scaled  If
    false, the non-selected keys will be adjusted during the scale  The default is true
    :type scaleSpecifiedKeys: boolean
    :param type: (E) rect | manip Specifies the type of scale manipulator to use
    :type type: string
    
    :returns: Context name
    :rtype: string
    """
    pass


def nameCommand(*args, annotation="", command=None, data1="", data2="", data3="", default=True,
                sourceType="", **kwargs):
    """
    This command creates a nameCommand object  Each nameCommand object can be connected to a
    hotkey  Thereafter, the nameCommand's command string will be executed whenever the hotkey
    is pressed (or released, as specified by the user)
    
    :param annotation: (C) A description of the command
    :type annotation: string
    :param command: (C) The command that is executed when the nameCommand is invoked
    :type command: script
    :param data1: (C) 
    :type data1: string
    :param data2: (C) 
    :type data2: string
    :param data3: (C) These are optional, user-defined data strings that are attached to the
    nameCommand object  They can be edited or queried using the assignCommand comm
    :type data3: string
    :param default: (C) Indicate that this name command is a default command  Default name
    commands will not be saved to preferences
    :type default: boolean
    :param sourceType: (C) Sets the language type for the command script  Can only be used in
    conjunction with the -command flag  Valid values are "mel" (enabled by default), a
    :type sourceType: string
    
    :returns: The name of the nameCommand object created
    :rtype: string
    """
    pass


def FBXExportReferencedContainersContent(*args, **kwargs):
    """
    
    """
    pass


def sbs_SetEditionModeScale(*args, **kwargs):
    """
    
    """
    pass


def MoveLeft(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def rename(*args, ignoreShape=True, uuid=True, **kwargs):
    """
    Renames the given object to have the new name  If only one argument is supplied the command
    will rename the (first) selected object  If the new name conflicts with an existing name,
    the object will be given a unique name based on the supplied name  It is not legal to
    rename an object to the empty string   When a transform is renamed then any shape 
    
    :param ignoreShape: (C) Indicates that renaming of shape nodes below transform nodes should
    be prevented
    :type ignoreShape: boolean
    :param uuid: (C) Indicates that the new name is actually a UUID, and that the command
    should change the node's UUID  (In which case its name remains unchanged.)
    :type uuid: boolean
    
    :returns: The new name. When undone returns original name.
    :rtype: string
    """
    pass


def TogglePolyDisplaySoftEdges(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dynCache(*args, **kwargs):
    """
    Cache the current state of all particle shapes at the current time
    
    
    :returns: 
    :rtype: None
    """
    pass


def SelectHierarchy(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OneClickMotionBuilderSendToCurrentScene(*args, **kwargs):
    """
    
    """
    pass


def manipPivot(*args, moveToolOri=0, ori=None, oriValid=True, pinPivot=True, pos=None,
               posValid=True, reset=True, resetOri=True, resetPos=True, rotateToolOri=0,
               scaleToolOri=0, snapOri=True, snapPos=True, valid=True, q=True, query=True,
               **kwargs):
    """
    Changes transform component pivot used by the move/rotate/scale manipulators
    
    :param moveToolOri: (C) Change move tool's axis orientation to the specified mode  This
    flag is the same as using "manipMoveContext -e -mode" on the Move tool except that th
    :type moveToolOri: int
    :param ori: (C Q) Component pivot orientation in world-space
    :type ori: [float, float, float]
    :param oriValid: (Q) Returns true if component pivot orientation is valid
    :type oriValid: boolean
    :param pinPivot: (C Q) Pin component pivot  Selection changes will not reset the pivot
    position/orientation when a custom pivot is set and pinning is on
    :type pinPivot: boolean
    :param pos: (C Q) Component pivot position in world-space
    :type pos: [float, float, float]
    :param posValid: (Q) Returns true if component pivot position is valid
    :type posValid: boolean
    :param reset: (C) Clear the saved component pivot position and orientation
    :type reset: boolean
    :param resetOri: (C) Clear the saved component pivot orientation
    :type resetOri: boolean
    :param resetPos: (C) Clear the saved component pivot position
    :type resetPos: boolean
    :param rotateToolOri: (C) Change rotate tool's axis orientation to the specified mode  This
    flag is the same as using "manipRotateContext -e -mode" on the Rotate tool except t
    :type rotateToolOri: int
    :param scaleToolOri: (C) Change scale tool's axis orientation to the specified mode  This
    flag is the same as using "manipScaleContext -e -mode" on the Scale tool except that
    :type scaleToolOri: int
    :param snapOri: (C Q) Snap pivot orientation  Modify pivot orientation when snapping the
    pivot to a component
    :type snapOri: boolean
    :param snapPos: (C Q) Snap pivot position  Modify pivot position when snapping the pivot to
    a component
    :type snapPos: boolean
    :param valid: (Q) Returns true if component pivot position or orientation is valid
    :type valid: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def renderPassRegistry(*args, channels=0, isPassSupported=True, passID="", passName=True,
                       renderer="", supportedChannelCounts=True, supportedDataTypes=True,
                       supportedPassSemantics=True, supportedRenderPassNames=True,
                       supportedRenderPasses=True, **kwargs):
    """
    query information related with render passes
    
    :param channels: (C) Specify the number of channels for query
    :type channels: int
    :param isPassSupported: (C) Return whether the pass is supported by the renderer This flag
    must be specified by the flag -passID firstly  The renderer whose default value is the
    :type isPassSupported: boolean
    :param passID: (C) Specify the render pass ID for query
    :type passID: string
    :param passName: (C) Get the pass name for the passID  This flag must be specified by the
    flag -passID firstly
    :type passName: boolean
    :param renderer: (C) Specify a renderer when using this command  By default the current
    renderer is specified
    :type renderer: string
    :param supportedChannelCounts: (C) List channel counts supported by the renderer(specified
    by the flag -renderer) and the specified pass ID  This flag must be specified by the flag
    -pa
    :type supportedChannelCounts: boolean
    :param supportedDataTypes: (C) List frame buffer types supported by the renderer(specified
    by the flag -renderer), the specified passID and channels  This flag must be specified by
    :type supportedDataTypes: boolean
    :param supportedPassSemantics: (C) List pass semantics supported by the specified passID 
    This flag must be specified by the flag -passId firstly
    :type supportedPassSemantics: boolean
    :param supportedRenderPassNames: (C) List render pass names supported by the
    renderer(specified by the flag -renderer)
    :type supportedRenderPassNames: boolean
    :param supportedRenderPasses: (C) List render passes supported by the renderer(specified by
    the flag -renderer)
    :type supportedRenderPasses: boolean
    
    :returns: Command result
    :rtype: string[]
    """
    pass


def MakePressureCurve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CycleIKHandleStickyState(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PruneSmallWeights(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ikSplineHandleCtx(*args, autoPriorityH=True, createCurve=True, createRootAxis=True,
                      exists=True, forceSolverH=True, history=True, image1="", image2="",
                      image3="", name="", numSpans=1, parentCurve=True, poWeightH=1,
                      priorityH=1, rootOnCurve=True, rootTwistMode=True, simplifyCurve=True,
                      snapCurve=True, snapHandleH=True, solverTypeH="", stickyH="off",
                      twistType="linear", weightH=1, q=True, query=True, e=True, edit=True,
                      **kwargs):
    """
    The ikSplineHandle context command (ikSplineHandleCtx) updates parameters of ikSplineHandle
    tool  The options for the tool will be set to the flags the user specifies
    
    :param autoPriorityH: (C Q E) Specifies that this handle's priority is assigned
    automatically  C: The default is off  Q: When queried, this flag returns an int
    :type autoPriorityH: boolean
    :param createCurve: (C Q E) Specifies if a curve should be automatically created for the
    ikSplineHandle  C: The default is on  Q: When queried, this flag returns an int
    :type createCurve: boolean
    :param createRootAxis: (E) Specifies if a root transform should automatically be created
    above the joints affected by the ikSplineHandle  This option is used to prevent the roo
    :type createRootAxis: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param forceSolverH: (C Q E) Specifies if the ikSolver is enabled for the ikHandle  C: The
    default is on  Q: When queried, this flag returns an int
    :type forceSolverH: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param numSpans: (E) Specifies the number of spans in the automatically generated curve of
    the ikSplineHandle  C: The default is 1  Q: When queried, this flag returns an
    :type numSpans: int
    :param parentCurve: (E) Specifies if the curve should automatically be parented to the
    parent of the first joint affected by the ikSplineHandle  C: The default is on  Q: Whe
    :type parentCurve: boolean
    :param poWeightH: (C Q E) Specifies the position/orientation weight of the ikHandle  C: The
    default is 1  Q: When queried, this flag returns a float
    :type poWeightH: float
    :param priorityH: (C Q E) Specifies the priority of the ikHandle  C: The default is 1  Q:
    When queried, this flag returns an int
    :type priorityH: int
    :param rootOnCurve: (E) Specifies if the root is locked onto the curve of the
    ikSplineHandle  C: The default is on  Q: When queried, this flag returns an int
    :type rootOnCurve: boolean
    :param rootTwistMode: (E) Specifies whether the start joint is allowed to twist or not  If
    not, then the required twist is distributed over the remaining joints  This applies
    :type rootTwistMode: boolean
    :param simplifyCurve: (E) Specifies if the ikSplineHandle curve should be simplified  C:
    The default is on  Q: When queried, this returns an int
    :type simplifyCurve: boolean
    :param snapCurve: (E) Specifies if the curve should automatically snap to the first joint
    affected by the ikSplineHandle  C: The default is off  Q: When queried, this flag
    :type snapCurve: boolean
    :param snapHandleH: (C Q E) Specifies if the ikHandle snapping is on  This flag is ignored
    for the ikSplineSolver  C: The default is on  Q: When queried, this flag returns an in
    :type snapHandleH: boolean
    :param solverTypeH: (C Q E) Lists what ikSolver is being used  For the ikSplineContext the
    solver can only be the ikSplineSolver and this flag is ignored  C: The default solver
    :type solverTypeH: string
    :param stickyH: (C Q E) Specifies if the ikHandle is sticky or not  Valid strings are
    "sticky" and "off"  This flag is ignored for the ikSplineSolver  C: The default is "off
    :type stickyH: string
    :param twistType: (E) Specifies the type of interpolation to be used by the ikSplineHandle 
    The interpolation options are "linear", "easeIn", "easeOut", and "easeInOut"  C
    :type twistType: string
    :param weightH: (C Q E) Specifies the weight of the ikHandle  This flag is ignored in the
    ikSplineHandleCtx  C: The default is 1  Q: When queried, this flag returns a float
    :type weightH: float
    
    :returns: The name of the context.
    :rtype: string
    """
    pass


def xgmAddGuide(*args, **kwargs):
    """
    
    """
    pass


def boxZoomCtx(*args, exists=True, history=True, image1="", image2="", image3="", name="",
               zoomScale=0.0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command can be used to create, edit, or query a box zoom context  If this context is
    used on a perspective camera, the field of view and view direction are changed  If the
    camera is orthographic, the orthographic width and eye point are changed  The left and
    middle mouse interactively zoom the view  The control key can be used to enable box zo
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param zoomScale: (C Q E) Scale the zoom
    :type zoomScale: float
    
    :returns: The name of the context
    :rtype: string
    """
    pass


def CreatePolygonTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddPondDynamicLocator(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MoveSkinJointsToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NewScene(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RemoveBindingSet(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MakePressureCurveOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateSubdivSurfaceOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowAnimationUI(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeSelectMaterialsFromObjects(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyDuplicateAndConnect(*args, removeOriginalFromShaders=True, renameChildren=True,
                            **kwargs):
    """
    This command duplicates the input polygonal object, connects up the outMesh attribute of
    the original polygonal shape to the inMesh attribute of the newly created duplicate shape
    and copies over the shader assignments from the original shape to the new duplicated shape 
     The command will fail if no objects are selected or sent as argument or if the
    
    :param removeOriginalFromShaders: (C) Used to specify if the original object should be
    removed from the shaders (shadingGroups) that it is a member of  The shader associations
    will get tr
    :type removeOriginalFromShaders: boolean
    :param renameChildren: (C) rename the children nodes of the hierarchy, to make them unique
    :type renameChildren: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def ProjectWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowWrapInfluences(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def rampWidget(*args, **kwargs):
    """
    
    """
    pass


def NodeEditorIncreaseTraversalDepth(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Delete(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def coarsenSubdivSelectionList(*args, **kwargs):
    """
    Coarsens a subdivision surface set of components based on the selection list  The selected
    components are selected at a coarser level
    
    
    :returns: Command result
    :rtype: boolean
    """
    pass


def SetFullBodyIKKeysBodyPart(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SymmetrizeUVBrushSizeOff(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddBifrostMotionField(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TogglePolygonFaceCenters(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ParticleInstancer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sortCaseInsensitive(*args, **kwargs):
    """
    This command sorts all the strings of an array in a case insensitive way
    
    
    :returns: string to sort
    :rtype: string[]
    """
    pass


def ModifyDisplacementPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def itemFilterAttr(*args, byName="", byNameString="", byScript="", classification="",
                   dynamic=True, exists=True, hasCurve=True, hasDrivenKey=True,
                   hasExpression=True, hidden=True, intersect=None, keyable=True,
                   listBuiltInFilters=True, listOtherFilters=True, listUserFilters=True,
                   negate=True, parent="", published=True, readable=True,
                   scaleRotateTranslate=True, secondScript="", text="", union=None,
                   writable=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a named itemFilterAttr object  This object can be attached to editors,
    in order to filter the attributes going through them  Using union and intersection filters,
    complex composite filters can be created
    
    :param byName: (C Q E) The filter will only pass items whose names match the given regular
    expression string  This string can contain the special characters * and ?  '?' ma
    :type byName: string
    :param byNameString: (C Q E M) The filter will only pass items whose names match the given
    string  This is a multi-use flag which allows the user to specify several strings  The fi
    :type byNameString: string
    :param byScript: (C Q E) The filter will run a MEL script named by the given string on each
    attribute name  Attributes will pass the filter if the script returns a non-zero v
    :type byScript: string
    :param classification: (C Q E) Indicates whether the filter is a built-in or user filter 
    The string argument must be either "builtIn" or "user"  The "other" filter classification
    :type classification: string
    :param dynamic: (C Q E) The filter will only pass dynamic attributes
    :type dynamic: boolean
    :param exists: (C Q E) The filter will only pass attributs that exist
    :type exists: boolean
    :param hasCurve: (C Q E) The filter will only pass attributes that are driven by animation
    curves
    :type hasCurve: boolean
    :param hasDrivenKey: (C Q E) The filter will only pass attributes that are driven by driven
    keys
    :type hasDrivenKey: boolean
    :param hasExpression: (C Q E) The filter will only pass attributes that are driven by
    expressions
    :type hasExpression: boolean
    :param hidden: (C Q E) The filter will only pass attributes that are hidden to the user
    :type hidden: boolean
    :param intersect: (C Q E) The filter will consist of the intersection of two other filters,
    whose names are the given strings  Attributes will pass this filter if and only if
    :type intersect: [string, string]
    :param keyable: (C Q E) The filter will only pass attributes that are keyable
    :type keyable: boolean
    :param listBuiltInFilters: (Q) Returns an array of all attribute filters with
    classification "builtIn"
    :type listBuiltInFilters: boolean
    :param listOtherFilters: (Q) The "other" classification has been deprecated  Use "user"
    instead  Returns an array of all attribute filters with classification "other"
    :type listOtherFilters: boolean
    :param listUserFilters: (Q) Returns an array of all attribute filters with classification
    "user"
    :type listUserFilters: boolean
    :param negate: (C Q E) This flag can be used to cause the filter to invert itself, and
    reverse what passes and what fails
    :type negate: boolean
    :param parent: () This flag is no longer supported
    :type parent: string
    :param published: (C Q E) The filter will only pass attributes that are published on the
    container
    :type published: boolean
    :param readable: (C Q E) The filter will only pass attributes that are readable (outputs)
    :type readable: boolean
    :param scaleRotateTranslate: (C Q E) The filter will show only SRT attributes: scale,
    rotate, translate and their children
    :type scaleRotateTranslate: boolean
    :param secondScript: (C Q E) Can be used in conjunction with the -bs flag  The second
    script is for filtering whole lists at once, rather than individually  Its signature must
    be
    :type secondScript: string
    :param text: (C Q E) Defines an annotation string to be stored with the filter
    :type text: string
    :param union: (C Q E) The filter will consist of the union of two other filters, whose
    names are the given strings  Attributes will pass this filter if they pass at least
    :type union: [string, string]
    :param writable: (C Q E) The filter will only pass attributes that are writable (inputs)
    :type writable: boolean
    
    :returns: Single command result
    :rtype: string
    """
    pass


def OutlinerToggleOrganizeByLayer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def caddyManip(*args, **kwargs):
    """
    
    """
    pass


def InsertEdgeLoopToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def geometryMergeCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyEvaluate(*args, accurateEvaluation=True, activeShells=True, activeUVShells=True,
                 area=True, boundingBox=True, boundingBox2d=True, boundingBoxComponent=True,
                 boundingBoxComponent2d=True, displayStats=True, edge=True, edgeComponent=True,
                 face=True, faceArea=True, faceComponent=True, format=True, shell=True,
                 triangle=True, triangleComponent=True, uvArea=True, uvComponent=True,
                 uvEdgePairs=True, uvFaceArea=True, uvSetName="", uvShell=True, uvShellIds=True,
                 uvcoord=True, uvsInShell=0, vertex=True, vertexComponent=True, worldArea=True,
                 worldFaceArea=True, **kwargs):
    """
    Returns the required counts on the specified objects
    
    :param accurateEvaluation: (C) used to get accurate results for the bounding box
    computation For objects with large vertex counts, accurate evaluation takes more time
    :type accurateEvaluation: boolean
    :param activeShells: (C) returns the indices of active shells as an array of int
    :type activeShells: boolean
    :param activeUVShells: (C) returns the indices of active UV shells (for the current map if
    one is not specified) as an array of int
    :type activeUVShells: boolean
    :param area: (C) returns the surface area of the object's faces in local space as a float
    :type area: boolean
    :param boundingBox: (C) returns the object's bounding box in 3d space as 6 floats in MEL:
    xmin xmax ymin ymax zmin zmax, or as a tuple of three pairs in Python: ((xmin,xmax)
    :type boundingBox: boolean
    :param boundingBox2d: (C) returns the object's uv bounding box (for the current map if one
    is not specified) in 2d space as 4 floats in MEL : xmin xmax ymin ymax, or as a tupl
    :type boundingBox2d: boolean
    :param boundingBoxComponent: (C) returns the bounding box of selected components in 3d
    space as 6 floats in MEL : xmin xmax ymin ymax zmin zmax, or as a tuple of three pairs in
    Pytho
    :type boundingBoxComponent: boolean
    :param boundingBoxComponent2d: (C) returns the bounding box of selected/specified
    components uv coordinates in 2d space as 4 floats in MEL : xmin xmax ymin ymax, or as a
    tuple of two p
    :type boundingBoxComponent2d: boolean
    :param displayStats: (C) toggles the display of poly statistics for the active View  All
    other flags are ignored if this flag is specified (Obsolete - refer to the headsUpDis
    :type displayStats: boolean
    :param edge: (C) returns the number of edges as an int
    :type edge: boolean
    :param edgeComponent: (C) returns the object's number of selected edges as an int
    :type edgeComponent: boolean
    :param face: (C) returns the number of faces as an int
    :type face: boolean
    :param faceArea: (C) returns the surface area of selected/specified faces in local space as
    an array of float
    :type faceArea: boolean
    :param faceComponent: (C) returns the object's number of selected faces as an int
    :type faceComponent: boolean
    :param format: (C) used to display the results as an explicit sentence
    :type format: boolean
    :param shell: (C) returns the number of shells (disconnected pieces) as an int
    :type shell: boolean
    :param triangle: (C) returns the number of triangles as an int
    :type triangle: boolean
    :param triangleComponent: (C) returns the number of triangles of selected components as an
    int
    :type triangleComponent: boolean
    :param uvArea: (C) returns the UV area of the object's faces in 2d space as a float
    :type uvArea: boolean
    :param uvComponent: (C) returns the object's number of selected uv coordinates as an int
    :type uvComponent: boolean
    :param uvEdgePairs: (C) returns the pairs of UVs that are on the selected/specified edges
    :type uvEdgePairs: boolean
    :param uvFaceArea: (C) returns the UV area of selected/specified faces in 2d space as an
    array of float
    :type uvFaceArea: boolean
    :param uvSetName: (C) used when querying texture vertices to specify the uv set  If a uv
    set is not specified then the current map for the object will be used
    :type uvSetName: string
    :param uvShell: (C) returns the number of UV shells (for the current map if one is not
    specified) as an int
    :type uvShell: boolean
    :param uvShellIds: (C) returns the UV shell indices for selected/specified faces or UVs as
    an array of int (for the current map if one is not specified), one shell index pe
    :type uvShellIds: boolean
    :param uvcoord: (C) returns the number of uv coordinates (for the current map if one is not
    specified) as an int
    :type uvcoord: boolean
    :param uvsInShell: (C) returns all UVs inside specified shell(for the current map if one is
    not specified), use activeUVShells to get shell indices for current selection, u
    :type uvsInShell: int
    :param vertex: (C) returns the number of vertices as an int
    :type vertex: boolean
    :param vertexComponent: (C) returns the object's number of selected vertices as an int
    :type vertexComponent: boolean
    :param worldArea: (C) returns the surface area of the object's faces in world space as a
    float
    :type worldArea: boolean
    :param worldFaceArea: (C) returns the surface area of selected/specified faces in world
    space as an array of float
    :type worldFaceArea: boolean
    
    :returns: a MEL array of values, a Python dictionary, or a string, depending on
    the format
    requested and the language called from.
    :rtype: Any
    """
    pass


def polySelectEditCtx(*args, adjustEdgeFlow=1.0, divisions=2, exists=True, fixQuads=False,
                      image1="", image2="", image3="", insertWithEdgeFlow=False,
                      smoothingAngle=0.0, splitType=0, useEqualMultiplier=True,
                      absoluteOffset=True, autoComplete=True, deleteEdge=True,
                      endVertexOffset=0.0, mode=0, startVertexOffset=0.0, q=True, query=True,
                      e=True, edit=True, **kwargs):
    """
    Create a new context to select and edit polygonal objects
    
    :param adjustEdgeFlow: (C Q E) The weight value of the edge vertices to be positioned 
    Default: 1.0f
    :type adjustEdgeFlow: float
    :param divisions: (C Q E) Number of divisions  Default: 2
    :type divisions: int
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param fixQuads: (C Q E) Fixes splits which go across a quad face leaving a 5 and 3 sided
    faces by splitting from the middle of the new edge to the vertex accross from the ed
    :type fixQuads: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param insertWithEdgeFlow: (C Q E) True to enable edge flow  Otherwise, the edge flow is
    disabled  Default: false
    :type insertWithEdgeFlow: boolean
    :param smoothingAngle: (C Q E) Angle below which new edges will be smoothed Default: kPi
    :type smoothingAngle: float
    :param splitType: (C Q E) Format: 0 - Absolute, 1 - Relative, 2 - Multi Default:
    TdnpolySplitRing::Relative
    :type splitType: int
    :param useEqualMultiplier: (C Q E) Changes how the profile curve effects the offset when
    doing a multisplit  If true then the verts will be offset the same distance based on the
    shorte
    :type useEqualMultiplier: boolean
    :param absoluteOffset: (C Q E) This flag is deprecated  Use splitType/stp instead  This
    flag is deprecated  Use splitType/stp instead
    :type absoluteOffset: boolean
    :param autoComplete: (C) If true then use auto completion on selections
    :type autoComplete: boolean
    :param deleteEdge: (C Q E) When true, the end edges are deleted so the end triangles are
    converted to quads
    :type deleteEdge: boolean
    :param endVertexOffset: (C Q E) Weight value controlling the offset of the end vertex of
    the edgeloop
    :type endVertexOffset: float
    :param mode: (C Q E) which mode to work on  Available modes are 1-loop and 2-ring
    :type mode: int
    :param startVertexOffset: (C Q E) Weight value controlling the offset of the start vertex
    of the edgeloop
    :type startVertexOffset: float
    
    :returns: The context name
    :rtype: string
    """
    pass


def sbs_GetPackageFullPathNameFromSubstanceNode(*args, **kwargs):
    """
    
    """
    pass


def polySetToFaceNormal(*args, setUserNormal=False, **kwargs):
    """
    This command takes selected polygonal vertices or vertex-faces and changes their normals 
    If the option  userNormal  is used, the new normal values will be the face normals arround
    the vertices/vertex-faces  Otherwise the new normal values will be default values according
    to the internal calculation
    
    :param setUserNormal: (C) when this flag is presented, user normals will be created on each
    vertex face and the values will be the face normal value  Otherwise the normal valu
    :type setUserNormal: boolean
    
    :returns: of the node name
    :rtype: string
    """
    pass


def FBXExportSmoothMesh(*args, **kwargs):
    """
    
    """
    pass


def polySeparate(*args, caching=True, nodeState=0, removeShells=True, separateSpecificShell=0,
                 q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates new objects from the given poly  A new object will be created for each
    section of the mesh that is distinct (no edges connect it to the rest of the mesh)
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param removeShells: (C) Remove the shells after creation
    :type removeShells: boolean
    :param separateSpecificShell: (C M) List of shell ids to be separated
    :type separateSpecificShell: int
    
    :returns: Object name(s) and node name.
    :rtype: string[]
    """
    pass


def CreateSpringOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ScaleKeysOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RemoveBifrostCollider(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def saveInitialState(*args, attribute="", saveall=True, **kwargs):
    """
    saveInitialState saves the current state of dynamics objects as the initial state  A
    dynamic object is a particle shape, rigid body, rigid constraint or rigid solver  If no
    objects are specified, it saves the initial state for any selected objects  It returns the
    names of the objects for which initial state was saved
    
    :param attribute: (C M) Save the initial state of the specified attribute only  This is a
    multi-use flag
    :type attribute: string
    :param saveall: (C) Save the initial state for all dynamics objects in the scene
    :type saveall: boolean
    
    :returns: Command result
    :rtype: string
    """
    pass


def dR_setRelaxAffectsBorders(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ResetReflectionOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def launch(*args, directory="", movie="", pdfFile="", webPage="", **kwargs):
    """
    Launch the appropriate application to open the document, web page or directory specified
    
    :param directory: (C) A directory
    :type directory: string
    :param movie: (C) A movie file  The only acceptable movie file formats are MPEG, Quicktime,
    and Windows Media file  The file's name must end with .mpg, .mpeg, .mp4, .w
    :type movie: string
    :param pdfFile: (C) A PDF (Portable Document Format) document  The file's name must end
    with .pdf
    :type pdfFile: string
    :param webPage: (C) A web page
    :type webPage: string
    
    :returns: 
    :rtype: None
    """
    pass


def xgmDataQueryHelperForTest(*args, **kwargs):
    """
    
    """
    pass


def RotateToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def attrControlGrp(*args, annotation="", attribute=None, changeCommand=None, enable=True,
                   exists=True, handlesAttribute=None, hideMapButton=True, label="",
                   preventOverride=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a control of the type most appropriate for the specified attribute,
    and associates the control with the attribute  Any change to the control will cause a
    change in the attribute value, and any change to the attribute value will be reflected in
    the control  Not all attribute types are supported
    
    :param annotation: (C Q E) Sets or queries the annotation value of the control group
    :type annotation: string
    :param attribute: (C Q E) Sets or queries the attribute the control represents  The name of
    the attribute must be fully specified, including the name of the node  Some types o
    :type attribute: name
    :param changeCommand: (C Q E) Sets or queries the change command of the control group  The
    change command will be executed when the control is used to change the value of the attr
    :type changeCommand: script
    :param enable: (C Q E) Sets or queries the enable state of the control group  The control
    is dimmed if the enable state is set to false
    :type enable: boolean
    :param exists: (C Q E) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param handlesAttribute: (Q E) Returns true or false as to whether this command can create
    a control for the specified attribute  In query mode, this flag needs a value
    :type handlesAttribute: name
    :param hideMapButton: (C Q E) Force the map button to remain hidden for this control
    :type hideMapButton: boolean
    :param label: (C Q E) Sets or queries the label of the control group
    :type label: string
    :param preventOverride: (C Q E) Sets or queries the prevent adjustment state of the control
    group  If true, the RMB menu for the control will not allow adjustments to be made
    :type preventOverride: boolean
    
    :returns: The control name.
    :rtype: string
    """
    pass


def ModifyOpacityRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def clearDynStartState(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def paramDimension(*args, **kwargs):
    """
    This command is used to create a param dimension to display the parameter value of a
    curve/surface at a specified point on the curve/surface
    
    
    :returns: Name of the paramDimension shape node created
    :rtype: string
    """
    pass


def applyTake(*args, channel="", device="", filter="", preview=True, recurseChannel=True,
              reset=True, specifyChannel=True, startTime=None, **kwargs):
    """
    This command takes data in a device (refered to as a take) and converts it into a form that
    may be played back and reviewed  The take can either be imported through the readTake
    action, or recorded by the recordDevice action  The take is either converted into animation
    curves or if the -preview flag is used, into blendDevice nodes   The command loo
    
    :param channel: (C M) This flag overrides the set channel enable value  If a channel is
    specified, it will be enabled  C: The default is all applyTake enabled channels for
    :type channel: string
    :param device: (C M) Specifies which device contains the take  C: The default is all
    applyTake enabled devices
    :type device: string
    :param filter: (C M) This flag specifies the filters to use during the applyTake  If this
    flag is used multiple times, the ordering of the filters is from left to right
    :type filter: string
    :param preview: (C) Applies the take to blendDevice nodes attached to the target attributes
    connected to the device attachments  Animation curves attached to the attribu
    :type preview: boolean
    :param recurseChannel: (C) When this flag is used, the children of the channel(s) specified
    by -c/channel are also applied  C: The default is all of the enabled channels
    :type recurseChannel: boolean
    :param reset: (C) Resets the blendDevice nodes affected by -preview  The preview data is
    removed and if animation curves exist, they are used during playback
    :type reset: boolean
    :param specifyChannel: (C) This flag is used with -c/channel flag  When used, applyTake
    will only work on the channels listed with the -c/channel flag  C: The default is all of
    :type specifyChannel: boolean
    :param startTime: (C) The default start time for a take is determined at record time  The
    startTime option sets the starting time of the take in the current animation unit
    :type startTime: time
    
    :returns: 
    :rtype: None
    """
    pass


def MoveRotateScaleTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TextureViewWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FitBSpline(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXResamplingRate(*args, **kwargs):
    """
    
    """
    pass


def dR_hypershadeTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_gridSnapPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def muMessageQuery(*args, **kwargs):
    """
    
    """
    pass


def FBXExportApplyConstantKeyReducer(*args, **kwargs):
    """
    
    """
    pass


def SelectFacePath(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExportSelectionOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeSaveSwatchesToDisk(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AbortCurrentTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def collision(*args, friction=0.0, name="", offset=0.0, resilience=0.0, q=True, query=True,
              e=True, edit=True, **kwargs):
    """
    For each listed object, the command creates a new field  The field has a shape which lives
    in the DAG and it has an associated dependency node  The field is added to the list of
    fields owned by the object  Use connectDynamic to cause the field to affect a dynamic
    object  Note that if more than one object is listed, a separate field is created for e
    
    :param friction: (Q E) Friction of the surface  This is the amount of the colliding
    particle's velocity parallel to the surface which is removed when the particle collides
    :type friction: float
    :param name: (Q E) name of field
    :type name: string
    :param offset: (Q E) Offset value for the connector
    :type offset: float
    :param resilience: (Q E) Resilience of the surface  This is the amount of the colliding
    particle's velocity reflected along the normal of the surface  A value of 1 will give
    :type resilience: float
    
    :returns: Geometry names that were setup for particle collision.
    :rtype: string[]
    """
    pass


def TexSewDeactivateBrushSize(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def makePaintable(*args, activate=True, activateAll=True, altAttribute="", attrType="",
                  clearAll=True, remove=True, shapeMode="", uiName="", q=True, query=True,
                  **kwargs):
    """
    Make attributes of nodes paintable to Attribute Paint Tool  This command is used to
    register new attributes to the Attribute Paint tool as paintable  Once registered the
    attributes will be recognized by the Attribute Paint tool and the user will be able to
    paint them
    
    :param activate: (C Q) Activate / deactivate the given paintable attribute  Used to filter
    out some nodes in the attribute paint tool
    :type activate: boolean
    :param activateAll: (C Q) Activate / deactivate all the registered paintable attributes 
    Used to filter out some nodes in the attribute paint tool
    :type activateAll: boolean
    :param altAttribute: (C Q M) Define an alternate attribute which will also receive the same
    values  There can be multiple such flags
    :type altAttribute: string
    :param attrType: (C Q) Paintable attribute type  Supported types: intArray, doubleArray,
    vectorArray, multiInteger, multiFloat, multiDouble, multiVector
    :type attrType: string
    :param clearAll: (C Q) Removes all paintable attribute definitions
    :type clearAll: boolean
    :param remove: (C Q) Make the attribute not paintable any more
    :type remove: boolean
    :param shapeMode: (C Q) This flag controls how Artisan correlates the paintable node to a
    corresponding shape node  It is used for attributes of type multi of multi, where t
    :type shapeMode: string
    :param uiName: (C Q) UI name  Default is the attribute name
    :type uiName: string
    
    :returns: 
    :rtype: None
    """
    pass


def licenseCheck(*args, **kwargs):
    """
    
    """
    pass


def RemoveLatticeTweaks(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DetachCurveOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyMultiLayoutUV(*args, flipReversed=True, gridU=0, gridV=0, layout=0, layoutMethod=0,
                      offsetU=0.0, offsetV=0.0, percentageSpace=0.0, prescale=0,
                      rotateForBestFit=0, scale=0, sizeU=0.0, sizeV=0.0, uvSetName="",
                      **kwargs):
    """
    place the UVs of the selected polygonal objects so that they do not overlap
    
    :param flipReversed: (C) If this flag is turned on, the reversed UV pieces are fliped
    :type flipReversed: boolean
    :param gridU: (C) The U size of the grids
    :type gridU: int
    :param gridV: (C) The V size of the grids
    :type gridV: int
    :param layout: (C) How to move the UV pieces, after cuts are applied: 0 No move is applied 
    1 Layout the pieces along the U axis  2 Layout the pieces in a square shape
    :type layout: int
    :param layoutMethod: (C) // -lm/layoutMethod layoutMethod integer // (C, E, Q) Which layout
    method to use: // 0 Block Stacking  // 1 Shape Stacking
    :type layoutMethod: int
    :param offsetU: (C) Offset the layout in the U direction by the given value
    :type offsetU: float
    :param offsetV: (C) Offset the layout in the V direction by the given value
    :type offsetV: float
    :param percentageSpace: (C) When layout is set to square, this value is a percentage of the
    texture area which is added around each UV piece  It can be used to ensure each UV pi
    :type percentageSpace: float
    :param prescale: (C) Prescale the shell before laying it out  0 No scale is applied  1
    Object space scaling applied  2 World space scaling applied
    :type prescale: int
    :param rotateForBestFit: (C) How to rotate the pieces, before move: 0 No rotation is
    applied  1 Only allow 90 degree rotations  2 Allow free rotations
    :type rotateForBestFit: int
    :param scale: (C) How to scale the pieces, after move: 0 No scale is applied  1 Uniform
    scale to fit in unit square  2 Non proportional scale to fit in unit square
    :type scale: int
    :param sizeU: (C) Scale the layout in the U direction by the given value
    :type sizeU: float
    :param sizeV: (C) Scale the layout in the V direction by the given value
    :type sizeV: float
    :param uvSetName: (C) Specifies the name of the uv set to edit uvs on  If not specified
    will use the current uv set if it exists
    :type uvSetName: string
    
    :returns: 
    :rtype: None
    """
    pass


def HypershadePublishConnections(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def showHelp(*args, absolute=True, docs=True, helpTable=True, version=True, q=True, query=True,
             **kwargs):
    """
    Invokes a web browser to open the on-line documentation and help files  It will open the
    help page for a given topic, or open a browser to a specific URL
    
    :param absolute: (C) The specified "URL" is an absolute URL that should be passed directly
    to the web browser
    :type absolute: boolean
    :param docs: (C Q) Use this flag to directly specify a help file relative to the on-line
    documentation root
    :type docs: boolean
    :param helpTable: (C Q) Use this flag to specify which file will be used to search for help
    topics when the -d/docs and -a/absolute flags are not used  If only a file name i
    :type helpTable: boolean
    :param version: (Q) Use this flag to get the Maya version that the showHelp command uses
    :type version: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def polySelectSp(*args, **kwargs):
    """
    
    """
    pass


def AssignTemplateOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ViewAlongAxisX(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ViewAlongAxisZ(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def distanceDimContext(*args, exists=True, history=True, image1="", image2="", image3="",
                       name="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    Command used to register the distanceDimCtx tool
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: - name of the context created
    :rtype: string
    """
    pass


def ATOMTemplateOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AppendToPolygonToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PaintCacheTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleBackfaceGeometry(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorGraphNoShapes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_mtkToolTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def subdAutoProjection(*args, caching=True, nodeState=0, constructionHistory=True, layout=0,
                       layoutMethod=0, name="", optimize=0, percentageSpace=0.0, planes=6,
                       scale=0, skipIntersect=True, worldSpace=True, q=True, query=True, e=True,
                       edit=True, **kwargs):
    """
    Projects a texture map onto an object, using several orthogonal projections simultaneously 
     The argument is a face selection list
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param layout: (C Q E) What layout algorithm should be used: 0 UV pieces are aligned along
    the U axis  1 UV pieces are moved in a square shape
    :type layout: int
    :param layoutMethod: (C Q E) Which layout method to use: 0 Block Stacking  1 Shape
    Stacking
    :type layoutMethod: int
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param optimize: (C Q E) Use two different flavors for the cut generation  0 Every face is
    assigned to the best plane  This optimizes the map distortion  1 Small UV pieces ar
    :type optimize: int
    :param percentageSpace: (C Q E) When layout is set to square, this value is a percentage of
    the texture area which is added around each UV piece  It can be used to ensure each UV pi
    :type percentageSpace: float
    :param planes: (C Q E) Number of intermediate projections used  Valid numbers are 4, 5, 6,
    8, and 12  C: Default is 6
    :type planes: int
    :param scale: (C Q E) How to scale the pieces, after projections: 0 No scale is applied  1
    Uniform scale to fit in unit square  2 Non proportional scale to fit in unit squ
    :type scale: int
    :param skipIntersect: (C Q E) When on, self intersection of UV pieces are not tested  This
    makes the projection faster and produces fewer pieces, but may lead to overlaps in UV sp
    :type skipIntersect: boolean
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def AddPfxToHairSystem(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dynPref(*args, autoCreate=True, echoCollision=True, runupFrom=0, runupToCurrentTime=True,
            saveOnQuit=True, saveRuntimeState=True, q=True, query=True, **kwargs):
    """
    This action modifies and queries the current state of "autoCreate rigid bodies", "run up to
    current time", and "run up from" (previous time or start time)
    
    :param autoCreate: (C Q) If on, autoCreate rigid bodies
    :type autoCreate: boolean
    :param echoCollision: (C Q) If on, will cause particle systems to echo to the Script Editor
    the command that they are running for each particle collision event  If off, only the
    :type echoCollision: boolean
    :param runupFrom: (C Q) If on, run up from previous time; if 2, run up from start time
    :type runupFrom: int
    :param runupToCurrentTime: (C Q) If on, run up the scene to current time
    :type runupToCurrentTime: boolean
    :param saveOnQuit: (C Q) If on, save the current values of preferences to userPrefs file
    :type saveOnQuit: boolean
    :param saveRuntimeState: (C Q) If on, runtime state as well as initial state of all
    particle objects will be saved to file  If off, only initial state will be saved
    :type saveRuntimeState: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def waitCursor(*args, state=True, q=True, query=True, **kwargs):
    """
    This command sets/resets a wait cursor for the entire Maya application  This works as a
    stack, such that for each waitCursor -state on command executed there should be a matching
    waitCursor -state off command pending  Warning: If a script fails that has turned the wait
    cursor on, the wait cursor may be left on  You need to turn it off manually from
    
    :param state: (C Q) Set or reset the wait cursor for the entire Maya application
    :type state: boolean
    
    :returns: True if the wait cursor is on.
    :rtype: boolean
    """
    pass


def FBXUIShowOptions(*args, **kwargs):
    """
    
    """
    pass


def hwRenderLoad(*args, **kwargs):
    """
    Empty command used to force the dynamic load of HR render
    
    
    :returns: 
    :rtype: None
    """
    pass


def RemoveBifrostAdaptiveMesh(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SubdivToNURBSOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UnfoldUV(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RemoveBifrostGuide(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteCurrentColorSet(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UpdateCurrentScene3dsMax(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RelaxInitialStateOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateTextureDeformer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def choice(*args, attribute="", controlPoints=False, index=0, name="", selector=None,
           shape=True, sourceAttribute=None, time=None, q=True, query=True, e=True, edit=True,
           **kwargs):
    """
    The choice command provides a mechanism for changing the inputs to an attribute based on
    some (usually time-based) criteria  For example, an object could be animated from frames 1
    to 30 by a motion path, then from frames 30 to 50 it follows keyframe animation, and after
    frame 50 it returns to the motion path  Or, a revolve surface could change its 
    
    :param attribute: (C M) specifies the attributes onto which choice node(s) should be
    created  The default is all keyable attributes of the given objects  Note that although
    :type attribute: string
    :param controlPoints: (C) Explicitly specify whether or not to include the control points
    of a shape (see "-s" flag) in the list of attributes  Default: false
    :type controlPoints: boolean
    :param index: (C Q) specifies the multi-input index of the choice node to connect the
    source attribute to  When queried, returns a list of integers one per specified -t/
    :type index: int
    :param name: (C Q) the name to give to any newly created choice node(s)  When queried,
    returns a list of strings
    :type name: string
    :param selector: (C Q) specifies the attribute to be used as the choice node's selector 
    The value of the selector at a given time determines which of the choice node's mul
    :type selector: name
    :param shape: (C) Consider all attributes of shapes below transforms as well, except
    "controlPoints"  Default: true
    :type shape: boolean
    :param sourceAttribute: (C) specifies the attribute to connect to the choice node that will
    be selected at the given time(s) specified by -t/time
    :type sourceAttribute: name
    :param time: (C M) specifies the time at which the choice should use the given source
    attribute, or the currently connected attribute if source attribute is not specifi
    :type time: time
    
    :returns: The newly created and/or modified choice nodes, with the attribute
    for which a
    selector keyframe was created.
    For example: choice1.input[3] choice2.input[3]
    :rtype: string[]
    """
    pass


def OutlinerToggleReferenceMembers(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SendToUnityAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MovePolygonComponent(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def objectType(*args, isAType="", isType="", tagFromType="", typeFromTag=0, typeTag=True,
               **kwargs):
    """
    This command returns the type of elements  Warning: This command is incomplete and may not
    be supported by all object types
    
    :param isAType: (C) Returns true if the object is the specified type or derives from an
    object that is of the specified type  This flag will only work with dependency no
    :type isAType: string
    :param isType: (C) Returns true if the object is exactly of the specified type  False
    otherwise
    :type isType: string
    :param tagFromType: (C) Returns the type tag given a type name
    :type tagFromType: string
    :param typeFromTag: (C) Returns the type name given an integer type tag
    :type typeFromTag: int
    :param typeTag: (C) Returns an integer tag that is unique for that object type  Not all
    object types will have tags  This is the unique 4-byte value that is used to iden
    :type typeTag: boolean
    
    :returns: The type of the specified object
    :rtype: string
    """
    pass


def AbcExport(*args, **kwargs):
    """
    
    """
    pass


def polyFlipUV(*args, caching=True, constructionHistory=True, createNewMap=True, cutUV=True,
               flipType=0, insertBeforeDeformers=True, local=True, name="", nodeState=0,
               pivotU=0.0, pivotV=0.0, usePivot=True, uvSetName="", worldSpace=True, q=True,
               query=True, e=True, edit=True, **kwargs):
    """
    Flip (mirror) the UVs (in texture space) of input polyFaces, about either the U or V axis.
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param createNewMap: (C) Set to true if a new map should be created
    :type createNewMap: boolean
    :param cutUV: (C Q E) Cut UV edges when flipping some components on a UV shell C: Default
    is on  Q: When queried, returns an int
    :type cutUV: boolean
    :param flipType: (C Q E) Vertical
    :type flipType: int
    :param insertBeforeDeformers: (C) Set to true if the new node created should inserted
    before any deformer nodes
    :type insertBeforeDeformers: boolean
    :param local: (C Q E) Flips in the local space of the input faces  C: Default is on  Q:
    When queried, returns an int
    :type local: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param pivotU: (C Q E) Specifies the pivot value, in the U direction
    :type pivotU: float
    :param pivotV: (C Q E) Specifies the pivot value, in the V direction
    :type pivotV: float
    :param usePivot: (C Q E) Flip using pivot or not  C: Default is off  Q: When queried,
    returns an int
    :type usePivot: boolean
    :param uvSetName: (C) Name of the UV set to be created
    :type uvSetName: string
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def ShowFkSkeleton(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BatchBakeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def createPolyPipeCtx(*args, **kwargs):
    """
    
    """
    pass


def SnapToGrid(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddSelectionAsCombinationTargetOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def scriptEditorInfo(*args, clearHistory=True, clearHistoryFile=True, historyFilename="",
                     input="", suppressErrors=True, suppressInfo=True, suppressResults=True,
                     suppressStackWindow=True, suppressWarnings=True, writeHistory=True, q=True,
                     query=True, e=True, edit=True, **kwargs):
    """
    Use this command to directly manipulate and query the contents of the Command Window window
     Note: Due to recent changes, certain flags will no longer work on the Script Editor Window
     All flags will continue to work with the CommandWindow (old Script Editor)  Note: This
    command cannot be used to create a new script editor window
    
    :param clearHistory: (E) Clears the read-only text in the upper field of the Command
    Window
    :type clearHistory: boolean
    :param clearHistoryFile: (E) Clear the file defined by the -hf/historyFilename flag, but
    only if -wh/writeHistory is true  Use this flag to start a new history file, since the de
    :type clearHistoryFile: boolean
    :param historyFilename: (Q E) Sets or returns the name of the file that the Command Window
    will use to echo all of its history to  If this is an empty string when the -wh/writeHis
    :type historyFilename: string
    :param input: (E) Sets the text in the lower field of the Command Window  Set this value to
    an empty string to clear the field  Note: this flag only affects the Comman
    :type input: string
    :param suppressErrors: (Q E) When true, Command Window and Script Editor will not display
    error messages
    :type suppressErrors: boolean
    :param suppressInfo: (Q E) When true, Command Window and Script Editor will not display
    info messages generated by Maya
    :type suppressInfo: boolean
    :param suppressResults: (Q E) When true, Command Window and Script Editor will not display
    command results
    :type suppressResults: boolean
    :param suppressStackWindow: (Q E) When true and when the stackTrace mechanism is on, this
    flag will suppress the display of the stack window  If stack trace is enabled then results
    wi
    :type suppressStackWindow: boolean
    :param suppressWarnings: (Q E) When true, Command Window and Script Editor will not display
    warning messages
    :type suppressWarnings: boolean
    :param writeHistory: (Q E) When true, Command Window will echo all of its history to the
    file defined by the -hf/historyFilename flag  This flag effectively turns file writing
    :type writeHistory: boolean
    
    :returns: The name of the Command Window window is returned.
    :rtype: string
    """
    pass


def GravityOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RenderFlagsWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Extrude(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def propMove(*args, percent=0.0, percentX=0.0, percentY=0.0, percentZ=0.0, pivot=None,
             rotate=None, scale=None, translate=None, worldSpace=True, **kwargs):
    """
    Performs a proportional translate, scale or rotate operation on any number of objects  The
    percentages to rotate, scale or translate by can be specified using either the -p flags or
    -px, -py, -pz flags  Each selected object must have a corresponding -p or -px, -py, -pz
    flag  The rotate, scale or translate performed is relative
    
    :param percent: (C M) The percentage effect that the specified x,y,z has on an object  This
    flag must be specified once for each object, ie  if there are 4 objects specifi
    :type percent: float
    :param percentX: (C M) The percentage effect that the specified x has on an object  This
    flag is specified one per object  The value ranges between 0.0 and 1.0, but can be
    :type percentX: float
    :param percentY: (C M) The percentage effect that the specified y has on an object  This
    flag is specified one per object  The value ranges between 0.0 and 1.0, but can be
    :type percentY: float
    :param percentZ: (C M) The percentage effect that the specified z has on an object  This
    flag is specified one per object  The value ranges between 0.0 and 1.0, but can be
    :type percentZ: float
    :param pivot: (C) Specify the pivot about which a rotation or scale will occur  The change
    in pivot lasts only as long as the current 'propMove' command, and so must b
    :type pivot: [float, float, float]
    :param rotate: (C) Proportionally rotate each object by the given angles  The rotation
    values are scaled by the percentage specified by that object's corresponding "-pe
    :type rotate: [float, float, float]
    :param scale: (C) Proportionally scale each object by the given amounts  The scale values
    are scaled by the percentage specified by that object's corresponding "-perce
    :type scale: [float, float, float]
    :param translate: (C) Proportionally translate each object by the given amounts  The
    translation values are scaled by the percentage specified by that object's correspondi
    :type translate: [float, float, float]
    :param worldSpace: (C) Use worldspace for the calculations
    :type worldSpace: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def SetStrokeControlCurves(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_vertUnlockAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyCBoolOp(*args, classification=0, faceAreaThreshold=0.0001, operation=0,
                preserveColor=False, useCarveBooleans=True, useThresholds=False,
                vertexDistanceThreshold=0.001, caching=True, mergeUVSets=0, nodeState=0, q=True,
                query=True, e=True, edit=True, **kwargs):
    """
    This command creates a new poly as the result of a boolean operation on input polys : union,
    intersection, difference
    
    :param classification: (C Q E) Changes how intersections of open and closed manifolds are
    treated  1 for "Edge", 2 for "Normal"
    :type classification: int
    :param faceAreaThreshold: (C Q E) Area threshold to determine whether faces should be
    collapsed before boolean  Attribute is ignored unless useThresholds is set to true Default:
    0.000
    :type faceAreaThreshold: float
    :param operation: (C Q E) Boolean operation type  1=union, 2=difference, 3=intersection 
    Default type is union  Default: kBoolOpUnion
    :type operation: int
    :param preserveColor: (C Q E) If true, boolean op will compute color for the new mesh  If
    false, the new mesh won't have any color set  Default: false
    :type preserveColor: boolean
    :param useCarveBooleans: (C Q E) If true, use the Carve Boolean library
    :type useCarveBooleans: boolean
    :param useThresholds: (C Q E) If true, merge vertices with separations less then
    vertexDistanceThreshold and collapse faces with areas less then faceAreaThreshold  If false,
    do no
    :type useThresholds: boolean
    :param vertexDistanceThreshold: (C Q E) Tolerance to determine whether vertices (and edges)
    should be merged before boolean operation is applied  Attribute is ignored unless
    useThresholds i
    :type vertexDistanceThreshold: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param mergeUVSets: (C Q E) Specify how UV sets will be merged on the output mesh  0 = "No
    Merge": Each UV set on each mesh will become a new UV set in the output  1 = "Merge By
    :type mergeUVSets: int
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    
    :returns: Object name and node name.
    :rtype: string[]
    """
    pass


def XgGroomingVis(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def meshReorderContext(*args, **kwargs):
    """
    
    """
    pass


def GraphCut(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def panZoomCtx(*args, alternateContext=True, buttonDown=True, buttonUp=True, exists=True,
               history=True, image1="", image2="", image3="", name="", panMode=True,
               toolName="", zoomMode=True, zoomScale=0.0, q=True, query=True, e=True, edit=True,
               **kwargs):
    """
    This command can be used to create camera 2D pan/zoom context
    
    :param alternateContext: (C Q) Set the ALT+MMB and ALT+SHIFT+MMB to refer to this context
    :type alternateContext: boolean
    :param buttonDown: (C) Perform the button down operation
    :type buttonDown: boolean
    :param buttonUp: (C) Perform the button up operation
    :type buttonUp: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param panMode: (C) Specify to create a camera 2D pan context, which is the default
    :type panMode: boolean
    :param toolName: (C Q) Name of the specific tool to which this command refers
    :type toolName: string
    :param zoomMode: (C) Specify to create a camera 2D zoom context
    :type zoomMode: boolean
    :param zoomScale: (C Q E) Scale the zoom  The smaller the scale the slower the drag
    :type zoomScale: float
    
    :returns: The name of the context
    :rtype: string
    """
    pass


def displaySurface(*args, flipNormals=True, twoSidedLighting=True, xRay=True, q=True,
                   query=True, **kwargs):
    """
    This command toggles display options on the specified or active surfaces  Typically this
    command applies to NURBS or poly mesh surfaces and ignores other type of objects
    
    :param flipNormals: (Q) flip normal direction on the surface
    :type flipNormals: boolean
    :param twoSidedLighting: (Q) toggle if the surface should be considered two-sided  If it's
    single-sided, drawing and rendering may use single sided lighting and back face cull to
    :type twoSidedLighting: boolean
    :param xRay: (Q) toggle X ray mode (make surface transparent)
    :type xRay: boolean
    
    :returns: when in the query mode.
    :rtype: boolean
    """
    pass


def SquareSurface(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RemoveShrinkWrapInnerObject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OutTangentSpline(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def help(*args, documentation=True, language="", list=True, popupDisplayTime=4, popupMode=True,
         popupPauseTime=800, popupSimpleMode=True, rolloverMode=True, syntaxOnly=True, q=True,
         query=True, **kwargs):
    """
    With no arguments, help tells how to use help  If a command name is specified, help will
    return the quick help for that command  Other flags can be used to open the online
    documentation, or to list available commands based on a pattern   Pattern follows the
    following syntax:  * matches any string ? matches any character [agj] matches a, g or j
    [^0-
    
    :param documentation: (C) Use a browser to show the documentation associated with the
    single command name given  A pattern cannot be used with this flag  If no command name is
    :type documentation: boolean
    :param language: (C) Show the help for this command in the specified language  Valid values
    are "mel" and "python"  The default is Mel  Used with the doc flag
    :type language: string
    :param list: (C) List all the commands whose names match the regular expression  Pass the
    regular expression as the first argument to the command specified
    :type list: boolean
    :param popupDisplayTime: (C Q) Set the amount of time, in seconds, that the popup help will
    be displayed  The default is 4 seconds  This flag is mutually exclusive of the list and
    :type popupDisplayTime: int
    :param popupMode: (C Q) Turn on or off popup help mode  This flag is mutually exclusive of
    the list and doc flags
    :type popupMode: boolean
    :param popupPauseTime: (C Q) Set the amount of time, in milliseconds, before the popup help
    will be displayed  The default is 800 milliseconds  This flag is mutually exclusive of
    :type popupPauseTime: int
    :param popupSimpleMode: (C Q) Turn on or off simple popup help mode  If set, ToolClips will
    display only name and keyboard shortcut
    :type popupSimpleMode: boolean
    :param rolloverMode: (C Q) Turn on or off rollover help mode  This flag is mutually
    exclusive with the list and doc flags
    :type rolloverMode: boolean
    :param syntaxOnly: (C) When no other flag is specified, return only the syntax part of the
    quick help
    :type syntaxOnly: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def treeView(*args, addItem=None, allowDragAndDrop=True, allowHiddenParents=True,
             allowMultiSelection=True, allowReparenting=True, annotation="",
             attachButtonRight=0, backgroundColor=None, borderHighlite=None,
             borderHighliteColor=None, buttonErase=None, buttonState=None, buttonStyle=None,
             buttonTextIcon=None, buttonTooltip=None, buttonTransparencyColor=None,
             buttonTransparencyOverride=None, buttonVisible=None, children="",
             clearSelection=True, contextMenuCommand=None, defineTemplate="", displayLabel=None,
             displayLabelSuffix=None, docTag="", dragAndDropCommand=None, dragCallback=None,
             dropCallback=None, editLabelCommand=None, enable=True, enableBackground=True,
             enableButton=None, enableKeyboardFocus=True, enableKeys=True, enableLabel=None,
             exists=True, expandCollapseCommand=None, expandItem=None, flatButton=0, font=None,
             fontFace=None, fullPathName=True, height=0, hideButtons=True, highlightColor=None,
             highlite=None, highliteColor=None, ignoreButtonClick=None, image=None,
             insertItem=None, isItemExpanded="", isLeaf="", isObscured=True, item="",
             itemAnnotation=None, itemDblClickCommand=None, itemDblClickCommand2=None,
             itemExists="", itemIndex="", itemParent="", itemRenamedCommand=None,
             itemSelected="", itemVisible=None, labelBackgroundColor=None, manage=True,
             noBackground=True, numberOfButtons=0, numberOfPopupMenus=True, ornament=None,
             ornamentColor=None, parent="", popupMenuArray=True, pressCommand=None,
             preventOverride=True, removeAll=True, removeItem="", reverseTreeOrder=True,
             rightPressCommand=None, select=None, selectCommand=None, selectItem=None,
             selectionChangedCommand=None, selectionColor=None, showItem="",
             statusBarMessage="", textColor=None, useTemplate="", visible=True,
             visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
             **kwargs):
    """
    This command creates a custom control
    
    :param addItem: (C E M) Adds a tree view item to the tree view  First argument specifies
    the item's name, second argument specifies the item's parent (use an empty string to
    :type addItem: [string, string]
    :param allowDragAndDrop: (C Q E) Allow the user to perform drag and drop of treeView items 
    If enabled, re-ordering / re-parenting operations can be perfomed with the middle mouse bu
    :type allowDragAndDrop: boolean
    :param allowHiddenParents: (C Q E) If not cleared(default), the treeView will make parent
    nodes of visible nodes automatically visible
    :type allowHiddenParents: boolean
    :param allowMultiSelection: (C Q E) Specify multi or single selection mode  Allow the user
    to perform multiple selection by holding ctrl or shift key while selecting items of
    treeView i
    :type allowMultiSelection: boolean
    :param allowReparenting: (C Q E) Allow the user to reparent items in the tree view using
    the middle mouse button  Defaults to true  If false, user can still reorder items within a
    gr
    :type allowReparenting: boolean
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param attachButtonRight: (C E) Sets tree view item's buttons to appear on the right or
    left  Argument specifies if they are to be attached to the right, if it is set to false
    they
    :type attachButtonRight: int
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param borderHighlite: (C E) Sets an item's border as highlit or not  First Argument
    specifies item, second argument specifies on or off
    :type borderHighlite: [string, boolean]
    :param borderHighliteColor: (C E) Sets the color an item's border highlite will turn when
    highlite is enabled  first parameter specifies layer three float values specify RGB values,
    b
    :type borderHighliteColor: [string, float, float, float]
    :param buttonErase: (C Q E M) If buttonErase was set true , then even if the button of the
    treeView item is set invisible , the treeView will still erase the buttonRect of this tr
    :type buttonErase: [string, boolean]
    :param buttonState: (C E M) Sets the state of a button  First argument specifies the layer,
    second argument specifies which button, third argument specifies the state Possible s
    :type buttonState: [string, int, string]
    :param buttonStyle: (C E M) Sets the type of button, used to indicate possible states and
    if the button is reset upon release  First argument specifies the layer, second argumen
    :type buttonStyle: [string, int, string]
    :param buttonTextIcon: (C E M) Sets a one letter text to use as the icon to use for a
    specific button on a specific item  First argument specifies the item, second argument
    specifi
    :type buttonTextIcon: [string, int, string]
    :param buttonTooltip: (C E M) Sets a tooltip for specific button on a specific item  First
    argument specifies the item, second argument specifies the button, third argument specif
    :type buttonTooltip: [string, int, string]
    :param buttonTransparencyColor: (C E M) Sets the background color of a button that will be
    used if buttonTransparencyOverride is enabled  First argument specifies item, second
    argument spec
    :type buttonTransparencyColor: [string, int, float, float, float]
    :param buttonTransparencyOverride: (C E M) Sets a button's background as being overridden
    or not  First argument specifies item, second argument specifies button, third argument
    specifies over
    :type buttonTransparencyOverride: [string, int, boolean]
    :param buttonVisible: (C M) Sets a button as visible or not  First Argument specifies item 
    Second Argument specifies a button  Third Argument specifies visible or not
    :type buttonVisible: [string, int, boolean]
    :param children: (Q) Query the children of an item  If the argument is null, all items will
    be returned  In query mode, this flag needs a value
    :type children: string
    :param clearSelection: (C E) Clears all selected items
    :type clearSelection: boolean
    :param contextMenuCommand: (C E) Set the callback function to be invoked just before any
    attached context menu is shown  This can be used as a replacement to, or in addition to the
    p
    :type contextMenuCommand: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param displayLabel: (C E M) Set a label for the item that is different than the string
    that identifies the item  This label will be used in the display of the item  The first pa
    :type displayLabel: [string, string]
    :param displayLabelSuffix: (C E M) Set a suffix for the display label for the item  This
    suffix will not be shown when renaming the item in the tree view
    :type displayLabelSuffix: [string, string]
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragAndDropCommand: (C E) Sets the callback function to be invoked upon drag and
    drop of layers  the callback function should take as parameters: - a string array of the
    dropp
    :type dragAndDropCommand: script
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param editLabelCommand: (C E) Set the callback function to be invoked when the user
    changes the name of an item by double clicking it in the UI  The callback should accept two
    str
    :type editLabelCommand: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableButton: (C E M) Sets a specific button on a specific item to being usable or
    not  First argument specifies the item, second argument specifies the button, third argu
    :type enableButton: [string, int, int]
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param enableKeys: (E) By default the treeview does not accept input from the keyboard  By
    enabling keyboard support The treeview will support up/down navigation using the
    :type enableKeys: boolean
    :param enableLabel: (C E) enables or disables the label of a tree view item from being
    displayed  The first parameter specifies the item, the second specifies on or off
    :type enableLabel: [string, int]
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param expandCollapseCommand: (C E) Set the callback function to be invoked upon hitting
    the expand/collapse button  The function should take as parameters: - a string for the item
    for
    :type expandCollapseCommand: script
    :param expandItem: (C E) Expands or collapses an item's children  First argument specifies
    the item, second argument specifies expanded or collapsed
    :type expandItem: [string, boolean]
    :param flatButton: (C Q E) Type of flat button to use
    :type flatButton: int
    :param font: (C Q E) The first parameter specifies the item string for the TtreeViewNode in
    the TtreeNodeMap  The second string specifies the font for the text  Valid val
    :type font: [string, string]
    :param fontFace: (C E) Sets the font face used for the specified item's text: 0 for normal,
    1 for bold, 2 for italic
    :type fontFace: [string, int]
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param hideButtons: (C E) Hides the buttons for an item in the tree view  Can only be used
    when adding the item to the tree with the "addItem" flag  Space for the buttons is l
    :type hideButtons: boolean
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param highlite: (C E) Sets an item as highlit  Highliting is shown by outlining the item 
    First parameter specifies the item, the second specifies the highliting or not
    :type highlite: [string, boolean]
    :param highliteColor: (C E) Sets the color an item's highlite will turn when highlite is
    enabled  first parameter specifies layer three float values specify RGB values, between
    :type highliteColor: [string, float, float, float]
    :param ignoreButtonClick: (C E M) Sets a specific button on a specific item to ignore the
    button clicks First argument specifies the item ,second argument specifies the button,
    third
    :type ignoreButtonClick: [string, int, int]
    :param image: (C E M) Sets an image to use as the icon for the button  First argument
    specifies the item, second argument specifies the button, third argument specifies th
    :type image: [string, int, string]
    :param insertItem: (C E M) Create and insert a tree view item to the tree view  First
    argument specifies the item's name, second argument specifies the item's parent (use an em
    :type insertItem: [string, string, int]
    :param isItemExpanded: (Q) Is the item in the tree view expanded  In query mode, this flag
    needs a value
    :type isItemExpanded: string
    :param isLeaf: (Q) Query whether an item is a leaf  In query mode, this flag needs a value
    :type isLeaf: string
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param item: (Q) Specify the item to query  Used with the flag "selectionColor" and
    "itemAnnotation"  In query mode, this flag needs a value
    :type item: string
    :param itemAnnotation: (C Q E) Annotate the specified item with an extra string value  When
    used for query, this flag has no argument and needs to be used with the flag "item"
    :type itemAnnotation: [string, string]
    :param itemDblClickCommand: (C E) Set the callback function to be invoked when an item in
    the tree has been double clicked  The callback should accept one string, the display label
    of
    :type itemDblClickCommand: script
    :param itemDblClickCommand2: (C E) Set the callback function to be invoked when an item in
    the tree has been double clicked  This callback is similar to itemDblClickCommand(idc), but
    i
    :type itemDblClickCommand2: script
    :param itemExists: (C Q) Queries the existence of the specified Tree View item  In query
    mode, this flag needs a value
    :type itemExists: string
    :param itemIndex: (C Q) Get the index for the specified item in the list of children of the
    item's parent  Index is 0-based  In query mode, this flag needs a value
    :type itemIndex: string
    :param itemParent: (C Q) If the specified item is a child, it returns the parent item  If
    the specified item is not a child it returns nothing  In query mode, this flag needs
    :type itemParent: string
    :param itemRenamedCommand: (C E) Set the callback function to be invoked when an item in
    the tree has been renamed  This occurs if there is a successful return of the command
    attache
    :type itemRenamedCommand: script
    :param itemSelected: (Q) Queries the item is currently selected or not  In query mode, this
    flag needs a value
    :type itemSelected: string
    :param itemVisible: (C Q E) Control the given item's visibility
    :type itemVisible: [string, boolean]
    :param labelBackgroundColor: (C E) Set the background color for text label for a particular
    item in the tree  The first parameter specifies layer  Set (-1.0, -1.0, -1.0) to restore
    the
    :type labelBackgroundColor: [string, float, float, float]
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfButtons: (C E) Specifies the number of buttons for items in the tree
    :type numberOfButtons: int
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param ornament: (C E) Sets an item as having an ornament (a small colored circle), its
    on/off state, if it should have a dot, and its size  First Argument specifies item,
    :type ornament: [string, int, int, int]
    :param ornamentColor: (C E) Sets the color an ornament will be draw with for the specified
    layer
    :type ornamentColor: [string, float, float, float]
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param pressCommand: (C E M) Sets the callback function to be invoked upon clicking a
    treeView button  First argument specifies which treeView button  Second argument specifies
    t
    :type pressCommand: [int, script]
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param removeAll: (C E) Removes all items from the tree view
    :type removeAll: boolean
    :param removeItem: (C E) Removes a tree view item from the tree view  If this item has
    children items, all children items are removed  First argument specifies the item's nam
    :type removeItem: string
    :param reverseTreeOrder: (C E) Controls the order the tree will be drawn in (reversed if
    true)
    :type reverseTreeOrder: boolean
    :param rightPressCommand: (C E M) Sets the callback function to be invoked upon right
    clicking a treeView button  First argument specifies which treeView button  Second argument
    speci
    :type rightPressCommand: [int, script]
    :param select: (C E) Set selection on an element  The first parameter specifies the item,
    the second specifies on or off
    :type select: [string, int]
    :param selectCommand: (C E) Set the callback function to be invoked when an item is
    selected or deselected in the tree  The function should accept one string argument and one
    in
    :type selectCommand: script
    :param selectItem: (C Q E) Sets an item's selected state  first argument specifies the item,
    second argument specifies selection status  When used for query without arguments,
    :type selectItem: [string, boolean]
    :param selectionChangedCommand: (C E) Set the callback function to be invoked when a
    complete selection operation triggered by the user has occurred successfully  The callback
    is invoked
    :type selectionChangedCommand: script
    :param selectionColor: (C Q E) Sets the color an item will turn to indicate that it is
    selected  first parameter specifies the item three float values specify RGB values, between
    0
    :type selectionColor: [string, float, float, float]
    :param showItem: (C E) Show the item  Scroll the list as necessary so that item is visible
    :type showItem: string
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param textColor: (C E) Sets the label's text color for the specified layer  first argument
    specifies layer  three float values specify RGB values, between 0 and 1
    :type textColor: [string, float, float, float]
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The full name of the control.
    :rtype: string
    """
    pass


def polyToSubdiv(*args, absolutePosition=True, applyMatrixToResult=True, caching=True,
                 maxEdgesPerVert=32, maxPolyCount=1000, nodeState=0,
                 preserveVertexOrdering=True, quickConvert=True, uvPoints=None, uvPointsU=0.0,
                 uvPointsV=0.0, uvTreatment=0, addUnderTransform=True, constructionHistory=True,
                 name="", object=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command converts a polygon and produces a subd surface  The name of the new
    subdivision surface is returned  If construction history is ON, then the name of the new
    dependency node is returned as well
    
    :param absolutePosition: (C Q E) If true, the possible blind data information that comes
    from the polygon will be treated as absolute positions of the vertices, instead of the
    relati
    :type absolutePosition: boolean
    :param applyMatrixToResult: (C Q E) If true, the matrix on the input geometry is applied to
    the object and the resulting geometry will have identity matrix on it  If false the
    conversio
    :type applyMatrixToResult: boolean
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param maxEdgesPerVert: (C Q E) The maximum allowed valence for a vertex on the input mesh
    Default: 32
    :type maxEdgesPerVert: int
    :param maxPolyCount: (C Q E) The maximum number of polygons accepted on the input mesh 
    Default: 1000
    :type maxPolyCount: int
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param preserveVertexOrdering: (C Q E) Preserve vertex ordering in conversion Default:
    true
    :type preserveVertexOrdering: boolean
    :param quickConvert: (C Q E) Debug flag to test the performance Default: true
    :type quickConvert: boolean
    :param uvPoints: (C Q E M) This is a cached uv point needed to transfer uv data associated
    with finer level vertices (when switching between standard editing mode and poly prox
    :type uvPoints: [float, float]
    :param uvPointsU: (C Q E) U value of a cached uv point
    :type uvPointsU: float
    :param uvPointsV: (C Q E) V value of a cached uv point
    :type uvPointsV: float
    :param uvTreatment: (C Q E) Treatment of Subd UVs when in proxy mode: 0 - preserve Subd UVs
    1 - build Subd UVs from Poly UVs 2 - no UVs on Subd Default: 0
    :type uvTreatment: int
    :param addUnderTransform: (C) If true then add the new subdivision surface under the poly's
    transform
    :type addUnderTransform: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    
    :returns: - the subdivision and optionally the dependency node name
    :rtype: string
    """
    pass


def enableDevice(*args, apply=True, device="", enable=True, monitor=True, record=True, q=True,
                 query=True, **kwargs):
    """
    Sets (or queries) the device enable state for actions involving the device    -monitor
    affects all assignInputDevice and attachDeviceAttr actions for the named device -record
    controls if the device is recorded (by default) by a recordDevice action -apply channelName
    [channelName ..  ] controls if data from the device channel is applied (by default)
    
    :param apply: (C Q) enable/disable "applyTake" for the specified channel(s)
    :type apply: boolean
    :param device: (C Q) specifies the device to change
    :type device: string
    :param enable: (C Q) enable (or disable) monitor/record/apply
    :type enable: boolean
    :param monitor: (C Q) enables/disables visible update for the device (default)
    :type monitor: boolean
    :param record: (C Q) enable/disable "recordDevice" device recording
    :type record: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def PolygonCollapse(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def assignInputDevice(*args, clutch="", continuous=True, device="", immediate=True,
                      multiple=True, q=True, query=True, **kwargs):
    """
    This command associates a command string (i.e  a mel script) with the input device  When
    the device moves or a button on the device is pressed, the command string is executed as if
    you typed it into the window  If the command string contains the names of buttons or axes
    of the device, the current value of these buttons/axes are substituted in  Butt
    
    :param clutch: (C) specify a clutch button  This button must be down for the command string
    to be executed  If no clutch is specified the command string is executed eve
    :type clutch: string
    :param continuous: (C) if this flag is set the command string is continously (once for
    everytime the device changes state)  By default if a clutch button is specified the c
    :type continuous: boolean
    :param device: (C) specify which device to assign the command string
    :type device: string
    :param immediate: (C) Immediately executes the command, without using the queue
    :type immediate: boolean
    :param multiple: (C) if this flag is set the other command strings associated with this
    device are not deleted  By default, when a new command string is attached to the d
    :type multiple: boolean
    
    :returns: Command result
    :rtype: string
    """
    pass


def ShowSelectedObjects(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def editMetadata(*args, memberName="", remove=True, stringValue="", value=0.0, channelName="",
                 channelType="", endIndex="", index="", indexType="", scene=True, startIndex="",
                 streamName="", **kwargs):
    """
    This command is used to set metadata elements onto or remove metadata elements from an
    object  Before using this command you must first attach a metadata stream type to the
    object using the addMetadata command or an API equivalent  The command has four basic
    variations:  Set per-component metadata on meshes Remove per-component metadata on meshes
    S
    
    :param memberName: (C) Name of the Structure member being edited  The names of the members
    are set up in the Structure definition, either through the description passed in
    :type memberName: string
    :param remove: (C) If the remove flag is set then the metadata will be removed rather than
    have values set  In this mode the "memberName", "value", and "stringValue" fl
    :type remove: boolean
    :param stringValue: (C M) String value to be set into the specified metadata locations 
    This flag can only be used when the data member is a numeric type  If the member has N
    :type stringValue: string
    :param value: (C M) Numeric value to be set into the specified metadata locations  This
    flag can only be used when the data member is a numeric type  If the member has N
    :type value: float
    :param channelName: (C Q) Filter the metadata selection to only recognize metadata
    belonging to the specified named Channel (e.g  "vertex")  This flag is ignored if the
    compon
    :type channelName: string
    :param channelType: (C Q) Obsolete - use the 'channelName' flag instead  In query mode,
    this flag can accept a value
    :type channelType: string
    :param endIndex: (C) The metadata is stored in a Stream, which is an indexed list  If you
    have mesh components selected then the metadata indices are implicit in the list
    :type endIndex: string
    :param index: (C Q M) In the typical case metadata is indexed using a simple integer value 
    Certain types of data may use other index types  e.g  a "vertexFace" component
    :type index: string
    :param indexType: (C Q) Name of the index type the new Channel should be using  If not
    specified this defaults to a simple integer index  Of the native types only a mesh "ve
    :type indexType: string
    :param scene: (C Q) Use this flag when you want to add metadata to the scene as a whole
    rather than to any individual nodes  If you use this flag and have nodes selected
    :type scene: boolean
    :param startIndex: (C) The metadata is stored in a Stream, which is an indexed list  If you
    have mesh components selected then the metadata indices are implicit in the list
    :type startIndex: string
    :param streamName: (C Q) Name of the metadata Stream  Depending on context it could be the
    name of a Stream to be created, or the name of the Stream to pass through the filte
    :type streamName: string
    
    :returns: Name of the node where the new edits reside, empty string if edits failed. It
    will be an editMetadata node if construction history was present.
    :rtype: string
    """
    pass


def EnableFluids(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SaveFluidStateAs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ModifyConstraintAxisOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OutlinerRevealSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyCollapseFacet(*args, areaThreshold=0.1, caching=True, constructionHistory=True, name="",
                      nodeState=0, useAreaThreshold=False, q=True, query=True, e=True,
                      edit=True, **kwargs):
    """
    Turns each selected facet into a point
    
    :param areaThreshold: (C Q E) Area threshold to determine whether faces should be collapsed
     Attribute is ignored unless useAreaThreshold is set to true  Default: 0.1
    :type areaThreshold: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param useAreaThreshold: (C Q E) If true only collapse faces with area less than the area
    threshold, otherwise collapse all faces regardless of area Default: false
    :type useAreaThreshold: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def xgmGuideGeom(*args, **kwargs):
    """
    
    """
    pass


def modelingToolkitSuperCtx(*args, **kwargs):
    """
    
    """
    pass


def ArtPaintBlendShapeWeightsTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectContainerContents(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ClosestPointOnOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ikHandleDisplayScale(*args, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This action modifies and queries the current display size of ikHandle  The default display
    scale is 1.0
    
    
    :returns: Returns current display size of ikHandle.
    :rtype: float
    """
    pass


def timeEditorClip(*args, absolute=True, addAttribute="", allowShrinking=True, animSource="",
                   audio="", children=0, clipAfter=True, clipBefore=True, clipDataType=True,
                   clipId=0, clipIdFromNodeName=0, clipIdFromPath=True, clipNode=True,
                   clipPath=True, copyClip=True, crossfadeMode=0, crossfadePlug=True,
                   curveTime=None, defaultGhostRoot=True, drivenAttributes=True,
                   drivenClipsBySource="", drivenObjects=True, drivenRootObjects=True,
                   drivingSources="", duplicateClip=True, duration=None, emptySource=True,
                   endTime=None, existingOnly=True, exists=True, explode=0, exportAllClips=True,
                   exportFbx="", extend=True, extendParent=True, ghost=True, ghostRootAdd="",
                   ghostRootRemove="", group=True, holdEnd=None, holdStart=None,
                   importTakeDestination=1, isContainer=True, listUserGhostRoot=True,
                   loopEnd=None, loopStart=None, minClipDuration=True, modifyAnimSource=True,
                   moveClip=None, mute=True, name="", parent=0, parentClipId=0,
                   parentGroupId=True, pasteClip=None, path="", preserveAnimationTiming=True,
                   razorClip=None, remap=None, remapSource=None, remappedSourceAttrs=True,
                   remappedTargetAttrs=True, removeAttribute="", removeClip=True,
                   removeCrossfade=True, removeWeightCurve=True, resetTiming=True,
                   resetTransition=True, ripple=True, rootClipId=0, rootPath="", scaleEnd=None,
                   scalePivot=None, scaleStart=None, setKeyframe="", speedRamping=7,
                   startTime=None, timeWarp=True, timeWarpCurve=True, timeWarpType=0, track="",
                   tracksNode=True, transition=True, trimEnd=None, trimStart=None,
                   truncated=True, uniqueAnimSource=True, userGhostRoot=True, weightCurve=True,
                   zeroKeying=True, addObjects="", addRelatedKG=True, addSelectedObjects=True,
                   attribute="", exclusive=True, importAllFbxTakes=True, importFbx="",
                   importFbxTakes="", importMayaFile="", importOption="",
                   importPopulateOption="", importedContainerNames="", includeRoot=True,
                   populateImportedAnimSources="", poseClip=True, recursively=True,
                   removeSceneAnimation=True, showAnimSourceRemapping=True, takeList="",
                   takesToImport="", type="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command edits/queries Time Editor clips
    
    :param absolute: (Q) This flag is used in conjunction with other timing flags like -s/start,
    -d/duration, -ed/end, etc  to query (global) absolute time
    :type absolute: boolean
    :param addAttribute: (E M) Add new attribute to the clip
    :type addAttribute: string
    :param allowShrinking: (E) When extending clip, allow shrinking
    :type allowShrinking: boolean
    :param animSource: (C Q E) Populate based on animation source
    :type animSource: string
    :param audio: (C) Create a clip with audio inside
    :type audio: string
    :param children: (Q) Get children clip IDs
    :type children: int
    :param clipAfter: (Q) Get the clip ID of the next clip
    :type clipAfter: boolean
    :param clipBefore: (Q) Get the clip ID of the previous clip
    :type clipBefore: boolean
    :param clipDataType: (Q) Query the type of data being driven by the given clip ID  Return
    values are: 0 : Animation - Clip drives animation curves 1 : Audio - Clip drives aud
    :type clipDataType: boolean
    :param clipId: (C E M) ID of the clip to be edited
    :type clipId: int
    :param clipIdFromNodeName: (Q) Get clip ID from clip node name
    :type clipIdFromNodeName: int
    :param clipIdFromPath: (Q) Flag for querying the clip ID given the path  Clip path is a
    vertical-bar-delimited string to indicate a hierarchical structure of a clip  Please ref
    :type clipIdFromPath: boolean
    :param clipNode: (Q) Flag for querying the name of the clip node
    :type clipNode: boolean
    :param clipPath: (Q) Flag for querying the path given the clip ID  Clip path is a vertical
    bar delimited string to indicate a hierarchical structure of a clip  Please ref
    :type clipPath: boolean
    :param copyClip: (E) Get the selected clip IDs and store them in a list that could be used
    for pasting
    :type copyClip: boolean
    :param crossfadeMode: (Q E) Set the crossfading mode between two clips that lie on the same
    track, and that are specified with the -clipId flags: 0 : linear - Two clips are blen
    :type crossfadeMode: int
    :param crossfadePlug: (Q) Get plug path for a custom crossfade curve between 2 clips
    :type crossfadePlug: boolean
    :param curveTime: (Q) Query the curve local time in relation to the given clip
    :type curveTime: time
    :param defaultGhostRoot: (Q E) Edit or query default ghost root variable  Determine whether
    to use the default ghost root (object driven by clip)
    :type defaultGhostRoot: boolean
    :param drivenAttributes: (Q) Return a list of attributes driven by a clip
    :type drivenAttributes: boolean
    :param drivenClipsBySource: (Q) Returns the clips driven by the given source  Can filter
    the return result by the specified type, like animCurve, expression, constraint, etc  This
    f
    :type drivenClipsBySource: string
    :param drivenObjects: (Q) Return an array of strings consisting of the names of all objects
    driven by the current clip and its children clips
    :type drivenObjects: boolean
    :param drivenRootObjects: (Q) Return an array of strings consisting of the names of all
    root objects driven by this clip and its children clips
    :type drivenRootObjects: boolean
    :param drivingSources: (Q) Return all sources driving the given clip  Can filter the return
    result by the specified type, like animCurve, expression, constraint, etc  If used a
    :type drivingSources: string
    :param duplicateClip: (E) Duplicate clip into two clips with the same timing info
    :type duplicateClip: boolean
    :param duration: (C Q) Relative duration of the new clip
    :type duration: time
    :param emptySource: (C) Create a clip with an empty source
    :type emptySource: boolean
    :param endTime: (Q) Query the relative end time of the clip
    :type endTime: time
    :param existingOnly: (E) This flag can only be used in edit mode, in conjunction with the
    animSource flag  Retain the animSource flag functionality but only bind attributes t
    :type existingOnly: boolean
    :param exists: (Q) Return true if the specified clip exists
    :type exists: boolean
    :param explode: (E) Reparent all tracks and their clips within a group out to its parent
    track node and remove the group
    :type explode: int
    :param exportAllClips: (E) When used with the ef/exportFbx flag, export all clips
    :type exportAllClips: boolean
    :param exportFbx: (E) Export currently selected clips to FBX files
    :type exportFbx: string
    :param extend: (E) Extend the clip to encompass all children
    :type extend: boolean
    :param extendParent: (E) Extend parent to fit this clip
    :type extendParent: boolean
    :param ghost: (Q E) Enable/disable ghosting for the specified clip
    :type ghost: boolean
    :param ghostRootAdd: (E M) Add path to specified node as a custom ghost root
    :type ghostRootAdd: string
    :param ghostRootRemove: (E M) Remove path to specified node as a custom ghost root
    :type ghostRootRemove: string
    :param group: (C) Specify if the new container should be created as a group, containing
    other specified clips
    :type group: boolean
    :param holdEnd: (Q E) Hold clip's end to time
    :type holdEnd: time
    :param holdStart: (Q E) Hold clip's start to time
    :type holdStart: time
    :param importTakeDestination: (C) Specify how to organize imported FBX takes: 0 - Import
    takes into a group (default) 1 - Import takes into multiple compositions 2 - Import takes
    as a
    :type importTakeDestination: int
    :param isContainer: (Q) Indicate if given clip ID is a container
    :type isContainer: boolean
    :param listUserGhostRoot: (Q) Get user defined ghost root object for indicated clips
    :type listUserGhostRoot: boolean
    :param loopEnd: (Q E) Loop clip's end to time
    :type loopEnd: time
    :param loopStart: (Q E) Loop clip's start to time
    :type loopStart: time
    :param minClipDuration: (Q) Returns the minimum allowed clip duration
    :type minClipDuration: boolean
    :param modifyAnimSource: (C E) When populating, automatically modify Anim Source without
    asking the user
    :type modifyAnimSource: boolean
    :param moveClip: (E) Move clip by adding delta to its start time
    :type moveClip: time
    :param mute: (Q E) Mute/Unmute the clip given a clip ID  In query mode, return the muted
    state of the clip  Clips muted by soloing are not affected by this flag
    :type mute: boolean
    :param name: (Q E) Name of the clip  A clip will never have an empty name  If an empty
    string is provided, it will be replaced with "_"
    :type name: string
    :param parent: (E) Specify group/object parent ID
    :type parent: int
    :param parentClipId: (C Q) Specify the parent clip ID of a clip to be created
    :type parentClipId: int
    :param parentGroupId: (Q) Return the parent group ID of the given clip
    :type parentGroupId: boolean
    :param pasteClip: (E) Paste clip to the given time and track  Destination track is required
    to be specified through the track flag in the format "tracksNode:trackIndex"  A
    :type pasteClip: time
    :param path: (E M) Full path of the clip to be edited  For example:
    composition1|track1|clip1  In query mode, this flag can accept a value
    :type path: string
    :param preserveAnimationTiming: (C) When used with the population command, it ensures the
    animation is offset within a clip in such way that it matches its original scene timing,
    regard
    :type preserveAnimationTiming: boolean
    :param razorClip: (E) Razor clip into two clips at the specified time
    :type razorClip: time
    :param remap: (E) Change animation source for a given clip item to a new one, specified by
    the target path  This removes all clips for the roster item and creates new
    :type remap: [string, string]
    :param remapSource: (E) Set animation source to be remapped for a given clip item to new
    one, specified by the target path
    :type remapSource: [string, string]
    :param remappedSourceAttrs: (Q) Return an array of attribute indices and names of the
    source attributes of a remapped clip
    :type remappedSourceAttrs: boolean
    :param remappedTargetAttrs: (Q) Return an array of attribute indices and names of the
    target attributes of a remapped clip
    :type remappedTargetAttrs: boolean
    :param removeAttribute: (E M) Remove attribute from the clip
    :type removeAttribute: string
    :param removeClip: (E) Remove clip of specified ID
    :type removeClip: boolean
    :param removeCrossfade: (E) Remove custom crossfade between two clips specified by -clipId
    flags
    :type removeCrossfade: boolean
    :param removeWeightCurve: (C Q E) Remove the weight curve connected to the clip
    :type removeWeightCurve: boolean
    :param resetTiming: (E) Reset start and duration of a clip with the given clip ID to the
    values stored in its Anim Source
    :type resetTiming: boolean
    :param resetTransition: (E) Reset transition intervals between specified clips
    :type resetTransition: boolean
    :param ripple: (E) Apply rippling to a clip operation
    :type ripple: boolean
    :param rootClipId: (E) ID of the root clip  It is used together with various clip editing
    flags  When used, the effect of clip editing and its parameters will be affected b
    :type rootClipId: int
    :param rootPath: (E) Path of the root clip  It is used together with various clip editing
    flags  When used, the effect of clip editing and its parameters will be affected
    :type rootPath: string
    :param scaleEnd: (E) Scale the end time of the clip to the given time
    :type scaleEnd: time
    :param scalePivot: (E) Scale the time of the clip based on the pivot  This should be used
    together with -scs/scaleStart or -sce/scaleEnd
    :type scalePivot: time
    :param scaleStart: (E) Scale the start time of the clip to the given time
    :type scaleStart: time
    :param setKeyframe: (E M) Set keyframe on a specific clip for a specified attribute
    :type setKeyframe: string
    :param speedRamping: (Q E) To control the playback speed of the clip by animation curve: 1
    : create - Attach a speed curve and a time warp curve to the clip to control the play
    :type speedRamping: int
    :param startTime: (C Q) Relative start time of the new clip
    :type startTime: time
    :param timeWarp: (Q) Return true if the clip is being warped by the speed curve  If no
    speed curve is attached to the clip, it will always return false
    :type timeWarp: boolean
    :param timeWarpCurve: (Q) Returns the name of the time warp curve connected to the clip
    :type timeWarpCurve: boolean
    :param timeWarpType: (Q E) Time warp mode: 0: remapping - Connected time warp curve
    performs frame by frame remapping 1: speed curve - Connected time warp curve acts as a
    speed
    :type timeWarpType: int
    :param track: (C Q E) The new clip container will be created on the track in the format
    "trackNode:trackNumber", or on a track path, for example "composition1|track1"  In
    :type track: string
    :param tracksNode: (Q) Get tracks node if specified clip is a group clip
    :type tracksNode: boolean
    :param transition: (E) Create transition intervals between specified clips
    :type transition: boolean
    :param trimEnd: (E) Trim the end time of the clip to the given time
    :type trimEnd: time
    :param trimStart: (E) Trim the start time of the clip to the given time
    :type trimStart: time
    :param truncated: (Q) This flag is used in conjunction with other timing flags like
    -s/start, -d/duration, -ed/end, etc  to query (global) truncated time
    :type truncated: boolean
    :param uniqueAnimSource: (E) If a given clip is sharing its Anim Source node with another
    clip, make the Anim Source of this clip unique
    :type uniqueAnimSource: boolean
    :param userGhostRoot: (Q E) Edit or query custom ghost root variable  Determine whether to
    use user defined ghost root
    :type userGhostRoot: boolean
    :param weightCurve: (C Q E) In edit mode, create a weight curve and connect it to the clip 
    In query mode, return the name of the weight curve connected to the clip
    :type weightCurve: boolean
    :param zeroKeying: (E) A toggle flag to use in conjunction with k/setKeyframe, set the
    value of the key frame(s) to be keyed to zero
    :type zeroKeying: boolean
    :param addObjects: (C Q E) Populate the given object(s) and their attributes to anim source
    to Time Editor  For multiple object, pass each name separated by semicolon  In query
    :type addObjects: string
    :param addRelatedKG: (C Q E) During population, determine if associated keying groups
    should be populated or not  Normally used for populating HIK  By default the value is
    false
    :type addRelatedKG: boolean
    :param addSelectedObjects: (C Q E) Populate the currently selected objects and their
    attributes to anim source or Time Editor  In query mode, return the number of attributes
    that will
    :type addSelectedObjects: boolean
    :param attribute: (C E M) Populate a specific attribute on a object
    :type attribute: string
    :param exclusive: (C E) Populate all types of animation sources which are not listed by
    "type" Flag
    :type exclusive: boolean
    :param importAllFbxTakes: (C) Import all FBX takes into the new anim sources (for
    timeEditorAnimSource command) or new containers (for timeEditorClip command)
    :type importAllFbxTakes: boolean
    :param importFbx: (C) Import an animation from FBX file into the new anim source (for
    timeEditorAnimSource command) or new container (for timeEditorClip command)
    :type importFbx: string
    :param importFbxTakes: (C) Import multiple FBX takes (separated by semicolons) into the new
    anim sources (for timeEditorAnimSource command) or new containers (for timeEditorCli
    :type importFbxTakes: string
    :param importMayaFile: (C) Import an animation from Maya file into the new anim sources
    (for timeEditorAnimSource command) or new containers (for timeEditorClip command)
    :type importMayaFile: string
    :param importOption: (E) Option for importing animation source  Specify either 'connect' or
    'generate'  connect: Only connect with nodes already existing in the scene  Import
    :type importOption: string
    :param importPopulateOption: (E) Option for population when importing
    :type importPopulateOption: string
    :param importedContainerNames: (C) Internal use only  To be used along with
    populateImportedAnimSources to specify names for the created containers
    :type importedContainerNames: string
    :param includeRoot: (C E) Populate transform (Translate, Rotate, Scale) of hierarchy root
    nodes
    :type includeRoot: boolean
    :param populateImportedAnimSources: (C) Internal use only  Populate the Time Editor with
    clips using the Animation Sources specified (use ; as a delimiter for multiple anim
    sources)
    :type populateImportedAnimSources: string
    :param poseClip: (C) Populate as pose clip with current attribute values
    :type poseClip: boolean
    :param recursively: (C E) Populate selection recursively, adding all the children
    :type recursively: boolean
    :param removeSceneAnimation: (C E) If true, remove animation from scene when creating clips
    or anim sources  Only Time Editor will drive the removed scene animation
    :type removeSceneAnimation: boolean
    :param showAnimSourceRemapping: (C) Show a remapping dialog when the imported anim source
    attributes do not match the scene attributes
    :type showAnimSourceRemapping: boolean
    :param takeList: (C) Internal use only  To be used along with populateImportedAnimSources
    to specify the imported take names
    :type takeList: string
    :param takesToImport: (C) Internal use only  To be used along with
    populateImportedAnimSources to specify the imported take indices
    :type takesToImport: string
    :param type: (C Q E M) Only populate the specified type of animation source
    :type type: string
    
    :returns: Return created clip's name.
    :rtype: string
    """
    pass


def xgmWrapXGen(*args, **kwargs):
    """
    
    """
    pass


def polyConnectComponents(*args, adjustEdgeFlow=0.0, caching=True, constructionHistory=True,
                          insertWithEdgeFlow=True, name="", nodeState=0, q=True, query=True,
                          e=True, edit=True, **kwargs):
    """
    Splits polygon edges according to the selected components  The selected components are
    gathered into connected 'paths' that define continuous splits  Mixed components (vertices,
    edges and faces) can be used at once  The connection rules are: * Edges can connect to
    other edges in the same face or to vertices in the same face (that are not in the edg
    
    :param adjustEdgeFlow: (C Q E) The weight value of the edge vertices to be positioned
    :type adjustEdgeFlow: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param insertWithEdgeFlow: (C Q E) True to enable edge flow  Otherwise, the edge flow is
    disabled
    :type insertWithEdgeFlow: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def MirrorCutPolygonGeometry(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PlanarProjectionOptions(*args, **kwargs):
    """
    unknown
    """
    pass


def FreezeTransformationsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def saveViewportSettings(*args, **kwargs):
    """
    This command causes all the 3d views to save their settings as optionVar's  This is called
    automatically by the system when Maya exits
    
    
    :returns: 
    :rtype: None
    """
    pass


def HypershadeShowCustomAttrs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorToggleNodeTitleMode(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreatePondOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xpmPicker(*args, fileName="", parent="", **kwargs):
    """
    Open a dialog and ask you to choose a xpm file
    
    :param fileName: (C) default filename to display in dialog
    :type fileName: string
    :param parent: (C) parent window for modal dialog
    :type parent: string
    
    :returns: The full name of the xpm file
    :rtype: string
    """
    pass


def manipComponentPivot(*args, **kwargs):
    """
    
    """
    pass


def GraphCopyOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ReverseCurveOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def batchRender(*args, filename="", melCommand="", numProcs=0, preRenderCommand="",
                remoteRenderMachine="", renderCommandOptions="", showImage=True, status="",
                useRemoteRender=True, useStandalone=True, verbosity=0, **kwargs):
    """
    The batchRender command is used to spawn off a separate rendering session of the current
    maya file  If no mayaFile is specified, it'll ask you whether you want the current job
    killed    The batchRender will spawn a separate maya process in which commands will be
    communicated to it through a commandPort  If Maya is unable to find an available port a
    
    :param filename: (C) Filename to be rendered; if empty, a temporary filename will be
    created
    :type filename: string
    :param melCommand: (C) Mel command to execute to run a renderer other than the software
    renderer
    :type melCommand: string
    :param numProcs: (C) Number of processors to use (0 means use all available processors)
    :type numProcs: int
    :param preRenderCommand: (C) Command to be run prior to invoking a batch render
    :type preRenderCommand: string
    :param remoteRenderMachine: (C) Name of remote render machine  Not available on Windows
    :type remoteRenderMachine: string
    :param renderCommandOptions: (C) Arguments to the render command for batch rendering
    :type renderCommandOptions: string
    :param showImage: (C) Show progress of the current rendering job
    :type showImage: boolean
    :param status: (C) Status string for displaying the batch render status
    :type status: string
    :param useRemoteRender: (C) If remote rendering is desired  Not available on Windows
    :type useRemoteRender: boolean
    :param useStandalone: (C) Batch rendering is to be done by exporting the scene and
    rendering with a standalone renderer
    :type useStandalone: boolean
    :param verbosity: (C) Defines the verbosity level to report the batch rendering status: 1:
    display only one start message, then one message when all frames are rendered  2
    :type verbosity: int
    
    :returns: 
    :rtype: None
    """
    pass


def CharacterMapper(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Art3dPaintTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ParentOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RotateToolMarkingMenu(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def resetTool(*args, **kwargs):
    """
    This command resets a tool back to its "factory settings"
    
    
    :returns: 
    :rtype: None
    """
    pass


def subdCleanTopology(*args, **kwargs):
    """
    Command cleans topology of subdiv surfaces - at all levels  It cleans the geometry of
    vertices that satisfy the following conditions: - Zero edits - Default uvs (uvs obtained by
    subdividing parent face)  - No creases
    
    
    :returns: Success or Failure.
    :rtype: boolean
    """
    pass


def convertSolidTx(*args, alpha=True, antiAlias=True, backgroundColor=None, backgroundMode="",
                   camera=None, componentRange=True, doubleSided=True, fileFormat="",
                   fileImageName="", fillTextureSeams=True, force=True, fullUvRange=True,
                   name="", pixelFormat="8", resolutionX=0, resolutionY=0, reuseDepthMap=False,
                   samplePlane=True, samplePlaneRange=None, shadows=True, uvBBoxIntersect=True,
                   uvRange=None, uvSetName="", q=True, query=True, e=True, edit=True,
                   **kwargs):
    """
    Command to convert a texture on a surface to a file texture  The first argument is a
    rendering node or attribute  If only the node is specified, the outColor attribute will be
    sampled  If the node does not have an outColor attribute, the first attribute on the node
    which is: readable, not writable, not hidden, connectable, and not a multi is used  
    
    :param alpha: (C) Specify whether to compute the transparency when baking lighting  The
    conversion will sample both the color and transparency of the shading network;
    :type alpha: boolean
    :param antiAlias: (C) Perform anti-aliasing on the resulting image  Convert solid texture
    will generally take four times longer than without anti-aliasing  By default this
    :type antiAlias: boolean
    :param backgroundColor: (C) Set the background color to a specific value  Default is to use
    the shader default color to fill the background  Valid values range from 0 to 255 if
    :type backgroundColor: [int, int, int]
    :param backgroundMode: (C) Defines how the background of the texture should be filled 
    Three modes are available: "shader" or 1: uses the default shader color  "color" or 2: us
    :type backgroundMode: string
    :param camera: (C) Specify a camera to use in baking lighting  If a camera is not specified
    the camera in the active view will be used
    :type camera: name
    :param componentRange: (C) If one or more components have been selected to use, then if
    this flag is set, then the uv range of the components is used to fit into the texture ma
    :type componentRange: boolean
    :param doubleSided: (C) Specify whether the sampler should flip the surface normal if the
    sample point faces away from the camera  Note: flipping the normal will make the re
    :type doubleSided: boolean
    :param fileFormat: (C) File format to be used for output  IFF is the default if unspecified
     Other valid formats are: als: Alias PIX cin: Cineon eps: EPS gif: GIF iff: Maya
    :type fileFormat: string
    :param fileImageName: (C) Specify the output path and name of file texture image  If the
    file name doesn't contain a directory separator, the image will be written to source i
    :type fileImageName: string
    :param fillTextureSeams: (C) Specify whether or not to overscan the polygon beyond its
    outer edges, when creating the file texture, in order to fill the texture seams  Default
    is
    :type fillTextureSeams: boolean
    :param force: (C) If the output image already exists overwrite it  By default this flag is
    off
    :type force: boolean
    :param fullUvRange: (C) Sample using the full uv range of the surface  This flag cannot be
    used with the -uvr flag  A 2D texture placement node will be created and connected
    :type fullUvRange: boolean
    :param name: (C) Set the name of the file texture node  Name conflict resolution will be
    used to determine valid names when multiple objects are specified
    :type name: string
    :param pixelFormat: (C) Specifies the pixel format of the image  Note that not all file
    formats support all pixel formats  Available options: "8": 8 bits per channel, unsign
    :type pixelFormat: string
    :param resolutionX: (C) Set the horizontal image resolution  If this flag is not specified,
    the resolution will be set to 256
    :type resolutionX: int
    :param resolutionY: (C) Set the vertical image resolution  If this flag is not specified,
    the resolution will be set to 256
    :type resolutionY: int
    :param reuseDepthMap: (C) Specify whether or not to reuse all the generated dmaps  Default
    is false
    :type reuseDepthMap: boolean
    :param samplePlane: (C) Specify whether to sample using a virtual plane  This virtual plane
    has texture coordinates in the rectangle defined by the -samplePlaneRange flag  I
    :type samplePlane: boolean
    :param samplePlaneRange: (C) Specify the uv range of the texture coordinates used to sample
    if the -samplePlane option is set  There are four arguments corresponding to uMin, uMa
    :type samplePlaneRange: [float, float, float, float]
    :param shadows: (C) Specify whether to compute shadows when baking lighting  Disk based
    shadow maps will be used  Only lights with depth map shadows enabled will contrib
    :type shadows: boolean
    :param uvBBoxIntersect: (C) This flag is obsolete
    :type uvBBoxIntersect: boolean
    :param uvRange: (C) Specify the uv range in which samples will be computed  There are four
    arguments corresponding to uMin, uMax, vMin and vMax  Each value should be spe
    :type uvRange: [float, float, float, float]
    :param uvSetName: (C) Specify which uv set has to be used as the driving parametrization
    for convert solid
    :type uvSetName: string
    
    :returns: File texture nodes
    :rtype: string[]
    """
    pass


def nClothMakeCollideOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleFBIKEffectorsRotatePinState(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FlipUVs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PickWalkRightSelect(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AlignUVOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nameField(*args, annotation="", backgroundColor=None, changeCommand=None, defineTemplate="",
              docTag="", dragCallback=None, drawInactiveFrame=True, dropCallback=None,
              enable=True, enableBackground=True, enableKeyboardFocus=True, exists=True,
              fullPathName=True, height=0, highlightColor=None, isObscured=True, manage=True,
              nameChangeCommand=None, noBackground=True, numberOfPopupMenus=True, object="",
              parent="", popupMenuArray=True, preventOverride=True, receiveFocusCommand=None,
              statusBarMessage="", useTemplate="", visible=True, visibleChangeCommand=None,
              width=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates an editable field that can be linked to the name of a Maya object  The
    field will always show the name of the object
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C Q E) This command is executed when the field text is changed by
    the user
    :type changeCommand: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param drawInactiveFrame: (C Q E) Sets whether the name field draws itself with a frame
    when it is inactive  By default, this option is false
    :type drawInactiveFrame: boolean
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param nameChangeCommand: (C Q E) This command is executed when the name of the node
    changes  NOTE: this will be executed when the node name changes, whether or not the
    name-change or
    :type nameChangeCommand: script
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param object: (C Q E) Attaches the field to the named dage object, so that the field will
    always display the object's name
    :type object: string
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param receiveFocusCommand: (C Q E) Command executed when the field receives focus
    :type receiveFocusCommand: script
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def UnmirrorSmoothProxyOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolygonSoftenHardenOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CVHardnessOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def modelCurrentTimeCtx(*args, exists=True, history=True, image1="", image2="", image3="",
                        name="", percent=50, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a context which may be used to change current time within the model
    views
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param percent: (Q E) Percent of the screen space that represents the full time slider
    range (default is 50%)
    :type percent: float
    
    :returns: Context name
    :rtype: string
    """
    pass


def UnlockCurveLength(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Lightning(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PreInfinityCycle(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeRenameActiveTab(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def playblast(*args, activeEditor=True, cameraSetup=None, clearCache=True, codecOptions=True,
              combineSound=True, completeFilename="", compression="", editorPanelName="",
              endTime=None, filename="", forceOverwrite=True, format="", frame=None,
              framePadding=0, height=0, indexFromZero=True, offScreen=True,
              offScreenViewportUpdate=True, options=True, percent=50, quality=0,
              rawFrameNumbers=True, replaceAudioOnly=True, replaceEndTime=None,
              replaceFilename="", replaceStartTime=None, sequenceTime=True, showOrnaments=True,
              sound="", startTime=None, throwOnError=True, useTraxSounds=True, viewer=True,
              width=0, widthHeight=None, **kwargs):
    """
    This command playblasts the current playback range  Sound is optional   Note that the
    playblast command registers a condition called "playblasting" so that users can monitor
    whether playblasting is occurring  You may monitor the condition using the API
    (MConditionMessage) or a script (scriptJob and condition commands)
    
    :param activeEditor: (C) This flag will return the current model editor that would be used
    for playblast  It does not invoke playblast itself
    :type activeEditor: boolean
    :param cameraSetup: (C M) Information about camera setup  The first string defines a camera
    setup MEL procedure  The camera setup procedure will be invoked before executing a
    :type cameraSetup: [string, string]
    :param clearCache: (C) When true, all previous temporary playblast files will be deleted
    before the new playblast files are created and the remaining temporary playblast fi
    :type clearCache: boolean
    :param codecOptions: (C) Brings up the OS specific dialog for setting playblast codec
    options, and does not run the playblast
    :type codecOptions: boolean
    :param combineSound: (C) Combine the trax sounds into a single track  This might force a
    resampling of the sound if the sound paramters don't match up
    :type combineSound: boolean
    :param completeFilename: (C) When set, this string specifies the exact name of the output
    image  In contrast with the -f/filename flag, -cf/completeFilename does not append any f
    :type completeFilename: string
    :param compression: (C) Specify the compression to use for the movie file  To determine
    which settings are available on your system, use the `playblast -options` command  Th
    :type compression: string
    :param editorPanelName: (C) This optional flag specifies the name of the model editor or
    panel, which is to be used for playblast  The current model editor or panel won't be use
    :type editorPanelName: string
    :param endTime: (C) Specify the end time of the playblast  Default is the end time of the
    playback range displayed in the Time Slider  Overridden by -frame
    :type endTime: time
    :param filename: (C) The filename to use for the output of this playblast  If the file
    already exists, a confirmation box will be displayed if playblast is performed inte
    :type filename: string
    :param forceOverwrite: (C) Overwrite existing playblast files which may have the the same
    name as the one specified with the "-f" flag
    :type forceOverwrite: boolean
    :param format: (C) Same as "image"
    :type format: string
    :param frame: (C M) List of frames to blast  One frame specified per flag  The frames can
    be specified in any order but will be output in an ordered sequence  When speci
    :type frame: time
    :param framePadding: (C) Number of zeros used to pad file name  Typically set to 4 to
    support fcheck
    :type framePadding: int
    :param height: (C) Height of the final image  This value will be clamped if larger than the
    width of the active window  Windows: If not using fcheck, the width and heig
    :type height: int
    :param indexFromZero: (C) Output frames starting with file.0000.ext and incrementing by one
     Typically frames use the Maya time as their frame number  This option can only be
    :type indexFromZero: boolean
    :param offScreen: (C) When set, this toggle allow playblast to use an offscreen buffer to
    render the view  This allows playblast to work when the application is iconified,
    :type offScreen: boolean
    :param offScreenViewportUpdate: (C) When set, this toggle allows playblast to update the
    viewport while rendering with the offscreen buffer
    :type offScreenViewportUpdate: boolean
    :param options: (C) Brings up a dialog for setting playblast options, and does not run the
    playblast
    :type options: boolean
    :param percent: (C) Percentage of current view size to use during blasting  Accepted values
    are integers between 10 and 100  All other values are clamped to be within th
    :type percent: int
    :param quality: (C) Specify the compression quality factor to use for the movie file  Value
    should be in the 0-100 range
    :type quality: int
    :param rawFrameNumbers: (C) Playblast typically numbers its frames sequentially, starting
    at zero  This flag will override the default action and frames will be numbered using t
    :type rawFrameNumbers: boolean
    :param replaceAudioOnly: (C) When set, this string dictates that only the audio will be
    replaced when the scene is re-playblasted
    :type replaceAudioOnly: boolean
    :param replaceEndTime: (C) Specify the end time of a replayblast of an existing playblast 
    Default is the start time of the playback range displayed in the Time Slider  Overrid
    :type replaceEndTime: time
    :param replaceFilename: (C) When set, this string specifies the name of an input playblast
    file which will have frames replaced according to the replace start and end times
    :type replaceFilename: string
    :param replaceStartTime: (C) Specify the start time of a replayblast of an existing
    playblast  Default is the start time of the playback range displayed in the Time Slider 
    Overr
    :type replaceStartTime: time
    :param sequenceTime: (C) Use sequence time
    :type sequenceTime: boolean
    :param showOrnaments: (C) Sets whether or not model view ornaments (e.g  the axis icon)
    should be displayed
    :type showOrnaments: boolean
    :param sound: (C) Specify the sound node to be used during playblast
    :type sound: string
    :param startTime: (C) Specify the start time of the playblast  Default is the start time of
    the playback range displayed in the Time Slider  Overridden by -frame
    :type startTime: time
    :param throwOnError: (C) Playblast is tolerant of failures in most situations  When set,
    this toggle allows playblast to throw an error on these failures
    :type throwOnError: boolean
    :param useTraxSounds: (C) Use sounds from TRAX
    :type useTraxSounds: boolean
    :param viewer: (C) Specify whether a viewer should be launched for the playblast  Default
    is "true"  Runs "fcheck" when -fmt is "image"  The player for movie files depe
    :type viewer: boolean
    :param width: (C) Width of the final image  This value will be clamped if larger than the
    width of the active window  Windows: If not using fcheck, the width and heigh
    :type width: int
    :param widthHeight: (C) Final image's width and height  Values larger than the dimensions
    of the active window are clamped  A width and height of 0 means to use the window's
    :type widthHeight: [int, int]
    
    :returns: Name of moviefile created.
    :rtype: string
    """
    pass


def NodeEditorPinSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def hilite(*args, replace=True, toggle=True, unHilite=True, **kwargs):
    """
    Hilites/Unhilites the specified object(s)  Hiliting an object makes it possible to select
    the components of the object  If no objects are specified then the selection list is used
    
    :param replace: (C) Hilite the specified objects  Any objects previously hilited will no
    longer be hilited
    :type replace: boolean
    :param toggle: (C) Toggle the hilite state of the specified objects
    :type toggle: boolean
    :param unHilite: (C) Remove the specified objects from the hilite list
    :type unHilite: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def AddSelectionAsTargetShapeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmLengthBrushContext(*args, **kwargs):
    """
    
    """
    pass


def containerView(*args, itemInfo="", itemList=True, viewDescription=True, viewLabel=True,
                  viewList=True, viewName="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    A container view defines the layout information for the published attributes of a
    particular container  Container views can be selected from a set of built-in views or may
    be defined on an associated container template  This command queries the view-related
    information for a container node  The information returned from this command will be based
    o
    
    :param itemInfo: (Q) Used in query mode in conjunction with the itemList flag  The command
    will return a list of information for each item in the view, the information fi
    :type itemInfo: string
    :param itemList: (Q) Used in query mode, the command will return a list of information for
    each item in the view  The viewName flag is used to select the view to query  T
    :type itemList: boolean
    :param viewDescription: (Q) Used in query mode, returns the description field associated
    with the selected view  If no description was defined for this view, the value will be e
    :type viewDescription: boolean
    :param viewLabel: (Q) Used in query mode, returns the display label associated with the
    view  An appropriate label suitable for the user interface will be returned based o
    :type viewLabel: boolean
    :param viewList: (Q) Used in query mode, command will return a list of all views defined
    for the given target (container or template)
    :type viewList: boolean
    :param viewName: (Q) Used in query mode, specifies the name of the queried view when used
    in conjunction with a template target  When used in conjunction with a container
    :type viewName: string
    
    :returns: 
    :rtype: None
    """
    pass


def listInputDeviceAxes(*args, **kwargs):
    """
    This command lists all of the axes of the specified input device
    
    
    :returns: Command result
    :rtype: string[]
    """
    pass


def SculptReferenceVectorMarkingMenuRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def cMuscleWeightSave(*args, **kwargs):
    """
    
    """
    pass


def SelectAllLattices(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TexSculptActivateBrushStrength(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Newton(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSetCutBrushTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeRenderPerspLayout(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowMarkers(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RetimeKeysToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def radial(*args, attenuation=0.0, magnitude=0.0, maxDistance=0.0, name="", perVertex=True,
           position=None, torusSectionRadius=0.0, type=0.0, volumeExclusion=True,
           volumeOffset=None, volumeShape="", volumeSweep=0.0, q=True, query=True, e=True,
           edit=True, **kwargs):
    """
    For each listed object, the command creates a new field  The field has a shape which lives
    in the DAG and it has an associated dependency node  The field is added to the list of
    fields owned by the object  Use connectDynamic to cause the field to affect a dynamic
    object  Note that if more than one object is listed, a separate field is created for e
    
    :param attenuation: (Q E) Attentuation rate of field
    :type attenuation: float
    :param magnitude: (Q E) Strength of field
    :type magnitude: float
    :param maxDistance: (Q E) Maximum distance at which field is exerted  -1 indicates that the
    field has no maximum distance
    :type maxDistance: float
    :param name: (Q E) name of field
    :type name: string
    :param perVertex: (Q E) Per-vertex application  If this flag is set true, then each
    individual point (CV, particle, vertex,etc.) of the chosen object exerts an identical cop
    :type perVertex: boolean
    :param position: (Q E M) Position in space (x,y,z) where you want to place a gravity field 
    The gravity then emanates from this position in space rather than from an object
    :type position: [float, float, float]
    :param torusSectionRadius: (Q E) Section radius for a torus volume  Applies only to torus 
    Similar to the section radius in the torus modelling primitive
    :type torusSectionRadius: float
    :param type: (Q E) Type of radial field (0 - 1)  This controls the algorithm by which the
    field is attenuated  Type 1, provided for backward compatibility, specifies th
    :type type: float
    :param volumeExclusion: (Q E) Volume exclusion of the field  If true, points outside the
    volume (defined by the volume shape attribute) are affected, If false, points inside the v
    :type volumeExclusion: boolean
    :param volumeOffset: (Q E) Volume offset of the field  Volume offset translates the field's
    volume by the specified amount from the actual field location  This is in the field'
    :type volumeOffset: [float, float, float]
    :param volumeShape: (Q E) Volume shape of the field  Sets/edits/queries the field's volume
    shape attribute  If set to any value other than "none", determines a 3-D volume with
    :type volumeShape: string
    :param volumeSweep: (Q E) Volume sweep of the field  Applies only to sphere, cone, cylinder,
    and torus  Similar effect to the sweep attribute in modelling
    :type volumeSweep: float
    
    :returns: Command result
    :rtype: string
    """
    pass


def dR_selConstraintElement(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def U3DBrushPressureOff(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def roundConstantRadius(*args, append=False, constructionHistory=True, name="", object=True,
                        radiuss=0.0, side=None, sidea=0, sideb=0, q=True, query=True, e=True,
                        edit=True, **kwargs):
    """
    This command generates constant radius NURBS fillets and NURBS corner surfaces for matching
    edge pairs on NURBS surfaces  An edge pair is a matching pair of surface isoparms or trim
    edges  This command can handle more than one edge pair at a time  This command can also
    handle compound edges, which is where an edge pair is composed of more than two 
    
    :param append: (C) If true, then an edge pair is being added to an existing round
    dependency node  Default is false  When this flag is true, an existing round dependenc
    :type append: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param radiuss: (C M) Use this flag to specify radius  This overrides the "r/radius" flag 
    If only one "rad" flag is used, then it is applied to all edge pairs  If more th
    :type radiuss: float
    :param side: (C M) Use this flag for compound edges  It replaces the sidea/sideb flags and
    is compatible with Python  The first argument must be either "a" or "b"  The
    :type side: [string, int]
    :param sidea: (C M) Use this flag for compound edges in conjunction with the following
    "-sb" flag  This flag is not intended for use from Python  Please see "side" flag
    :type sidea: int
    :param sideb: (C M) Use this flag for compound edges in conjunction with the "-sa" flag 
    See description for the "-sa" flag  This flag is not intended for use from Pytho
    :type sideb: int
    
    :returns: (resulting NURBS surfaces' names and node name)
    :rtype: string[]
    """
    pass


def RenderViewNextImage(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorSetKey(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def IncreaseExposureCoarse(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def openMayaPref(*args, errlog=True, lazyLoad=True, oldPluginWarning=True, q=True, query=True,
                 e=True, edit=True, **kwargs):
    """
    Set or query API preferences
    
    :param errlog: (C Q E) toggles whether or not an error log of failed API method calls will
    be created  When set to true, a file called "OpenMayaErrorLog" will be created in
    :type errlog: boolean
    :param lazyLoad: (C Q E) toggles whether or not plugins will be loaded with the RTLD_NOW
    flag or the RTLD_LAZY flag of dlopen(3C)  If set to true, RTLD_LAZY will be used  In
    :type lazyLoad: boolean
    :param oldPluginWarning: (C Q E) toggles whether or not loadPlugin will generate a warning
    when plug-ins are loaded that were compiled against an older, and possibly incompatible
    May
    :type oldPluginWarning: boolean
    
    :returns: indicates success or failure
    :rtype: int
    """
    pass


def renderInfo(*args, castShadows=True, chordHeight=0.0, chordHeightRatio=0.0, doubleSided=True,
               edgeSwap=True, minScreen=0.0, name="", opposite=True, smoothShading=True, unum=0,
               useChordHeight=True, useChordHeightRatio=True, useDefaultLights=True,
               useMinScreen=True, utype=0, vnum=0, vtype=0, q=True, query=True, e=True,
               edit=True, **kwargs):
    """
    The renderInfo commands sets geometric properties of surfaces of the selected object
    
    :param castShadows: (C) Determines if object casts shadow or not
    :type castShadows: boolean
    :param chordHeight: (C) Tessellation subdivision criteria
    :type chordHeight: float
    :param chordHeightRatio: (C) Tessellation subdivision criteria
    :type chordHeightRatio: float
    :param doubleSided: (C) Determines if object double or single sided
    :type doubleSided: boolean
    :param edgeSwap: (C) Tessellation subdivision criteria
    :type edgeSwap: boolean
    :param minScreen: (C) Tessellation subdivision criteria
    :type minScreen: float
    :param name: (C) Namespace to use
    :type name: string
    :param opposite: (C) Determines if the normals of the object is to be reversed
    :type opposite: boolean
    :param smoothShading: (C) Determines if smooth shaded, or flat shaded - applies only to
    polysets
    :type smoothShading: boolean
    :param unum: (C) Tessellation subdivision criteria
    :type unum: int
    :param useChordHeight: (C) Tessellation subdivision criteria
    :type useChordHeight: boolean
    :param useChordHeightRatio: (C) Tessellation subdivision criteria
    :type useChordHeightRatio: boolean
    :param useDefaultLights: (C) Obsolete flag
    :type useDefaultLights: boolean
    :param useMinScreen: (C) Tessellation subdivision criteria
    :type useMinScreen: boolean
    :param utype: (C) Tessellation subdivision criteria
    :type utype: int
    :param vnum: (C) Tessellation subdivision criteria
    :type vnum: int
    :param vtype: (C) Tessellation subdivision criteria
    :type vtype: int
    
    :returns: 
    :rtype: None
    """
    pass


def DeleteAllIKHandles(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CutPolygon(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSetDensityBrushToolOption(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def reorderContainer(*args, back=True, front=True, relative=0, q=True, query=True, e=True,
                     edit=True, **kwargs):
    """
    This command reorders (moves) objects relative to their siblings in a container   For
    relative moves, both positive and negative numbers may be specified  Positive numbers move
    the object forward and negative numbers move the object backward amoung its siblings  When
    an object is at the end (beginning) of the list of siblings, a relative move of 1 
    
    :param back: (C Q E) Move object(s) to back of container contents list
    :type back: boolean
    :param front: (C Q E) Move object(s) to front of container contents list
    :type front: boolean
    :param relative: (C Q E) Move object(s) relative to other container contents
    :type relative: int
    
    :returns: 
    :rtype: None
    """
    pass


def TranslateToolMarkingMenuPopDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_connectRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OutTangentPlateau(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportAnimationOnly(*args, **kwargs):
    """
    
    """
    pass


def NamespaceEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MirrorSubdivSurfaceOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def checkBoxGrp(*args, adjustableColumn=0, adjustableColumn2=0, adjustableColumn3=0,
                adjustableColumn4=0, adjustableColumn5=0, adjustableColumn6=0, annotation="",
                backgroundColor=None, changeCommand=None, changeCommand1=None,
                changeCommand2=None, changeCommand3=None, changeCommand4=None, columnAlign=None,
                columnAlign2=None, columnAlign3=None, columnAlign4=None, columnAlign5=None,
                columnAlign6=None, columnAttach=None, columnAttach2=None, columnAttach3=None,
                columnAttach4=None, columnAttach5=None, columnAttach6=None, columnOffset2=None,
                columnOffset3=None, columnOffset4=None, columnOffset5=None, columnOffset6=None,
                columnWidth=None, columnWidth1=0, columnWidth2=None, columnWidth3=None,
                columnWidth4=None, columnWidth5=None, columnWidth6=None, defineTemplate="",
                docTag="", dragCallback=None, dropCallback=None, editable=True, enable=True,
                enable1=True, enable2=True, enable3=True, enable4=True, enableBackground=True,
                enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
                highlightColor=None, isObscured=True, label="", label1="", label2="", label3="",
                label4="", labelArray2=None, labelArray3=None, labelArray4=None, manage=True,
                noBackground=True, numberOfCheckBoxes=0, numberOfPopupMenus=True,
                offCommand=None, offCommand1=None, offCommand2=None, offCommand3=None,
                offCommand4=None, onCommand=None, onCommand1=None, onCommand2=None,
                onCommand3=None, onCommand4=None, parent="", popupMenuArray=True,
                preventOverride=True, rowAttach=None, statusBarMessage="", useTemplate="",
                value1=True, value2=True, value3=True, value4=True, valueArray2=None,
                valueArray3=None, valueArray4=None, vertical=True, visible=True,
                visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
                **kwargs):
    """
    All of the group commands position their individual controls in columns starting at column
    1  The layout of each control (ie  column) can be customized using the -cw/columnWidth,
    -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumn flags  By
    default, columns are left aligned with no offset and are 100 pixels wide  Only o
    
    :param adjustableColumn: (C E) Specifies which column has an adjustable size that changes
    with the sizing of the layout  The column value is a 1-based index  Passing 0 as argument
    :type adjustableColumn: int
    :param adjustableColumn2: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly two columns
    :type adjustableColumn2: int
    :param adjustableColumn3: (C E) Specifies that the column has an adjustable size that
    changes with the size of the parent layout  Ignored if there are not exactly three columns
    :type adjustableColumn3: int
    :param adjustableColumn4: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly four columns
    :type adjustableColumn4: int
    :param adjustableColumn5: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly five columns
    :type adjustableColumn5: int
    :param adjustableColumn6: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly six columns
    :type adjustableColumn6: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Command executed when the group changes state  Note that this
    flag should not be used in conjunction with onCommand and offCommand  That is, one shou
    :type changeCommand: script
    :param changeCommand1: (C E) 
    :type changeCommand1: script
    :param changeCommand2: (C E) 
    :type changeCommand2: script
    :param changeCommand3: (C E) 
    :type changeCommand3: script
    :param changeCommand4: (C E) Specify a changed state command for each respective check box
    :type changeCommand4: script
    :param columnAlign: (C E M) Arguments are : column number, alignment type  Possible
    alignments are: left | right | center  Specifies alignment type for the specified column
    :type columnAlign: [int, string]
    :param columnAlign2: (C E) Sets the text alignment of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "center"
    :type columnAlign2: [string, string]
    :param columnAlign3: (C E) Sets the text alignment for all three columns  Ignored if there
    are not exactly three columns  Valid values are "left", "right", and "center"
    :type columnAlign3: [string, string, string]
    :param columnAlign4: (C E) Sets the text alignment for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "center"
    :type columnAlign4: [string, string, string, string]
    :param columnAlign5: (C E) Sets the text alignment for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "center"
    :type columnAlign5: [string, string, string, string, string]
    :param columnAlign6: (C E) Sets the text alignment for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "center"
    :type columnAlign6: [string, string, string, string, string, string]
    :param columnAttach: (C E M) Arguments are : column number, attachment type, and offset 
    Possible attachments are: left | right | both  Specifies column attachment types and offe
    :type columnAttach: [int, string, int]
    :param columnAttach2: (C E) Sets the attachment type of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "both"
    :type columnAttach2: [string, string]
    :param columnAttach3: (C E) Sets the attachment type for all three columns  Ignored if
    there are not exactly three columns  Valid values are "left", "right", and "both"
    :type columnAttach3: [string, string, string]
    :param columnAttach4: (C E) Sets the attachment type for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "both"
    :type columnAttach4: [string, string, string, string]
    :param columnAttach5: (C E) Sets the attachment type for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "both"
    :type columnAttach5: [string, string, string, string, string]
    :param columnAttach6: (C E) Sets the attachment type for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "both"
    :type columnAttach6: [string, string, string, string, string, string]
    :param columnOffset2: (C E) This flag is used in conjunction with the -columnAttach2 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the tw
    :type columnOffset2: [int, int]
    :param columnOffset3: (C E) This flag is used in conjunction with the -columnAttach3 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the th
    :type columnOffset3: [int, int, int]
    :param columnOffset4: (C E) This flag is used in conjunction with the -columnAttach4 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fo
    :type columnOffset4: [int, int, int, int]
    :param columnOffset5: (C E) This flag is used in conjunction with the -columnAttach5 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fi
    :type columnOffset5: [int, int, int, int, int]
    :param columnOffset6: (C E) This flag is used in conjunction with the -columnAttach6 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the si
    :type columnOffset6: [int, int, int, int, int, int]
    :param columnWidth: (C E M) Arguments are : column number, column width  Sets the width of
    the specified column where the first parameter specifies the column (1 based index) an
    :type columnWidth: [int, int]
    :param columnWidth1: (C E) Sets the width of the first column  Ignored if there is not
    exactly one column
    :type columnWidth1: int
    :param columnWidth2: (C E) Sets the column widths of both columns  Ignored if there are not
    exactly two columns
    :type columnWidth2: [int, int]
    :param columnWidth3: (C E) Sets the column widths for all 3 columns  Ignored if there are
    not exactly 3 columns
    :type columnWidth3: [int, int, int]
    :param columnWidth4: (C E) Sets the column widths for all 4 columns  Ignored if there are
    not exactly 4 columns
    :type columnWidth4: [int, int, int, int]
    :param columnWidth5: (C E) Sets the column widths for all 5 columns  Ignored if there are
    not exactly 5 columns
    :type columnWidth5: [int, int, int, int, int]
    :param columnWidth6: (C E) Sets the column widths for all 6 columns  Ignored if there are
    not exactly 6 columns
    :type columnWidth6: [int, int, int, int, int, int]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param editable: (C Q E) The edit state of the group  By default, this flag is set to true
    and the check box values may be changed by clicking on them  If false then the chec
    :type editable: boolean
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enable1: (C Q E) 
    :type enable1: boolean
    :param enable2: (C Q E) 
    :type enable2: boolean
    :param enable3: (C Q E) 
    :type enable3: boolean
    :param enable4: (C Q E) Enable state of the individual check boxes
    :type enable4: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) When present on creation an optional text label will be built with
    the group  The string specifes the label text
    :type label: string
    :param label1: (C Q E) 
    :type label1: string
    :param label2: (C Q E) 
    :type label2: string
    :param label3: (C Q E) 
    :type label3: string
    :param label4: (C Q E) Specify label strings for the respective check boxes in the group
    :type label4: string
    :param labelArray2: (C Q E) 
    :type labelArray2: [string, string]
    :param labelArray3: (C Q E) 
    :type labelArray3: [string, string, string]
    :param labelArray4: (C Q E) Specify multiple labels in a single flag  These flags are
    ignored if the number of radio buttons doesn't match
    :type labelArray4: [string, string, string, string]
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfCheckBoxes: (C) Number of check boxes in the group (1 - 4)
    :type numberOfCheckBoxes: int
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param offCommand: (C E) Command executed when any check box turns off
    :type offCommand: script
    :param offCommand1: (C E) 
    :type offCommand1: script
    :param offCommand2: (C E) 
    :type offCommand2: script
    :param offCommand3: (C E) 
    :type offCommand3: script
    :param offCommand4: (C E) Off command for each respective check box
    :type offCommand4: script
    :param onCommand: (C E) Command executed when any check box turns on
    :type onCommand: script
    :param onCommand1: (C E) 
    :type onCommand1: script
    :param onCommand2: (C E) 
    :type onCommand2: script
    :param onCommand3: (C E) 
    :type onCommand3: script
    :param onCommand4: (C E) On command for each respective check box
    :type onCommand4: script
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rowAttach: (C E M) Arguments are : column, attachment type, offset  Possible
    attachments are: top | bottom | both  Specifies attachment types and offsets for the
    entire
    :type rowAttach: [int, string, int]
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param value1: (C Q E) 
    :type value1: boolean
    :param value2: (C Q E) 
    :type value2: boolean
    :param value3: (C Q E) 
    :type value3: boolean
    :param value4: (C Q E) Values for the respective check boxes in the group
    :type value4: boolean
    :param valueArray2: (C Q E) 
    :type valueArray2: [boolean, boolean]
    :param valueArray3: (C Q E) 
    :type valueArray3: [boolean, boolean, boolean]
    :param valueArray4: (C Q E) Specifies multiple values in a single flag  These flags are
    ignored if the number of check boxes doesn't match
    :type valueArray4: [boolean, boolean, boolean, boolean]
    :param vertical: (C Q) Whether the orientation of the checkbox controls in this group are
    horizontal (default) or vertical
    :type vertical: boolean
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def event(*args, count=0, delete=True, dieAtCollision=True, emit=0, list=True, name="",
          proc=None, random=True, rename="", select=True, split=0, spread=0.0, target="",
          q=True, query=True, e=True, edit=True, **kwargs):
    """
    The event command assigns collision events to a particle object  Collision events are
    stored in multi-attributes in the particle shape  The event command returns the event name
    
    :param count: (Q E) Collision number (for each particle) to which this event applies  Zero
    (the default) indicates that it applies to all collisions
    :type count: int
    :param delete: (C) Delete the specified event
    :type delete: boolean
    :param dieAtCollision: (Q E) Particle dies at the collision specified by "count." If no
    count value is given, die at first collision
    :type dieAtCollision: boolean
    :param emit: (Q E) Emit n additional particles into the assigned target object  The
    original (colliding) particle survives as well, and remains in its original object
    :type emit: int
    :param list: (C) List all events for the chosen shape, like this: event1Name event2Name .. 
    If no shape identified, list all events for all shapes, like this: shape1N
    :type list: boolean
    :param name: (C Q E) Assign a name to an event you are creating, or identify an event you
    wish to edit, query, or delete  See examples
    :type name: string
    :param proc: (C Q E) Specify a MEL proc to be called each time the event occurs  This must
    be a global proc with arguments as follows: global proc procName( string obj, i
    :type proc: script
    :param random: (Q E) Used with -split and -emit flags  If -random is set true and -split or
    -emit is set to n, then a random number of particles uniformly distributed bet
    :type random: boolean
    :param rename: (Q) Assign a new name to an event you are editing  See examples
    :type rename: string
    :param select: () This flag is obsolete  See the -name flag
    :type select: boolean
    :param split: (Q E) Colliding particle splits into specified number of new particles  These
    new particles become part of the assigned target object  If no target has bee
    :type split: int
    :param spread: (Q E) Particles created at collision will spread out a random amount from
    the rebound direction of the colliding particle  The spread is specified as a fra
    :type spread: float
    :param target: (Q E) Target object for emitting or split particles  New particles created
    through the -emit or -split flags join this object
    :type target: string
    
    :returns: for creation; string array for list.
    :rtype: string
    """
    pass


def UnpublishAttributes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OpenCloseSurfaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def simplify(*args, animation="keysOrObjects.", attribute="", controlPoints=False, float=None,
             floatTolerance=0.0, hierarchy="", includeUpperBound=True, index=0, shape=True,
             time=None, timeTolerance=None, valueTolerance=0.0, **kwargs):
    """
    This command operates on a keyset  A keyset is defined as a group of keys within a
    specified time range on one or more animation curves   The animation curves comprising a
    keyset depend on the value of the "-animation" flag:  keysOrObjects: Any active keys, when
    no target objects or -attribute flags appear on the command line, or All animation curv
    
    :param animation: (C) Where this command should get the animation to act on  Valid values
    are "objects," "keys," and "keysOrObjects" Default: "keysOrObjects." (See Descrip
    :type animation: string
    :param attribute: (C M) List of attributes to select In query mode, this flag needs a
    value
    :type attribute: string
    :param controlPoints: (C) This flag explicitly specifies whether or not to include the
    control points of a shape (see "-s" flag) in the list of attributes  Default: false  (No
    :type controlPoints: boolean
    :param float: (C M) value uniquely representing a non-time-based key (or key range) on a
    time-based animCurve  Valid floatRange include single values (-f 10) or a string
    :type float: floatrange
    :param floatTolerance: (C) Specify the x-axis tolerance (defaults to 0.05) for float-input
    animCurves such as those created by "Set Driven Keyframe"  This flag is ignored on an
    :type floatTolerance: float
    :param hierarchy: (C) Hierarchy expansion options  Valid values are "above," "below," "both,
    " and "none." (Not valid for "pasteKey" cmd.) In query mode, this flag needs a
    :type hierarchy: string
    :param includeUpperBound: (C) When the -t/time or -f/float flags represent a range of keys,
    this flag determines whether the keys at the upper bound of the range are included in t
    :type includeUpperBound: boolean
    :param index: (C M) index of a key on an animCurve In query mode, this flag needs a value
    :type index: int
    :param shape: (C) Consider attributes of shapes below transforms as well, except
    "controlPoints"  Default: true  (Not valid for "pasteKey" cmd.) In query mode, this fl
    :type shape: boolean
    :param time: (C M) time uniquely representing a key (or key range) on a time-based
    animCurve  See the code examples below on how to format for a single frame or frame r
    :type time: timerange
    :param timeTolerance: (C) Specify the x-axis tolerance (defaults to 0.05 seconds) for
    time-input animCurves  This flag is ignored on animCurves driven by floats  Higher time t
    :type timeTolerance: time
    :param valueTolerance: (C) Specify the value tolerance (defaults to 0.01)
    :type valueTolerance: float
    
    :returns: Number of animation curves simplified
    :rtype: int
    """
    pass


def renderWindowEditor(*args, autoResize=True, blendMode=0, caption="", changeCommand=None,
                       clear=None, cmEnabled=True, colorManage=True, compDisplay=0,
                       compImageFile="", control=True, currentCamera="", currentCameraRig="",
                       defineTemplate="", displayImage=0, displayImageViewCount=0,
                       displayStyle="", docTag="", doubleBuffer=True, drawAxis=True,
                       editorName=True, exists=True, exposure=0.0, filter="",
                       forceMainConnection="", frameImage=True, frameRegion=True, gamma=0.0,
                       highlightConnection="", loadImage="", lockMainConnection=True,
                       mainListConnection="", marquee=None, nbImages=True, nextViewImage=True,
                       outputColorManage=True, panel="", parent="", pcaption="", realSize=True,
                       refresh=True, removeAllImages=True, removeImage=True, resetRegion=True,
                       resetViewImage=True, saveImage=True, scaleBlue=0.0, scaleGreen=0.0,
                       scaleRed=0.0, selectionConnection="", showRegion=None, singleBuffer=True,
                       snapshot=None, snapshotMode=True, stateString=True, stereo=0,
                       stereoImageOrientation=None, stereoMode="", toggle=True, unParent=True,
                       unlockMainConnection=True, updateMainConnection=True, useTemplate="",
                       viewImageCount=0, viewTransformName="", writeImage="", q=True,
                       query=True, e=True, edit=True, **kwargs):
    """
    Create a editor window that can receive the result of the rendering process
    
    :param autoResize: (C Q E) Lets the render view editor automatically resize the viewport or
    not
    :type autoResize: boolean
    :param blendMode: (C Q E) Sets the blend mode for the render view  New image sent to the
    render view will be blended with the previous image in the render view, and the compos
    :type blendMode: int
    :param caption: (C Q E) Sets the caption which appears at the bottom of the render view
    :type caption: string
    :param changeCommand: (C Q E) Parameters: First string: command Second string: editorName
    Third string: editorCmd Fourth string: updateFunc Call the command when something changes
    :type changeCommand: [string, string, string, string]
    :param clear: (C Q E) Clear the image with the given color at the given resolution 
    Argumnets are respecively: width height red green blue
    :type clear: [int, int, float, float, float]
    :param cmEnabled: (Q E) Turn on or off applying color management in the View  If set, the
    color management configuration set in the current view is used
    :type cmEnabled: boolean
    :param colorManage: (E) When used with the writeImage flag, causes the written image to be
    color-managed using the settings from the view color manager attached to the view
    :type colorManage: boolean
    :param compDisplay: (C Q E) 0 : disable compositing  1 : displays the composited image
    immediately  For example, when foreground layer tile is sent to the render view window, th
    :type compDisplay: int
    :param compImageFile: (C Q E) Open the given image file and blend with the buffer as if the
    image was just rendered
    :type compImageFile: string
    :param control: (Q) Query only  Returns the top level control for this editor  Usually used
    for getting a parent to attach popup menus  Caution: It is possible for an ed
    :type control: boolean
    :param currentCamera: (C Q E) Get or set the current camera  (used when redoing last
    render)
    :type currentCamera: string
    :param currentCameraRig: (C Q E) Get or set the current camera rig name  If a camera rig is
    specified, it will be used when redoing the last render as opposed to the currentCamera va
    :type currentCameraRig: string
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param displayImage: (Q E) Set a particular image in the Editor Image Stack as the current
    Editor Image  Images are added to the Editor Image Stack using the "si/saveImage" fla
    :type displayImage: int
    :param displayImageViewCount: (Q) Query the number of views stored for a given image in the
    Editor Image Stack  This is not the same as querying using "viewImageCount" which returns
    t
    :type displayImageViewCount: int
    :param displayStyle: (C Q E) Set the mode to display the image  Valid values are: "color"
    to display the basic RGB image "mask" to display the mask channel "lum" to display the l
    :type displayStyle: string
    :param docTag: (C Q E) Attaches a tag to the editor
    :type docTag: string
    :param doubleBuffer: (C Q E) Set the display in double buffer mode
    :type doubleBuffer: boolean
    :param drawAxis: (C Q E) Set or query whether the axis will be drawn
    :type drawAxis: boolean
    :param editorName: (Q) Returns the name of the editor, or an empty string if the editor has
    not been created yet
    :type editorName: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param exposure: (Q E) The exposure value used by the color management of the current view
    :type exposure: float
    :param filter: (C Q E) Specifies the name of an itemFilter object to be used with this
    editor  This filters the information coming onto the main list of the editor
    :type filter: string
    :param forceMainConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type forceMainConnection: string
    :param frameImage: (C Q E) Frames the image inside the window
    :type frameImage: boolean
    :param frameRegion: (C Q E) Frames the region inside the window
    :type frameRegion: boolean
    :param gamma: (Q E) The gamma value used by the color management of the current view
    :type gamma: float
    :param highlightConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its highlight list  Not all editors have a highlight list 
    F
    :type highlightConnection: string
    :param loadImage: (E) load an image from disk and set it as the current Editor Image
    :type loadImage: string
    :param lockMainConnection: (C E) Locks the current list of objects within the
    mainConnection, so that only those objects are displayed within the editor  Further changes
    to the origi
    :type lockMainConnection: boolean
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type mainListConnection: string
    :param marquee: (C Q E) The arguments define the four corners of a rectangle: top left
    bottom right  The rectangle defines a marquee for the render computation
    :type marquee: [float, float, float, float]
    :param nbImages: (Q) returns the number of images
    :type nbImages: boolean
    :param nextViewImage: (C E) The render editor has the capability to render multiple cameras
    within a single view  This is different from image binning where an image is saved  M
    :type nextViewImage: boolean
    :param outputColorManage: (E) When used with the writeImage flag, causes the written image
    to be color-managed using the outpute color space in the color preferences attached to t
    :type outputColorManage: boolean
    :param panel: (C Q) Specifies the panel for this editor  By default if an editor is created
    in the create callback of a scripted panel it will belong to that panel  If a
    :type panel: string
    :param parent: (C Q E) Specifies the parent layout for this editor  This flag will only
    have an effect if the editor is currently un-parented
    :type parent: string
    :param pcaption: (C Q E) Get or set the permanent caption which appears under the image
    that is currently showing in the render editor
    :type pcaption: string
    :param realSize: (C Q E) Display the image with a one to one pixel match
    :type realSize: boolean
    :param refresh: (E) requests a refresh of the current Editor Image
    :type refresh: boolean
    :param removeAllImages: (E) remove all the Editor Images from the Editor Image Stack
    :type removeAllImages: boolean
    :param removeImage: (E) remove the current Editor Image from the Editor Image Stack
    :type removeImage: boolean
    :param resetRegion: (C Q E) Forces a reset of any marquee/region
    :type resetRegion: boolean
    :param resetViewImage: (C E) The render editor has the capability to render multiple
    cameras within a single view  This is different from image binning where an image is saved 
    M
    :type resetViewImage: boolean
    :param saveImage: (E) save the current Editor Image to memory  Saved Editor Images are
    stored in an Editor Image Stack  The most recently saved image is stored in position
    :type saveImage: boolean
    :param scaleBlue: (C Q E) Define the scaling factor for the blue component in the View  The
    default value is 1 and can be between -1000 to +1000
    :type scaleBlue: float
    :param scaleGreen: (C Q E) Define the scaling factor for the green component in the View 
    The default value is 1 and can be between -1000 to +1000
    :type scaleGreen: float
    :param scaleRed: (C Q E) Define the scaling factor for the red component in the View  The
    default value is 1 and can be between -1000 to +1000
    :type scaleRed: float
    :param selectionConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its own selection list  As the user selects things in this
    e
    :type selectionConnection: string
    :param showRegion: (C Q E) Shows the current region at the given resolution  The two
    parameters define the width and height
    :type showRegion: [int, int]
    :param singleBuffer: (C Q E) Set the display in single buffer mode
    :type singleBuffer: boolean
    :param snapshot: (C Q E) Makes a copy of the camera of the model editor at the given size 
    First argument is the editor name, second is the width, third is the height
    :type snapshot: [string, int, int]
    :param snapshotMode: (C Q E) Get or set the window's snapshot mode
    :type snapshotMode: boolean
    :param stateString: (Q) Query only flag  Returns the MEL command that will create an editor
    to match the current editor state  The returned command string uses the string va
    :type stateString: boolean
    :param stereo: (C Q E) Puts the editor into stereo image mode  The effective resolution of
    the output image is twice the size of the horizontal size  The orientation of the
    :type stereo: int
    :param stereoImageOrientation: (C Q E) Specifies the orientation of stereo camera renders 
    The first argument specifies the orientation value for the firstleft image and the second
    argumen
    :type stereoImageOrientation: [string, string]
    :param stereoMode: (C Q E) Specifies how the image is displayed in the view  By default the
    stereo is rendered with a side by side image  The rendered image is a single image t
    :type stereoMode: string
    :param toggle: (C Q E) Turns the ground plane display on/off
    :type toggle: boolean
    :param unParent: (C E) Specifies that the editor should be removed from its layout  This
    cannot be used in query mode
    :type unParent: boolean
    :param unlockMainConnection: (C E) Unlocks the mainConnection, effectively restoring the
    original mainConnection (if it is still available), and dynamic updates
    :type unlockMainConnection: boolean
    :param updateMainConnection: (C E) Causes a locked mainConnection to be updated from the
    orginal mainConnection, but preserves the lock state
    :type updateMainConnection: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param viewImageCount: (C Q E) The render editor has the capability to render multiple
    cameras within a single view  This is different from image binning where an image is saved 
    M
    :type viewImageCount: int
    :param viewTransformName: (Q E) Sets/gets the view transform to be applied if color
    management is enabled in the current view
    :type viewTransformName: string
    :param writeImage: (E) write the current Editor Image to disk
    :type writeImage: string
    
    :returns: The name of the editor
    :rtype: string
    """
    pass


def SubdivSurfaceCleanTopology(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_symmetrize(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def copyDeformerWeights(*args, destinationDeformer="", destinationShape="", mirrorInverse=True,
                        mirrorMode="", noMirror=True, smooth=True, sourceDeformer="",
                        sourceShape="", surfaceAssociation="", uvSpace=None, q=True, query=True,
                        e=True, edit=True, **kwargs):
    """
    Command to copy or mirror the deformer weights accross one of the three major axes  The
    command can be used to mirror weights either from one surface to another or within the same
    surface
    
    :param destinationDeformer: (C Q E) Specify the deformer used by the destination shape
    :type destinationDeformer: string
    :param destinationShape: (C Q E) Specify the destination deformed shape
    :type destinationShape: string
    :param mirrorInverse: (C Q E) Values are mirrored from the positive side to the negative 
    If this flag is used then the direction is inverted
    :type mirrorInverse: boolean
    :param mirrorMode: (C Q E) The mirrorMode flag defines the plane of mirroring (XY, YZ, or
    XZ) when the mirror flag is used  The default plane is XY
    :type mirrorMode: string
    :param noMirror: (C Q E) When the no mirror flag is used, the weights are copied instead of
    mirrored
    :type noMirror: boolean
    :param smooth: (C Q E) When the smooth flag is used, the weights are smoothly interpolated
    between the closest vertices, instead of assigned from the single closest
    :type smooth: boolean
    :param sourceDeformer: (C Q E) Specify the deformer whose weights should be mirrored  When
    queried, returns the deformers used by the source shapes
    :type sourceDeformer: string
    :param sourceShape: (C Q E) Specify the source deformed shape
    :type sourceShape: string
    :param surfaceAssociation: (C Q E) The surfaceAssociation flag controls how the weights are
    transferred between the surfaces: "closestPoint", "rayCast", or "closestComponent"  The
    defa
    :type surfaceAssociation: string
    :param uvSpace: (C Q E) The uvSpace flag indicates that the weight transfer should occur in
    UV space, based on the source and destination UV sets specified
    :type uvSpace: [string, string]
    
    :returns: 
    :rtype: None
    """
    pass


def rebuildSurface(*args, caching=True, degreeU=3, degreeV=3, direction=2, endKnots=0,
                   fitRebuild=0, keepControlPoints=False, keepCorners=True, keepRange=1,
                   nodeState=0, rebuildType=0, spansU=4, spansV=4, tolerance=0.01,
                   constructionHistory=True, name="", object=True, polygon=0,
                   replaceOriginal=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command rebuilds a surface by modifying its parameterization  In some cases the shape
    of the surface may also change  The rebuildType (-rt) attribute determines how the surface
    is rebuilt   The optional second surface can be used to specify a reference
    parameterization
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param degreeU: (C Q E) The degree of the resulting surface in the u direction 0 - maintain
    current, 1 - linear, 2 - quadratic, 3 - cubic, 5 - quintic, 7 - heptic Default: 3
    :type degreeU: int
    :param degreeV: (C Q E) The degree of the resulting surface in the v direction 0 - maintain
    current, 1 - linear, 2 - quadratic, 3 - cubic, 5 - quintic, 7 - heptic Default: 3
    :type degreeV: int
    :param direction: (C Q E) The direction in which to rebuild: 0 - U, 1 - V, 2 - Both U and V
    Default: 2
    :type direction: int
    :param endKnots: (C Q E) End conditions for the surface 0 - uniform end knots, 1 - multiple
    end knots, Default: 0
    :type endKnots: int
    :param fitRebuild: (C Q E) Specify the type of rebuild method to be used: 0 - Convert
    Classic, the default and original convert method  1 - Fit using the least squares fit meth
    :type fitRebuild: int
    :param keepControlPoints: (C Q E) Use the control points of the input surface  This forces
    uniform parameterization unless rebuildType is 2 (match knots) Default: false
    :type keepControlPoints: boolean
    :param keepCorners: (C Q E) The corners of the resulting surface will not change from the
    corners of the input surface  Default: true
    :type keepCorners: boolean
    :param keepRange: (C Q E) Determine the parameterization for the resulting surface  0 -
    reparameterize the resulting surface from 0 to 1; 1 - keep the original surface paramet
    :type keepRange: int
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param rebuildType: (C Q E) The rebuild type: 0 - uniform, 1 - reduce spans, 2 - match
    knots, 3 - remove multiple knots, 4 - force non rational 5 - rebuild ends 6 - trim convert
    :type rebuildType: int
    :param spansU: (C Q E) The number of spans in the u direction in resulting surface  Used
    only when rebuildType is 0 - uniform  If 0, keep the same number of spans as the or
    :type spansU: int
    :param spansV: (C Q E) The number of spans in the v direction in resulting surface  Used
    only when rebuildType is 0 - uniform  If 0, keep the same number of spans as the or
    :type spansV: int
    :param tolerance: (C Q E) The tolerance with which to rebuild Default: 0.01
    :type tolerance: float
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param polygon: (C) The value of this argument controls the type of the object created by
    this operation 0: nurbs surface 1: polygon (use nurbsToPolygonsPref to set the
    :type polygon: int
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def FloodSurfaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OutTangentFixed(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeSelectObjectsWithMaterials(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def characterizationToolUICmd(*args, **kwargs):
    """
    
    """
    pass


def listSets(*args, allSets=True, extendToShape=True, object=None, type=0, **kwargs):
    """
    The listSets command is used to get a list of all the sets an object belongs to  To get
    sets of a specific type for an object use the type flag as well   To get a list of all sets
    in the scene then don't use an object in the command line but use one of the flags instead
    
    :param allSets: (C) Returns all sets in the scene
    :type allSets: boolean
    :param extendToShape: (C) When requesting a transform's sets also walk down to the shape
    immediately below it for its sets
    :type extendToShape: boolean
    :param object: (C) Returns all sets which this object is a member of
    :type object: name
    :param type: (C) Returns all sets in the scene of the given type: 1 - all rendering sets 2
    - all deformer sets
    :type type: int
    
    :returns: (string array of all sets the object belongs to)
    :rtype: string[]
    """
    pass


def polyColorPerVertex(*args, alpha=0.0, clamped=True, colorB=0.0, colorDisplayOption=True,
                       colorG=0.0, colorR=0.0, colorRGB=None, notUndoable=True, relative=True,
                       remove=True, representation=0, q=True, query=True, e=True, edit=True,
                       **kwargs):
    """
    Command associates color(rgb and alpha) with vertices on polygonal objects  When used with
    the query flag, it returns the color associated with the specified components
    
    :param alpha: (C Q E) Specifies the alpha channel of color
    :type alpha: float
    :param clamped: (C Q E) This flag specifies if the color set will truncate any value that
    is outside 0 to 1 range
    :type clamped: boolean
    :param colorB: (C Q E) Specifies the B channel of color
    :type colorB: float
    :param colorDisplayOption: (C Q E) Change the display options on the mesh to display the
    vertex colors
    :type colorDisplayOption: boolean
    :param colorG: (C Q E) Specifies the G channel of color
    :type colorG: float
    :param colorR: (C Q E) Specifies the R channel of color
    :type colorR: float
    :param colorRGB: (C Q E) Specifies the RGB channels of color
    :type colorRGB: [float, float, float]
    :param notUndoable: (C Q E) Execute the command, but without having the command be undoable
     This option will greatly improve performance for large numbers of object  This will
    :type notUndoable: boolean
    :param relative: (C Q E) When used, the color values specified are added relative to the
    current values
    :type relative: boolean
    :param remove: (C Q E) When used, the color values are removed from the selected or
    specified objects or components  This option only supports meshes with no construction h
    :type remove: boolean
    :param representation: (C Q E) This flag corresponds to the color channels to used, for
    example A(alpha only), RGB, and RGBA
    :type representation: int
    
    :returns: Success or Failure.
    :rtype: boolean
    """
    pass


def TimeEditorMuteSelectedTracks(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Revolve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BakeChannel(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AttributeEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_setRelaxAffectsAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def showHidden(*args, above=True, allObjects=True, below=True, lastHidden=True, **kwargs):
    """
    The showHidden command is used to make invisible objects visible  If no flags are specified,
    only the objects given to the command will be made visible  If a parent of an object is
    invisible, the object will still be invisible  Invisibility is inherited  To ensure the
    object becomes visible, use the -a/above flag  This forces all invisible ancestor
    
    :param above: (C) Make objects and all their invisible ancestors visible
    :type above: boolean
    :param allObjects: (C) Make all invisible objects visible
    :type allObjects: boolean
    :param below: (C) Make objects and all their invisible descendants visible
    :type below: boolean
    :param lastHidden: (C) Show everything that was hidden with the last hide command
    :type lastHidden: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def displaySmoothness(*args, all=True, boundary=True, defaultCreation=True, divisionsU=0,
                      divisionsV=0, full=True, hull=True, pointsShaded=0, pointsWire=0,
                      polygonObject=0, renderTessellation=True, simplifyU=0, simplifyV=0,
                      q=True, query=True, **kwargs):
    """
    This command is responsible for setting the display smoothness of NURBS curves and surfaces
    to either predefined or custom values  It also sets display modes for smoothness such as
    hulls and the hull simplification factors  At present, this command is NOT un-doable
    
    :param all: (C Q) Change smoothness for all curves and surfaces
    :type all: boolean
    :param boundary: (C Q) Display wireframe surfaces using only the boundaries of the surface
    Not fully implemented yet
    :type boundary: boolean
    :param defaultCreation: (C Q) The default values at creation (applies only -du, -dv, -pw,
    -ps)
    :type defaultCreation: boolean
    :param divisionsU: (C Q) Number of isoparm divisions per span in the U direction  The valid
    range of values is [0,64]
    :type divisionsU: int
    :param divisionsV: (C Q) Number of isoparm divisions per span in the V direction  The valid
    range of values is [0,64]
    :type divisionsV: int
    :param full: (C Q) Display surface at full resolution - the default
    :type full: boolean
    :param hull: (C Q) Display surface using the hull (control points are drawn rather than
    surface knot points)  This mode is a useful display performance improvement when
    :type hull: boolean
    :param pointsShaded: (C Q) Number of points per surface span in shaded mode  The valid
    range of values is [1,64]
    :type pointsShaded: int
    :param pointsWire: (C Q) Number of points per surface isoparm span or the number of points
    per curve span in wireframe mode  The valid range of values is [1,128]  Note: This
    :type pointsWire: int
    :param polygonObject: (C Q) Display the polygon objects with the given resolution
    :type polygonObject: int
    :param renderTessellation: (C Q) Display using render tesselation parameters when in shaded
    mode
    :type renderTessellation: boolean
    :param simplifyU: (C Q) Number of spans to skip in the U direction when in hull display
    mode
    :type simplifyU: int
    :param simplifyV: (C Q) Number of spans to skip in the V direction when in hull display
    mode
    :type simplifyV: int
    
    :returns: 
    :rtype: None
    """
    pass


def dagCommandWrapper(*args, **kwargs):
    """
    
    """
    pass


def polyReduce(*args, caching=True, cachingReduce=False, colorWeights=0, compactness=0.0,
               constructionHistory=True, geomWeights=1, invertVertexWeights=True,
               keepBorder=True, keepBorderWeight=0.5, keepColorBorder=True,
               keepColorBorderWeight=0.5, keepCreaseEdge=True, keepCreaseEdgeWeight=0.5,
               keepFaceGroupBorder=True, keepFaceGroupBorderWeight=0.5, keepHardEdge=True,
               keepHardEdgeWeight=0.5, keepMapBorder=True, keepMapBorderWeight=0.5,
               keepOriginalVertices=False, keepQuadsWeight=0, name="", nodeState=0,
               percentage=0, preserveLocation=False, preserveTopology=True,
               replaceOriginal=True, sharpness=0, symmetryPlaneW=0, symmetryPlaneX=0,
               symmetryPlaneY=0, symmetryPlaneZ=0, symmetryTolerance=0, termination=0,
               triangleCount=0, triangulate=True, useVirtualSymmetry=0, uvWeights=0, version=0,
               vertexCount=0, vertexMapName="", vertexWeightCoefficient=1,
               weightCoefficient=10000, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Simplify a polygonal object by reducing geometry while preserving the overall shape of the
    mesh   The algorithm for polyReduce was changed in 2014 to use a new algorithm derived from
    Softimage  However, the command still defaults to using the old algorithm for backwards
    compatibility  Therefore, we recommend setting the version flag to 1 for best r
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param cachingReduce: (C Q E) Cache intermediate reductions for speed at the expense of
    memory  It is recommended that caching be enabled when using the new algorithm  (-version
    1
    :type cachingReduce: boolean
    :param colorWeights: (C Q E) This flag only applies when using the old algorithm and is
    provided for backwards compatibility  How much consideration vertex color is given in the
    :type colorWeights: float
    :param compactness: (C Q E) This flag only applies when using the old algorithm and is
    provided for backwards compatibility  Tolerance for compactness for the generated triangle
    :type compactness: float
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param geomWeights: (C Q E) This flag only applies when using the old algorithm and is
    provided for backwards compatibility  How much consideration vertex positions are given in
    :type geomWeights: float
    :param invertVertexWeights: (C Q E) This flag controls how weight map values are
    interpreted  If true, a vertex weight of 1.0 means a vertex is unlikely to be reduced  If
    false, a verte
    :type invertVertexWeights: boolean
    :param keepBorder: (C Q E) If true, reduction will try to retain geometric borders and the
    border of the selection  C: Default is true  Q: When queried, this flag returns a boo
    :type keepBorder: boolean
    :param keepBorderWeight: (C Q E) If keepBorder is on, this flag specifies the weight to
    assign to borders  Setting this value to 0 will disable border preservation and a value of
    1 w
    :type keepBorderWeight: float
    :param keepColorBorder: (C Q E) If true, reduction will try to retain color borders  These
    are determined according to color Ids  This flag only applies when using the new algorithm
    :type keepColorBorder: boolean
    :param keepColorBorderWeight: (C Q E) If keepColorBorder is on, this flag specifies the
    weight to assign to color borders  Setting this value to 0 will disable color border
    preservation a
    :type keepColorBorderWeight: float
    :param keepCreaseEdge: (C Q E) If true, reduction will try to retain crease edges  C:
    Default is true  This flag only applies when using the new algorithm  (-version 1) C:
    Default
    :type keepCreaseEdge: boolean
    :param keepCreaseEdgeWeight: (C Q E) If keepCreaseEdge is on, this flag specifies the
    weight to assign to crease edges  Setting this value to 0 will disable crease edge
    preservation and
    :type keepCreaseEdgeWeight: float
    :param keepFaceGroupBorder: (C Q E) If true, reduction will try to retain borders of face
    groups, which are mostly used to define material assignments  This flag only applies when
    using
    :type keepFaceGroupBorder: boolean
    :param keepFaceGroupBorderWeight: (C Q E) If keepFaceGroupBorder is on, this flag specifies
    the weight to assign to material borders  Setting this value to 0 will disable group border
    preserv
    :type keepFaceGroupBorderWeight: float
    :param keepHardEdge: (C Q E) If true, reduction will try to retain hard edges  C: Default
    is true  Q: When queried, this flag returns a boolean
    :type keepHardEdge: boolean
    :param keepHardEdgeWeight: (C Q E) If keepHardEdge is on, this flag specifies the weight to
    assign to hard edges  Setting this value to 0 will disable hard edge preservation and a
    valu
    :type keepHardEdgeWeight: float
    :param keepMapBorder: (C Q E) If true, reduction will try to retain UV borders  A UV border
    is present if the faces on either side of the edge do not share UV Ids  C: Default is t
    :type keepMapBorder: boolean
    :param keepMapBorderWeight: (C Q E) If keepMapBorder is on, this flag specifies the weight
    to assign to UV map borders  Setting this value to 0 will disable UV map border
    preservation a
    :type keepMapBorderWeight: float
    :param keepOriginalVertices: (C Q E) This flag only applies when using the old algorithm
    and is provided for backwards compatibility  If true, vertices will try to retain their
    original
    :type keepOriginalVertices: boolean
    :param keepQuadsWeight: (C Q E) This flag controls how much consideration is given to
    oreserving quad faces during reduction  A higher weight means the reduction will try harder
    to
    :type keepQuadsWeight: float
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param percentage: (C Q E) This flag specifies how many vertices to remove during reduction
    as a percentage of the original mesh  This flag only applies if the termination flag
    :type percentage: float
    :param preserveLocation: (C) This flag guarantees that if the original geometry is
    preserved, the new geometry will have the same location  C: Default is false
    :type preserveLocation: boolean
    :param preserveTopology: (C Q E) this flag guarantees that the topological type will be
    preserved during reduction  In particular, if the input is manifold then the output will be
    ma
    :type preserveTopology: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace) (not available in all
    commands)  NOTE: This flag is intended for use by the "Reduce" menu item  If 'polyReduce
    -rpo
    :type replaceOriginal: boolean
    :param sharpness: (C Q E) Sharpness controls the balance between preserving small, sharp
    details versus larger shapes  At low values, details that are small relative to the ge
    :type sharpness: float
    :param symmetryPlaneW: (C Q E) W value of the symmetry plane  This flag only applies when
    using the new algorithm (-version 1) and the useVirtualSymmetry flag is set to 2  C: Defau
    :type symmetryPlaneW: float
    :param symmetryPlaneX: (C Q E) X value of the symmetry plane  This flag only applies when
    using the new algorithm (-version 1) and the useVirtualSymmetry flag is set to 2  C: Defau
    :type symmetryPlaneX: float
    :param symmetryPlaneY: (C Q E) Y value of the symmetry plane  This flag only applies when
    using the new algorithm (-version 1) and the useVirtualSymmetry flag is set to 2  C: Defau
    :type symmetryPlaneY: float
    :param symmetryPlaneZ: (C Q E) Z value of the symmetry plane  This flag only applies when
    using the new algorithm (-version 1) and the useVirtualSymmetry flag is set to 2  C: Defau
    :type symmetryPlaneZ: float
    :param symmetryTolerance: (C Q E) Tolerance to use when applying symmetry  For each vertex
    of the mesh, we find its exact symmetric point, then we look for the closest vertex to the
    e
    :type symmetryTolerance: float
    :param termination: (C Q E) This flag specifies the termination condition to use when
    reducing the mesh  This flag only applies to the new algorithm  (-version 1) 0 Percentage
    1
    :type termination: int
    :param triangleCount: (C Q E) This flag specifies a target number of triangles to retain
    after reduction  Note that other factors such as quad and feature preservation may take pr
    :type triangleCount: int
    :param triangulate: (C Q E) This flag only applies when using the old algorithm and is
    provided for backwards compatibility  This attribute specifies if the geometry or the sele
    :type triangulate: boolean
    :param useVirtualSymmetry: (C Q E) This flag controls whether symmetry is preserved during
    the reduction  This flag only applies when using the new algorithm (-version 1) and the
    keepQ
    :type useVirtualSymmetry: int
    :param uvWeights: (C Q E) This flag only applies when using the old algorithm and is
    provided for backwards compatibility  How much consideration uv positions are given in the
    :type uvWeights: float
    :param version: (C Q E) Version of the poly reduce algorithm to use  0 Old algorithm used
    in Maya 2013 and prior for backwards compatibility 1 New algorithm derived from Sof
    :type version: int
    :param vertexCount: (C Q E) This flag specifies a target number of vertices to retain after
    reduction  Note that other factors such as quad and feature preservation may take pre
    :type vertexCount: int
    :param vertexMapName: (C Q) Name of a color set to be added to the output mesh that stores
    a mapping from vertices in the output mesh to vertices in the input mesh  The color se
    :type vertexMapName: string
    :param vertexWeightCoefficient: (C Q E) This flag specifies a constant value to multiply to
    each weight map value  A value of zero turns off the weight map  This flag only applies
    when usin
    :type vertexWeightCoefficient: float
    :param weightCoefficient: (C Q E) This flag only applies when using the old algorithm and
    is provided for backwards compatibility  The weight of each vertex is multiplied with this
    co
    :type weightCoefficient: float
    
    :returns: The node name.
    :rtype: string
    """
    pass


def tumbleCtx(*args, alternateContext=True, autoOrthoConstrain=True, autoSetPivot=True,
              exists=True, history=True, image1="", image2="", image3="", localTumble=0,
              name="", objectTumble=True, orthoLock=True, orthoStep=0.0, toolName="",
              tumbleScale=0.0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command can be used to create, edit, or query a tumble context
    
    :param alternateContext: (C Q) Set the ALT+MMB and ALT+SHIFT+MMB to refer to this context
    :type alternateContext: boolean
    :param autoOrthoConstrain: (C Q E) Automatically constrain horizontal and vertical
    rotations when the camera is orthographic  The shift key can be used to unconstrain the
    rotation
    :type autoOrthoConstrain: boolean
    :param autoSetPivot: (C Q E) Automatically set the camera pivot to the selection or tool
    effect region
    :type autoSetPivot: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param localTumble: (C Q E) Describes what point the camera will tumble around: 0 for the
    camera's tumble pivot 1 for the camera's center of interest 2 for the camera's local ax
    :type localTumble: int
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param objectTumble: (C Q E) Make the camera tumble around the selected object, if true
    :type objectTumble: boolean
    :param orthoLock: (C Q E) Orthographic cameras cannot be tumbled while orthoLock is on
    :type orthoLock: boolean
    :param orthoStep: (C Q E) Specify the angular step in degrees for orthographic rotation  If
    camera is orthographic and autoOrthoConstrain is toggled on the rotation will be st
    :type orthoStep: float
    :param toolName: (C Q) Name of the specific tool to which this command refers
    :type toolName: string
    :param tumbleScale: (C Q E) Set the rotation speed  A tumble scale of 1.0 will result in in
    40 degrees of rotation per 100 pixels of cursor drag
    :type tumbleScale: float
    
    :returns: The name of the context
    :rtype: string
    """
    pass


def RenderViewWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def EmptyAnimLayer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def uvLink(*args, b=True, isValid=True, make=True, queryObject=None, texture=None, uvSet=None,
           q=True, query=True, **kwargs):
    """
    This command is used to make, break and query UV linking relationships between UV sets on
    objects and textures that use those UV sets   If no make, break or query flag is specified
    and both uvSet and texture flags are present, the make flag is assumed to be specified   If
    no make, break or query flag is specified and only one of the uvSet and textu
    
    :param b: (C) The presence of this flag on the command indicates that the command is being
    invoked to break links between UV sets and textures
    :type b: boolean
    :param isValid: (C) This flag is used to verify whether or not a texture or UV set is valid
    for the purposes of UV linking  It should be used in conjunction with either
    :type isValid: boolean
    :param make: (C) The presence of this flag on the command indicates that the command is
    being invoked to make links between UV sets and textures
    :type make: boolean
    :param queryObject: (C) This flag should only be used in conjunction with a query of a
    texture  This flag is used to indicate that the results of the query should be limited
    :type queryObject: name
    :param texture: (C) The argument to the texture flag specifies the texture to be used by
    the command in performing the action
    :type texture: name
    :param uvSet: (C) The argument to the uvSet flag specifies the UV set to be used by the
    command in performing the action
    :type uvSet: name
    
    :returns: or array of strings for query
    boolean for isValid
    :rtype: string
    """
    pass


def PoleVectorConstraintOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def renameUI(*args, **kwargs):
    """
    This command renames the UI object passed as first arument to the new name specified as
    second argument  If the new name is a duplicate, or not valid, then re-naming fails and the
    old name is returned
    
    
    :returns: The new name, or the old name if re-naming fails.
    :rtype: string
    """
    pass


def AnimationSnapshot(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmSplineSetCurrentDescription(*args, **kwargs):
    """
    
    """
    pass


def ToggleUVIsolateViewSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def jointCluster(*args, aboveBound=0.0, aboveCluster=True, aboveDropoffType="", aboveValue=0.0,
                 belowBound=0.0, belowCluster=True, belowDropoffType="", belowValue=0.0,
                 deformerTools=True, joint="", name="", q=True, query=True, e=True, edit=True,
                 **kwargs):
    """
    The joint cluster command adds high-level controls to manage the cluster percentage values
    on a bound skin around a joint  JointClusters are one way to create smooth bending
    behaviour on skin when joints rotate     a <---- aboveBound   ____________a_________   a \ 
     Joint1 a Joint2   _____________a_______ \   a \ \ b <--- belowBound   a \ \ b   \ b
    
    :param aboveBound: (C Q E) Specifies the where the drop-off begins in the direction of the
    bone above the joint  A value of 100 indicates the entire length of the bone  The def
    :type aboveBound: float
    :param aboveCluster: (Q) Returns the name of the cluster associated with the bone above
    this joint
    :type aboveCluster: boolean
    :param aboveDropoffType: (C Q E) Specifies the type of percentage drop-off in the direction
    of the bone above this joint  Valid values are "linear", "exponential", "sine" and "none"
    :type aboveDropoffType: string
    :param aboveValue: (C Q E) Specifies the drop-off percentage of the joint cluster in the
    direction of the bone above the cluster  A value of 100 indicates the entire length of
    :type aboveValue: float
    :param belowBound: (C Q E) Specifies where the drop-off ends in the direction of the bone
    below the joint  A value of 100 indicates the entire length of the bone  The default v
    :type belowBound: float
    :param belowCluster: (Q) Returns the name of the cluster associated with this joint
    :type belowCluster: boolean
    :param belowDropoffType: (C Q E) Specifies the type of type of percentage drop-off in the
    direction of the bone below this joint  Valid values are "linear", "exponential", "sine"
    and
    :type belowDropoffType: string
    :param belowValue: (C Q E) Specifies the drop-off percentage of the joint cluster in the
    direction of the joint below the cluster  A value of 100 indicates the entire length of
    :type belowValue: float
    :param deformerTools: (Q) Used to query for the helper nodes associated with the
    jointCluster
    :type deformerTools: boolean
    :param joint: (C) Specifies the joint that the cluster should act about
    :type joint: string
    :param name: (C) This flag is obsolete
    :type name: string
    
    :returns: Name of the new jointCluster node
    :rtype: string
    """
    pass


def DuplicateWithTransform(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AttachSelectedAsSourceField(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def subdCollapse(*args, caching=True, level=0, nodeState=0, constructionHistory=True, name="",
                 object=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command converts a takes a subdivision surface, passed as the argument, and produces a
    subdivision surface with a number of hierarchy levels "removed"  Returns the name of the
    subdivision surface created and optionally the DG node that does the conversion
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param level: (C Q E) The level that will now become the base mesh  Default: 0
    :type level: int
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    
    :returns: The subd surface and optionally the dependency node name
    :rtype: string[]
    """
    pass


def HideJoints(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleChannelsLayers(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddHolderOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NEmitFromObject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSetLengthBrushTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetMeshScrapeTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def StraightenCurvesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportUseTmpFilePeripheral(*args, **kwargs):
    """
    
    """
    pass


def PolyMerge(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def rigidBody(*args, active=True, angularVelocity=True, applyForceAt="", bounciness=0.6,
              cache=True, centerOfMass=None, collisions=True, contactCount=True,
              contactName=True, contactPosition=True, damping=0.0, deleteCache=True,
              dynamicFriction=0.2, force=True, ignore=True, impulse=None, impulsePosition=None,
              initialAngularVelocity=None, initialVelocity=None, layer=0, lockCenterOfMass=True,
              mass=1.0, name="", orientation=None, particleCollision=True, passive=True,
              position=None, removeShape="", solver="", spinImpulse=None, standInObject="",
              staticFriction=0.2, tesselationFactor=200, velocity=True, q=True, query=True,
              e=True, edit=True, **kwargs):
    """
    This command creates a rigid body from a polygonal or nurbs surface
    
    :param active: (C Q E) Creates a rigid body that is active  An active rigid body accepts
    and causes collisions and is effected by dynamic fields  This is the default
    :type active: boolean
    :param angularVelocity: (Q) Current angular velocity of rigid body
    :type angularVelocity: boolean
    :param applyForceAt: (C Q E) Determines how forces are applied to the rigid body  The
    choices are centerOfMass | boundingBox | verticesOrCVs  Default: boundingBox
    :type applyForceAt: string
    :param bounciness: (C Q E) Sets the restitution (or bounciness) of the rigid body  Range:
    0.0 - 2.0 Default: 0.6
    :type bounciness: float
    :param cache: (C Q E) Turns caching on (1) or off (0) for the rigid body  Default: off
    :type cache: boolean
    :param centerOfMass: (C Q E) Sets the center of mass (x,y,z) of the rigid body  Default:
    actual center of mass
    :type centerOfMass: [float, float, float]
    :param collisions: (C Q E) Truns collisions on/off for the rigid body  If the collisions
    are turned of the rigid body will not collide with any other rigid body  Default: on
    :type collisions: boolean
    :param contactCount: (Q) returns the current contact count for the rigid body
    :type contactCount: boolean
    :param contactName: (Q) returns all the rigid body names which are in contact with this
    shape  One name for each contact will be returned
    :type contactName: boolean
    :param contactPosition: (Q) returns all the contact position  One position for each contact
    will be returned
    :type contactPosition: boolean
    :param damping: (C Q E) Sets the damping value of the rigid body  Range: -2.0 - 2.0
    Default: 0.0
    :type damping: float
    :param deleteCache: (E) Deletes the cache (if one exists) of the rigid body
    :type deleteCache: boolean
    :param dynamicFriction: (C Q E) Sets the dynamic friction for the rigid body  Range: 0.0 -
    1.0 Default: 0.2
    :type dynamicFriction: float
    :param force: (Q) Current force on the rigid body
    :type force: boolean
    :param ignore: (C Q E) Causes the rigid body to be ignored in the rigid solver  Default:
    off
    :type ignore: boolean
    :param impulse: (C E) Applies an impulse (instantaneous) force on a rigid body  Default:
    0.0 0.0 0.0
    :type impulse: [float, float, float]
    :param impulsePosition: (C E) The position at which the impulse is applied  Default: the
    bodies center of mass
    :type impulsePosition: [float, float, float]
    :param initialAngularVelocity: (C Q E) Sets the initial angular velocity of the rigid body 
    Default: 0.0 0.0 0.0
    :type initialAngularVelocity: [float, float, float]
    :param initialVelocity: (C Q E) Sets the initial velocity of the rigid body  Default: 0.0
    0.0 0.0
    :type initialVelocity: [float, float, float]
    :param layer: (C Q E) Sets the collision layer of the rigid body  Only rigid bodies in the
    same collision layer can collide with each other  Range: >= 0 Default: 0
    :type layer: int
    :param lockCenterOfMass: (C Q E) Locks the center of mass for the rigid body  Default: off
    :type lockCenterOfMass: boolean
    :param mass: (C Q E) Sets the mass of the rigid body  Range: > 0 Default: 1.0
    :type mass: float
    :param name: (C Q E) Assigns the rigid body the given name
    :type name: string
    :param orientation: (C Q E) Sets the initial orientation (x,y,z) of the rigid body 
    Default: current orientation
    :type orientation: [float, float, float]
    :param particleCollision: (C Q E) Turns the ability for a rigid body to collide with
    particles on and off  The particles will exert a force on the rigid body  Default: off
    :type particleCollision: boolean
    :param passive: (C Q E) Creates a rigid body that is passive  A passive rigid body does not
    react to collisions but active rigid bodies can collide with it  Dynamic Fields w
    :type passive: boolean
    :param position: (C Q E) Sets the initial position (x,y,z) of the rigid body  Default:
    current position
    :type position: [float, float, float]
    :param removeShape: (C Q E) Remove the named shape
    :type removeShape: string
    :param solver: (C Q E) The name of the solver which this rigid node is to resided  If the
    solver does not exists then the rigid body will not be created  If the edit flag i
    :type solver: string
    :param spinImpulse: (C E) Applies an spin impulse (instantaneous rotational) force on a
    rigid body  Default: 0.0 0.0 0.0
    :type spinImpulse: [float, float, float]
    :param standInObject: (C Q E) Causes the simulator to use a stand in object for the
    simulation  The choices are none | cube | sphere  The default is none  Default: none
    :type standInObject: string
    :param staticFriction: (C Q E) Sets the static friction for the rigid body  Range: 0.0 -
    1.0 Default: 0.2
    :type staticFriction: float
    :param tesselationFactor: (C Q) Sets the tesselation factor for a rigid body surface 
    Range: >= 10 Default: 200
    :type tesselationFactor: int
    :param velocity: (Q) Current velocity of rigid body
    :type velocity: boolean
    
    :returns: New rigid body name.
    :rtype: string
    """
    pass


def canCreateCaddyManip(*args, **kwargs):
    """
    This command returns true if there can be a manipulator made for the specified selection,
    false otherwise
    
    
    :returns: The queried value
    :rtype: boolean
    """
    pass


def timePort(*args, annotation="", backgroundColor=None, defineTemplate="", docTag="",
             dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
             enableKeyboardFocus=True, exists=True, fullPathName=True, globalTime=True,
             height=0, highlightColor=None, isObscured=True, manage=True, noBackground=True,
             numberOfPopupMenus=True, parent="", popupMenuArray=True, preventOverride=True,
             snap=True, statusBarMessage="", useTemplate="", visible=True,
             visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
             **kwargs):
    """
    This command creates a simple time control widget  See also the "timeControl" command
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param globalTime: (C Q E) "true" means this widget controls and displays the global,
    dependency graph time  "false" means time changes here do NOT affect the dependency graph
    :type globalTime: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param snap: (C Q E) "true" means this widget is constrained to having values that are
    integers representing the current time unit.  "false" means the current time indica
    :type snap: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Widget name
    :rtype: string
    """
    pass


def MakeBrushSpringOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def selectKeyframeRegionCtx(*args, exists=True, history=True, image1="", image2="", image3="",
                            name="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a context which may be used to select keyframes within the keyframe
    region of the dope sheet editor
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: 
    :rtype: None
    """
    pass


def ShowLightManipulators(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def deleteExtension(*args, attribute="", forceDelete=True, nodeType="", **kwargs):
    """
    This command is used to delete an extension attribute from a node type  The attribute can
    be specified by using either the long or short name  Only one extension attribute can be
    deleted at a time  Children of a compound attribute cannot be deleted, you must delete the
    complete compound attribute  This command has no undo, edit, or query capabiliti
    
    :param attribute: (C) Specify either the long or short name of the attribute
    :type attribute: string
    :param forceDelete: (C) If this flag is set and turned ON then data values for the
    extension attributes are all deleted without confirmation  If it's set and turned OFF then
    :type forceDelete: boolean
    :param nodeType: (C) The name of the node type
    :type nodeType: string
    
    :returns: Number of nodes with altered data after the delete
    :rtype: int
    """
    pass


def AnimationSnapshotOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def setRenderPassType(*args, defaultDataType=True, numChannels=0, type="", **kwargs):
    """
    This command will set the passID of a renderPass node and create the custom attributes
    specified by the corresponding render pass definition  If the render pass node already has
    a passID assigned to it, attributes that are no longer required become hidden, and new
    attributes are unhidden and/or created as needed  This allows passIDs to be changed b
    
    :param defaultDataType: (C) If set, the render pass will use its default data type
    :type defaultDataType: boolean
    :param numChannels: (C) Specify the number of channels to use in the render pass  Note that
    this flag is only valid if there is an implementation supporting the requested nu
    :type numChannels: int
    :param type: (C) Specify the pass type to assign to the pass node(s)
    :type type: string
    
    :returns: true/false
    :rtype: boolean
    """
    pass


def renameAttr(*args, **kwargs):
    """
    Renames the given user-defined attribute to the name given in the string argument  If the
    new name conflicts with an existing name then this command will fail  Note that it is not
    legal to rename an attribute to the empty string
    
    
    :returns: The new name. When undone returns the original name.
    :rtype: string
    """
    pass


def geometryConstraint(*args, layer="", name="", remove=True, targetList=True, weight=0.0,
                       weightAliasList=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Constrain an object's position based on the shape of the target surface(s) at the closest
    point(s) to the object   A geometryConstraint takes as input one or more surface shapes
    (the targets) and a DAG transform node (the object)  The geometryConstraint position
    constrained object such object lies on the surface of the target with the greatest weig
    
    :param layer: (C E) Specify the name of the animation layer where the constraint should be
    added
    :type layer: string
    :param name: (C Q E) Sets the name of the constraint node to the specified name  Default
    name is constrainedObjectName_constraintType
    :type name: string
    :param remove: (E) removes the listed target(s) from the constraint
    :type remove: boolean
    :param targetList: (Q) Return the list of target objects
    :type targetList: boolean
    :param weight: (C Q E) Sets the weight value for the specified target(s)  If not given at
    creation time, the default value of 1.0 is used
    :type weight: float
    :param weightAliasList: (Q) Returns the names of the attributes that control the weight of
    the target objects  Aliases are returned in the same order as the targets are returned
    :type weightAliasList: boolean
    
    :returns: Name of the created constraint node
    :rtype: string[]
    """
    pass


def toolCollection(*args, collectionItemArray=True, defineTemplate="", exists=True, gl=True,
                   numberOfCollectionItems=True, parent="", select="", useTemplate="", q=True,
                   query=True, e=True, edit=True, **kwargs):
    """
    This command creates a tool button collection  Collections are parented to the current
    default layout if no parent is specified with the -p/parent flag  As children of the layout
    they will be deleted when the layout is deleted  Collections may also span more than one
    window if the -gl/global flag is used  In this case the collection has no parent a
    
    :param collectionItemArray: (Q) Returns a string list giving the long names of all the
    items in this collection
    :type collectionItemArray: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param gl: (C Q) Set the collection to have no parent layout  This flag must be specified
    when the collection is created and can not be queried or edited  Consequentl
    :type gl: boolean
    :param numberOfCollectionItems: (Q) Returns the number of items that are in this
    collection
    :type numberOfCollectionItems: boolean
    :param parent: (C) Specify the parent to associate the collection with  The collection will
    be deleted along with the parent  This flag must be specified when the colle
    :type parent: string
    :param select: (C Q E) Select the specified collection item  If queried will return the
    name of the currently selected collection item
    :type select: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: The name of the toolCollection created.
    :rtype: string
    """
    pass


def RigidBindSkin(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nodeGrapher(*args, **kwargs):
    """
    
    """
    pass


def AppendToHairCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteSurfaceFlow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetMeshFillTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def fileBrowserDialog(*args, actionName="", dialogStyle=0, fileCommand=None, fileType="",
                      filterList="", includeName="", mode=0, operationMode="", tipMessage="",
                      windowTitle="", **kwargs):
    """
    The fileBrowserDialog and fileDialog commands have now been deprecated  Both commands are
    still callable, but it is recommended that the fileDialog2 command be used instead  To
    maintain some backwards compatibility, both fileBrowserDialog and fileDialog will convert
    the flags/values passed to them into the appropriate flags/values that the fileDial
    
    :param actionName: (C) Script to be called when the file is validated
    :type actionName: string
    :param dialogStyle: (C) 0 for old style dialog 1 for Windows 2000 style Explorer style 2
    for Explorer style with "Shortcut" tip at bottom
    :type dialogStyle: int
    :param fileCommand: (C) The script to run on command action
    :type fileCommand: script
    :param fileType: (C) Set the type of file to filter  By default this can be any one of:
    "mayaAscii", "mayaBinary", "mel", "OBJ", "directory", "plug-in", "audio", "move",
    :type fileType: string
    :param filterList: (C M) Specify file filters  Used with dialog style 1 and 2  Each string
    should be a description followed by a comma followed by a semi-colon separated list
    :type filterList: string
    :param includeName: (C) Include the given string after the actionName in parentheses  If
    the name is too long, it will be shortened to fit on the dialog (for example, /usr/a
    :type includeName: string
    :param mode: (C) Defines the mode in which to run the file brower: 0 for read 1 for write 2
    for write without paths (segmented files) 4 for directories have meaning w
    :type mode: int
    :param operationMode: (C) Enables the option dialog  Valid strings are: "Import"
    "Reference" "SaveAs" "ExportAll" "ExportActive"
    :type operationMode: string
    :param tipMessage: (C) Message to be displayed at the bottom of the style 2 dialog box
    :type tipMessage: string
    :param windowTitle: (C) Set the window title of a style 1 or 2 dialog box
    :type windowTitle: string
    
    :returns: Dialog name
    :rtype: string
    """
    pass


def PolyEditEdgeFlow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PaintEffectsToPoly(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def instancer(*args, addObject=True, cycle="none", cycleStep=0.0, cycleStepUnits="frames",
              index=0, levelOfDetail="geometry", name="", object="", objectPosition="",
              objectRotation="", objectScale="", pointDataSource=True, removeObject=True,
              rotationOrder="", rotationUnits="", valueName="", q=True, query=True, e=True,
              edit=True, **kwargs):
    """
    This command is used to create a instancer node and set the proper attributes in the node
    
    :param addObject: (C E) This flag indicates that objects specified by the -object flag will
    be added to the instancer node as instanced objects
    :type addObject: boolean
    :param cycle: (C Q E) This flag sets or queries the cycle attribute for the instancer node 
    The options are "none" or "sequential"  The default is "none"
    :type cycle: string
    :param cycleStep: (C Q E) This flag sets or queries the cycle step attribute for the
    instancer node  This attribute indicates the size of the step in frames or seconds (see cy
    :type cycleStep: float
    :param cycleStepUnits: (C Q E) This flag sets or queries the cycle step unit attribute for
    the instancer node  The options are "frames" or "seconds"  The default is "frames"
    :type cycleStepUnits: string
    :param index: (Q) This flag is used to query the name of the ith instanced object
    :type index: int
    :param levelOfDetail: (C Q E) This flag sets or queries the level of detail of the
    instanced objects  The options are "geometry", "boundingBox", "boundingBoxes"  The default
    is "g
    :type levelOfDetail: string
    :param name: (C Q) This flag sets or queries the name of the instancer node
    :type name: string
    :param object: (C Q E M) This flag indicates which objects will be add/removed from the
    list of instanced objects  The flag is used in conjuction with the -add and -remove fl
    :type object: string
    :param objectPosition: (Q) This flag queries the given objects position  This object can be
    any instanced object or sub-object
    :type objectPosition: string
    :param objectRotation: (Q) This flag queries the given objects rotation  This object can be
    any instanced object or sub-object
    :type objectRotation: string
    :param objectScale: (Q) This flag queries the given objects scale  This object can be any
    instanced object or sub-object
    :type objectScale: string
    :param pointDataSource: (Q) This flag is used to query the source node supply the data for
    the input points
    :type pointDataSource: boolean
    :param removeObject: (E) This flag indicates that objects specified by the -object flag
    will be removed from the instancer node as instanced objects
    :type removeObject: boolean
    :param rotationOrder: (C Q E) This flag specifies the rotation order associated with the
    rotation flag  The options are XYZ, XZY, YXZ, YZX, ZXY, or ZYX  By default the attribute i
    :type rotationOrder: string
    :param rotationUnits: (C Q E) This flag specifies the rotation units associated with the
    rotation flag  The options are degrees or radians  By default the attribute is degrees
    :type rotationUnits: string
    :param valueName: (Q) This flag is used to query the value(s) of the array associated with
    the given name  If the -index flag is used in conjuction with this flag then the
    :type valueName: string
    
    :returns: Command result
    :rtype: string
    """
    pass


def HideNURBSCurves(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def openGLExtension(*args, extension="", renderer=True, vendor=True, version=True, **kwargs):
    """
    Command returns the extension name depending on whether a given OpenGL extension is
    supported or not  The input is the extension string to the -extension flag  If the
    -extension flag is not used, or if the string argument to this flag is an empty string than
    all extension names are returned in a single string  If the extension exists it is not
    nece
    
    :param extension: (C) Specifies the OpenGL extension to query
    :type extension: string
    :param renderer: (C) Specifies to query the OpenGL renderer
    :type renderer: boolean
    :param vendor: (C) Specifies to query the company responsible for the OpenGL
    implementation
    :type vendor: boolean
    :param version: (C) Specifies to query the OpenGL version
    :type version: boolean
    
    :returns: The supported string(s)
    :rtype: string
    """
    pass


def SubdivSmoothnessMediumOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def arnoldCopyAsAdmin(*args, **kwargs):
    """
    
    """
    pass


def LoftOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def u3dUnfold(*args, **kwargs):
    """
    
    """
    pass


def TurbulenceOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ReferenceEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXImportSetMayaFrameRate(*args, **kwargs):
    """
    
    """
    pass


def texManipContext(*args, exists=True, image1="", image2="", image3="", q=True, query=True,
                    e=True, edit=True, **kwargs):
    """
    Command used to register the texSelectCtx tool  Command used to register the texManipCtx
    tool
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    
    :returns: : name of the context created
    :rtype: string
    """
    pass


def xgmDensityComp(*args, **kwargs):
    """
    
    """
    pass


def createNurbsPlaneCtx(*args, **kwargs):
    """
    
    """
    pass


def CreateNURBSSquare(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def truncateHairCache(*args, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command sets the end time of a hair cache to the current time  If the current time is
    less than the end time of the cache, the cache is truncated so that only the portion of the
    cache up to and including the current time is preserved
    
    
    :returns: 
    :rtype: None
    """
    pass


def arcLenDimContext(*args, exists=True, history=True, image1="", image2="", image3="", name="",
                     q=True, query=True, e=True, edit=True, **kwargs):
    """
    Command used to register the arcLenDimCtx tool
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: : name of the context created
    :rtype: string
    """
    pass


def RemoveWireOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def promptDialog(*args, backgroundColor=None, button="", cancelButton="", defaultButton="",
                 dismissString="", message="", messageAlign="", parent="", scrollableField=True,
                 style="", text="", title="", q=True, query=True, **kwargs):
    """
    The promptDialog command creates a modal dialog with a message to the user, a text field in
    which the user may enter a response, and a variable number of buttons to dismiss the dialog
     The dialog is dismissed when the user presses any button or chooses the close item from
    the window menu  In the case where a button is pressed then the name of the b
    
    :param backgroundColor: (C) The background color of the dialog  The arguments correspond to
    the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type backgroundColor: [float, float, float]
    :param button: (C M) Create a button with the given string as it's text
    :type button: string
    :param cancelButton: (C) The cancel button is activated by pressing the escape key  Note
    that this flag does not create a button, it simply indicates which button created via
    :type cancelButton: string
    :param defaultButton: (C) The default button is activated by pressing the enter key  Note
    that this flag does not create a button, it simply indicates which button created via
    :type defaultButton: string
    :param dismissString: (C) The string returned when the user selects the 'Close' item from
    the Window Manager menu  If this flag is not set then the string "dismiss" is returne
    :type dismissString: string
    :param message: (C) The message text appearing in the dialog
    :type message: string
    :param messageAlign: (C) Align the message left, center, or right
    :type messageAlign: string
    :param parent: (C) Specify the parent window for the dialog  The dialog will be centered on
    this window and raise and lower with it's parent  By default, the dialog is
    :type parent: string
    :param scrollableField: (C) By default a single line text field is used in the dialog 
    Specify true for a multi-line scroll field
    :type scrollableField: boolean
    :param style: (C) Specify the type of input expected in the input field  Vaid input types
    are "integer" "float" "text"  If this flag is not specified, we assume the in
    :type style: string
    :param text: (C Q) The field text
    :type text: string
    :param title: (C) The dialog title
    :type title: string
    
    :returns: Indicates how the dialog was dismissed. If a button is
    pressed then the label of
    the button is returned. If the dialog is
    closed then the value for the flag
    ds/dismissString is
    returned.
    :rtype: string
    """
    pass


def TimeEditorFrameSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def InsertIsoparms(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXImportLights(*args, **kwargs):
    """
    
    """
    pass


def dR_meshAlphaTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nodeCast(*args, copyDynamicAttrs=True, disableAPICallbacks=True,
             disableScriptJobCallbacks=True, disconnectUnmatchedAttrs=True, force=True,
             swapNames=True, swapValues=True, **kwargs):
    """
    Given two nodes, a source node of type A and a target node of type B, where type A is
    either type B or a sub-type of B, this command will replace the target node with the source
    node  That is, all node connections, DAG hierarchy and attribute values on the target node
    will be removed from the target node and placed on the source node  This operatio
    
    :param copyDynamicAttrs: (C) If the target node contains any dynamic attributes that are
    not defined on the source node, then create identical dynamic attricutes on the source no
    :type copyDynamicAttrs: boolean
    :param disableAPICallbacks: (C) add comment
    :type disableAPICallbacks: boolean
    :param disableScriptJobCallbacks: (C) add comment
    :type disableScriptJobCallbacks: boolean
    :param disconnectUnmatchedAttrs: (C) If the node that is being swapped out has any
    connections that do not exist on the target node, then indicate if the connection should be
    disconnecte
    :type disconnectUnmatchedAttrs: boolean
    :param force: (C) Forces the command to do the node cast operation even if the nodes do not
    share a common base object  When this flag is specified the command will tr
    :type force: boolean
    :param swapNames: (C) Swap the names of the nodes  By default names are not swapped
    :type swapNames: boolean
    :param swapValues: (C) Indicates if the commands should exchange attributes on the common
    attributes between the two nodes  For example, if the nodes are the same base type
    :type swapValues: boolean
    
    :returns: 0 for success, 1 for failure.
    :rtype: int
    """
    pass


def reorder(*args, back=True, front=True, relative=0, **kwargs):
    """
    This command reorders (moves) objects relative to their siblings   For relative moves, both
    positive and negative numbers may be specified  Positive numbers move the object forward
    and negative numbers move the object backward amoung its siblings  When an object is at the
    end (beginning) of the list of siblings, a relative move of 1 (-1) will put t
    
    :param back: (C) Move object(s) to back of sibling list
    :type back: boolean
    :param front: (C) Move object(s) to front of sibling list
    :type front: boolean
    :param relative: (C) Move object(s) relative to other siblings
    :type relative: int
    
    :returns: 
    :rtype: None
    """
    pass


def polyDuplicateEdge(*args, adjustEdgeFlow=0.0, deleteEdge=True, endVertexOffset=0.0,
                      insertWithEdgeFlow=True, offset=0.0, smoothingAngle=0.0, splitType=0,
                      startVertexOffset=0.0, caching=True, constructionHistory=True, name="",
                      nodeState=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Duplicates a series of connected edges (edgeLoop)
    
    :param adjustEdgeFlow: (C Q E) The weight value of the edge vertices to be positioned
    :type adjustEdgeFlow: float
    :param deleteEdge: (C Q E) When true, the end edges are deleted so the end triangles are
    converted to quads
    :type deleteEdge: boolean
    :param endVertexOffset: (C Q E) Weight value controlling the offset of the end vertex of
    the edgeloop
    :type endVertexOffset: float
    :param insertWithEdgeFlow: (C Q E) True to enable edge flow  Otherwise, the edge flow is
    disabled
    :type insertWithEdgeFlow: boolean
    :param offset: (C) Weight value controlling the relative positioning of the new edges  The
    range of values is [0.0, 1.0]
    :type offset: float
    :param smoothingAngle: (C Q E) Angle below which new edges will be smoothed
    :type smoothingAngle: float
    :param splitType: (C Q E) Format: 0 - Absolute, 1 - Relative, 2 - Multi
    :type splitType: int
    :param startVertexOffset: (C Q E) Weight value controlling the offset of the start vertex
    of the edgeloop
    :type startVertexOffset: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def BrushPresetReplaceShadingOff(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def saveImage(*args, annotation="", backgroundColor=None, currentView=True, defineTemplate="",
              docTag="", dragCallback=None, dropCallback=None, enable=True,
              enableBackground=True, enableKeyboardFocus=True, exists=True, fullPathName=True,
              height=0, highlightColor=None, image="", isObscured=True, manage=True,
              noBackground=True, numberOfPopupMenus=True, objectThumbnail="", parent="",
              popupMenuArray=True, preventOverride=True, sceneFile="", statusBarMessage="",
              useTemplate="", visible=True, visibleChangeCommand=None, width=0, q=True,
              query=True, e=True, edit=True, **kwargs):
    """
    This command creates a static image for non-xpm files  Any image file format supported by
    the file texture node is supported by this command   This command creates a static image
    control for non-xpm files used to display a thumbnail image of the scene file
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param currentView: (E) Generate the image from the current view
    :type currentView: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param image: (C Q E) Sets the image given the file name
    :type image: string
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param objectThumbnail: (E) Use an image of the named object, if possible
    :type objectThumbnail: string
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param sceneFile: (E) The name of the file that the icon is to be associated with
    :type sceneFile: string
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the image created.
    :rtype: string
    """
    pass


def ExportOfflineFileOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadePickWalkUp(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectCVsMask(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorSetTraversalDepthZero(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def relationship(*args, b=True, relationshipData="", q=True, query=True, e=True, edit=True,
                 **kwargs):
    """
    This is primarily for use with file IO  Rather than write out the specific
    attributes/connections required to maintain a relationship, a description of the related
    nodes/plugs is written instead  The relationship must have an owner node, and have a
    specific type  During file read, maya will make the connections and/or set the data
    necessary to repr
    
    :param b: (C Q E) Break the specified relationship instead of creating it
    :type b: boolean
    :param relationshipData: (C Q E M) Provide relationship data to be used when creating the
    relationship
    :type relationshipData: string
    
    :returns: 
    :rtype: None
    """
    pass


def pfxstrokes(*args, filename="", postCallback=True, selected=True, **kwargs):
    """
    This command will loop through all the Paint Effects strokes, including pfxHair nodes, and
    write the current state of all the tubes to a file  For normal stroke nodes tubes must be
    ON in the brush or there will be no output  For pfxHair nodes there will always be output,
    but the format is different than for stroke nodes(however one can assign a bru
    
    :param filename: (C) The output file
    :type filename: string
    :param postCallback: (C) Output information to the file after the Runtime Callback MEL
    function has been invoked  The default is to output the information prior to the callba
    :type postCallback: boolean
    :param selected: (C) Only loop through the selected strokes
    :type selected: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def launchImageEditor(*args, editImageFile="", viewImageFile="", **kwargs):
    """
    Launch the appropriate application to edit/view the image files specified  This command
    works only on the Macintosh and Windows platforms
    
    :param editImageFile: (C) If the file is a PSD, then the specified verison of Photoshop is
    launched, and the file is opened in it  If file is any other image type, then the pr
    :type editImageFile: string
    :param viewImageFile: (C) Opens up an Image editor to view images
    :type viewImageFile: string
    
    :returns: 
    :rtype: None
    """
    pass


def RedoPreviousIPRRender(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExtendCurveOnSurfaceOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectAllFurs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def detachDeviceAttr(*args, all=True, attribute="", axis="", device="", selection=True, q=True,
                     query=True, **kwargs):
    """
    This command detaches connections between device axes and node attributes  The command line
    arguments are the same as for the corresponding attachDeviceAttr except for the clutch
    argument which can not be used in this command
    
    :param all: (C) Delete all attachments on every device
    :type all: boolean
    :param attribute: (C) The attribute to detach  This flag must be used with the -d/device
    flag
    :type attribute: string
    :param axis: (C) The axis to detach  This flag must be used with the -d/device flag
    :type axis: string
    :param device: (C) Delete the attachment for this device  If the -ax/axis flag is not used,
    all of the attachments connected to this device are detached
    :type device: string
    :param selection: (C) Detaches selection attachments
    :type selection: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def AddShrinkWrapSurfaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypergraphDecreaseDepth(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmMoveDescription(*args, **kwargs):
    """
    
    """
    pass


def PruneLattice(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSetPartBrushToolOption(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SendToUnrealSelection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GetHIKChildId(*args, **kwargs):
    """
    
    """
    pass


def XgmSetLengthBrushToolOption(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideNonlinears(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolygonNormalEditTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AutoPaintMarkingMenuPopDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def subdivDisplaySmoothness(*args, smoothness=0, q=True, query=True, **kwargs):
    """
    Sets or querys the display smoothness of subdivision surfaces on the selection list or of
    all subdivision surfaces if the -all option is set  Smoothness options are; rough, medium,
    or fine  Rough is the default
    
    :param smoothness: (C Q) Smoothness - 1 rough, 2 medium, 3 fine
    :type smoothness: int
    
    :returns: Command result
    :rtype: boolean
    """
    pass


def TexSculptUnpinAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectContiguousEdges(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def InTangentClamped(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def curveCVCtx(*args, bezier=True, degree=0, exists=True, history=True, image1="", image2="",
               image3="", multEndKnots=True, name="", preserveShape=True, rational=True,
               refit=True, symmetry=True, uniform=True, q=True, query=True, e=True, edit=True,
               **kwargs):
    """
    The curveCVCtx command creates a new context for creating curves by placing control
    vertices (CVs)
    
    :param bezier: (C Q E) 
    :type bezier: boolean
    :param degree: (C Q E) Curve degree
    :type degree: int
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param multEndKnots: (C Q E) Specify if multiple end knots are to be created
    :type multEndKnots: boolean
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param preserveShape: (C Q E) Set this flag to make the operation preserve the shape
    :type preserveShape: boolean
    :param rational: (C Q E) Should the curve be rational?
    :type rational: boolean
    :param refit: (C Q E) Set this flag to refit the curve
    :type refit: boolean
    :param symmetry: (C Q E) Specify if symmetry is to be used
    :type symmetry: boolean
    :param uniform: (C Q E) Should the curve use uniform parameterization?
    :type uniform: boolean
    
    :returns: (name of the new context)
    :rtype: string
    """
    pass


def NodeEditorSelectUpStream(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def setEditCtx(*args, exists=True, history=True, image1="", image2="", image3="", name="",
               q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a tool that can be used to modify set membership
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: The name of the context
    :rtype: string
    """
    pass


def AddBlendShape(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorCutClips(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def selectPriority(*args, allComponents=0, allObjects=0, animBreakdown=0, animCurve=0,
                   animInTangent=0, animKeyframe=0, animOutTangent=0, byName=None, camera=0,
                   cluster=0, collisionModel=0, controlVertex=0, curve=0, curveKnot=0,
                   curveOnSurface=0, curveParameterPoint=0, dimension=0, dynamicConstraint=0,
                   edge=0, editPoint=0, emitter=0, facet=0, field=0, fluid=0, follicle=0,
                   hairSystem=0, handle=0, hull=0, ikEndEffector=0, ikHandle=0, imagePlane=0,
                   implicitGeometry=0, isoparm=0, joint=0, jointPivot=0, lattice=0,
                   latticePoint=0, light=0, localRotationAxis=0, locator=0, locatorUV=0,
                   locatorXYZ=0, meshUVShell=0, motionTrailPoint=0, motionTrailTangent=0,
                   nCloth=0, nParticle=0, nParticleShape=0, nRigid=0, nonlinear=0, nurbsCurve=0,
                   nurbsSurface=0, orientationLocator=0, particle=0, particleShape=0, plane=0,
                   polymesh=0, polymeshEdge=0, polymeshFace=0, polymeshFreeEdge=0, polymeshUV=0,
                   polymeshVertex=0, polymeshVtxFace=0, queryByName="", rigidBody=0,
                   rigidConstraint=0, rotatePivot=0, scalePivot=0, sculpt=0, selectHandle=0,
                   spring=0, springComponent=0, stroke=0, subdiv=0, subdivMeshEdge=0,
                   subdivMeshFace=0, subdivMeshPoint=0, subdivMeshUV=0, surfaceEdge=0,
                   surfaceFace=0, surfaceKnot=0, surfaceParameterPoint=0, surfaceRange=0,
                   texture=0, vertex=0, q=True, query=True, **kwargs):
    """
    The selectPriority command is used to change the selection priority of particular types of
    objects that can be selected when using the select tool  It accepts no other arguments
    besides the flags  These flags are the same as used by the 'selectType' command
    
    :param allComponents: (C Q) Set all component selection priority
    :type allComponents: int
    :param allObjects: (C Q) Set all object selection priority
    :type allObjects: int
    :param animBreakdown: (C Q) Set animation breakdown selection priority
    :type animBreakdown: int
    :param animCurve: (C Q) Set animation curve selection priority
    :type animCurve: int
    :param animInTangent: (C Q) Set animation in-tangent selection priority
    :type animInTangent: int
    :param animKeyframe: (C Q) Set animation keyframe selection priority
    :type animKeyframe: int
    :param animOutTangent: (C Q) Set animation out-tangent selection priority
    :type animOutTangent: int
    :param byName: (C M) Set selection priority for the specified user-defined selection type
    :type byName: [string, boolean]
    :param camera: (C Q) Set camera selection priority
    :type camera: int
    :param cluster: (C Q) Set cluster selection priority
    :type cluster: int
    :param collisionModel: (C Q) Set collision model selection priority
    :type collisionModel: int
    :param controlVertex: (C Q) Set control vertex selection priority
    :type controlVertex: int
    :param curve: (C Q) Set curve selection priority
    :type curve: int
    :param curveKnot: (C Q) Set curve knot selection priority
    :type curveKnot: int
    :param curveOnSurface: (C Q) Set curve-on-surface selection priority
    :type curveOnSurface: int
    :param curveParameterPoint: (C Q) Set curve parameter point selection priority
    :type curveParameterPoint: int
    :param dimension: (C Q) Set dimension shape selection priority
    :type dimension: int
    :param dynamicConstraint: (C Q) Set dynamicConstraint selection priority
    :type dynamicConstraint: int
    :param edge: (C Q) Set mesh edge selection priority
    :type edge: int
    :param editPoint: (C Q) Set edit-point selection priority
    :type editPoint: int
    :param emitter: (C Q) Set emitter selection priority
    :type emitter: int
    :param facet: (C Q) Set mesh face selection priority
    :type facet: int
    :param field: (C Q) Set field selection priority
    :type field: int
    :param fluid: (C Q) Set fluid selection priority
    :type fluid: int
    :param follicle: (C Q) Set follicle selection priority
    :type follicle: int
    :param hairSystem: (C Q) Set hairSystem selection priority
    :type hairSystem: int
    :param handle: (C Q) Set object handle selection priority
    :type handle: int
    :param hull: (C Q) Set hull selection priority
    :type hull: int
    :param ikEndEffector: (C Q) Set ik end effector selection priority
    :type ikEndEffector: int
    :param ikHandle: (C Q) Set ik handle selection priority
    :type ikHandle: int
    :param imagePlane: (C Q) Set image plane selection mask priority
    :type imagePlane: int
    :param implicitGeometry: (C Q) Set implicit geometry selection priority
    :type implicitGeometry: int
    :param isoparm: (C Q) Set surface iso-parm selection priority
    :type isoparm: int
    :param joint: (C Q) Set ik handle selection priority
    :type joint: int
    :param jointPivot: (C Q) Set joint pivot selection priority
    :type jointPivot: int
    :param lattice: (C Q) Set lattice selection priority
    :type lattice: int
    :param latticePoint: (C Q) Set lattice point selection priority
    :type latticePoint: int
    :param light: (C Q) Set light selection priority
    :type light: int
    :param localRotationAxis: (C Q) Set local rotation axis selection priority
    :type localRotationAxis: int
    :param locator: (C Q) Set locator (all types) selection priority
    :type locator: int
    :param locatorUV: (C Q) Set uv locator selection priority
    :type locatorUV: int
    :param locatorXYZ: (C Q) Set xyz locator selection priority
    :type locatorXYZ: int
    :param meshUVShell: (C Q) Set uv shell component mask on/off
    :type meshUVShell: int
    :param motionTrailPoint: (C Q) Set motion point selection priority
    :type motionTrailPoint: int
    :param motionTrailTangent: (C Q) Set motion point tangent priority
    :type motionTrailTangent: int
    :param nCloth: (C Q) Set nCloth selection priority
    :type nCloth: int
    :param nParticle: (C Q) Set nParticle point selection priority
    :type nParticle: int
    :param nParticleShape: (C Q) Set nParticle shape selection priority
    :type nParticleShape: int
    :param nRigid: (C Q) Set nRigid selection priority
    :type nRigid: int
    :param nonlinear: (C Q) Set nonlinear selection priority
    :type nonlinear: int
    :param nurbsCurve: (C Q) Set nurbs-curve selection priority
    :type nurbsCurve: int
    :param nurbsSurface: (C Q) Set nurbs-surface selection priority
    :type nurbsSurface: int
    :param orientationLocator: (C Q) Set orientation locator selection priority
    :type orientationLocator: int
    :param particle: (C Q) Set particle point selection priority
    :type particle: int
    :param particleShape: (C Q) Set particle shape selection priority
    :type particleShape: int
    :param plane: (C Q) Set sketch plane selection priority
    :type plane: int
    :param polymesh: (C Q) Set poly-mesh selection priority
    :type polymesh: int
    :param polymeshEdge: (C Q) Set poly-mesh edge selection priority
    :type polymeshEdge: int
    :param polymeshFace: (C Q) Set poly-mesh face selection priority
    :type polymeshFace: int
    :param polymeshFreeEdge: (C Q) Set poly-mesh free-edge selection priority
    :type polymeshFreeEdge: int
    :param polymeshUV: (C Q) Set poly-mesh UV point selection priority
    :type polymeshUV: int
    :param polymeshVertex: (C Q) Set poly-mesh vertex selection priority
    :type polymeshVertex: int
    :param polymeshVtxFace: (C Q) Set poly-mesh vtxFace selection priority
    :type polymeshVtxFace: int
    :param queryByName: (Q) Query selection priority for the specified user-defined selection
    type In query mode, this flag needs a value
    :type queryByName: string
    :param rigidBody: (C Q) Set rigid body selection priority
    :type rigidBody: int
    :param rigidConstraint: (C Q) Set rigid constraint selection priority
    :type rigidConstraint: int
    :param rotatePivot: (C Q) Set rotate pivot selection priority
    :type rotatePivot: int
    :param scalePivot: (C Q) Set scale pivot selection priority
    :type scalePivot: int
    :param sculpt: (C Q) Set sculpt selection priority
    :type sculpt: int
    :param selectHandle: (C Q) Set select handle selection priority
    :type selectHandle: int
    :param spring: (C Q) Set spring shape selection priority
    :type spring: int
    :param springComponent: (C Q) Set individual spring selection priority
    :type springComponent: int
    :param stroke: (C Q) Set stroke selection priority
    :type stroke: int
    :param subdiv: (C Q) Set subdivision surface selection priority
    :type subdiv: int
    :param subdivMeshEdge: (C Q) Set subdivision surface mesh edge selection priority
    :type subdivMeshEdge: int
    :param subdivMeshFace: (C Q) Set subdivision surface mesh face selection priority
    :type subdivMeshFace: int
    :param subdivMeshPoint: (C Q) Set subdivision surface mesh point selection priority
    :type subdivMeshPoint: int
    :param subdivMeshUV: (C Q) Set subdivision surface mesh UV map selection priority
    :type subdivMeshUV: int
    :param surfaceEdge: (C Q) Set surface edge selection priority
    :type surfaceEdge: int
    :param surfaceFace: (C Q) Set surface face selection priority
    :type surfaceFace: int
    :param surfaceKnot: (C Q) Set surface knot selection priority
    :type surfaceKnot: int
    :param surfaceParameterPoint: (C Q) Set surface parameter point selection priority
    :type surfaceParameterPoint: int
    :param surfaceRange: (C Q) Set surface range selection priority
    :type surfaceRange: int
    :param texture: (C Q) Set texture selection priority
    :type texture: int
    :param vertex: (C Q) Set mesh vertex selection priority
    :type vertex: int
    
    :returns: if a query operation
    :rtype: int
    """
    pass


def ExportProxyContainerOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TogglePolyCount(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgCreateDescriptionEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def arnoldUpdateTx(*args, **kwargs):
    """
    
    """
    pass


def hudSlider(*args, allowOverlap=True, block=0, blockAlignment="", blockSize="",
              decimalPrecision=0, dragCommand=None, internalPadding=0, label="",
              labelFontSize="", labelWidth=0, maxValue=0.0, minValue=0.0, padding=0,
              pressCommand=None, releaseCommand=None, section=0, sliderIncrement=0.0,
              sliderLength=0, type="", value=0.0, valueAlignment="", valueFontSize="",
              valueWidth=0, visible=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a Heads-up Display (HUD) slider control which is placed in a 2D
    inactive overlay plane on the 3D viewport  It is to be used to provide hands-on interaction
    designated by a user script  The HUD slider is derived from a generic HUD object and thus
    inherits a similar workflow   Although this command provides much of the same funct
    
    :param allowOverlap: (C Q E) Sets the Heads-Up Display to be visible regardless of
    overlapping section widths/limitations (see -s/section flag description for more details)
    :type allowOverlap: boolean
    :param block: (C Q E) Denotes the individual block that the HUD will reside in, within a
    section  Each section is composed of a single column of blocks  The total number o
    :type block: int
    :param blockAlignment: (C Q E) Specifies the alignment of the block within its respective
    column  Available alignments are: "center", "left" and "right"  The default alignment is "
    :type blockAlignment: string
    :param blockSize: (C Q E) Sets the height of each block  Available heights are: small,
    medium and large  In pixel measurements, each corresponds to a 20, 35 or 50 pixel height
    :type blockSize: string
    :param decimalPrecision: (C Q E) Sets the decimal precision of any floating point value
    returned by the command  The valid range of precision values are 1 to 8
    :type decimalPrecision: int
    :param dragCommand: (C Q E) Specifies the procedure or script to run during a mouse drag
    event
    :type dragCommand: script
    :param internalPadding: (C Q E) Specifies the amount of padding between the internal
    elements of the HUD  For the hudSlider, this represents the padding between the slider bar
    and t
    :type internalPadding: int
    :param label: (C Q E) Text label of the HUD
    :type label: string
    :param labelFontSize: (C Q E) Sets the font size of the label  Available sizes are: small
    and large
    :type labelFontSize: string
    :param labelWidth: (C Q E) Specifies the pixel width of the virtual "textbox" which will
    hold the label  The contents of this "textbox" will be left justified  If the width of
    :type labelWidth: int
    :param maxValue: (C Q E) Specify the maximum value of the slider  Note: Although this flag
    takes in a FLOAT as an argument, if the HUD type is "int", the value will be automa
    :type maxValue: float
    :param minValue: (C Q E) Specify the minimum value of the slider  Note: Although this flag
    takes in a FLOAT as an argument, if the HUD type is "int", the value will be automa
    :type minValue: float
    :param padding: (C Q E) Specifies the width of both the left and right margins of a block 
    Default value is 15 pixels
    :type padding: int
    :param pressCommand: (C Q E) Specifies the procedure or script to run during a mouse click
    event
    :type pressCommand: script
    :param releaseCommand: (C Q E) Specifies the procedure or script to run during a mouse
    release event
    :type releaseCommand: script
    :param section: (C Q E) Defines the section the HUD will appear in  There are 10 sections
    divided across the screen  Five columns and two rows make up the ten element matrix
    :type section: int
    :param sliderIncrement: (C Q E) Specify the number of increments along the slider  If not
    specified or set to 0 or less, the slider will be linearly even and continuous from
    minValu
    :type sliderIncrement: float
    :param sliderLength: (C Q E) Specifies the length of the slider in pixels
    :type sliderLength: int
    :param type: (C Q E) Specify the numeric type of the HUD  Available types are: "float" and
    "int"
    :type type: string
    :param value: (C Q E) Set/Return the slider value if the HUD is a valid HUD slider  Note:
    Although this flag takes in a FLOAT as an argument, if the HUD type is "int", the
    :type value: float
    :param valueAlignment: (C Q E) Specifies the alignment of the data blocks and the data text,
    within a HUD block  Available alignments are: "left" and "right"  The default alignment
    :type valueAlignment: string
    :param valueFontSize: (C Q E) Sets the font size of the slider value  Available sizes are:
    small and large
    :type valueFontSize: string
    :param valueWidth: (C Q E) Specifies the pixel width of the virtual "textbox" which will
    hold the slider value  (To see a layout of a block, see the description of the -block f
    :type valueWidth: int
    :param visible: (C Q E) Sets the visibility of the Heads-Up Display on and off
    :type visible: boolean
    
    :returns: ID number of the Heads-Up Display (HUD).
    :rtype: int
    """
    pass


def SaveHIKCharacterDefinition(*args, **kwargs):
    """
    
    """
    pass


def CustomNURBSSmoothnessOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def STRSTweakModeToggle(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def bifrost(*args, **kwargs):
    """
    
    """
    pass


def Bevel(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmPlaceBrushContext(*args, **kwargs):
    """
    
    """
    pass


def TesselateSubdivSurfaceOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def timeEditorComposition(*args, active=True, allCompositions=True, createTrack=True,
                          delete=True, duplicateFrom="", rename=None, tracksNode=True, q=True,
                          query=True, e=True, edit=True, **kwargs):
    """
    Commands related to composition management inside Time Editor
    
    :param active: (Q E) Query or edit the active composition
    :type active: boolean
    :param allCompositions: (Q) Return all compositions inside Time Editor
    :type allCompositions: boolean
    :param createTrack: (C) Create a default track when creating a new composition
    :type createTrack: boolean
    :param delete: (Q E) Delete the composition
    :type delete: boolean
    :param duplicateFrom: (C) Duplicate the composition
    :type duplicateFrom: string
    :param rename: (E) Rename the composition of the first name to the second name
    :type rename: [string, string]
    :param tracksNode: (Q) Query the tracks node of a composition
    :type tracksNode: boolean
    
    :returns: Return values currently not documented.
    :rtype: string
    """
    pass


def PruneSmallWeightsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypergraphHierarchyWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetMeshAmplifyTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AlignSurfacesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def graphEditor(*args, **kwargs):
    """
    unknown
    """
    pass


def dR_convertSelectionToVertex(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorCopyClips(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowMeshFreezeToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowMeshFlattenToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def savePrefs(*args, colors=True, general=True, hotkeys=True, menuSets=True, plugins=True,
              uiLayout=True, **kwargs):
    """
    This command saves preferences to disk  If no flags are specified then all pref types get
    saved out
    
    :param colors: (C) Save the color prefs to disk
    :type colors: boolean
    :param general: (C) Save the general prefs to disk (optionVars)
    :type general: boolean
    :param hotkeys: (C) Save the hotkeys to disk
    :type hotkeys: boolean
    :param menuSets: (C) Save the menuSet preferences to disk
    :type menuSets: boolean
    :param plugins: (C) Save the plug-in prefs to disk
    :type plugins: boolean
    :param uiLayout: (C) Save each window's size and position to disk
    :type uiLayout: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def NodeEditorGraphAddSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowUIElements(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nucleusDisplayDynamicConstraintNodes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ModifyStampDepthRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteEntireHairSystem(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OffsetEdgeLoopToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DisableIKSolvers(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ScaleTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sculptTarget(*args, after=True, afterReference=True, before=True, deformerTools=True,
                 exclusive="", frontOfChain=True, geometry="", geometryIndices=True,
                 ignoreSelected=True, inbetweenWeight=0.0, includeHiddenSelections=False,
                 name="", parallel=True, prune=True, regenerate=True, remove=True, snapshot=0,
                 split=True, target=0, e=True, edit=True, **kwargs):
    """
    This command is used to specify the blend shape target to be modified by the sculpting
    tools and transform manipulators
    
    :param after: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type after: boolean
    :param afterReference: (C E) The -afterReference flag is used to specify deformer ordering
    in a hybrid way that choses between -before and -after automatically  If the geometry b
    :type afterReference: boolean
    :param before: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type before: boolean
    :param deformerTools: () Returns the name of the deformer tool objects (if any) as string
    string ..
    :type deformerTools: boolean
    :param exclusive: (C) Puts the deformation set in a deform partition
    :type exclusive: string
    :param frontOfChain: (C E) This command is used to specify that the new deformer node
    should be placed ahead (upstream) of existing deformer and skin nodes in the shape's histo
    :type frontOfChain: boolean
    :param geometry: (E M) The specified object will be added to the list of objects being
    deformed by this deformer object, unless the -rm flag is also specified  When queried
    :type geometry: string
    :param geometryIndices: () Complements the -geometry flag in query mode  Returns the multi
    index of each geometry
    :type geometryIndices: boolean
    :param ignoreSelected: (C) Tells the command to not deform objects on the current selection
    list
    :type ignoreSelected: boolean
    :param inbetweenWeight: (E) Specifies the in between target weight of the blend shape node
    that will be made editable by the sculpting and transform tools
    :type inbetweenWeight: float
    :param includeHiddenSelections: (C) Apply the deformer to any visible and hidden objects in
    the selection list  Default is false
    :type includeHiddenSelections: boolean
    :param name: (C) Used to specify the name of the node being created
    :type name: string
    :param parallel: (C E) Inserts the new deformer in a parallel chain to any existing
    deformers in the history of the object  A blendShape is inserted to blend the parallel r
    :type parallel: boolean
    :param prune: (E) Removes any points not being deformed by the deformer in its current
    configuration from the deformer set
    :type prune: boolean
    :param regenerate: (E) When this flag is specified a new shape is created for the specified
    blend shape target, if the shape does not already exist  The name of the new sha
    :type regenerate: boolean
    :param remove: (E M) Specifies that objects listed after the -g flag should be removed from
    this deformer
    :type remove: boolean
    :param snapshot: (E) This flag should only be used internally to add in-between target 
    When this flag is specified a snapshot of the shape will be taken for the specifie
    :type snapshot: int
    :param split: (C E) Branches off a new chain in the dependency graph instead of
    inserting/appending the deformer into/onto an existing chain  Works in create mode (and e
    :type split: boolean
    :param target: (E) Specifies the target index of the blend shape node that will be made
    editable by the sculpting and transform tools
    :type target: int
    
    :returns: 
    :rtype: None
    """
    pass


def xgmGroomConvert(*args, **kwargs):
    """
    
    """
    pass


def DisplayWireframe(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PanelPreferencesWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MinimizeApplication(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def timeCode(*args, mayaStartFrame=0.0, productionStartFrame=0.0, productionStartHour=0.0,
             productionStartMinute=0.0, productionStartSecond=0.0, q=True, query=True, e=True,
             edit=True, **kwargs):
    """
    Use this command to query and set the time code information in the file
    
    :param mayaStartFrame: (C Q E) Sets the Maya start time of the time code, in frames  In
    query mode, returns the Maya start frame of the time code
    :type mayaStartFrame: float
    :param productionStartFrame: (C Q E) Sets the production start time of the time code, in
    terms of frames  In query mode, returns the sub-second frame of production start time
    :type productionStartFrame: float
    :param productionStartHour: (C Q E) Sets the production start time of the time code, in
    terms of hours  In query mode, returns the hour of production start time
    :type productionStartHour: float
    :param productionStartMinute: (C Q E) Sets the production start time of the time code, in
    terms of minutes  In query mode, returns the minute of production start time
    :type productionStartMinute: float
    :param productionStartSecond: (C Q E) Sets the production start time of the time code, in
    terms of seconds  In query mode, returns the second of production start time
    :type productionStartSecond: float
    
    :returns: values
    :rtype: time
    """
    pass


def lassoContext(*args, drawClosed=True, exists=True, history=True, image1="", image2="",
                 image3="", name="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    Creates a context to perform selection via a "lasso"  Use for irregular selection regions,
    where the "marquee-style" select of the "selectContext" is inappropriate
    
    :param drawClosed: (C Q E) Turns the closed display of the lasso on/off
    :type drawClosed: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: Name of the context created
    :rtype: string
    """
    pass


def setMenuMode(*args, **kwargs):
    """
    Optionally sets a new Menu Mode for the menu bar in the main Maya window  Returns the
    current Menu Mode, and if a new one is specified, then the previous Menu Mode is returned 
    Note that due to recent changes to the menu set architecture (8.0+), this function now
    takes a menu set as a parameter instead of a label
    
    
    :returns: The current Menu Mode for the menu bar in the main Maya window.
    :rtype: string
    """
    pass


def PolyMergeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowManipulators(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def play(*args, forward=True, playSound=True, record=True, sound="", state=True, wait=True,
         q=True, query=True, **kwargs):
    """
    This command starts and stops playback  In order to change the frame range of playback, see
    the playbackOptions command
    
    :param forward: (C Q) When true, play back the animation from the currentTime to the
    maximum of the playback range  When false, play back from the currentTime to the minim
    :type forward: boolean
    :param playSound: (C Q) Specify whether or not sound should be used during playback
    :type playSound: boolean
    :param record: (C Q) enable the recording system and start one playback loop
    :type record: boolean
    :param sound: (C Q) Specify the sound node to be used during playback
    :type sound: string
    :param state: (C Q) start or stop playing back
    :type state: boolean
    :param wait: (C) Wait till completion before returning control to command Window
    :type wait: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def SelectToggleMode(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def hotkeyEditorPanel(*args, annotation="", backgroundColor=None, defineTemplate="", docTag="",
                      dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
                      enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
                      highlightColor=None, isObscured=True, manage=True, noBackground=True,
                      numberOfPopupMenus=True, parent="", popupMenuArray=True,
                      preventOverride=True, statusBarMessage="", useTemplate="", visible=True,
                      visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
                      **kwargs):
    """
    A hotkeyEditor creates a new hotkey editor in the current layout  The hotkey editor lets
    you assign predefined commands, MEL scripts, or marking menus to keys and key combinations
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the editor.
    :rtype: string
    """
    pass


def getPanel(*args, allConfigs=True, allPanels=True, allScriptedTypes=True, allTypes=True,
             atPosition=None, configWithLabel="", containing="", invisiblePanels=True,
             scriptType="", type="", typeOf="", underPointer=True, visiblePanels=True,
             withFocus=True, withLabel="", **kwargs):
    """
    This command returns panel and panel configuration information
    
    :param allConfigs: (C) Return the names of the all panel configuration in a string array
    :type allConfigs: boolean
    :param allPanels: (C) Return the names of all the panels in a string array
    :type allPanels: boolean
    :param allScriptedTypes: (C) Return the names of all types of scripted panels in a string
    array
    :type allScriptedTypes: boolean
    :param allTypes: (C) Return the names of all types of panels, except scripted types in a
    string array
    :type allTypes: boolean
    :param atPosition: (C) Return the name of the panel which contains the specified screen
    coordinates  An empty string is returned if there is no panel at those coordinates
    :type atPosition: [int, int]
    :param configWithLabel: (C) Return the name of the panel configuration with the specified
    label text
    :type configWithLabel: string
    :param containing: (C) Return the name of the panel containing the specified control  An
    empty string is returned if the specified control is not in any panel
    :type containing: string
    :param invisiblePanels: (C) Return the names of all the invisible panels in a string array
    :type invisiblePanels: boolean
    :param scriptType: (C) Return the names of all scripted panels of the specified type in a
    string array
    :type scriptType: string
    :param type: (C) Return the names of all panels of the specified type in a string array
    :type type: string
    :param typeOf: (C) Return the type of the specified panel
    :type typeOf: string
    :param underPointer: (C) Return the name of the panel that the pointer is currently over 
    An empty string is returned if the pointer is not over any panel
    :type underPointer: boolean
    :param visiblePanels: (C) Return the names of all the visible panels in a string array
    :type visiblePanels: boolean
    :param withFocus: (C) Return the name of the panel that currently has focus  If no panel
    has focus then the last panel that had focus is returned
    :type withFocus: boolean
    :param withLabel: (C) Return the name of the panel with the specified label text
    :type withLabel: string
    
    :returns: An array of panel names
    :rtype: string[]
    """
    pass


def polyBridgeEdge(*args, bridgeOffset=0, caching=True, constructionHistory=True, curveType=0,
                   divisions=1, inputCurve=None, name="", nodeState=0, smoothingAngle=0.0,
                   startVert1=1, startVert2=1, taper=1.0, taperCurve_FloatValue=0.0,
                   taperCurve_Interp=0, taperCurve_Position=0.0, twist=0.0, worldSpace=True,
                   q=True, query=True, e=True, edit=True, **kwargs):
    """
    Bridges two sets of edges
    
    :param bridgeOffset: (C Q E) Add offset to which vertices are connected  Default: 0
    :type bridgeOffset: int
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param curveType: (C Q E) Format: 0 - Linear, 1 - Blend, 2 - Curve Default:
    TdnpolyBridgeEdge::Linear
    :type curveType: int
    :param divisions: (C Q E) The number of subdivisions in the bridging faces (resulting in
    (divisions+1) row of faces)  Default: 1
    :type divisions: int
    :param inputCurve: (C) This flag specifies the name of the curve to be used as input for
    the operation
    :type inputCurve: name
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param smoothingAngle: (C Q E) Angle below which new edges will be smoothed Default:
    kPi/6.0
    :type smoothingAngle: float
    :param startVert1: (C Q E) The start vertex from the first set of edges Default: -1
    :type startVert1: int
    :param startVert2: (C Q E) The start vertex from the second set of edges Default: -1
    :type startVert2: int
    :param taper: (C Q E) Taper or Scale along the extrusion path Default: 1.0
    :type taper: float
    :param taperCurve_FloatValue: (C Q E) Value for taperCurve; Curve control for taper along
    extrusion Using this curve, the taper along extrusion can be changed from a simple linear
    scaling
    :type taperCurve_FloatValue: float
    :param taperCurve_Interp: (C Q E) Interpolation type for taperCurve; Curve control for
    taper along extrusion Using this curve, the taper along extrusion can be changed from a
    simple l
    :type taperCurve_Interp: int
    :param taperCurve_Position: (C Q E) Position for taperCurve; Curve control for taper along
    extrusion Using this curve, the taper along extrusion can be changed from a simple linear
    scal
    :type taperCurve_Position: float
    :param twist: (C Q E) Twist or Rotation along the extrusion path Default: 0.0
    :type twist: float
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def PolyExtrudeVerticesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UVGatherShells(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorToggleShowNamespace(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nClothDeleteCacheOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AssignBrushToHairSystem(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_cycleCustomCameras(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def view2dToolCtx(*args, alternateContext=True, boxzoom=True, dolly=True, exists=True,
                  history=True, image1="", image2="", image3="", name="", toolName="",
                  track=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This class creates a context for the View Tools "track", "dolly", and "box zoom" in the
    Hypergraph
    
    :param alternateContext: (C Q) Set the ALT+MMB and ALT+SHIFT+MMB to refer to this context
    :type alternateContext: boolean
    :param boxzoom: (C Q) Perform Box Zoom
    :type boxzoom: boolean
    :param dolly: (C Q) Dollies the view
    :type dolly: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param toolName: (C Q) Name of the specific tool to which this command refers
    :type toolName: string
    :param track: (C Q) Tracks the view
    :type track: boolean
    
    :returns: The context name
    :rtype: string
    """
    pass


def hasMetadata(*args, asList=True, ignoreDefault=True, memberName="", channelName="",
                channelType="", endIndex="", index="", indexType="", scene=True, startIndex="",
                streamName="", **kwargs):
    """
    This command is used to query for the presence of metadata elements on a node, components,
    or scene  The command works at all levels of metadata presence, from the existence of any
    metadata at all on a node or scene right down to the presence of metadata values set on a
    particular metadata Stream index  Filter Flags channelName - Only look for meta
    
    :param asList: (C) Use this flag when you want to return string values indicating where the
    metadata lives rather than boolean values  See the command description for m
    :type asList: boolean
    :param ignoreDefault: (C) Use this flag when you want to skip over any metadata that has
    only default values  i.e  the metadata may exist but it hasn't had a new value set yet
    :type ignoreDefault: boolean
    :param memberName: (C) Name of the Structure member being checked  The names of the members
    are set up in the Structure definition, either through the description passed in
    :type memberName: string
    :param channelName: (C Q) Filter the metadata selection to only recognize metadata
    belonging to the specified named Channel (e.g  "vertex")  This flag is ignored if the
    compon
    :type channelName: string
    :param channelType: (C Q) Obsolete - use the 'channelName' flag instead  In query mode,
    this flag can accept a value
    :type channelType: string
    :param endIndex: (C) The metadata is stored in a Stream, which is an indexed list  If you
    have mesh components selected then the metadata indices are implicit in the list
    :type endIndex: string
    :param index: (C Q M) In the typical case metadata is indexed using a simple integer value 
    Certain types of data may use other index types  e.g  a "vertexFace" component
    :type index: string
    :param indexType: (C Q) Name of the index type the new Channel should be using  If not
    specified this defaults to a simple integer index  Of the native types only a mesh "ve
    :type indexType: string
    :param scene: (C Q) Use this flag when you want to add metadata to the scene as a whole
    rather than to any individual nodes  If you use this flag and have nodes selected
    :type scene: boolean
    :param startIndex: (C) The metadata is stored in a Stream, which is an indexed list  If you
    have mesh components selected then the metadata indices are implicit in the list
    :type startIndex: string
    :param streamName: (C Q) Name of the metadata Stream  Depending on context it could be the
    name of a Stream to be created, or the name of the Stream to pass through the filte
    :type streamName: string
    
    :returns: List of indexes in the filtered list which contain metadata
    :rtype: string[]
    """
    pass


def scriptJob(*args, allChildren=True, attributeAdded=None, attributeChange=None,
              attributeDeleted=None, compressUndo=True, conditionChange=None,
              conditionFalse=None, conditionTrue=None, connectionChange=None,
              disregardIndex=True, event=None, exists=0, force=True, idleEvent=None, kill=0,
              killAll=True, killWithScene=True, listConditions=True, listEvents=True,
              listJobs=True, nodeDeleted=None, nodeNameChanged=None, optionVarChanged=None,
              parent="", permanent=True, protected=True, replacePrevious=True, runOnce=True,
              timeChange=None, uiDeleted=None, **kwargs):
    """
    This command creates a "script job", which is a MEL command or script  This job is attached
    to the named condition, event, or attribute  Each time the condition switches to the
    desired state (or the trigger is triggered, etc), the script is run   Script jobs are tied
    to the event loop in the interactive application  They are run during idle events 
    
    :param allChildren: (C) This flag can only be used in conjunction with the
    -ac/attributeChange flag  If it is specified, and the job is attached to a compound
    attribute, the
    :type allChildren: boolean
    :param attributeAdded: (C) Run the script when the named attribute is added  The string
    must identify both the dependency node and the particular attribute  If the dependency n
    :type attributeAdded: [string, script]
    :param attributeChange: (C) Run the script when the named attribute changes value  The
    string must identify both the dependency node and the particular attribute  If the depende
    :type attributeChange: [string, script]
    :param attributeDeleted: (C) Run the script when the named attribute is deleted  The string
    must identify both the dependency node and the particular attribute  If the dependency
    :type attributeDeleted: [string, script]
    :param compressUndo: (C) If this is set to true, and the scriptJob is undoable, then its
    action will be bundled with the last user action for undo purposes  For example; if t
    :type compressUndo: boolean
    :param conditionChange: (C) Run the script when the named condition changes state  The
    string must be the name of a pre-defined, or a user-defined boolean condition  To get a li
    :type conditionChange: [string, script]
    :param conditionFalse: (C) Run the script when the named condition becomes false  The
    string must be the name of a pre-defined, or a user-defined boolean condition  To get a li
    :type conditionFalse: [string, script]
    :param conditionTrue: (C) Run the script when the named condition becomes true  The string
    must be the name of a pre-defined, or a user-defined boolean condition  To get a lis
    :type conditionTrue: [string, script]
    :param connectionChange: (C) Run the script when the named attribute changes its
    connectivity  The string must identify both the dependency node and the particular
    attribute  If
    :type connectionChange: [string, script]
    :param disregardIndex: (C) This flag can only be used in conjunction with the
    -ac/attributeChange flag  If it is specified, and the job is attached to a multi (indexed)
    attribu
    :type disregardIndex: boolean
    :param event: (C) Run the script when the named event occurs  This string must be the name
    of a pre-defined maya event  To get a list of what events exist, use the -li
    :type event: [string, script]
    :param exists: (C) Returns true if a scriptJob with the specified "job number" exists, and
    false otherwise  The "job number" should be a value that was returned on crea
    :type exists: int
    :param force: (C) This flag can only be used with -kill, -killAll, or -replacePrevious  It
    enables the deletion of protected jobs
    :type force: boolean
    :param idleEvent: (C) Run the script every time maya is idle  WARNING, as long as an idle
    event is is registered, the application will keep calling it and will use up all
    :type idleEvent: script
    :param kill: (C M) Kills the job with the specified job number  Permanent jobs cannot be
    killed, however, and protected jobs can only be killed if the -force flag is us
    :type kill: int
    :param killAll: (C) Kills all jobs  Permanent jobs will not be deleted, and protected jobs
    will only be deleted if the -force flag is used
    :type killAll: boolean
    :param killWithScene: (C) Attaches the job to the current scene, and when the scene is
    emptied  The current scene is emptied by opening a new or existing scene
    :type killWithScene: boolean
    :param listConditions: (C) User Interface for Rendering
    :type listConditions: boolean
    :param listEvents: (C) This causes the command to return a string array containing the
    names of all existing events  Below is the descriptions for all the existing events:
    :type listEvents: boolean
    :param listJobs: (C) This causes the command to return a string array containing a
    description of all existing jobs, along with their job numbers  These numbers can be us
    :type listJobs: boolean
    :param nodeDeleted: (C) Run the script when the named node is deleted
    :type nodeDeleted: [string, script]
    :param nodeNameChanged: (C) Run the script when the name of the named node changes
    :type nodeNameChanged: [string, script]
    :param optionVarChanged: (C) Run the script when the named optionVar changes value  If the
    optioNVar is deleted, this job is killed (even if the deletion is undoable)
    :type optionVarChanged: [string, script]
    :param parent: (C) Attaches this job to a piece of maya UI  When the UI is destroyed, the
    job will be killed along with it
    :type parent: string
    :param permanent: (C) Makes the job un-killable  Permanent jobs exist for the life of the
    application, or for the life of their parent object  The -killWithScene flag does
    :type permanent: boolean
    :param protected: (C) Makes the job harder to kill  Protected jobs must be killed or
    replaced intentionally by using the -force flag  The -killWithScene flag does apply to
    :type protected: boolean
    :param replacePrevious: (C) This flag can only be used with the -parent flag  Before the
    new scriptJob is created, any existing scriptJobs that have the same parent are first de
    :type replacePrevious: boolean
    :param runOnce: (C) If this is set to true, the script will only be run a single time  If
    false (the default) the script will run every time the triggering condition/eve
    :type runOnce: boolean
    :param timeChange: (C) Run the script whenever the current time changes  The script will
    not be executed if the time is changed by clicking on the time slider, whereas scri
    :type timeChange: script
    :param uiDeleted: (C) Run the script when the named piece of UI is deleted
    :type uiDeleted: [string, script]
    
    :returns: The job number, which can be used to kill the job. The job
    number will be a value
    greater than or equal to zero
    :rtype: int
    """
    pass


def XgmSetDirectionBrushTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeDeleteAllLights(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideDeformingGeometry(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def checkBox(*args, align="", annotation="", backgroundColor=None, changeCommand=None,
             defineTemplate="", docTag="", dragCallback=None, dropCallback=None, editable=True,
             enable=True, enableBackground=True, enableKeyboardFocus=True, exists=True,
             fullPathName=True, height=0, highlightColor=None, isObscured=True, label="",
             manage=True, noBackground=True, numberOfPopupMenus=True, offCommand=None,
             onCommand=None, parent="", popupMenuArray=True, preventOverride=True,
             recomputeSize=True, statusBarMessage="", useTemplate="", value=True, visible=True,
             visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
             **kwargs):
    """
    This command creates a check box  A check box is a simple control containing a text label
    and a state of either on or off  Commands can be attached to any or all of the following
    events: when the check box is turned on, turned off, or simply when it's state is changed
    
    :param align: (C Q E) This flag is obsolete and should no longer be used  The check box
    label will always be left-aligned
    :type align: string
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C Q E) Command executed when the check box's state is changed  Note
    that this flag should not be used in conjunction with onCommand and offCommand  That is,
    :type changeCommand: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param editable: (C Q E) The edit state of the check box  By default, this flag is set to
    true and the check box value may be changed by clicking on it  If false then the che
    :type editable: boolean
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) The label text  The default label is the name of the control
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param offCommand: (C Q E) Command executed when the check box is turned off
    :type offCommand: script
    :param onCommand: (C Q E) Command executed when the check box is turned on
    :type onCommand: script
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param recomputeSize: (C Q E) If true then the control will recompute it's size to just fit
    the size of the label  If false then the control size will remain fixed as you change t
    :type recomputeSize: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param value: (C Q E) State of the check box
    :type value: boolean
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def FBXImportAxisConversionEnable(*args, **kwargs):
    """
    
    """
    pass


def blindDataType(*args, dataType="", longDataName="", longNames=True, query=True,
                  shortDataName="", shortNames=True, typeId=0, typeNames=True, **kwargs):
    """
    This command creates a blind data type, which is represented by a blindDataTemplate node in
    the DG  A blind data type can have one or more attributes  On the command line, the
    attributes should be ordered by type for best memory utilization, largest first: string,
    binary, double, float, int, and finally boolean  Once a blind data type is created, b
    
    :param dataType: (C M) Specifies the dataTypes that are part of BlindData node being
    created  Allowable strings are "int", "float", "double", "string", "boolean" and "binar
    :type dataType: string
    :param longDataName: (C M) Specifies the long names of the datas that are part of BlindData
    node being created  Must be used togeter with the -dt and -sdn flags to specify each
    :type longDataName: string
    :param longNames: (C) Specifies that for a query command the long attributes names be
    listed
    :type longNames: boolean
    :param query: (C) Specifies that this is a special query type command
    :type query: boolean
    :param shortDataName: (C M) Specifies the short names of the data that are part of
    BlindData node being created  Must be used togeter with the -dt and -ldn flags to specify
    each
    :type shortDataName: string
    :param shortNames: (C) Specifies that for a query command the short attribute names be
    listed
    :type shortNames: boolean
    :param typeId: (C) Specifies the typeId of the BlindData type being created
    :type typeId: int
    :param typeNames: (C) Specifies that for a query command the data types be listed
    :type typeNames: boolean
    
    :returns: Name of nodes created
    :rtype: string
    """
    pass


def FilletBlendToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SmoothingDisplayToggle(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleFBIKEffectorsTranslatePinState(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def artBaseCtx(*args, **kwargs):
    """
    
    """
    pass


def Quadrangulate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def psdTextureFile(*args, channelRGB=None, channels=None, imageFileName=None, psdFileName="",
                   snapShotImageName="", uvSnapPostionTop=True, xResolution=0, yResolution=0,
                   **kwargs):
    """
    Creates a Photoshop file with UVSnap shot image and the layer set names as the input
    
    :param channelRGB: (C M) (M) Layer set names, index, red, green and blue values are given
    as input  Using this flag, the layers created can be filled with specified colors  T
    :type channelRGB: [string, int, int, int, int]
    :param channels: (C M) (M) Layer set names and index are given as input  This is a multi
    use flag  A layer set with the given name will be created  The second argument is t
    :type channels: [string, int, boolean]
    :param imageFileName: (C M) Image file name, Layerset name and index  The image in the file
    will be transferred to layer set specified  The index specifies the placement order o
    :type imageFileName: [string, string, int]
    :param psdFileName: (C) PSD file name
    :type psdFileName: string
    :param snapShotImageName: (C) Image file name on the disk containing UV snapshot /
    reference image
    :type snapShotImageName: string
    :param uvSnapPostionTop: (C) Specifies the position of UV snapshot image layer in the PSD
    file  "True" positions this layer at the top and "False" positions the layer at the bott
    :type uvSnapPostionTop: boolean
    :param xResolution: (C) X - resolution of the image
    :type xResolution: int
    :param yResolution: (C) Y - resolution of the image
    :type yResolution: int
    
    :returns: 
    :rtype: None
    """
    pass


def paintPointsCmd(*args, **kwargs):
    """
    
    """
    pass


def ToggleHoleFaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmExportSplineDataInternal(*args, **kwargs):
    """
    
    """
    pass


def DeactivateGlobalScreenSlider(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def doBlur(*args, colorFile="", length=0.0, memCapSize=0.0, sharpness=0.0, smooth=0.0,
           smoothColor=True, vectorFile="", **kwargs):
    """
    The doBlur command will invoke the blur2d, which is a Maya stand-alone application to do
    2.5 motion blur given the color image and the motion vector file  For a given input
    colorFile name, e.g  "xxx.iff", the output blurred image will be "xxx_blur.iff" in the same
    directory as the input colorFile  There is currently no control over the name of the 
    
    :param colorFile: (C) Name of the input color image to be blurred
    :type colorFile: string
    :param length: (C) Scale applied on the motion vector  Ranges from 0 to infinity
    :type length: float
    :param memCapSize: (C) Size of the memory cap, in bytes
    :type memCapSize: float
    :param sharpness: (C) Determines the shape of the blur filter  The higher the value, the
    narrower the filter, the sharper the blur  The lower the value, the wider the filt
    :type sharpness: float
    :param smooth: (C) Filter size to smooth the blurred image  The higher the value, the more
    anti-aliased the alpha channel  Ranges from 1.0 to 5.0
    :type smooth: float
    :param smoothColor: (C) Whether to smooth the color or not
    :type smoothColor: boolean
    :param vectorFile: (C) Name of the input motion vector file
    :type vectorFile: string
    
    :returns: Command result
    :rtype: string
    """
    pass


def PlanarOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def blend(*args, **kwargs):
    """
    
    """
    pass


def GoToBindPose(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sbs_SetEngine(*args, **kwargs):
    """
    
    """
    pass


def TimeEditorClipRazor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def applyMetadata(*args, format="", scene=True, value="", **kwargs):
    """
    Define the values of a particular set of metadata on selected objects  This command is used
    in preservation of metadata through Maya file formats (.ma/.mb)  If any metadata already
    exists it will be kept and merged with the new metadata, overwriting duplicate entries 
    (i.e  if this command specifies data at index N and you already have a value at i
    
    :param format: (C) Name of the data association format type to use in the value flag
    parsing  Default value is "raw"
    :type format: string
    :param scene: (C) Use this flag when you want to apply metadata to the scene as a whole
    rather than to any individual nodes  If you use this flag and have nodes select
    :type scene: boolean
    :param value: (C) String containing all of the metadata to be assigned to the selected
    object
    :type value: string
    
    :returns: True if the application succeeded
    :rtype: Boolean
    """
    pass


def HypershadePickWalkDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideHairSystems(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PlayblastWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ViewAlongAxisY(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideKinematics(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowIKHandles(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowMeshRelaxToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PublishAttributes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def autoSave(*args, destination=0, destinationFolder=True, enable=True, folder="", interval=0.0,
             limitBackups=True, maxBackups=0, perform=True, prompt=True, q=True, query=True,
             **kwargs):
    """
    Provides an interface to the auto-save mechanism
    
    :param destination: (C Q) Sets the option for where auto-save files go  0 - auto-saves go
    into the workspace autosave folder 1 - auto-saves go into the named folder (set with
    :type destination: int
    :param destinationFolder: (Q) Queries the actual destination folder for auto-saves, based
    on the current setting of the -destination flag, workspace rules and environment variable
    :type destinationFolder: boolean
    :param enable: (C Q) Enables or disables auto-saves
    :type enable: boolean
    :param folder: (C Q) Sets the folder for auto-saves used if the destination option is 1
    :type folder: string
    :param interval: (C Q) Sets the interval between auto-saves (in seconds)  The default
    interval is 600 seconds (10 minutes)
    :type interval: float
    :param limitBackups: (C Q) Sets whether the number of auto-save files is limited
    :type limitBackups: boolean
    :param maxBackups: (C Q) Sets the maximum number of auto-save files, if limiting is in
    effect
    :type maxBackups: int
    :param perform: (C) Invokes the auto-save process
    :type perform: boolean
    :param prompt: (C Q) Sets whether the auto-save prompts the user before auto-saving
    :type prompt: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def ToggleToolMessage(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToolSettingsWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polySelectConstraint(*args, angle=0, anglePropagation=True, angleTolerance=0.0,
                         anglebound=None, border=True, borderPropagation=True, convexity=0,
                         crease=True, disable=True, dist=0, distaxis=None, distbound=None,
                         distpoint=None, edgeDistance=0, geometricarea=0,
                         geometricareabound=None, holes=0, length=0, lengthbound=None,
                         loopPropagation=True, max2dAngle=0.0, max3dAngle=0.0, mode=0,
                         nonmanifold=0, oppositeEdges=True, order=0, orderbound=None, orient=0,
                         orientaxis=None, orientbound=None, planarity=0, propagate=0, random=0,
                         randomratio=0.0, returnSelection=True, ringPropagation=True,
                         shell=True, size=0, smoothness=0, stateString=True, textured=0,
                         texturedarea=0, texturedareabound=None, textureshared=0, topology=0,
                         type=0, uvBorderSelection=True, uvConstraint=True,
                         uvEdgeLoopPropagation=True, uvEdgeRingPropagation=True,
                         uvFaceOrientation=0, uvShell=True, visibility=0, visibilityangle=0.0,
                         visibilitypoint=None, where=0, wholeSensitive=True, q=True, query=True,
                         **kwargs):
    """
    Changes the global polygonal selection constraints
    
    :param angle: (C Q) 0(off) 1(on)
    :type angle: int
    :param anglePropagation: (C Q) If true, selection will be extended to all connected
    components whose normal is close to any of the normals of the original selection (see
    angleToler
    :type anglePropagation: boolean
    :param angleTolerance: (C Q) When angle propagation is turned on, this controls what is the
    maximum difference of the normal vectors where the selection propagates
    :type angleTolerance: float
    :param anglebound: (C Q) min and max angles  The given value should be in the current units
    that Maya is using  See the examples for how to check the current unit  For vertic
    :type anglebound: [float, float]
    :param border: (C Q) Use "-uvConstraint true" to edit/query UV view constraint  If true,
    selection will be extended to all connected border components so that the whole "
    :type border: boolean
    :param borderPropagation: (C Q) If true, selection will be extended to all connected border
    components so that the whole "loop" is selected
    :type borderPropagation: boolean
    :param convexity: (C Q) 0(off) 1(concave) 2(convex)
    :type convexity: int
    :param crease: (C Q) If true, selection will be extended to all connected creased
    components
    :type crease: boolean
    :param disable: (C) Toggles off all constraints for all component types, but leaves the
    other constraint parameters  This flag may be used together with other ones toggl
    :type disable: boolean
    :param dist: (C Q) 0(off) 1(to point) 2(to axis) 3(to plane)
    :type dist: int
    :param distaxis: (C Q) axis  (Normal to the plane in case of distance to plane)
    :type distaxis: [float, float, float]
    :param distbound: (C Q) min and max distances
    :type distbound: [float, float]
    :param distpoint: (C Q) point  (Axis/plane origin in case of distance to axis/plane)
    :type distpoint: [float, float, float]
    :param edgeDistance: (C) Maximum distance (number of edges) to extend the edge selection
    for "Contiguous Edges" propagate mode  0 means to ignore the distance constraint
    :type edgeDistance: int
    :param geometricarea: (C Q) 0(off) 1(on)
    :type geometricarea: int
    :param geometricareabound: (C Q) min and max areas
    :type geometricareabound: [float, float]
    :param holes: (C Q) 0(off) 1(holed) 2(non holed)
    :type holes: int
    :param length: (C Q) 0(off) 1(on)
    :type length: int
    :param lengthbound: (C Q) min and max lengths
    :type lengthbound: [float, float]
    :param loopPropagation: (C Q) If true, edge selection will be extended to a loop
    :type loopPropagation: boolean
    :param max2dAngle: (C) Maximum angle between two consecutive edges in the 2d tangent plane
    for "Contiguous Edges" propagate mode
    :type max2dAngle: float
    :param max3dAngle: (C) Maximum angle between two consecutive edges in 3d space for
    "Contiguous Edges" propagate mode
    :type max3dAngle: float
    :param mode: (C Q) 0(Off) 1(Next) 2(Current and Next) 3(All and Next)  Off : no constraints
    are used at all  Next : constraints will be used to filter next selections
    :type mode: int
    :param nonmanifold: (C Q) 0(off) 1(on)
    :type nonmanifold: int
    :param oppositeEdges: (C) Use the opposite edges
    :type oppositeEdges: boolean
    :param order: (C Q) 0(off) 1(on)
    :type order: int
    :param orderbound: (C Q) min and max orders  number of owning edges
    :type orderbound: [int, int]
    :param orient: (C Q) 0(off) 1(orientation) 2(direction)
    :type orient: int
    :param orientaxis: (C Q) axis
    :type orientaxis: [float, float, float]
    :param orientbound: (C Q) min and max angles  The given value should be in the current
    units that Maya is using  See the examples for how to check the current unit
    :type orientbound: [float, float]
    :param planarity: (C Q) 0(off) 1(non planar) 2(planar)
    :type planarity: int
    :param propagate: (C Q) 0(Off) 1(More) 2(Less) 3(Border) 4(Contiguous Edges) 5(Grow Along
    Loop) 6(Shrink Along Loop)  More : will add current selection border to current sel
    :type propagate: int
    :param random: (C Q) 0(off) 1(on)
    :type random: int
    :param randomratio: (C Q) ratio [0,1]
    :type randomratio: float
    :param returnSelection: (C) If true, current selection will not be modified, instead the
    new selection will be returned as result
    :type returnSelection: boolean
    :param ringPropagation: (C Q) If true, edge selection will be extended to a ring
    :type ringPropagation: boolean
    :param shell: (C Q) If true, selection will be extended to all connected components so that
    the whole piece of object is selected
    :type shell: boolean
    :param size: (C Q) 0(off) 1(triangles) 2(quads) 3(nsided)
    :type size: int
    :param smoothness: (C Q) 0(off) 1(hard) 2(smooth)
    :type smoothness: int
    :param stateString: (Q) Query only flag  Returns the MEL command that would restore all the
    current settings
    :type stateString: boolean
    :param textured: (C Q) 0(off) 1(mapped) 2(unmapped)
    :type textured: int
    :param texturedarea: (C Q) 0(off) 1(Area specified is unsigned) 2(Area specified is
    signed)
    :type texturedarea: int
    :param texturedareabound: (C Q) min and max areas
    :type texturedareabound: [float, float]
    :param textureshared: (C Q) 0(off) 1(on)  This option will select any UVs on the currentMap
    which are shared by more than one vertex
    :type textureshared: int
    :param topology: (C Q) 0(off) 1(non triangulatable) 2(lamina) 3(non triangulatable and
    lamina)
    :type topology: int
    :param type: (C Q) 0x0000(none) 0x0001(vertex) 0x8000(edge) 0x0008(face) 0x0010(texture
    coordinates)
    :type type: int
    :param uvBorderSelection: (C Q) This flag only works on UV view If true, selection will be
    extended to all UV border components It also removes all components not on UV border from
    :type uvBorderSelection: boolean
    :param uvConstraint: (C) If true, applicable constraint flags will work on UV view  In
    query mode, this flag can accept a value
    :type uvConstraint: boolean
    :param uvEdgeLoopPropagation: (C Q) Use "-uvConstraint true" to edit/query UV view
    constraint  If true, UV edge selection will be extended to a loop
    :type uvEdgeLoopPropagation: boolean
    :param uvEdgeRingPropagation: (C Q) This flag only works on UV view If true, UV edge
    selection will be extended to a ring
    :type uvEdgeRingPropagation: boolean
    :param uvFaceOrientation: (C Q) This flag only works on UV view 0(Off) 1(Front Face) 2(Back
    Face)
    :type uvFaceOrientation: int
    :param uvShell: (C Q) If true, selection will be extended to all connected components in UV
    space
    :type uvShell: boolean
    :param visibility: (C Q) 0(off) 1(on)
    :type visibility: int
    :param visibilityangle: (C Q) angle [0,360]
    :type visibilityangle: float
    :param visibilitypoint: (C Q) point
    :type visibilitypoint: [float, float, float]
    :param where: (C Q) 0(off) 1(on border) 2(inside)
    :type where: int
    :param wholeSensitive: (C Q) Tells how to select faces : either by picking anywhere inside
    the face (if true) or by picking on the face center marker (if false)
    :type wholeSensitive: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def CreateSubdivCylinder(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorCreateClip(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SubdCutUVs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def createNurbsSphereCtx(*args, **kwargs):
    """
    
    """
    pass


def RemoveBifrostEmitter(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideStrokes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BakeCustomPivot(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TextureCentricUVLinkingEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyCone(*args, axis=None, caching=True, constructionHistory=True, createUVs=2, height=2.0,
             name="", nodeState=0, object=True, radius=1.0, roundCap=False, subdivisionsAxis=20,
             subdivisionsCap=0, subdivisionsHeight=1, subdivisionsX=20, subdivisionsY=1,
             subdivisionsZ=0, texture=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The cone command creates a new polygonal cone
    
    :param axis: (C Q E) This flag specifies the primitive axis used to build the cone  Q: When
    queried, this flag returns a float[3]
    :type axis: [float, float, float]
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param createUVs: (C Q E) Create UVs or not  0: No UVs 1: No Normalization 2: Normalize 3:
    Normalize and Preserve Aspect Ratio Default: 2
    :type createUVs: int
    :param height: (C Q E) Height of the cone  Default: 2.0
    :type height: float
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param object: (C) Create the result, or just the dependency node (where applicable)
    :type object: boolean
    :param radius: (C Q E) Radius of the cone  Default: 1.0
    :type radius: float
    :param roundCap: (C Q E) To indicate whether we need a round cap Default: false
    :type roundCap: boolean
    :param subdivisionsAxis: (C Q E) Subdivisions around the axis  Default: 20
    :type subdivisionsAxis: int
    :param subdivisionsCap: (C Q E) Subdivisions on the bottom cap  Default: 0
    :type subdivisionsCap: int
    :param subdivisionsHeight: (C Q E) Subdivisions along the height  Default: 1
    :type subdivisionsHeight: int
    :param subdivisionsX: (C Q E) This specifies the number of subdivisions in the X direction
    for the cone  C: Default is 20  Q: When queried, this flag returns an int
    :type subdivisionsX: int
    :param subdivisionsY: (C Q E) This flag specifies the number of subdivisions in the Y
    direction for the cone  C: Default is 1  Q: When queried, this flag returns an int
    :type subdivisionsY: int
    :param subdivisionsZ: (C Q E) This flag specifies the number of subdivisions in the Z
    direction for the cone  C: Default is 0  Q: When queried, this flag returns an int
    :type subdivisionsZ: int
    :param texture: (C Q E) Apply texture or not  Default: true
    :type texture: boolean
    
    :returns: Object name and node name.
    :rtype: string[]
    """
    pass


def HypershadeHideAttributes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShortPolygonNormals(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXImportGenerateLog(*args, **kwargs):
    """
    
    """
    pass


def CreateDiskCacheOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PasteKeysOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ModelingPanelRedoViewChange(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def IKSplineHandleToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RenameCurrentColorSet(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleFkSkeletonVisibility(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TagAsController(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PruneCluster(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xform(*args, absolute=True, boundingBox=True, boundingBoxInvisible=True, centerPivots=True,
          centerPivotsOnComponents=True, deletePriorHistory=True, euler=True, matrix=None,
          objectSpace=True, pivots=None, preserve=True, preserveUV=False, reflection=True,
          reflectionAboutBBox=True, reflectionAboutOrigin=True, reflectionAboutX=True,
          reflectionAboutY=True, reflectionAboutZ=True, reflectionTolerance=0.0, relative=True,
          rotateAxis=None, rotateOrder="", rotatePivot=None, rotateTranslation=None,
          rotation=None, scale=None, scalePivot=None, scaleTranslation=None, shear=None,
          translation=None, worldSpace=True, worldSpaceDistance=True, zeroTransformPivots=True,
          q=True, query=True, **kwargs):
    """
    This command can be used query/set any element in a transformation node  It can also be
    used to query some values that cannot be set directly such as the transformation matrix or
    the bounding box  It can also set both pivot points to convenient values   All values are
    specified in transformation coordinates  (attribute-space)  In addition, the attr
    
    :param absolute: (C) perform absolute transformation (default)
    :type absolute: boolean
    :param boundingBox: (Q) Returns the bounding box of an object  The values returned are in
    the following order: xmin ymin zmin xmax ymax zmax
    :type boundingBox: boolean
    :param boundingBoxInvisible: (Q) Returns the bounding box of an object  This includes the
    bounding boxes of all invisible children which are not included using the boundingBox flag
    :type boundingBoxInvisible: boolean
    :param centerPivots: (C) Set pivot points to the center of the object's bounding box  (see
    -p flag)
    :type centerPivots: boolean
    :param centerPivotsOnComponents: (C) Set pivot points to the center of the component's
    bounding box  (see -p flag)
    :type centerPivotsOnComponents: boolean
    :param deletePriorHistory: (C) If true then delete the construction history before the
    operation is performed
    :type deletePriorHistory: boolean
    :param euler: (C) modifer for -relative flag that specifies rotation values should be added
    to current XYZ rotation values
    :type euler: boolean
    :param matrix: (C Q) Sets/returns the composite transformation matrix  *Note* the matrix is
    represented by 16 double arguments that are specified in row order
    :type matrix: [float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float]
    :param objectSpace: (C Q) treat values as object-space transformation values (only works
    for pivots, translations, rotation, rotation axis, matrix, and bounding box flags)
    :type objectSpace: boolean
    :param pivots: (C Q) convenience method that changes both the rotate and scale pivots
    simultaneously  (see -rp -sp flags for more info)
    :type pivots: [float, float, float]
    :param preserve: (C) preserve overall transformation  used to prevent object from "jumping"
    when changing pivots or rotation order  the default value is true  (used with
    :type preserve: boolean
    :param preserveUV: (C) When true, UV values on rotated components are projected across the
    rotation in 3d space  For small edits, this will freeze the world space texture m
    :type preserveUV: boolean
    :param reflection: (C) To move the corresponding symmetric components also
    :type reflection: boolean
    :param reflectionAboutBBox: (C) Sets the position of the reflection axis at the geometry
    bounding box
    :type reflectionAboutBBox: boolean
    :param reflectionAboutOrigin: (C) Sets the position of the reflection axis at the origin
    :type reflectionAboutOrigin: boolean
    :param reflectionAboutX: (C) Specifies the X=0 as reflection plane
    :type reflectionAboutX: boolean
    :param reflectionAboutY: (C) Specifies the Y=0 as reflection plane
    :type reflectionAboutY: boolean
    :param reflectionAboutZ: (C) Specifies the Z=0 as reflection plane
    :type reflectionAboutZ: boolean
    :param reflectionTolerance: (C) Specifies the tolerance to findout the corresponding
    reflected components
    :type reflectionTolerance: float
    :param relative: (C) perform relative transformation
    :type relative: boolean
    :param rotateAxis: (C Q) rotation axis orientation (when used with the -p flag the overall
    rotation is preserved by modifying the rotation to compensate for the axis rotation
    :type rotateAxis: [float, float, float]
    :param rotateOrder: (C Q) rotation order (when used with the -p flag the overall rotation
    is preserved by modifying the local rotation to be quivalent to the old one) Valid va
    :type rotateOrder: string
    :param rotatePivot: (C Q) rotate pivot point transformation (when used with the -p flag the
    overall transformation is preserved by modifying the rotation translation)
    :type rotatePivot: [float, float, float]
    :param rotateTranslation: (C Q) rotation translation
    :type rotateTranslation: [float, float, float]
    :param rotation: (C Q) rotation transformation
    :type rotation: [float, float, float]
    :param scale: (C Q) scale transformation
    :type scale: [float, float, float]
    :param scalePivot: (C Q) scale pivot point transformation (when used with the -p flag the
    overall transformation is preserved by modifying the scale translation)
    :type scalePivot: [float, float, float]
    :param scaleTranslation: (C Q) scale translation
    :type scaleTranslation: [float, float, float]
    :param shear: (C Q) shear transformation  The values represent the shear <xy,xz,yz>
    :type shear: [float, float, float]
    :param translation: (C Q) translation
    :type translation: [float, float, float]
    :param worldSpace: (C Q) (works for pivots, translations, rotation, rotation axis, matrix,
    and bounding box flags)  Note that, when querying the scale, that this calculation
    :type worldSpace: boolean
    :param worldSpaceDistance: (C Q) Values for -sp, -rp, -st, -rt, -t, -piv flags are treated
    as world space distances to move along the local axis  (where the local axis depends on
    whe
    :type worldSpaceDistance: boolean
    :param zeroTransformPivots: (C) reset pivot points and pivot translations without changing
    the overall matrix by applying these values into the translation channel
    :type zeroTransformPivots: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def dynParticleCtx(*args, conserve=0.0, cursorPlacement=True, exists=True, grid=True,
                   gridSpacing=0.0, history=True, image1="", image2="", image3="",
                   jitterRadius=0.0, lowerLeftX=0.0, lowerLeftY=0.0, lowerLeftZ=0.0, name="",
                   nucleus=True, numJitters=0, particleName="", sketch=True, sketchInterval=0,
                   textPlacement=True, upperRightX=0.0, upperRightY=0.0, upperZ=0.0, q=True,
                   query=True, e=True, edit=True, **kwargs):
    """
    The particle context command creates a particle context  The particle context provides an
    interactive means to create particle objects  The particle context command also provides an
    interactive means to set the option values, through the Tool Property Sheet, for the
    "particle" command that the context will issue
    
    :param conserve: (Q E) Conservation of momentum control (between 0 and 1)  For smaller
    values, the field will tend to erase any existing velocity the object has (in other w
    :type conserve: float
    :param cursorPlacement: (Q E) Use the cursor to place the lower left and upper right of the
    grid
    :type cursorPlacement: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param grid: (Q E) Create a particle grid
    :type grid: boolean
    :param gridSpacing: (Q E) Spacing between particles in the grid
    :type gridSpacing: float
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param jitterRadius: (Q E) Max radius from the center to place the particle instances
    :type jitterRadius: float
    :param lowerLeftX: (Q E) Lower left X position of the particle grid
    :type lowerLeftX: float
    :param lowerLeftY: (Q E) Lower left Y position of the particle grid
    :type lowerLeftY: float
    :param lowerLeftZ: (Q E) Lower left Z position of the particle grid
    :type lowerLeftZ: float
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param nucleus: (Q E) If set true then an nParticle is generated with a nucleus node
    connection  Otherwise a standard particle is created
    :type nucleus: boolean
    :param numJitters: (Q E) Number of jitters (instances) per particle
    :type numJitters: int
    :param particleName: (Q E) Particle name
    :type particleName: string
    :param sketch: (Q E) Create particles in sketch mode
    :type sketch: boolean
    :param sketchInterval: (Q E) Interval between particles, when in sketch mode
    :type sketchInterval: int
    :param textPlacement: (Q E) Use the textfields to specify the lower left and upper right
    of/ the grid
    :type textPlacement: boolean
    :param upperRightX: (Q E) Upper right X position of the particle grid
    :type upperRightX: float
    :param upperRightY: (Q E) Upper right Y position of the particle grid
    :type upperRightY: float
    :param upperZ: (Q E) Upper right Z position of the particle grid
    :type upperZ: float
    
    :returns: 
    :rtype: None
    """
    pass


def DeleteAllContainers(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CutKeysOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyMapSew(*args, caching=True, constructionHistory=True, name="", nodeState=0, q=True,
               query=True, e=True, edit=True, **kwargs):
    """
    Sew border edges in texture space  Selected edges must be map borders
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def SurfaceEditingTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ClearBifrostInitialState(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_symmetryTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polySpinEdge(*args, **kwargs):
    """
    
    """
    pass


def detachSurface(*args, caching=True, direction=1, keep=True, nodeState=0, parameter=0.0,
                  constructionHistory=True, name="", object=True, replaceOriginal=True, q=True,
                  query=True, e=True, edit=True, **kwargs):
    """
    The detachSurface command detaches a surface into pieces, given a list of parameter values
    and a direction  You can also specify which pieces to keep and which to discard using the
    "-k" flag  The names of the newly detached surface(s) are returned  If history is on, the
    name of the resulting dependency node is also returned   You can only detach in
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param direction: (C Q E) Direction in which to detach: 0 - V direction, 1 - U direction
    Default: 1
    :type direction: int
    :param keep: (C Q E M) Keep the detached pieces  Default: true
    :type keep: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param parameter: (C Q E M) Parameter at which to detach  Default: 0.0
    :type parameter: float
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def filletCurve(*args, bias=0.0, blendControl=False, caching=True, circular=True,
                curveParameter1=0.0, curveParameter2=0.0, depth=0.5, freeformBlend=False,
                nodeState=0, radius=1.0, constructionHistory=True, join=True, name="",
                object=True, replaceOriginal=True, trim=True, q=True, query=True, e=True,
                edit=True, **kwargs):
    """
    The curve fillet command creates a fillet curve between two curves  If no objects are
    specified in the command line, then the first two active curves are used  The fillet
    created can be circular (with a radius) or freeform (with a type of tangent or blend)
    
    :param bias: (C Q E) Adjusting the bias value causes the fillet curve to be skewed to one
    of the input curves  Available only if blendControl is true  Default: 0.0
    :type bias: float
    :param blendControl: (C Q E) If true then depth and bias can be controlled  Otherwise,
    depth and bias are not available options  Default: false
    :type blendControl: boolean
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param circular: (C Q E) Curve fillet will be created as circular if true or freeform if
    false  Default: true
    :type circular: boolean
    :param curveParameter1: (C Q E) Parameter where fillet curve will contact the primary input
    curve  Default: 0.0
    :type curveParameter1: float
    :param curveParameter2: (C Q E) Parameter where fillet curve will contact the secondary
    input curve  Default: 0.0
    :type curveParameter2: float
    :param depth: (C Q E) Adjusts the depth of the fillet curve  Available only if blendControl
    is true  Default: 0.5
    :type depth: float
    :param freeformBlend: (C Q E) The freeform type is blend if true or tangent if false 
    Available if the fillet type is freeform  Default: false
    :type freeformBlend: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param radius: (C Q E) The radius if creating a circular fillet  Default: 1.0
    :type radius: float
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param join: (C) Should the fillet be joined?
    :type join: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    :param trim: (C) Should the fillet be trimmed?
    :type trim: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def referenceQuery(*args, child=True, isExportEdits=True, isLoaded=True, liveEdits=True,
                   dagPath=True, editAttrs=True, editNodes=True, editStrings=True,
                   failedEdits=True, filename=True, isNodeReferenced=True, isPreviewOnly=True,
                   namespace=True, nodes=True, parent=True, parentNamespace=True,
                   referenceNode=True, shortName=True, showDagPath=True, showNamespace=True,
                   successfulEdits=True, topReference=True, unresolvedName=True,
                   withoutCopyNumber=True, editCommand="", onReferenceNode="", **kwargs):
    """
    Use this command to find out information about references and referenced nodes  A valid
    target is either a reference node, a reference file, or a referenced node  Some flags don't
    require a target, see flag descriptions for more information on what effect this has  When
    a scene contains multiple levels of file references, those edits which affect a
    
    :param child: (C) This flag modifies the '-rfn/-referenceNode' and '-f/-filename' flags to
    indicate the the children of the target reference will be returned  Returns
    :type child: boolean
    :param isExportEdits: (C) Returns a boolean indicating whether the specified reference node
    or file name is an edits file (created with the Export Edits feature)
    :type isExportEdits: boolean
    :param isLoaded: (C) Returns a boolean indicating whether the specified reference node or
    file name refers to a loaded or unloaded reference
    :type isLoaded: boolean
    :param liveEdits: (C) Specifies that the edits should be returned based on the live edits
    database  Only valid when used in conjunction with the editStrings flag
    :type liveEdits: boolean
    :param dagPath: (C) This flag modifies the '-n/-nodes' flag to indicate that the names of
    any dag objects returned will include as much of the dag path as is necessary t
    :type dagPath: boolean
    :param editAttrs: (C) Returns string array  A main flag used to query the edits that have
    been applied to the target  Only the names of the attributes involved in the refe
    :type editAttrs: boolean
    :param editNodes: (C) Returns string array  A main flag used to query the edits that have
    been applied to the target  Only the names of the nodes involved in the reference
    :type editNodes: boolean
    :param editStrings: (C) Returns string array  A main flag used to query the edits that have
    been applied to the target  The edit will be returned as a valid MEL command  A v
    :type editStrings: boolean
    :param failedEdits: (C) This is a secondary flag used to indicate whether or not failed
    edits should be acted on (e.g  queried, removed, etc...)  A failed edit is an edit wh
    :type failedEdits: boolean
    :param filename: (C) Returns string  A main flag used to query the filename associated with
    the target reference
    :type filename: boolean
    :param isNodeReferenced: (C) Returns boolean  A main flag used to determine whether or not
    the target node comes from a referenced file  true if the target node comes from a refe
    :type isNodeReferenced: boolean
    :param isPreviewOnly: (C) Returns boolean  This flag is used to determine whether or not
    the target reference node is only a preview reference node
    :type isPreviewOnly: boolean
    :param namespace: (C) Returns string  This flag returns the full namespace path of the
    target reference, starting from the root namespace ":"  It can be combined with the
    :type namespace: boolean
    :param nodes: (C) Returns string array  A main flag used to query the contents of the
    target reference
    :type nodes: boolean
    :param parent: (C) This flag modifies the '-rfn/-referenceNode' and '-f/-filename' flags to
    indicate the the parent of the target reference will be returned
    :type parent: boolean
    :param parentNamespace: (C) A main flag used to query and return the parent namespace of
    the target reference
    :type parentNamespace: boolean
    :param referenceNode: (C) Returns string  A main flag used to query the reference node
    associated with the target reference
    :type referenceNode: boolean
    :param shortName: (C) This flag modifies the '-f/-filename' and '-ns/-namespace' flags 
    Used with the '-f/-filename' flag indicates that the file name returned will be the
    :type shortName: boolean
    :param showDagPath: (C) Shows/hides the full dag path for edits  If false only displays the
    node-name of reference edits  Must be used with the -editNodes, -editStrings or -
    :type showDagPath: boolean
    :param showNamespace: (C) Shows/hides the namespaces on nodes in the reference edits  Must
    be used with the -editNodes, -editStrings or -editAttrs flag
    :type showNamespace: boolean
    :param successfulEdits: (C) This is a secondary flag used to indicate whether or not
    successful edits should be acted on (e.g  queried, removed, etc...)  A successful edit is
    an
    :type successfulEdits: boolean
    :param topReference: (C) This flag modifies the '-rfn/-referenceNode' flag to indicate the
    top level ancestral reference of the target reference will be returned
    :type topReference: boolean
    :param unresolvedName: (C) This flag modifies the '-f/-filename' flag to indicate that the
    file name returned will be unresolved (i.e  it will be the path originally specified
    :type unresolvedName: boolean
    :param withoutCopyNumber: (C) This flag modifies the '-f/-filename' flag to indicate that
    the file name returned will not have a copy number (e.g  '{1}') appended to the end  If t
    :type withoutCopyNumber: boolean
    :param editCommand: (C Q M) This is a secondary flag used to indicate which type of
    reference edits should be considered by the command  If this flag is not specified all edit
    t
    :type editCommand: string
    :param onReferenceNode: (C Q M) This is a secondary flag used to indicate that only those
    edits which are stored on the indicated reference node should be considered  This flag
    only
    :type onReferenceNode: string
    
    :returns: For query execution.
    :rtype: string[]
    """
    pass


def autoPlace(*args, useMouse=True, **kwargs):
    """
    This command takes a point in the centre of the current modeling pane and projects it onto
    the live surface  This produces a point in 3 space which is returned  If the um/useMouse
    flag is set the current mouse position is used rather than the centre of the modeling pane
    
    :param useMouse: (C) Use the current mouse position rather than the centre of the active
    view
    :type useMouse: boolean
    
    :returns: Placement location in 3D space
    :rtype: float[]
    """
    pass


def Triangulate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteHairCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def truncateFluidCache(*args, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command sets the end time of a fluid cache to the current time  If the current time is
    less than the end time of the cache, the cache is truncated so that only the portion of the
    cache up to and including the current time is preserved
    
    
    :returns: 
    :rtype: None
    """
    pass


def adskAssetList(*args, **kwargs):
    """
    
    """
    pass


def UpdateBindingSetOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nClothMergeCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectUVBorderComponents(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeToggleNodeTitleMode(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideSmoothSkinInfluences(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sbs_GetEngine(*args, **kwargs):
    """
    
    """
    pass


def Help(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def listAnimatable(*args, active=True, manip=True, manipHandle=True, shape=True, type=True,
                   **kwargs):
    """
    This command list the animatable attributes of a node  Command flags allow filtering by the
    current manipulator, or node type
    
    :param active: (C) This flag is obsolete and no longer supported
    :type active: boolean
    :param manip: (C) Return only those attributes affected by the current manip  If there is
    no manip active and any other flags are specified, output is the same as if t
    :type manip: boolean
    :param manipHandle: (C) Return only those attributes affected by the current manip handle 
    If there is no manip handle active and any other flags are specified, output is th
    :type manipHandle: boolean
    :param shape: (C) This flag is obsolete and no longer supported
    :type shape: boolean
    :param type: (C) Instead of returning attributes, Return the types of nodes that are
    currently animatable
    :type type: boolean
    
    :returns: All animatable attributes found
    :rtype: string[]
    """
    pass


def ConnectComponents(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def blendTwoAttr(*args, attribute="", attribute0=None, attribute1=None, blender=None,
                 controlPoints=False, driver=0, name="", shape=True, time=None, q=True,
                 query=True, e=True, edit=True, **kwargs):
    """
    A blendTwoAttr nodes takes two inputs, and blends the values of the inputs from one to the
    other, into an output value  The blending of the two inputs uses a blending function, and
    the following formula:
    
    :param attribute: (C M) A list of attributes for the selected nodes for which a
    blendTwoAttr node will be created  In query mode, this flag needs a value
    :type attribute: string
    :param attribute0: (C Q E) The attribute that should be connected to the first input of the
    new blendTwoAttr node  When queried, it returns a string
    :type attribute0: name
    :param attribute1: (C Q E) The attribute that should be connected to the second input of
    the new blendTwoAttr node  When queried, it returns a string
    :type attribute1: name
    :param blender: (C Q E) The blender attribute  This is the attribute that will be connected
    to the newly created blendTwoAttr node(s) blender attribute  This attribute contr
    :type blender: name
    :param controlPoints: (C) Explicitly specify whether or not to include the control points
    of a shape (see "-s" flag) in the list of attributes  Default: false
    :type controlPoints: boolean
    :param driver: (C Q E) The index of the driver attribute for this blend node (0 or 1) When
    queried, it returns an integer
    :type driver: int
    :param name: (C Q) name for the new blend node(s)
    :type name: string
    :param shape: (C) Consider all attributes of shapes below transforms as well, except
    "controlPoints"  Default: true
    :type shape: boolean
    :param time: (C) The time range between which the blending between the 2 attributes should
    occur  If a single time is specified, then the blend will cause an abrupt c
    :type time: timerange
    
    :returns: The names of the blendTwoAttr dependency nodes that were created.
    :rtype: string[]
    """
    pass


def gpuCache(*args, **kwargs):
    """
    
    """
    pass


def CreateHairCacheOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyCreateFacetCtx(*args, append=True, exists=True, image1="", image2="", image3="",
                       maximumNumberOfPoints=0, planarConstraint=True, subdivision=1, texture=0,
                       q=True, query=True, e=True, edit=True, **kwargs):
    """
    Create a new context to create polygonal objects
    
    :param append: (C Q E) Allows to switch to polyAppendFacetCtx tool
    :type append: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param maximumNumberOfPoints: (C Q E) Allows the ability to set a upper bound on the number
    of points in interactively place before polygon is created  A value less than 2 will mean
    that
    :type maximumNumberOfPoints: int
    :param planarConstraint: (C Q E) allows/avoid new facet to be non-planar  If on, all new
    points will be projected onto current facet plane
    :type planarConstraint: boolean
    :param subdivision: (C Q E) Number of subdivisions for each edge  Default: 1
    :type subdivision: int
    :param texture: (C Q E) What texture mechanism to be applied 0=No textures, 1=Normalized,
    Undistorted textures 2=Unitized textures Default: 0
    :type texture: int
    
    :returns: 
    :rtype: None
    """
    pass


def getAttr(*args, asString=True, caching=True, channelBox=True,
            expandEnvironmentVariables=True, keyable=True, lock=True, multiIndices=True,
            settable=True, silent=True, size=True, time=None, type=True, **kwargs):
    """
    This command returns the value of the named object's attribute  UI units are used where
    applicable  Currently, the types of attributes that can be displayed are:   numeric
    attributes string attributes matrix attributes numeric compound attributes (whose children
    are all numeric) vector array attributes double array attributes int32 array attributes
    
    :param asString: (C) This flag is only valid for enum attributes  It allows you to get the
    attribute values as strings instead of integer values  Note that the returned s
    :type asString: boolean
    :param caching: (C) Returns whether the attribute is set to be cached internally
    :type caching: boolean
    :param channelBox: (C) Returns whether the attribute is set to show in the channelBox 
    Keyable attributes also show in the channel box
    :type channelBox: boolean
    :param expandEnvironmentVariables: (C) Expand any environment variable and (tilde
    characters on UNIX) found in string attributes which are returned
    :type expandEnvironmentVariables: boolean
    :param keyable: (C) Returns the keyable state of the attribute
    :type keyable: boolean
    :param lock: (C) Returns the lock state of the attribute
    :type lock: boolean
    :param multiIndices: (C) If the attribute is a multi, this will return a list containing
    all of the valid indices for the attribute
    :type multiIndices: boolean
    :param settable: (C) Returns 1 if this attribute is currently settable by setAttr, 0
    otherwise  An attribute is settable if it's not locked and either not connected, or h
    :type settable: boolean
    :param silent: (C) When evaluating an attribute that is not a numeric or string value,
    suppress the error message saying that the data cannot be displayed  The attribut
    :type silent: boolean
    :param size: (C) Returns the size of a multi-attribute array  Returns 1 if non-multi
    :type size: boolean
    :param time: (C) Evaluate the attribute at the given time instead of the current time
    :type time: time
    :param type: (C) Returns the type of data currently in the attribute  Attributes of simple
    types such as strings and numerics always contain data, but attributes of c
    :type type: boolean
    
    :returns: Value or state of the attribute. The number and type
    of values returned is
    dependent on the attribute type.
    :rtype: Any
    """
    pass


def PolySpinEdgeForward(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def LevelOfDetailUngroup(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleLatticeShape(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BakeSimulation(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GlobalDiskCacheControl(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def IKHandleToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def unknownPlugin(*args, dataTypes=True, list=True, nodeTypes=True, remove=True, version=True,
                  q=True, query=True, **kwargs):
    """
    Allows querying of the unknown plug-ins used by the scene, and provides a means to remove
    them
    
    :param dataTypes: (Q) Returns the data types associated with the given unknown plug-in 
    This will always be empty for pre-Maya 2014 files
    :type dataTypes: boolean
    :param list: (Q) Lists the unknown plug-ins in the scene
    :type list: boolean
    :param nodeTypes: (Q) Returns the node types associated with the given unknown plug-in 
    This will always be empty for pre-Maya 2014 files
    :type nodeTypes: boolean
    :param remove: (C) Removes the given unknown plug-in from the scene  For Maya 2014 files
    and onwards, this will fail if node or data types defined by the plug-in are st
    :type remove: boolean
    :param version: (Q) Returns the version string of the given unknown plug-in
    :type version: boolean
    
    :returns: in query mode
    :rtype: string[]
    """
    pass


def ShowGeometry(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def InsertKeysToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def arnoldAIR(*args, **kwargs):
    """
    
    """
    pass


def MoveUp(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def optionMenu(*args, alwaysCallChangeCommand=True, annotation="", backgroundColor=None,
               beforeShowPopup=None, changeCommand=None, defineTemplate="", docTag="",
               dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
               enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
               highlightColor=None, isObscured=True, itemListLong=True, itemListShort=True,
               label="", manage=True, maxVisibleItems=0, noBackground=True, numberOfItems=True,
               numberOfPopupMenus=True, parent="", popupMenuArray=True, preventOverride=True,
               select=0, statusBarMessage="", useTemplate="", value="", visible=True,
               visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
               **kwargs):
    """
    This command creates a popup menu control  The command creates the control and provides its
    menu  Subsequent calls to the menuItem command will place them in the popup  Note that
    commands attached to menu items will not get called  Attach any commands via the
    -cc/changedCommand flag
    
    :param alwaysCallChangeCommand: (C Q) Toggle whether to always call the change command,
    regardless of the change
    :type alwaysCallChangeCommand: boolean
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param beforeShowPopup: (C E) Callback that is called just before we show the drop down
    menu
    :type beforeShowPopup: script
    :param changeCommand: (C E) Adds a callback that is called when a new item is selected  The
    MEL script will have the newly selected item's value substituted for #1  For Python,
    :type changeCommand: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param itemListLong: (Q) The long names of the menu items
    :type itemListLong: boolean
    :param itemListShort: (Q) The short names of the menu items
    :type itemListShort: boolean
    :param label: (C Q E) The optional label text to the left of the popup menu
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param maxVisibleItems: (C Q E) The maximum number of items that are visible in the popup
    menu  If the popup contains more items than this, a scrollbar is added automatically
    :type maxVisibleItems: int
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfItems: (Q) The number of menu items
    :type numberOfItems: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param select: (C Q E) The current menu item  The argument and return value is 1-based 
    Note that the current menu item can only be set if it is enabled
    :type select: int
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param value: (C Q E) The text of the current menu item
    :type value: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def ConformPolygon(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyOptions(*args, activeObjects=True, allEdges=True, backCullVertex=True, backCulling=True,
                colorMaterialChannel="", colorShadedDisplay=True, displayAlphaAsGreyScale=True,
                displayBorder=True, displayCenter=True, displayCreaseEdge=True,
                displayCreaseVertex=True, displayGeometry=True, displayInvisibleFaces=True,
                displayItemNumbers=None, displayMapBorder=True, displayMetadata=None,
                displayNormal=True, displaySubdComps=True, displayTangent=True,
                displayTriangle=True, displayUVTopology=True, displayUVs=True,
                displayVertex=True, displayWarp=True, facet=True, fullBack=True, gl=True,
                hardBack=True, hardEdge=True, hardEdgeColor=True, materialBlend="",
                newPolymesh=True, point=True, pointFacet=True, relative=True,
                reuseTriangles=True, sizeBorder=0.0, sizeNormal=0.0, sizeUV=0.0, sizeVertex=0.0,
                smoothDrawType=0, softEdge=True, vertexNormalMethod=0, wireBackCulling=True,
                q=True, query=True, **kwargs):
    """
    Changes the global display polygonal attributes
    
    :param activeObjects: (C Q) Apply user choices for all active objects
    :type activeObjects: boolean
    :param allEdges: (C Q) Display all edges in solid line
    :type allEdges: boolean
    :param backCullVertex: (C Q) BackCull vertices
    :type backCullVertex: boolean
    :param backCulling: (C Q) Display with no back culling
    :type backCulling: boolean
    :param colorMaterialChannel: (C Q) If colorShadedDisplay is true, then determines which
    material channel to display color per vertex in  The options are: "none" : disable material
    shad
    :type colorMaterialChannel: string
    :param colorShadedDisplay: (C Q) Use color per vertex display in shaded mode
    :type colorShadedDisplay: boolean
    :param displayAlphaAsGreyScale: (C Q) Display alpha as grey scale
    :type displayAlphaAsGreyScale: boolean
    :param displayBorder: (C Q) Highlight border edge
    :type displayBorder: boolean
    :param displayCenter: (C Q) Display facet centers
    :type displayCenter: boolean
    :param displayCreaseEdge: (C Q) Highlight creased edges
    :type displayCreaseEdge: boolean
    :param displayCreaseVertex: (C Q) Highlight creased vertices
    :type displayCreaseVertex: boolean
    :param displayGeometry: (C Q) Display geometry
    :type displayGeometry: boolean
    :param displayInvisibleFaces: (C Q) Highlight invisible faces
    :type displayInvisibleFaces: boolean
    :param displayItemNumbers: (C Q) Displays item numbers (vertices edges facets uvs)
    :type displayItemNumbers: [boolean, boolean, boolean, boolean]
    :param displayMapBorder: (C Q) Highlight map border edge
    :type displayMapBorder: boolean
    :param displayMetadata: (C Q) Displays component metadata (vertices edges facets
    vertexFaces)
    :type displayMetadata: [boolean, boolean, boolean]
    :param displayNormal: (C Q) Display normals
    :type displayNormal: boolean
    :param displaySubdComps: (C Q) Display subdivided components when in Smooth Mesh Preview
    mode
    :type displaySubdComps: boolean
    :param displayTangent: (C Q) Display tangent
    :type displayTangent: boolean
    :param displayTriangle: (C Q) Display triangulation
    :type displayTriangle: boolean
    :param displayUVTopology: (C Q) Option on UV display to display UVs topologically
    :type displayUVTopology: boolean
    :param displayUVs: (C Q) Display UVs
    :type displayUVs: boolean
    :param displayVertex: (C Q) Display vertices
    :type displayVertex: boolean
    :param displayWarp: (C Q) Highlight warped facets
    :type displayWarp: boolean
    :param facet: (C Q) For use with -dn flag  Set the normal display style to facet display
    :type facet: boolean
    :param fullBack: (C Q) Display with full back culling
    :type fullBack: boolean
    :param gl: (C Q) Apply user choices for all objects
    :type gl: boolean
    :param hardBack: (C Q) Backculled hard edges only for backculled faces
    :type hardBack: boolean
    :param hardEdge: (C Q) Display only hard edges
    :type hardEdge: boolean
    :param hardEdgeColor: (C Q) Display hard edges as separate color
    :type hardEdgeColor: boolean
    :param materialBlend: (C Q) The options are: "overwrite" "add" "subtract" "multiply"
    "divide" "average" "modulate2x"
    :type materialBlend: string
    :param newPolymesh: (C Q) Set component display state of new polymesh objects
    :type newPolymesh: boolean
    :param point: (C Q) For use with -dn flag  Set the normal display style to vertex display
    :type point: boolean
    :param pointFacet: (C Q) For use with -dn flag  Set the normal display style to vertex and
    face display
    :type pointFacet: boolean
    :param relative: (C Q) When this flag is used with flags dealing with size, the value
    (size) is a multiplication factor : i.e for flags : -sizeNormal, -sizeBorder  When thi
    :type relative: boolean
    :param reuseTriangles: (C Q) Avoid regenerating triangles, by reusing the old triangles
    upstream in the construction history  The construction history is searched upstream and do
    :type reuseTriangles: boolean
    :param sizeBorder: (C Q) Set the size of the polygonal border edges
    :type sizeBorder: float
    :param sizeNormal: (C Q) Set the size of the polygonal normals
    :type sizeNormal: float
    :param sizeUV: (C Q) Set the size of the polygonal UV
    :type sizeUV: float
    :param sizeVertex: (C Q) Set the size of the polygonal vertex
    :type sizeVertex: float
    :param smoothDrawType: (C Q) This setting only works with the newPolymesh flag  Sets a new
    default attribute value for the smoothDrawType attribute on a polymesh object  Options
    :type smoothDrawType: int
    :param softEdge: (C Q) Display soft edges in dotted lines
    :type softEdge: boolean
    :param vertexNormalMethod: (C Q) This setting only works with the newPolymesh flag  Sets a
    new default attribute value for the vertexNormalMethod attribute on a polymesh object 
    Opti
    :type vertexNormalMethod: int
    :param wireBackCulling: (C Q) Backculled faces are in wireframe
    :type wireBackCulling: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def CreateCharacter(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TransformNoSelectOnTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MergeVertexToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Create2DContainer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PlaceFullBodyPivot(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HIKLiveConnectionTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def draggerContext(*args, anchorPoint=None, button=0, currentStep=0, cursor="",
                   dragCommand=None, dragPoint=None, drawString="", exists=True, finalize=None,
                   helpString="", history=True, holdCommand=None, image1="", image2="",
                   image3="", initialize=None, modifier="", name="", plane=None,
                   prePressCommand=None, pressCommand=None, projection="", releaseCommand=None,
                   snapping=True, space="", stepsCount=0, undoMode="", q=True, query=True,
                   e=True, edit=True, **kwargs):
    """
    The draggerContext allows the user to program the behavior of the mouse or an equivalent
    dragging device in MEL
    
    :param anchorPoint: (Q) Anchor point (double array) where dragger was initially pressed
    :type anchorPoint: [float, float, float]
    :param button: (Q) Returns the current mouse button (1,2,3)
    :type button: int
    :param currentStep: (Q) Current step (press-drag-release sequence) for dragger context 
    When queried before first press event happened, returns 0
    :type currentStep: int
    :param cursor: (C Q E) Cursor displayed while context is active  Valid values are:
    "default", "hand", "crossHair", "dolly", "track", and "tumble"
    :type cursor: string
    :param dragCommand: (C Q E) Command called when mouse dragger is dragged
    :type dragCommand: script
    :param dragPoint: (Q) Drag point (double array) current position of dragger during drag
    :type dragPoint: [float, float, float]
    :param drawString: (C E) A string to be drawn at the current position of the pointer
    :type drawString: string
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param finalize: (C Q E) Command called when the tool is exited
    :type finalize: script
    :param helpString: (Q) Help string for context
    :type helpString: string
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param holdCommand: (C Q E) Command called when mouse dragger is held
    :type holdCommand: script
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param initialize: (C Q E) Command called when the tool is entered
    :type initialize: script
    :param modifier: (Q) Returns the current modifier type: ctrl, alt or none
    :type modifier: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param plane: (C E) Provide normal of projection plane (see -projection flag for details)
    :type plane: [float, float, float]
    :param prePressCommand: (C Q E) Command called when mouse dragger is pressed  It is called
    before pressCommand, so it can be used for initialization of context
    :type prePressCommand: script
    :param pressCommand: (C Q E) Command called when mouse dragger is pressed
    :type pressCommand: script
    :param projection: (C Q E) project to closest point on object bounding box
    :type projection: string
    :param releaseCommand: (C Q E) Command called when mouse dragger is released
    :type releaseCommand: script
    :param snapping: (C Q E) Enable/disable snapping for dragger context
    :type snapping: boolean
    :param space: (C Q E) screen space
    :type space: string
    :param stepsCount: (C Q E) Number of steps (press-drag-release sequences) for dragger
    context  When combined with undoMode flag, several steps might be recorded as single undo
    :type stepsCount: int
    :param undoMode: (C Q E) Undo queue mode for the context actions  Acceptable values are:
    "all" default behaviour when every action that happens during dragger context activit
    :type undoMode: string
    
    :returns: The name of the context.
    :rtype: string
    """
    pass


def polyChipOff(*args, attraction=0.0, caching=True, constructionHistory=True, duplicate=True,
                gain=1.0, gravity=None, gravityX=0.0, gravityY=0.0, gravityZ=0.0,
                keepFacesTogether=True, keepFacetTogether=True, localCenter=0,
                localDirection=None, localDirectionX=0.0, localDirectionY=0.0,
                localDirectionZ=0.0, localRotate=None, localRotateX=0.0, localRotateY=0.0,
                localRotateZ=0.0, localScale=None, localScaleX=0.0, localScaleY=0.0,
                localScaleZ=0.0, localTranslate=None, localTranslateX=0.0, localTranslateY=0.0,
                localTranslateZ=0.0, magnX=0.0, magnY=0.0, magnZ=0.0, magnet=None, name="",
                nodeState=0, offset=0.0, pivot=None, pivotX=0.0, pivotY=0.0, pivotZ=0.0,
                random=0.0, scale=None, scaleX=0.0, scaleY=0.0, scaleZ=0.0, translate=None,
                translateX=0.0, translateY=0.0, translateZ=0.0, weight=0.0, worldSpace=True,
                q=True, query=True, e=True, edit=True, **kwargs):
    """
    Extract facets  Faces can be extracted separately or together, and manipulations can be
    performed either in world or object space
    
    :param attraction: (C Q E) Attraction, related to magnet  The range is [-2.0, 2.0] 
    Default: 0.0
    :type attraction: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param duplicate: (C Q E) If "on", facets are duplicated, otherwise original facets are
    removed  C: Default is "on"  Q: When queried, this flag returns an int
    :type duplicate: boolean
    :param gain: (C Q E M) Gain factor per component  Can be painted using Artisan  Default:
    1.0
    :type gain: float
    :param gravity: (C Q E) The gravity vector  Default: 0.0, -1.0, 0.0
    :type gravity: [float, float, float]
    :param gravityX: (C Q E) Gravity X coord
    :type gravityX: float
    :param gravityY: (C Q E) Gravity Y coord
    :type gravityY: float
    :param gravityZ: (C Q E) Gravity Z coord
    :type gravityZ: float
    :param keepFacesTogether: (C Q E) How to extrude edges  If "on", extruded faces produced
    from the edges being extruded will be kept together  Otherwise they are pulled
    independently
    :type keepFacesTogether: boolean
    :param keepFacetTogether: (C Q E) How to extrude edges  If "on", extruded faces produced
    from the edges being extruded will be kept together  Otherwise they are pulled
    independently
    :type keepFacetTogether: boolean
    :param localCenter: (C Q E) Local center on the edge : 0=Middle point, 1=Start point, 2=End
    point  Default: 0
    :type localCenter: int
    :param localDirection: (C Q E) Direction to determine X axis for local space  Default: 1.0,
    0.0, 0.0
    :type localDirection: [float, float, float]
    :param localDirectionX: (C Q E) X coord of the X axis
    :type localDirectionX: float
    :param localDirectionY: (C Q E) Y coord of the X axis
    :type localDirectionY: float
    :param localDirectionZ: (C Q E) Z coord of the X axis
    :type localDirectionZ: float
    :param localRotate: (C Q E) The local rotations  Default: 0.0, 0.0, 0.0
    :type localRotate: [float, float, float]
    :param localRotateX: (C Q E) Local rotate X coord  The range is [0, 360]
    :type localRotateX: float
    :param localRotateY: (C Q E) Local rotate Y coord  The range is [0, 360]
    :type localRotateY: float
    :param localRotateZ: (C Q E) Local rotate Z coord : Rotation along the normal  The range is
    [0, 360]
    :type localRotateZ: float
    :param localScale: (C Q E) Local Scale  Default: 1.0, 1.0, 1.0
    :type localScale: [float, float, float]
    :param localScaleX: (C Q E) Scale X coord
    :type localScaleX: float
    :param localScaleY: (C Q E) Scale Y coord
    :type localScaleY: float
    :param localScaleZ: (C Q E) Scale Z coord
    :type localScaleZ: float
    :param localTranslate: (C Q E) Local translate  Default: 0.0, 0.0, 0.0
    :type localTranslate: [float, float, float]
    :param localTranslateX: (C Q E) Local translation X coord
    :type localTranslateX: float
    :param localTranslateY: (C Q E) Local translation Y coord
    :type localTranslateY: float
    :param localTranslateZ: (C Q E) Local translation Z coord : Move along the normal
    :type localTranslateZ: float
    :param magnX: (C Q E) Magnet X coord
    :type magnX: float
    :param magnY: (C Q E) Magnet Y coord
    :type magnY: float
    :param magnZ: (C Q E) Magnet Z coord
    :type magnZ: float
    :param magnet: (C Q E) The magnet vector  Default: 0.0, 0.0, 0.0
    :type magnet: [float, float, float]
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param offset: (C Q E) Local offset  Faces are moved this distance towards the inside of
    the face  Default: 0.0
    :type offset: float
    :param pivot: (C Q E) The pivot for scaling and rotation  Default: 0.0, 0.0, 0.0
    :type pivot: [float, float, float]
    :param pivotX: (C Q E) Pivot X coord
    :type pivotX: float
    :param pivotY: (C Q E) Pivot Y coord
    :type pivotY: float
    :param pivotZ: (C Q E) Pivot Z coord
    :type pivotZ: float
    :param random: (C Q E) Random value for all parameters  Default: 0.0
    :type random: float
    :param scale: (C Q E) Scaling vector  Default: 1.0, 1.0, 1.0
    :type scale: [float, float, float]
    :param scaleX: (C Q E) Scale X coord
    :type scaleX: float
    :param scaleY: (C Q E) Scale Y coord
    :type scaleY: float
    :param scaleZ: (C Q E) Scale Z coord
    :type scaleZ: float
    :param translate: (C Q E) Translation vector  Default: 0.0, 0.0, 0.0
    :type translate: [float, float, float]
    :param translateX: (C Q E) Translation X coord
    :type translateX: float
    :param translateY: (C Q E) Translation Y coord
    :type translateY: float
    :param translateZ: (C Q E) Translation Z coord
    :type translateZ: float
    :param weight: (C Q E) The weight, related to gravity  Default: 0.0
    :type weight: float
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def DisplayShadedAndTextured(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def keyframeRegionDirectKeyCtx(*args, exists=True, history=True, image1="", image2="",
                               image3="", name="", option="", q=True, query=True, e=True,
                               edit=True, **kwargs):
    """
    This command creates a context which may be used to directly manipulate keyframes within
    the dope sheet editor
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param option: (C) Valid values are "move," "insert," "over," and "segmentOver." When you
    "move" a key, the key will not cross over (in time) any keys before or after i
    :type option: string
    
    :returns: Context name
    :rtype: string
    """
    pass


def ConvertSelectionToVertexPerimeter(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polySubdivideEdge(*args, caching=True, constructionHistory=True, divisions=1, name="",
                      nodeState=0, size=0.0, worldSpace=True, q=True, query=True, e=True,
                      edit=True, **kwargs):
    """
    Subdivides an edge into two or more subedges   Default : divide edge into two edges of
    equal length
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param divisions: (C Q E) The maximum number of vertices to be inserted in each edge  This
    number may be reduced if it creates edges shorter than the specified minimum length
    :type divisions: int
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param size: (C Q E) The minimum length of each subedge created  If the given subdivision
    creates edges that are shorter than this length, the number of divisions is chan
    :type size: float
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def InTangentFixed(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def mouldMesh(*args, **kwargs):
    """
    
    """
    pass


def createLayeredPsdFile(*args, imageFileName=None, psdFileName="", xResolution=0,
                         yResolution=0, **kwargs):
    """
    Creates a layered PSD file with image names as input to individual layers
    
    :param imageFileName: (C M) Layer name, blend mode, Image file name The image in the file
    will be transferred to layer specified  The image file specified can be in any of the f
    :type imageFileName: [string, string, string]
    :param psdFileName: (C) PSD file name
    :type psdFileName: string
    :param xResolution: (C) X - resolution of the image
    :type xResolution: int
    :param yResolution: (C) Y - resolution of the image
    :type yResolution: int
    
    :returns: 
    :rtype: None
    """
    pass


def xgmNoiseBrushToolCmd(*args, **kwargs):
    """
    
    """
    pass


def hitTest(*args, **kwargs):
    """
    The hitTest command hit-tests a point in the named control and returns a list of items
    underneath the point  The point is specified in pixels with the origin (0,0) at the
    top-left corner  This position is compatible with the coordinates provided by a
    drop-callback  The types of items that may be returned depends upon the specific control;
    not all c
    
    
    :returns: items underneath the hit-point
    :rtype: string[]
    """
    pass


def intScrollBar(*args, annotation="", backgroundColor=None, changeCommand=None,
                 defineTemplate="", docTag="", dragCallback=None, dragCommand=None,
                 dropCallback=None, enable=True, enableBackground=True,
                 enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
                 highlightColor=None, horizontal=True, isObscured=True, largeStep=0,
                 manage=True, maxValue=0, minValue=0, noBackground=True,
                 numberOfPopupMenus=True, parent="", popupMenuArray=True, preventOverride=True,
                 statusBarMessage="", step=0, useTemplate="", value=0, visible=True,
                 visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
                 **kwargs):
    """
    Create a scroll bar control that accepts only integer values and is bound by a minimum and
    maximum value  The scroll bar displays a marker indicating the current value of the scroll
    bar relative to its minimum and maximum values  Click and drag the marker or on the scroll
    bar itself to change the current value
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Command executed when the value changes  This command is not
    invoked when the value changes via the -v/value flag
    :type changeCommand: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dragCommand: (C E) Command executed when the value changes by dragging the scroll
    bar's value marker
    :type dragCommand: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param horizontal: (C Q) Orientation of the scroll bar  This flag is true by default, which
    corresponds to a horizontally oriented scroll bar
    :type horizontal: boolean
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param largeStep: (C Q E) Larger increment for the scroll bar, ie  the increment used when
    the press is between the arrow button and the thumb
    :type largeStep: int
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param maxValue: (C Q E) Upper limit of the scroll bar
    :type maxValue: int
    :param minValue: (C Q E) Lower limit of the scroll bar
    :type minValue: int
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param step: (C Q E) Smaller increment for the scroll bar, ie  the increment used when the
    arrow buttons are pressed
    :type step: int
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param value: (C Q E) Value of the scroll bar
    :type value: int
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def setDynStartState(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def workspacePanel(*args, defineTemplate="", exists=True, mainWindow=True, useTemplate="",
                   q=True, query=True, e=True, edit=True, **kwargs):
    """
    Workspace panel
    
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param mainWindow: (C Q E) Main window for the application  The main window has an 'Exit'
    item in the Window Manager menu  By default, the first created window becomes the main
    :type mainWindow: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: Full path name to the workspace panel.
    :rtype: string
    """
    pass


def GraphEditorDisplayValues(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorBackToParent(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideNURBSSurfaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HyperGraphPanelUndoViewChange(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UVEditorUnpinAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def subdiv(*args, currentLevel=True, currentSubdLevel=True, deepestLevel=0, displayLoad=True,
           edgeStats=True, faceStats=True, maxPossibleLevel=0, proxyMode=0, smallOffsets=True,
           q=True, query=True, **kwargs):
    """
    Provides useful information about the selected subdiv or components, such as the deepest
    subdivided level, the children or parents of the currently selected components, etc
    
    :param currentLevel: (C Q) When queried, this flag returns an integer representing the
    level of the currently selected subdiv surface component(s)  Returns -1, if there are mor
    :type currentLevel: boolean
    :param currentSubdLevel: (C Q) When queried, this flag returns an integer representing the
    level of the currently selected subdiv surface, regardless of whether components are sele
    :type currentSubdLevel: boolean
    :param deepestLevel: (C Q) When queried, this flag returns an integer representing the
    deepest level to which the queried subdiv surface has been subdivided
    :type deepestLevel: int
    :param displayLoad: (C Q) When queried, this flag prints the display load of selected
    subdiv
    :type displayLoad: boolean
    :param edgeStats: (C Q) When queried, this flag prints stats on the current subd
    :type edgeStats: boolean
    :param faceStats: (C Q) When queried, this flag prints stats on the current subd
    :type faceStats: boolean
    :param maxPossibleLevel: (C Q) When queried, this flag returns an integer representing the
    maximum possible level to which the queried subdiv surface can been subdivided
    :type maxPossibleLevel: int
    :param proxyMode: (C Q) When queried, this flag returns an integer representing whether or
    not the subdivision surface is in "polygon proxy" mode  "Proxy" mode allows the ba
    :type proxyMode: int
    :param smallOffsets: (C Q) When queried, this flag prints the number of subdiv vertices in
    the hierarchy that have a small enough offset so that the vertex is not required
    :type smallOffsets: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def exportEdits(*args, excludeHierarchy=True, excludeNode="", exportSelected=True, force=True,
                includeAnimation=True, includeConstraints=True, includeDeformers=True,
                includeNetwork=True, includeNode="", includeSetAttrs=True,
                includeSetDrivenKeys=True, includeShaders=True, selected=True, type="",
                editCommand="", onReferenceNode="", q=True, query=True, **kwargs):
    """
    Use this command to export edits made in the scene to a file  The exported file can be
    subsequently imported to another scene  Edits may include: nodes, connections and reference
    edits such as value changes  The nodes that are included in the exported file will be based
    on the options used  At least one option flag that describes the set of target 
    
    :param excludeHierarchy: (C Q) By default, all DAG parents and DAG history are written to
    the export file  To prevent any DAG relations not otherwise connected to the target nodes
    :type excludeHierarchy: boolean
    :param excludeNode: (C Q M) Prevent the node from being included in the list of nodes being
    exported  This flag is useful to exclude specific scene nodes that might otherwise be
    :type excludeNode: string
    :param exportSelected: (C Q) The selected nodes and their connections to each other will be
    exported  Additionally, any dangling connections to non-exported nodes will be exporte
    :type exportSelected: boolean
    :param force: (C Q) Force the export action to take place  This flag is required to
    overwrite an existing file
    :type force: boolean
    :param includeAnimation: (C Q) Additionally include animation nodes and animation helper
    nodes associated with the target nodes being exported
    :type includeAnimation: boolean
    :param includeConstraints: (C Q) Additionally include constraint-related nodes associated
    with the target nodes being exported
    :type includeConstraints: boolean
    :param includeDeformers: (C Q) Additionally include deformer networks associated with the
    target nodes being exported
    :type includeDeformers: boolean
    :param includeNetwork: (C Q) Additionally include the network of nodes connected to the
    target nodes being exported
    :type includeNetwork: boolean
    :param includeNode: (C Q M) Additionally include the named node in the list of nodes being
    exported  In the case where more than one Maya node has the same name, the DAG path ca
    :type includeNode: string
    :param includeSetAttrs: (C Q) When using the -selected/-sel flag, if any of the selected
    nodes are referenced, also include/exclude any setAttr edits on those nodes  If used with
    :type includeSetAttrs: boolean
    :param includeSetDrivenKeys: (C Q) Additionally include setDrivenKey-related nodes
    associated with the target nodes being exported
    :type includeSetDrivenKeys: boolean
    :param includeShaders: (C Q) Additionally include shaders associated with the target nodes
    being exported
    :type includeShaders: boolean
    :param selected: (C Q) Export will operate on the list of nodes currently selected  This
    flag differs from the exportSelected flag in that the selected nodes are not export
    :type selected: boolean
    :param type: (C Q) Set the type of the exported file  Valid values are "editMA" or "editMB"
     Note that this command respects the global "defaultExtensions" setting for
    :type type: string
    :param editCommand: (C Q M) This is a secondary flag used to indicate which type of
    reference edits should be considered by the command  If this flag is not specified all edit
    t
    :type editCommand: string
    :param onReferenceNode: (C Q M) This is a secondary flag used to indicate that only those
    edits which are stored on the indicated reference node should be considered  This flag
    only
    :type onReferenceNode: string
    
    :returns: For query execution.
    :rtype: string[]
    """
    pass


def GraphEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddMissingFBIKEffectors(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def addPP(*args, attribute="", **kwargs):
    """
    Adds per-point (per-cv, per-vertex, or per-particle) attribute capability for an attribute
    of an emitter or field  The -atr flag identifies the attribute  If no attribute is named,
    addPP returns a warning and does nothing   The command adds any other necessary attributes
    wherever they are needed, and makes all necessary connections  If any of the a
    
    :param attribute: (C) Name of attribute to which you wish to add PP capability  Currently
    the only attribute supported is rate (for emitters)
    :type attribute: string
    
    :returns: Returns names of emitters/fields for which the per-point
    capability was added for
    the specified attribute.
    :rtype: string[]
    """
    pass


def SelectTextureReferenceObject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowKinematics(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportInAscii(*args, **kwargs):
    """
    
    """
    pass


def HypershadeDeleteAllBakeSets(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def copyNode(*args, **kwargs):
    """
    
    """
    pass


def dR_bevelRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeDisplayInterestingShapes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def scriptedPanelType(*args, addCallback="", copyStateCallback="", createCallback="",
                      customView=True, defineTemplate="", deleteCallback="", exists=True,
                      hotkeyCtxClient="", initCallback="", label="", obsolete=True,
                      removeCallback="", retainOnFileOpen=True, saveStateCallback="",
                      unique=True, useTemplate="", q=True, query=True, e=True, edit=True,
                      **kwargs):
    """
    This command defines the callbacks for a type of scripted panel  The panel type created by
    this command is then used when creating a scripted panel  See also the 'scriptedPanel'
    command
    
    :param addCallback: (C Q E) This flag specifies the callback procedure for adding the panel
    to a particular control layout  The parent layout is guaranteed to be the current def
    :type addCallback: string
    :param copyStateCallback: (C Q E) This flag specifies the callback procedure for copying
    the state of the panel when a tear-off copy of the panel is made  The callback proc has the
    fo
    :type copyStateCallback: string
    :param createCallback: (C Q E) This flag specifies the callback procedure for initially
    creating the panel object  No UI should be created here  Any editors owned by the panel
    shou
    :type createCallback: string
    :param customView: (C Q E) This flag specifies if this view is a custom 3d view for
    MPx3dModelView types  This flag should only be used for MPx3dModelView types
    :type customView: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param deleteCallback: (C Q E) This flag specifies the callback procedure for final
    deletion of the panel  The callback proc has the form: global proc procName (string
    $panelName)
    :type deleteCallback: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param hotkeyCtxClient: (C Q E) This flag is used to specify the name of the hotkey context
    client for this panel type  By default, it is the same as the panel type
    :type hotkeyCtxClient: string
    :param initCallback: (C Q E) This flag specifies the callback procedure for the initialize
    callback  This will be called on file -new and file -open to give the panel an opportun
    :type initCallback: string
    :param label: (C Q E) Label for the panel
    :type label: string
    :param obsolete: (C Q E) This flag specifies that this type is no longer used in Maya
    :type obsolete: boolean
    :param removeCallback: (C Q E) This flag specifies the callback procedure for removing the
    panel from its current control layout  Any editors should be unparented here  The callbac
    :type removeCallback: string
    :param retainOnFileOpen: (C Q E) This flag specifies if panels of this type should be
    retained after restoring panel cofiguration during file open  Default value is false
    :type retainOnFileOpen: boolean
    :param saveStateCallback: (C Q E) This flag specifies the callback procedure for saving the
    state of the panel  The callback proc has the form: global proc string procName (string
    $pa
    :type saveStateCallback: string
    :param unique: (C Q E) This flag specifies if only one instance of this type of panel can
    exist at a given time
    :type unique: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: The name of the scripted panel type.
    :rtype: string
    """
    pass


def GraphCutOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetVertexNormalOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DistributeUVsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleMainMenubar(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorToggleNodeSwatchSize(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FullCreaseSubdivSurface(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ModifyDisplacementRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXLoadMBExportPresetFile(*args, **kwargs):
    """
    
    """
    pass


def grabColor(*args, hsvValue=True, rgbValue=True, **kwargs):
    """
    This command changes the cursor and enters a modal state which will be exited by pressing a
    mouse button  The color component values of the pixel below the cursor at the time of the
    button press are returned
    
    :param hsvValue: (C) The 3 returned float values will specify the hue, saturation and value
    color components
    :type hsvValue: boolean
    :param rgbValue: (C) The 3 returned float values will specify the red, green and blue color
    components
    :type rgbValue: boolean
    
    :returns: []
    
    Three float values representing the color components of the pixel below
    the
    cursor.  If no flags are specified then the default is to return
    the red, green and blue
    color components.
    :rtype: float
    """
    pass


def FBXExportColladaSingleMatrix(*args, **kwargs):
    """
    
    """
    pass


def hotkey(*args, altModifier=True, autoSave=True, commandModifier=True, ctrlModifier=True,
           ctxClient="", dragPress=True, factorySettings=True, isModifier=True, keyShortcut="",
           name="", pressCommandRepeat=True, releaseCommandRepeat=True, releaseName="",
           shiftModifier=True, sourceUserHotkeys=True, q=True, query=True, **kwargs):
    """
    This command sets the single-key hotkeys for the entire application
    
    :param altModifier: (C Q) 
    :type altModifier: boolean
    :param autoSave: (C) If set to true then the hotkeys will always be saved when you quit  If
    false then the hotkeys are not saved unless "savePrefs -hotkeys" is used
    :type autoSave: boolean
    :param commandModifier: (C) The Command key must be pressed to get the hotkey  This is only
    available on systems which have a separate command key  Note that if menu item accele
    :type commandModifier: boolean
    :param ctrlModifier: (C Q) The Ctrl key must be pressed to get the hotkey  Note that if
    menu item accelerator keys are being used (menuItem -ke/keyEquivalent), then the acceler
    :type ctrlModifier: boolean
    :param ctxClient: (C Q) Specifies the hotkey context  It is used together with the other
    flags to modify or query the hotkey for a certain hotkey context  If it is not speci
    :type ctxClient: string
    :param dragPress: (C) Specify true and the command may be executed during manipulator
    dragging, if the tool context also allows this  This flag is false by default
    :type dragPress: boolean
    :param factorySettings: (C) Resets the hotkeys back to the initial defaults
    :type factorySettings: boolean
    :param isModifier: (C) This flag is obsolete and should no longer be used
    :type isModifier: boolean
    :param keyShortcut: (C) Specify what key is being set  The key must be either a single
    ascii character (capital and lowercase can be set independently) or one of the keyword
    :type keyShortcut: string
    :param name: (C Q) The name of the namedCommand object that will be executed when the key
    is pressed
    :type name: string
    :param pressCommandRepeat: (C) Specify true and the command may be repeated by executing
    the command repeatLast  This flag is false by default
    :type pressCommandRepeat: boolean
    :param releaseCommandRepeat: (C) Specify true and the command may be repeated by executing
    the command repeatLast  This flag is false by default
    :type releaseCommandRepeat: boolean
    :param releaseName: (C Q) The name of the namedCommand object that will be executed when
    the key is released
    :type releaseName: string
    :param shiftModifier: (C Q) The Shift key must be pressed to get the hotkey
    :type shiftModifier: boolean
    :param sourceUserHotkeys: (C) This flag is obsolete  Please use import flag from hotkeySet
    command to import the user hotkeys
    :type sourceUserHotkeys: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def paintEffectsDisplay(*args, meshDrawEnable=True, q=True, query=True, **kwargs):
    """
    Command to set the global display methods for paint effects items
    
    :param meshDrawEnable: (C Q) Set whether mesh draw is enabled on objects
    :type meshDrawEnable: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def MovePolygonComponentOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SculptSubdivsTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_meshOffsetTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UnlockNormals(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_objectTemplateTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleShowResults(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def LayoutUV(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def EditFluidResolution(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowMeshMaskToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def makeIdentity(*args, apply=False, jointOrient=True, normal=0, preserveNormals=True,
                 rotate=True, scale=True, translate=True, **kwargs):
    """
    The makeIdentity command is a quick way to reset the selected transform and all of its
    children down to the shape level by the identity transformation  You can also specify which
    of transform, rotate or scale is applied down from the selected transform  The identity
    transformation means:  translate = 0, 0, 0 rotate = 0, 0, 0 scale = 1, 1, 1 shear =
    
    :param apply: (C) If this flag is true, the accumulated transforms are applied to the shape
    after the transforms are made identity, such that the world space positions
    :type apply: boolean
    :param jointOrient: (C) If this flag is set, the joint orient on joints will be reset to
    align with worldspace
    :type jointOrient: boolean
    :param normal: (C) If this flag is set to 1, the normals on polygonal objects will be
    frozen  This flag is valid only when the -apply flag is on  If this flag is set to
    :type normal: int
    :param preserveNormals: (C) If this flag is true, the normals on polygonal objects will be
    reversed if the objects are negatively scaled (reflection)  This flag is valid only wh
    :type preserveNormals: boolean
    :param rotate: (C) If this flag is true, only the rotation is applied to the shape  The
    rotation will be changed to 0, 0, 0  If neither translate nor rotate nor scale f
    :type rotate: boolean
    :param scale: (C) If this flag is true, only the scale is applied to the shape  The scale
    factor will be changed to 1, 1, 1  If neither translate nor rotate nor scale
    :type scale: boolean
    :param translate: (C) If this flag is true, only the translation is applied to the shape 
    The translation will be changed to 0, 0, 0  If neither translate nor rotate nor s
    :type translate: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def HypershadeDeleteUnusedNodes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSetSmoothBrushToolOption(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def EditPolygonType(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_viewPersp(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def cMuscleSimulate(*args, **kwargs):
    """
    
    """
    pass


def separator(*args, annotation="", backgroundColor=None, defineTemplate="", docTag="",
              dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
              enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
              highlightColor=None, horizontal=True, isObscured=True, manage=True,
              noBackground=True, numberOfPopupMenus=True, parent="", popupMenuArray=True,
              preventOverride=True, statusBarMessage="", style="", useTemplate="", visible=True,
              visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
              **kwargs):
    """
    This command creates a separator widget in a variety of drawing styles
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param horizontal: (C Q) Specify the orientation of the separator  True for horizontal and
    false for vertical  Only valid when style equals "single"
    :type horizontal: boolean
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param style: (C Q E) Specify the style of the separator  Valid values are "none", "single",
    "in", "out" and "shelf"  Note: the values "double", "singleDash" and "doubleDa
    :type style: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def DisplaySmoothShaded(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dynPaintEditor(*args, activeOnly=True, autoSave=True, camera="", canvasMode=True,
                   canvasUndo=True, changeCommand=None, clear=None, control=True,
                   currentCanvasSize=True, defineTemplate="", displayAppearance="",
                   displayFog=True, displayImage=0, displayLights="", displayStyle="",
                   displayTextures=True, docTag="", doubleBuffer=True, drawAxis=True,
                   drawContext=True, exists=True, fastUpdate=0, fileName="", filter="",
                   forceMainConnection="", highlightConnection="", iconGrab=True, loadImage="",
                   lockMainConnection=True, mainListConnection="", menu="", nbImages=True,
                   newImage=None, paintAll=0.0, panel="", parent="", redrawLast=True,
                   refresh=True, refreshMode=0, removeAllImages=True, removeImage=True,
                   rollImage=None, saveAlpha=True, saveBumpmap="", saveImage=True,
                   scaleBlue=0.0, scaleGreen=0.0, scaleRed=0.0, selectionConnection="",
                   singleBuffer=True, snapShot=True, stateString=True, swap=0, tileSize=0,
                   unParent=True, undoCache=True, unlockMainConnection=True,
                   updateMainConnection=True, useTemplate="", wrap=None, writeImage="",
                   zoom=0.0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Create a editor window that can be painted into
    
    :param activeOnly: (Q E) For Scene mode, this determines if only the active strokes will be
    refreshed
    :type activeOnly: boolean
    :param autoSave: (Q E) For Canvas mode, this determines if the buffer will be saved to a
    disk file after every stroke  Good for painting textures and viewing the results in
    :type autoSave: boolean
    :param camera: (Q E) Sets the name of the camera which the Paint Effects panel looks
    through
    :type camera: string
    :param canvasMode: (Q E) Sets the Paint Effects panel into Canvas mode if true
    :type canvasMode: boolean
    :param canvasUndo: (E) Does a fast undo in Canvas mode  This is a special undo because we
    are not using any history when we paint in Canvas mode so we provide a single leve
    :type canvasUndo: boolean
    :param changeCommand: (C Q E) Parameters: First string: command Second string: editorName
    Third string: editorCmd Fourth string: updateFunc Call the command when something changes
    :type changeCommand: [string, string, string, string]
    :param clear: (E) Clears the buffer (if in Canvas mode) to the floating point values (R,G,
    B)
    :type clear: [float, float, float]
    :param control: (Q) Query only  Returns the top level control for this editor  Usually used
    for getting a parent to attach popup menus  Caution: It is possible for an ed
    :type control: boolean
    :param currentCanvasSize: (Q) In Query mode, this returns the (X,Y) resolution of the
    current canvas
    :type currentCanvasSize: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param displayAppearance: (Q E) Sets the display appearance of the model panel  Possible
    values are "wireframe", "points", "boundingBox", "smoothShaded", "flatShaded"  This flag
    may
    :type displayAppearance: string
    :param displayFog: (Q E) For Scene mode, this determines if fog will be displayed in the
    Paint Effects panel when refreshing the scene  If fog is on, but this is off, fog wil
    :type displayFog: boolean
    :param displayImage: (Q E) Set a particular image in the Editor Image Stack as the current
    Editor Image  Images are added to the Editor Image Stack using the "si/saveImage" fla
    :type displayImage: int
    :param displayLights: (Q E) Sets the lighting for shaded mode  Possible values are
    "selected", "active", "all", "default"
    :type displayLights: string
    :param displayStyle: (C Q E) Set the mode to display the image  Valid values are: "color"
    to display the basic RGB image "mask" to display the mask channel "lum" to display the l
    :type displayStyle: string
    :param displayTextures: (Q E) Turns on or off display of textures in shaded mode
    :type displayTextures: boolean
    :param docTag: (C Q E) Attaches a tag to the editor
    :type docTag: string
    :param doubleBuffer: (C Q E) Set the display in double buffer mode
    :type doubleBuffer: boolean
    :param drawAxis: (C Q E) Set or query whether the axis will be drawn
    :type drawAxis: boolean
    :param drawContext: (Q) Returns the name of the context
    :type drawContext: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fastUpdate: () Obsolete - do not use
    :type fastUpdate: int
    :param fileName: (Q E) This sets the file to which the canvas will be saved
    :type fileName: string
    :param filter: (C Q E) Specifies the name of an itemFilter object to be used with this
    editor  This filters the information coming onto the main list of the editor
    :type filter: string
    :param forceMainConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type forceMainConnection: string
    :param highlightConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its highlight list  Not all editors have a highlight list 
    F
    :type highlightConnection: string
    :param iconGrab: (E) This puts the Paint Effects panel into Grab Icon mode where the user
    is expected to drag out a section of the screen to be made into an icon
    :type iconGrab: boolean
    :param loadImage: (E) load an image from disk and set it as the current Editor Image
    :type loadImage: string
    :param lockMainConnection: (C E) Locks the current list of objects within the
    mainConnection, so that only those objects are displayed within the editor  Further changes
    to the origi
    :type lockMainConnection: boolean
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type mainListConnection: string
    :param menu: (C) Sets the name of the script used to build a menu in the editor  The script
    takes the editor name as an argument
    :type menu: string
    :param nbImages: (Q) returns the number of images
    :type nbImages: boolean
    :param newImage: (Q E) Starts a new image in edit mode, setting the resolution to the
    integer values (X,Y) and clearing the buffer to the floating point values (R,G,B)  In
    :type newImage: [int, int, float, float, float]
    :param paintAll: (E) Redraws the buffer in current refresh mode
    :type paintAll: float
    :param panel: (C Q) Specifies the panel for this editor  By default if an editor is created
    in the create callback of a scripted panel it will belong to that panel  If a
    :type panel: string
    :param parent: (C Q E) Specifies the parent layout for this editor  This flag will only
    have an effect if the editor is currently un-parented
    :type parent: string
    :param redrawLast: (E) Redraws the last stroke again  Useful when it's brush has just
    changed  This feature does a fast undo and redraws the stroke again
    :type redrawLast: boolean
    :param refresh: (E) requests a refresh of the current Editor Image
    :type refresh: boolean
    :param refreshMode: (Q E) Sets the refresh mode to the specified value  0 - Do not draw
    strokes on refresh, 1 - Redraw strokes in wireframe mode, 2 - Redraw strokes in final r
    :type refreshMode: int
    :param removeAllImages: (E) remove all the Editor Images from the Editor Image Stack
    :type removeAllImages: boolean
    :param removeImage: (E) remove the current Editor Image from the Editor Image Stack
    :type removeImage: boolean
    :param rollImage: (E) In Canvas mode, this rolls the image by the floating point values (X,
    Y)  X and Y are between 0 (no roll) and 1 (full roll)  A value of .5 rolls the i
    :type rollImage: [float, float]
    :param saveAlpha: (Q E) For Canvas mode, this determines if the alpha will be saved when
    storing the canvas to a disk file
    :type saveAlpha: boolean
    :param saveBumpmap: (Q E) Saves the current buffer as a bump map to the specified file
    :type saveBumpmap: string
    :param saveImage: (E) save the current Editor Image to memory  Saved Editor Images are
    stored in an Editor Image Stack  The most recently saved image is stored in position
    :type saveImage: boolean
    :param scaleBlue: (C Q E) Define the scaling factor for the blue component in the View  The
    default value is 1 and can be between -1000 to +1000
    :type scaleBlue: float
    :param scaleGreen: (C Q E) Define the scaling factor for the green component in the View 
    The default value is 1 and can be between -1000 to +1000
    :type scaleGreen: float
    :param scaleRed: (C Q E) Define the scaling factor for the red component in the View  The
    default value is 1 and can be between -1000 to +1000
    :type scaleRed: float
    :param selectionConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its own selection list  As the user selects things in this
    e
    :type selectionConnection: string
    :param singleBuffer: (C Q E) Set the display in single buffer mode
    :type singleBuffer: boolean
    :param snapShot: (E) Takes a snapshot of the current camera view
    :type snapShot: boolean
    :param stateString: (Q) Query only flag  Returns the MEL command that will create an editor
    to match the current editor state  The returned command string uses the string va
    :type stateString: boolean
    :param swap: () Obsolete - do not use
    :type swap: int
    :param tileSize: (E) Sets the size of the tile for the hardware texture redraw of the
    display buffer
    :type tileSize: int
    :param unParent: (C E) Specifies that the editor should be removed from its layout  This
    cannot be used in query mode
    :type unParent: boolean
    :param undoCache: (E) By default the last image is cached for undo  If this is set false,
    then undoing will be disabled in canvas mode and undo in scene mode will force a
    :type undoCache: boolean
    :param unlockMainConnection: (C E) Unlocks the mainConnection, effectively restoring the
    original mainConnection (if it is still available), and dynamic updates
    :type unlockMainConnection: boolean
    :param updateMainConnection: (C E) Causes a locked mainConnection to be updated from the
    orginal mainConnection, but preserves the lock state
    :type updateMainConnection: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param wrap: (Q E) For Canvas mode, should the buffer wrap in U, and V (respectively) when
    painting
    :type wrap: [boolean, boolean]
    :param writeImage: (E) write the current Editor Image to disk
    :type writeImage: string
    :param zoom: (Q E) Zooms the Canvas image by the specified value
    :type zoom: float
    
    :returns: Editor name
    :rtype: string
    """
    pass


def CreateSubdivTorus(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MapUVBorder(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddBifrostKillField(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def currentUnit(*args, angle="", fullName=True, linear="", time="", updateAnimation=True,
                q=True, query=True, **kwargs):
    """
    This command allows you to change the units in which you will work in Maya  There are three
    types of units: linear, angular and time   The current unit affects how all commands in
    Maya interpret their numeric values  For example, if the current linear unit is cm, then
    the command: move 5 -2 3; sphere -radius 4;  will be interpreted as moving 5cm in
    
    :param angle: (C Q) Set the current angular unit  Valid strings are: [deg | degree | rad |
    radian] When queried, returns a string which is the current angular unit
    :type angle: string
    :param fullName: (Q) A query only flag  When specified in conjunction with any of the
    -linear/-angle/-time flags, will return the long form of the unit  For example, mm a
    :type fullName: boolean
    :param linear: (C Q) Set the current linear unit  Valid strings are: [mm | millimeter | cm
    | centimeter | m | meter | km | kilometer | in | inch | ft | foot | yd | yard |
    :type linear: string
    :param time: (C Q) Set the current time unit  Valid strings are: [hour | min | sec |
    millisec | game | film | pal | ntsc | show | palf | ntscf | 23.976fps | 29.97fps |
    :type time: string
    :param updateAnimation: (C) An edit only flag  When specified in conjunction with the -time
    flag indicates that times for keys are not updated  By default when the current time
    :type updateAnimation: boolean
    
    :returns: The new current unit that has been set
    :rtype: string
    """
    pass


def FBXExportShapes(*args, **kwargs):
    """
    
    """
    pass


def HypershadeSortByName(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def layoutDialog(*args, backgroundColor=None, dismiss="", parent="", title="", uiScript=None,
                 **kwargs):
    """
    The layoutDialog command creates a modal dialog containing a formLayout with 100 divisions 
    The formLayout can be populated with arbitrary UI elements through use of the
    '-ui/-uiScript' flag   NOTE: A layoutDialog is not a window and certain UI elements will
    not function properly within it  In particular menuBars and panels containing menuBars
    shou
    
    :param backgroundColor: (C) The background color of the dialog  The arguments correspond to
    the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type backgroundColor: [float, float, float]
    :param dismiss: (C) Dismiss the current layoutDialog  The specified string will be set as
    the result of the initial layoutDialog command
    :type dismiss: string
    :param parent: (C) Specify the parent window for the dialog  The dialog will be centered on
    this window and raise and lower with it's parent  By default, the dialog is
    :type parent: string
    :param title: (C) The dialog title
    :type title: string
    :param uiScript: (C) The specified MEL procedure name will be invoked to build the UI of
    the layoutDialog  This flag is required when creating a layoutDialog  The top-lev
    :type uiScript: script
    
    :returns: The string specified by the -dismiss flag, or "dismiss" if the dialog
    was closed.
    :rtype: string
    """
    pass


def DeleteAllShadingGroupsAndMaterials(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_coordSpaceWorld(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateAmbientLight(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_objectBackfaceTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RelaxUVShell(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CollapseSubdivSurfaceHierarchy(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OptimzeUVs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OneClickDispatch(*args, **kwargs):
    """
    
    """
    pass


def rowColumnLayout(*args, adjustableColumn=0, annotation="", backgroundColor=None,
                    childArray=True, columnAlign=None, columnAttach=None, columnOffset=None,
                    columnSpacing=None, columnWidth=None, defineTemplate="", docTag="",
                    dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
                    enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
                    highlightColor=None, isObscured=True, manage=True, noBackground=True,
                    numberOfChildren=True, numberOfColumns=0, numberOfPopupMenus=True,
                    numberOfRows=0, parent="", popupMenuArray=True, preventOverride=True,
                    rowAlign=None, rowAttach=None, rowHeight=None, rowOffset=None,
                    rowSpacing=None, statusBarMessage="", useTemplate="", visible=True,
                    visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
                    **kwargs):
    """
    This command creates a rowColumn layout  A rowColumn layout positions children in either a
    row or column format  A column layout, specified with the -nc/numberOfColumns flag, allows
    you set text alignment, attachments and offsets for each column in the layout  Every member
    of a column will have the same alignment, attachment and offsets  Likewise t
    
    :param adjustableColumn: (C E) Specifies which column has an adjustable size that changes
    with the sizing of the layout
    :type adjustableColumn: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param childArray: (Q) Returns a string array of the names of the layout's immediate
    children
    :type childArray: boolean
    :param columnAlign: (C E M) Alignment for text and pixmaps in the specified column  Values
    are: "left", "right" and "center"  Only valid for column format, ie  number of columns
    :type columnAlign: [int, string]
    :param columnAttach: (C E M) The attachments and offsets for the children in the specified
    column  The first argument is the 1-based column index  The second argument is the atta
    :type columnAttach: [int, string, int]
    :param columnOffset: (C E M) The attachment offset for the specified column  The first
    argument is the 1-based column index  The second argument is the attachment, valid values
    a
    :type columnOffset: [int, string, int]
    :param columnSpacing: (C E M) The space between columns in pixels  In column format this
    flag specifies that the space be to the left of the given column  In row format it specifi
    :type columnSpacing: [int, int]
    :param columnWidth: (C E M) Width of a column  This flag is valid only in column format 
    The column width must be greater than 0  The first argument is the 1-based column index
    :type columnWidth: [int, int]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfChildren: (Q) Returns in an int the number of immediate children of the
    layout
    :type numberOfChildren: boolean
    :param numberOfColumns: (C Q) Number of columns  This flag is mutually exclusive to the
    -nr/numRows flag  Either one or the other can be specified
    :type numberOfColumns: int
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param numberOfRows: (C Q) Number of rows  This flag is mutually exclusive to the
    -nc/numColumns flag  Either one or the other can be specified
    :type numberOfRows: int
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rowAlign: (C E M) Alignment for text and pixmaps in the specified row  Values are:
    "left", "right" and "center"  Only valid for row format, ie  number of rows specifie
    :type rowAlign: [int, string]
    :param rowAttach: (C E M) The attachments and offsets for the children in the specified row
     The first argument is the 1-based row index  The second argument is the attachment
    :type rowAttach: [int, string, int]
    :param rowHeight: (C E M) Height of a row  This flag is only valid in row format  The row
    height must be greater than 0  The first argument is the 1-based row index  The secon
    :type rowHeight: [int, int]
    :param rowOffset: (C E M) The attachment offset for the specified row  The first argument
    is the 1-based row index  The second argument is the attachment, valid values are "to
    :type rowOffset: [int, string, int]
    :param rowSpacing: (C E M) The space between rows, in pixels  In row format this specifies
    the space above the specified row  In column format it specifies the space between al
    :type rowSpacing: [int, int]
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def SelectAllSubdivGeometry(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleReflection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DistributeUVs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def keyingGroup(*args, activator=None, addElement=None, afterFilters=True, category="",
                clear=None, color=0, copy=None, edges=True, editPoints=True, empty=True,
                excludeDynamic=True, excludeRotate=True, excludeScale=True,
                excludeTranslate=True, excludeVisibility=True, facets=True, flatten=None,
                forceElement=None, include=None, intersection=None, isIntersecting=None,
                isMember=None, layer=True, minimizeRotation=True, name="", noSurfaceShader=True,
                noWarnings=True, nodesOnly=True, remove=None, removeActivator=None,
                renderable=True, setActiveFilter="", size=True, split=None, subtract=None,
                text="", union=None, vertices=True, q=True, query=True, e=True, edit=True,
                **kwargs):
    """
    This command is used to manage the membership of a keying group  Keying groups allow users
    to effectively manage related keyframe data, allowing keys on attributes in the keying
    group to be set and edited as a single entity
    
    :param activator: (Q E) Sets the selected node(s) as activators for the given keying group 
    In query mode, returns list of objects that activate the given keying group
    :type activator: name
    :param addElement: (E) Adds the list of items to the given set  If some of the items cannot
    be added to the set because they are in another set which is in the same partiti
    :type addElement: name
    :param afterFilters: (E) Default state is false  This flag is valid in edit mode only  This
    flag is for use on sets that are acted on by deformers such as sculpt, lattice, bl
    :type afterFilters: boolean
    :param category: (C Q E) Sets the keying group's category  This is what the global, active
    keying group filter will use to match
    :type category: string
    :param clear: (E) An operation which removes all items from the given set making the set
    empty
    :type clear: name
    :param color: (C Q E) Defines the hilite color of the set  Must be a value in range [-1, 7]
    (one of the user defined colors)  -1 marks the color has being undefined and th
    :type color: int
    :param copy: (C) Copies the members of the given set to a new set  This flag is for use in
    creation mode only
    :type copy: name
    :param edges: (C Q) Indicates the new set can contain edges only  This flag is for use in
    creation or query mode only  The default value is false
    :type edges: boolean
    :param editPoints: (C Q) Indicates the new set can contain editPoints only  This flag is
    for use in creation or query mode only  The default value is false
    :type editPoints: boolean
    :param empty: (C) Indicates that the set to be created should be empty  That is, it ignores
    any arguments identifying objects to be added to the set  This flag is only
    :type empty: boolean
    :param excludeDynamic: (C) When creating the keying group, exclude dynamic attributes
    :type excludeDynamic: boolean
    :param excludeRotate: (C) When creating the keying group, exclude rotate attributes from
    transform-type nodes
    :type excludeRotate: boolean
    :param excludeScale: (C) When creating the keying group, exclude scale attributes from
    transform-type nodes
    :type excludeScale: boolean
    :param excludeTranslate: (C) When creating the keying group, exclude translate attributes
    from transform-type nodes  For example, if your keying group contains joints only, perha
    :type excludeTranslate: boolean
    :param excludeVisibility: (C) When creating the keying group, exclude visibility attribute
    from transform-type nodes
    :type excludeVisibility: boolean
    :param facets: (C Q) Indicates the new set can contain facets only  This flag is for use in
    creation or query mode only  The default value is false
    :type facets: boolean
    :param flatten: (E) An operation that flattens the structure of the given set  That is, any
    sets contained by the given set will be replaced by its members so that the s
    :type flatten: name
    :param forceElement: (E) For use in edit mode only  Forces addition of the items to the set
     If the items are in another set which is in the same partition as the given set,
    :type forceElement: name
    :param include: (E) Adds the list of items to the given set  If some of the items cannot be
    added to the set, a warning will be issued  This is a less strict version of
    :type include: name
    :param intersection: (C) An operation that returns a list of items which are members of all
    the sets in the list
    :type intersection: name
    :param isIntersecting: (C) An operation which tests whether the sets in the list have
    common members
    :type isIntersecting: name
    :param isMember: (C) An operation which tests whether all the given items are members of
    the given set
    :type isMember: name
    :param layer: (C) OBSOLETE  DO NOT USE
    :type layer: boolean
    :param minimizeRotation: (C Q E) This flag only affects the attribute contained in the
    immediate keyingGroup  It does not affect attributes in sub-keyingGroups  Those will need
    to se
    :type minimizeRotation: boolean
    :param name: (C) Assigns string as the name for a new set  This flag is only valid for
    operations that create a new set
    :type name: string
    :param noSurfaceShader: (C) If set is renderable, do not connect it to the default surface
    shader  Flag has no meaning or effect for non renderable sets  This flag is for use in
    :type noSurfaceShader: boolean
    :param noWarnings: (C) Indicates that warning messages should not be reported such as when
    trying to add an invalid item to a set  (used by UI)
    :type noWarnings: boolean
    :param nodesOnly: (Q) This flag is usable with the -q/query flag but is ignored if used
    with another queryable flags  This flag modifies the results of the set membership
    :type nodesOnly: boolean
    :param remove: (E) Removes the list of items from the given set
    :type remove: name
    :param removeActivator: (E) Removes the selected node(s) as activators for the given keying
    group
    :type removeActivator: name
    :param renderable: (C Q) This flag indicates that a special type of set should be created 
    This type of set (shadingEngine as opposed to objectSet) has certain restrictions o
    :type renderable: boolean
    :param setActiveFilter: (C Q E) Sets the global, active keying group filter, which will
    affect activation of keying groups  Only keying groups with categories that match the
    filter
    :type setActiveFilter: string
    :param size: (Q) Use the size flag to query the length of the set
    :type size: boolean
    :param split: (C) Produces a new set with the list of items and removes each item in the
    list of items from the given set
    :type split: name
    :param subtract: (C) An operation between two sets which returns the members of the first
    set that are not in the second set
    :type subtract: name
    :param text: (C Q E) Defines an annotation string to be stored with the set
    :type text: string
    :param union: (C) An operation that returns a list of all the members of all sets listed
    :type union: name
    :param vertices: (C Q) Indicates the new set can contain vertices only  This flag is for
    use in creation or query mode only  The default value is false
    :type vertices: boolean
    
    :returns: For creation operations (name of the keying group that was created or edited)
    :rtype: string
    """
    pass


def MoveDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmDirectionBrushContext(*args, **kwargs):
    """
    
    """
    pass


def HypershadeRemoveAsset(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmPolyToGuide(*args, **kwargs):
    """
    
    """
    pass


def ShowRiggingUI(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def deleteAttrPattern(*args, allPatterns=True, patternName="", patternType="", **kwargs):
    """
    After a while the list of attribute patterns could become cluttered  This command provides
    a way to remove patterns from memory so that only the ones of interest will show
    
    :param allPatterns: (C) If specified it means delete all known attribute patterns
    :type allPatterns: boolean
    :param patternName: (C) The name of the pattern to be deleted
    :type patternName: string
    :param patternType: (C) Delete all patterns of the given type
    :type patternType: string
    
    :returns: Name(s) of deleted pattern(s)
    :rtype: string
    """
    pass


def ScaleConstraint(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SaveBrushPreset(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXClose(*args, **kwargs):
    """
    
    """
    pass


def NextFrame(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HIKCycleMode(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolygonBooleanUnion(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def artAttrPaintVertexCtx(*args, accopacity=False, activeListChangedProc="", afterStrokeCmd="",
                          alphaclamp="none", alphaclamplower=0.0, alphaclampupper=1.0,
                          attrSelected="", beforeStrokeCmd="", brushalignment=True,
                          brushfeedback=True, clamp="none", clamplower=0.0, clampupper=1.0,
                          clear=True, colorAlphaValue=0.0, colorRGBAValue=None,
                          colorRGBValue=None, colorRamp="", colorfeedback=False,
                          colorfeedbackOverride=False, colorrangelower=0.0, colorrangeupper=1.0,
                          dataTypeIndex=0, disablelighting=False, dragSlider="",
                          duringStrokeCmd="", dynclonemode=True, exists=True,
                          expandfilename=True, exportaspectratio=0.0,
                          exportfilemode="luminance/rgb", exportfilesave="", exportfilesizex=0,
                          exportfilesizey=0, exportfiletype="", filterNodes=True, history=True,
                          image1="", image2="", image3="", importfileload="",
                          importfilemode="alpha", importreassign=False, interactiveUpdate=True,
                          lastRecorderCmd="", lastStampName="", lowerradius=0.0, makeStroke=0,
                          mappressure="none", maxvalue=1.0, minvalue=0.0, name="",
                          objattrArray="", opacity=1.0, outline=True, outwhilepaint=False,
                          paintComponent=0, paintNodeArray="", paintNumChannels=0,
                          paintRGBA=False, paintVertexFace=False, paintattrselected="",
                          paintmode="screen", paintoperationtype="Paint", pickColor=True,
                          pickValue=True, playbackCursor=None, playbackPressure=0.0,
                          preserveclonesource=True, profileShapeFile="", projective=False,
                          radius=1.0, rampMaxColor=None, rampMinColor=None, record=True,
                          reflection=False, reflectionaboutorigin=True, reflectionaxis="x",
                          screenRadius=0.0, selectclonesource=True, selectedattroper="absolute",
                          showactive=True, stampDepth=0.0, stampProfile="", stampSpacing=1.0,
                          strokesmooth="", surfaceConformedBrushVertices=True, tablet=True,
                          tangentOutline=True, toolOffProc="", toolOnProc="", useColorRamp=True,
                          useMaxMinColor=True, usepressure=False, value=0.0,
                          vertexColorRange=False, vertexColorRangeLower=0.0,
                          vertexColorRangeUpper=1.0, whichTool="", worldRadius=0.0, q=True,
                          query=True, e=True, edit=True, **kwargs):
    """
    This is a context command to set the flags on the artAttrContext, which is the base context
    for attribute painting operations  All commands require the name of the context as the last
    argument as this provides the name of the context to create, edit or query   This is a
    context command to set the flags on the Paint color on vertex Tool context
    
    :param accopacity: (C Q E) Sets opacity accumulation on/off  C: Default is false (Except
    for sculpt tool for which it is true by default)  Q: When queried, it returns a boolean
    :type accopacity: boolean
    :param activeListChangedProc: (C Q E) Accepts a string that contains a MEL command that is
    invoked whenever the active list changes  There may be some situations where the UI, for
    example
    :type activeListChangedProc: string
    :param afterStrokeCmd: (C Q E) The passed string is executed as a MEL command immediately
    after the end of a stroke  C: Default is no command  Q: When queried, it returns the curre
    :type afterStrokeCmd: string
    :param alphaclamp: (C Q E) Specifies if the weight value should be alpha clamped to the
    lower and upper bounds  There are four options here: "none" - no clamping is performed,
    :type alphaclamp: string
    :param alphaclamplower: (C Q E) Specifies the lower bound for the alpha values  C: Default
    is 0.0  Q: When queried, it returns a float
    :type alphaclamplower: float
    :param alphaclampupper: (C Q E) Specifies the upper bound for the alpha values  C: Default
    is 1.0  Q: When queried, it returns a float
    :type alphaclampupper: float
    :param attrSelected: (Q) Returns a name of the currently selected attribute  Q: When
    queried, it returns a string
    :type attrSelected: string
    :param beforeStrokeCmd: (C Q E) The passed string is executed as a MEL command immediately
    before the start of a stroke  C: Default is no command  Q: When queried, it returns the cu
    :type beforeStrokeCmd: string
    :param brushalignment: (C Q E) Specifies the path brush alignemnt  If true, the brush will
    align to stroke path, otherwise it will align to up vector  C: Default is true  Q: When q
    :type brushalignment: boolean
    :param brushfeedback: (C Q E) Specifies if the brush additional feedback should be drawn 
    C: Default is TRUE  Q: When queried, it returns a boolean
    :type brushfeedback: boolean
    :param clamp: (C Q E) Specifies if the weight value should be clamped to the lower and
    upper bounds  There are four options here: "none" - no clamping is performed, "lower
    :type clamp: string
    :param clamplower: (C Q E) Specifies the lower bound for the values  C: Default is 0.0  Q:
    When queried, it returns a float
    :type clamplower: float
    :param clampupper: (C Q E) Specifies the upper bound for the values  C: Default is 1.0  Q:
    When queried, it returns a float
    :type clampupper: float
    :param clear: (C E) Floods all cvs/vertices to the current value
    :type clear: boolean
    :param colorAlphaValue: (C Q E) The Alpha value of the color
    :type colorAlphaValue: float
    :param colorRGBAValue: (C Q E) The RGBA value of the color
    :type colorRGBAValue: [float, float, float, float]
    :param colorRGBValue: (C Q E) The RGB value of the color
    :type colorRGBValue: [float, float, float]
    :param colorRamp: (C Q E) Allows a user defined color ramp to be used to map values to
    colors
    :type colorRamp: string
    :param colorfeedback: (C Q E) Sets on/off the color feedback display  C: Default is FALSE 
    Q: When queried, it returns a boolean
    :type colorfeedback: boolean
    :param colorfeedbackOverride: (C Q E) Sets on/off the color feedback override  C: Default
    is FALSE  Q: When queried, it returns a boolean
    :type colorfeedbackOverride: boolean
    :param colorrangelower: (C Q E) Specifies the value that maps to black when color feedback
    mode is on  C: Default is 0.0  Q: When queried, it returns a float
    :type colorrangelower: float
    :param colorrangeupper: (C Q E) Specifies the value that maps to the maximum color when
    color feedback mode is on  C: Default is 1.0  Q: When queried, it returns a float
    :type colorrangeupper: float
    :param dataTypeIndex: (Q E) When the selected paintable attribute is a vectorArray, it
    specifies which field to paint on
    :type dataTypeIndex: int
    :param disablelighting: (C Q E) If color feedback is on, this flag determines whether
    lighting is disabled or not for the surfaces that are affected  C: Default is FALSE  Q:
    When qu
    :type disablelighting: boolean
    :param dragSlider: (C E) Sets the current brush drag state for resizing or offsetting the
    brush (like the 'b' and 'm' default hotkeys)  The string argument is one of: "radius
    :type dragSlider: string
    :param duringStrokeCmd: (C Q E) The passed string is executed as a MEL command during the
    stroke, each time the mouse is dragged  C: Default is no command  Q: When queried, it
    retur
    :type duringStrokeCmd: string
    :param dynclonemode: (C Q E) Enable or disable dynamic clone mode
    :type dynclonemode: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param expandfilename: (C E) If true, it will expand the name of the export file and
    concatenate it with the surface name  Otherwise it will take the name as it is  C: Default
    is
    :type expandfilename: boolean
    :param exportaspectratio: (C Q E) Value of aspect ratio for export
    :type exportaspectratio: float
    :param exportfilemode: (C Q E) Specifies the export channel.The valid entries here are:
    "alpha", "luminance", "rgb", "rgba"  C: Default is "luminance/rgb"  Q: When queried, it
    retu
    :type exportfilemode: string
    :param exportfilesave: (E) Exports the attribute map and saves to a specified file
    :type exportfilesave: string
    :param exportfilesizex: (C Q E) Specifies the width of the attribute map to export  C:
    Default width is 256  Q: When queried, it returns an integer
    :type exportfilesizex: int
    :param exportfilesizey: (C Q E) Specifies the width of the attribute map to export  C:
    Default width is 256  Q: When queried, it returns an integer
    :type exportfilesizey: int
    :param exportfiletype: (C Q E) Specifies the image file format  It can be one of the
    following: "iff", "tiff", "jpeg", "alias", "rgb", "fit" "postScriptEPS", "softimage",
    "wavefron
    :type exportfiletype: string
    :param filterNodes: (E) Sets the node filter
    :type filterNodes: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param importfileload: (E) Load the attribute map a specified file
    :type importfileload: string
    :param importfilemode: (C Q E) Specifies the channel to import  The valid entries here are:
    "alpha", "luminance", "red", "green", "blue", and "rgb" C: Default is "alpha"  Q: When q
    :type importfilemode: string
    :param importreassign: (C Q E) Specifies if the multiply atrribute maps are to be
    reassigned while importing  Only maps previously exported from within Artisan can be
    reassigned  C
    :type importreassign: boolean
    :param interactiveUpdate: (C Q E) Specifies how often to transfer the painted values into
    the attribute  TRUE: transfer them "continuously" (many times per stroke) FALSE: transfer
    the
    :type interactiveUpdate: boolean
    :param lastRecorderCmd: (C Q E) Value of last recorded command
    :type lastRecorderCmd: string
    :param lastStampName: (C Q E) Value of the last stamp name
    :type lastStampName: string
    :param lowerradius: (C Q E) Sets the lower size of the brush (only apply on tablet)
    :type lowerradius: float
    :param makeStroke: (C Q E M) Stroke point values
    :type makeStroke: int
    :param mappressure: (C Q E) Sets the tablet pressure mapping when the table is used  There
    are four options: "none" - the pressure has no effect, "opacity" - the pressure is map
    :type mappressure: string
    :param maxvalue: (C Q E) Specifies the maximum value for each attribute  C: Default is 1.0 
    Q: When queried, it returns a float
    :type maxvalue: float
    :param minvalue: (C Q E) Specifies the minimum value for each attribute  C: Default is 0.0 
    Q: When queried, it returns a float
    :type minvalue: float
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param objattrArray: (Q) An array of all paintable attributes  Each element of the array is
    a string with the following information: NodeType.NodeName.AttributeName.MenuType
    :type objattrArray: string
    :param opacity: (C Q E) Sets the brush opacity  C: Default is 1.0  Q: When queried, it
    returns a float
    :type opacity: float
    :param outline: (C Q E) Specifies if the brush should be drawn  C: Default is TRUE  Q: When
    queried, it returns a boolean
    :type outline: boolean
    :param outwhilepaint: (C Q E) Specifies if the brush outline should be drawn while painting
     C: Default is FALSE  Q: When queried, it returns a boolean
    :type outwhilepaint: boolean
    :param paintComponent: (C Q E) Specifies whether face or vertex or vertex face is being
    painted  1 - Vertex 2 - VertexFace 3 - Face C: Default is Vertex  Q: When queried, it
    return
    :type paintComponent: int
    :param paintNodeArray: (Q) An array of paintable nodes  Q: When queried, it returns a
    string
    :type paintNodeArray: string
    :param paintNumChannels: (C Q E) Number of channels to paint - 1 (alpha), 3 (RGB), or 4
    (RGBA)
    :type paintNumChannels: int
    :param paintRGBA: (C Q E) Specifies whether RGB or RGBA channels are being painted  TRUE:
    RGBA channels  FALSE: RGB channels  Alpha channel remains unaffected  C: Default is F
    :type paintRGBA: boolean
    :param paintVertexFace: (C Q E) Specifies whether vertex face is being painted  TRUE:
    Vertex face being painted  (Allows each face connected to the vertex to be painted) FALSE:
    Vert
    :type paintVertexFace: boolean
    :param paintattrselected: (E) An array of selected paintable attributes  Each element of
    the array is a string with the following information: NodeType.NodeName.AttributeName
    :type paintattrselected: string
    :param paintmode: (C Q E) Specifies the paint mode  There are two possibilities: "screen"
    and "tangent"  C: Default is "screen"  Q: When queried, it returns a string
    :type paintmode: string
    :param paintoperationtype: (C Q E) Specifies the operation type used by the Paint Tool 
    Currently, we support the following paint modes: "Paint", "Smear", "Blur", "Erase" and
    "Clone"
    :type paintoperationtype: string
    :param pickColor: (C Q E) Set pick color mode on or off
    :type pickColor: boolean
    :param pickValue: (C Q E) Toggle for picking
    :type pickValue: boolean
    :param playbackCursor: (C Q E M) Values for the playback cursor
    :type playbackCursor: [float, float]
    :param playbackPressure: (C Q E M) Valus for the playback pressure
    :type playbackPressure: float
    :param preserveclonesource: (C Q E) Whether or not to preserve a clone source
    :type preserveclonesource: boolean
    :param profileShapeFile: (Q E) Passes a name of the image file for the stamp shape profile
    :type profileShapeFile: string
    :param projective: (C Q E) Specifies the projective paint mode  C: Default is 'false'  Q:
    When queried, it returns a boolean
    :type projective: boolean
    :param radius: (C Q E) Sets the size of the brush  C: Default is 1.0 cm  Q: When queried,
    it returns a float
    :type radius: float
    :param rampMaxColor: (C Q E) Defines a special color to be used when the value is greater
    than or equal to the maximum value
    :type rampMaxColor: [float, float, float]
    :param rampMinColor: (C Q E) Defines a special color to be used when the value is less than
    or equal to the minimum value
    :type rampMinColor: [float, float, float]
    :param record: (C Q E) Toggle on for recording
    :type record: boolean
    :param reflection: (C Q E) Specifies the reflection mode  C: Default is 'false'  Q: When
    queried, it returns a boolean
    :type reflection: boolean
    :param reflectionaboutorigin: (C Q E) Toggle on to reflect about the origin
    :type reflectionaboutorigin: boolean
    :param reflectionaxis: (C Q E) Specifies the reflection axis  There are three
    possibilities: "x", "y" and "z"  C: Default is "x"  Q: When queried, it returns a string
    :type reflectionaxis: string
    :param screenRadius: (C Q E) Brush radius on the screen
    :type screenRadius: float
    :param selectclonesource: (C Q E) Toggle on to select the clone source
    :type selectclonesource: boolean
    :param selectedattroper: (C Q E) Sets the edit weight operation  Four edit weights
    operations are provided : "absolute" - the value of the weight is replaced by the current
    one, "add
    :type selectedattroper: string
    :param showactive: (C Q E) Sets on/off the display of the surface isoparms  C: Default is
    TRUE  Q: When queried, it returns a boolean
    :type showactive: boolean
    :param stampDepth: (C Q E) Depth of the stamps
    :type stampDepth: float
    :param stampProfile: (C Q E) Sets the brush profile of the current stamp  Currently, the
    following profiles are supported: "gaussian", "poly", "solid" and "square"  C: Default is
    :type stampProfile: string
    :param stampSpacing: (C Q E) Specifies the stamp spacing  Default is 1.0
    :type stampSpacing: float
    :param strokesmooth: (C Q E) Stroke smoothing type name
    :type strokesmooth: string
    :param surfaceConformedBrushVertices: (C Q E) Enables/disables the the display of the
    effective brush area as affected vertices
    :type surfaceConformedBrushVertices: boolean
    :param tablet: (Q) Returns true if the tablet device is present, false if it is absent
    :type tablet: boolean
    :param tangentOutline: (C Q E) Enables/disables the display of the brush circle tangent to
    the surface
    :type tangentOutline: boolean
    :param toolOffProc: (C Q E) Accepts a strings describing the name of a MEL procedure that
    is invoked whenever the tool is turned off  For example, cloth invokes "clothPaintToolO
    :type toolOffProc: string
    :param toolOnProc: (C Q E) Accepts a strings describing the name of a MEL procedure that is
    invoked whenever the tool is turned on  For example, cloth invokes "clothPaintToolOn
    :type toolOnProc: string
    :param useColorRamp: (C Q E) Specifies whether the user defined color ramp should be used
    to map values from to colors  If this is turned off, the default greyscale feedback will
    :type useColorRamp: boolean
    :param useMaxMinColor: (C Q E) Specifies whether the out of range colors should be used 
    See rampMinColor and rampMaxColor flags for further details
    :type useMaxMinColor: boolean
    :param usepressure: (C Q E) Sets the tablet pressure on/off  C: Default is false  Q: When
    queried, it returns a boolean
    :type usepressure: boolean
    :param value: (C Q E) Specifies the value for each attribute  C: Default is 0.0  Q: When
    queried, it returns a float
    :type value: float
    :param vertexColorRange: (C Q E) Specifies whether the vertex color range should be applied
    to the currently selected object  C: Default is false Q: When queried, it returns a boolea
    :type vertexColorRange: boolean
    :param vertexColorRangeLower: (C Q E) Specifies the min value of the vertex color range  C:
    Default is 0.0  Q: When queried, it returns a float
    :type vertexColorRangeLower: float
    :param vertexColorRangeUpper: (C Q E) Specifies the max value of the vertex color range  C:
    Default is 1.0  Q: When queried, it returns a float
    :type vertexColorRangeUpper: float
    :param whichTool: (C Q E) The string defines the name of the tool to be used for the
    Artisan context  An example is "artClothPaint"  In query mode, the tool name for the given
    :type whichTool: string
    :param worldRadius: (C Q E) Radius in worldspace
    :type worldRadius: float
    
    :returns: 
    :rtype: None
    """
    pass


def GoToMaxFrame(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def requires(*args, dataType="", nodeType="", **kwargs):
    """
    This command is used during file I/O to specify the requirements needed to load the given
    file  It defines what file format version was used to write the file, or what plug-ins are
    required to load the scene   The first string names a product (either "maya", or a plug-in
    name)  The second string gives the version  This command is only useful during
    
    :param dataType: (C M) Specify a data type defined by this plug-in  The data type is
    specified by MFnPlugin::registerData() when register the plug-in
    :type dataType: string
    :param nodeType: (C M) Specify a node type defined by this plug-in  The node type is
    specified by MFnPlugin::registerNode() when register the plug-in
    :type nodeType: string
    
    :returns: 
    :rtype: None
    """
    pass


def SmoothBindSkinOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ConvertSelectionToContainedEdges(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyMoveVertex(*args, caching=True, constructionHistory=True, gain=1.0, localDirection=None,
                   localDirectionX=0.0, localDirectionY=0.0, localDirectionZ=0.0,
                   localTranslate=None, localTranslateX=0.0, localTranslateY=0.0,
                   localTranslateZ=0.0, name="", nodeState=0, pivot=None, pivotX=0.0,
                   pivotY=0.0, pivotZ=0.0, random=0.0, rotate=None, rotateX=0.0, rotateY=0.0,
                   rotateZ=0.0, scale=None, scaleX=0.0, scaleY=0.0, scaleZ=0.0, translate=None,
                   translateX=0.0, translateY=0.0, translateZ=0.0, worldSpace=True, q=True,
                   query=True, e=True, edit=True, **kwargs):
    """
    Modifies vertices of a polygonal object  Translate, rotate or scale vertices in local or
    world space
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param gain: (C Q E M) Gain factor per component  Can be painted using Artisan  Default:
    1.0
    :type gain: float
    :param localDirection: (C Q E) Direction to determine X axis for local space  Default: 1.0,
    0.0, 0.0
    :type localDirection: [float, float, float]
    :param localDirectionX: (C Q E) X coord of the X axis
    :type localDirectionX: float
    :param localDirectionY: (C Q E) Y coord of the X axis
    :type localDirectionY: float
    :param localDirectionZ: (C Q E) Z coord of the X axis
    :type localDirectionZ: float
    :param localTranslate: (C Q E) Local translate  Default: 0.0, 0.0, 0.0
    :type localTranslate: [float, float, float]
    :param localTranslateX: (C Q E) Local translation X coord
    :type localTranslateX: float
    :param localTranslateY: (C Q E) Local translation Y coord
    :type localTranslateY: float
    :param localTranslateZ: (C Q E) Local translation Z coord : Move along the normal
    :type localTranslateZ: float
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param pivot: (C Q E) The pivot for scaling and rotation  Default: 0.0, 0.0, 0.0
    :type pivot: [float, float, float]
    :param pivotX: (C Q E) Pivot X coord
    :type pivotX: float
    :param pivotY: (C Q E) Pivot Y coord
    :type pivotY: float
    :param pivotZ: (C Q E) Pivot Z coord
    :type pivotZ: float
    :param random: (C Q E) Random value for all parameters  Default: 0.0
    :type random: float
    :param rotate: (C Q E) Rotation angles around X, Y, Z  Default: 0.0, 0.0, 0.0
    :type rotate: [float, float, float]
    :param rotateX: (C Q E) Rotation angle around X
    :type rotateX: float
    :param rotateY: (C Q E) Rotation angle around Y
    :type rotateY: float
    :param rotateZ: (C Q E) Rotation angle around Z
    :type rotateZ: float
    :param scale: (C Q E) Scaling vector  Default: 1.0, 1.0, 1.0
    :type scale: [float, float, float]
    :param scaleX: (C Q E) Scale X coord
    :type scaleX: float
    :param scaleY: (C Q E) Scale Y coord
    :type scaleY: float
    :param scaleZ: (C Q E) Scale Z coord
    :type scaleZ: float
    :param translate: (C Q E) Translation vector  Default: 0.0, 0.0, 0.0
    :type translate: [float, float, float]
    :param translateX: (C Q E) Translation X coord
    :type translateX: float
    :param translateY: (C Q E) Translation Y coord
    :type translateY: float
    :param translateZ: (C Q E) Translation Z coord
    :type translateZ: float
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def HypershadeDeleteDuplicateShadingNetworks(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SubdivSmoothnessRoughOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OutTangentClamped(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def srtContext(*args, exists=True, history=True, image1="", image2="", image3="", name="",
               q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command can be used to create a combined transform (translate/scale/rotate) context
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: - name of the newly created context
    :rtype: string
    """
    pass


def orientConstraint(*args, createCache=None, deleteCache=True, layer="", maintainOffset=True,
                     name="", offset=None, remove=True, skip="", targetList=True, weight=0.0,
                     weightAliasList=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Constrain an object's orientation to match the orientation of the target or the average of
    a number of targets   An orientConstraint takes as input one or more "target" DAG transform
    nodes to control the orientation of the single "constraint object" DAG transform The
    orientConstraint orients the constrained object to match the weighted average of t
    
    :param createCache: (E) This flag is used to generate an animation curve that serves as a
    cache for the constraint  The two arguments define the start and end frames  The ca
    :type createCache: [float, float]
    :param deleteCache: (E) Delete an existing interpolation cache
    :type deleteCache: boolean
    :param layer: (C E) Specify the name of the animation layer where the constraint should be
    added
    :type layer: string
    :param maintainOffset: (C) The offset necessary to preserve the constrained object's
    initial orientation will be calculated and used as the offset
    :type maintainOffset: boolean
    :param name: (C Q E) Sets the name of the constraint node to the specified name  Default
    name is constrainedObjectName_constraintType
    :type name: string
    :param offset: (C Q E) Sets or queries the value of the offset  Default is 0,0,0
    :type offset: [float, float, float]
    :param remove: (E) removes the listed target(s) from the constraint
    :type remove: boolean
    :param skip: (C E M) Specify the axis to be skipped  Valid values are "x", "y", "z" and
    "none"  The default value in create mode is "none"  This flag is multi-use
    :type skip: string
    :param targetList: (Q) Return the list of target objects
    :type targetList: boolean
    :param weight: (C Q E) Sets the weight value for the specified target(s)  If not given at
    creation time, the default value of 1.0 is used
    :type weight: float
    :param weightAliasList: (Q) Returns the names of the attributes that control the weight of
    the target objects  Aliases are returned in the same order as the targets are returned
    :type weightAliasList: boolean
    
    :returns: [] ( name of the created constraint node)
    :rtype: string
    """
    pass


def SetTimecode(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSetFreezeBrushTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def geoUtils(*args, **kwargs):
    """
    
    """
    pass


def PolyConvertToRingAndCollapse(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ImportDeformerWeights(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FlowPathObjectOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def viewHeadOn(*args, **kwargs):
    """
    The viewHeadOn command positions the specified camera so it is looking "down" the normal of
    the live object, and fitted to the live object  If the live object is a surface, an
    arbitrary normal is chosen
    
    
    :returns: 
    :rtype: None
    """
    pass


def ikHandle(*args, autoPriority=True, connectEffector=True, createCurve=True,
             createRootAxis=True, curve=None, disableHandles=True, enableHandles=True,
             endEffector="", exists="", forceSolver=True, freezeJoints=True, jointList=True,
             name="", numSpans=0, parentCurve=True, positionWeight=0.0, priority=0,
             rootOnCurve=True, rootTwistMode=True, setupForRPsolver=True, simplifyCurve=True,
             snapCurve=True, snapHandleFlagToggle=True, snapHandleToEffector=True, solver="",
             startJoint="", sticky="", twistType="", weight=0.0, q=True, query=True, e=True,
             edit=True, **kwargs):
    """
    The handle command is used to create, edit, and query a handle within Maya  The standard
    edit (-e) and query (-q) flags are used for edit and query functions   If there are 2
    joints selected and neither -startJoint nor -endEffector flags are not specified, then the
    handle will be created from the selected joints   If a single joint is selected and 
    
    :param autoPriority: (E) Specifies that this handle's priority is assigned automatically 
    The assigned priority will be based on the hierarchy distance from the root of the s
    :type autoPriority: boolean
    :param connectEffector: (C E) This option is set to true as default, meaning that
    end-effector translate is connected with the endJoint translate
    :type connectEffector: boolean
    :param createCurve: (C) Specifies if a curve should automatically be created for the
    ikSplineHandle
    :type createCurve: boolean
    :param createRootAxis: (C) Specifies if a root transform should automatically be created
    above the joints affected by the ikSplineHandle  This option is used to prevent the roo
    :type createRootAxis: boolean
    :param curve: (C Q E) Specifies the curve to be used by the ikSplineHandle  Joints will be
    moved to align with this curve  This flag is mandatory if you use the -freezeJoi
    :type curve: name
    :param disableHandles: (E) set given handles to full fk (ikBlend attribute = 0.0)
    :type disableHandles: boolean
    :param enableHandles: (E) set given handles to full ik (ikBlend attribute = 1.0)
    :type enableHandles: boolean
    :param endEffector: (C Q E) Specifies the end-effector of the handle's joint chain  The end
    effector may be specified with a joint or an end-effector  If a joint is specified, a
    :type endEffector: string
    :param exists: (E) Indicates if the specified handle exists or not
    :type exists: string
    :param forceSolver: (C Q E) Forces the solver to be used everytime  It could also be known
    as animSticky  So, after you set the first key the handle is sticky
    :type forceSolver: boolean
    :param freezeJoints: (C E) Forces the curve, specfied by -curve option, to align itself
    along the existing joint chain  When false, or unspecified, the joints will be moved to
    :type freezeJoints: boolean
    :param jointList: (E) Returns the list of joints that the handle is manipulating
    :type jointList: boolean
    :param name: (C Q E) Specifies the name of the handle
    :type name: string
    :param numSpans: (C) Specifies the number of spans in the automatically generated curve of
    the ikSplineHandle
    :type numSpans: int
    :param parentCurve: (C) Specifies if the curve should automatically be parented to the
    parent of the first joint affected by the ikSplineHandle
    :type parentCurve: boolean
    :param positionWeight: (C Q E) Specifies the position/orientation weight of a handle  This
    is used to compute the "distance" between the goal position and the end-effector position
    :type positionWeight: float
    :param priority: (C Q E) Sets the priority of the handle  Logically, all handles with a
    lower number priority are solved before any handles with a higher numbered priority  (
    :type priority: int
    :param rootOnCurve: (C Q E) Specifies if the root is locked onto the curve of the
    ikSplineHandle
    :type rootOnCurve: boolean
    :param rootTwistMode: (C Q E) Specifies whether the start joint is allowed to twist or not 
    If not, then the required twist is distributed over the remaining joints  This applies
    :type rootTwistMode: boolean
    :param setupForRPsolver: (E) If the flag is set and ikSolver is ikRPsolver, call
    RPRotateSetup for the new ikHandle  It is for ikRPsolver only
    :type setupForRPsolver: boolean
    :param simplifyCurve: (C) Specifies if the ikSplineHandle curve should be simplified
    :type simplifyCurve: boolean
    :param snapCurve: (C) Specifies if the curve should automatically snap to the first joint
    affected by the ikSplineHandle
    :type snapCurve: boolean
    :param snapHandleFlagToggle: (C Q E) Specifies that the handle position should be snapped
    to the end-effector position if the end-effector is moved by the user  Setting this flag on
    allo
    :type snapHandleFlagToggle: boolean
    :param snapHandleToEffector: (E) All handles are immediately moved so that the handle
    position and orientation matches the end-effector position and orientation
    :type snapHandleToEffector: boolean
    :param solver: (C Q E) Specifies the solver  The complete list of available solvers may not
    be known until run-time because some of the solvers may be implemented as plug-i
    :type solver: string
    :param startJoint: (C Q E) Specifies the start joint of the handle's joint chain
    :type startJoint: string
    :param sticky: (C Q E) Specifies that this handle is "sticky"  Valid values are "off",
    "sticky", "superSticky"  Sticky handles are solved when the skeleton is being manipul
    :type sticky: string
    :param twistType: (C Q E) Specifies the type of interpolation to be used by the
    ikSplineHandle  The interpolation options are "linear", "easeIn", "easeOut", and
    "easeInOut"
    :type twistType: string
    :param weight: (C Q E) Specifies the handles weight in error calculations  The weight only
    applies when handle goals are in conflict and cannot be solved simultaneously  Wh
    :type weight: float
    
    :returns: Command result
    :rtype: string
    """
    pass


def mrMapVisualizer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sbs_GoToMarketPlace(*args, **kwargs):
    """
    
    """
    pass


def VertexNormalEditTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def typeManipContextCommand(*args, **kwargs):
    """
    
    """
    pass


def SelectHullsMask(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def renderWindowSelectContext(*args, exists=True, image1="", image2="", image3="", q=True,
                              query=True, e=True, edit=True, **kwargs):
    """
    Set the selection context for the render view panel
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    
    :returns: Context name
    :rtype: string
    """
    pass


def dR_showAbout(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def addDynamicAttribute(*args, **kwargs):
    """
    
    """
    pass


def error(*args, noContext=True, showLineNumber=True, **kwargs):
    """
    The error command is provided so that the user can issue error messages from his/her
    scripts and control execution in the event of runtime errors   The string argument is
    displayed in the command window (or stdout if running in batch mode) after being prefixed
    with an error message heading and surrounded by //   The error command also causes
    execut
    
    :param noContext: (C) Do not include the context information with the error message
    :type noContext: boolean
    :param showLineNumber: (C) Obsolete  Will be deleted in the next version of Maya  Use the
    checkbox in the script editor that enables line number display instead
    :type showLineNumber: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def MirrorPolygonGeometryOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowHotbox(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def defineVirtualDevice(*args, axis=0, channel="", clear=True, create=True, device="",
                        parent="", undefine=True, usage="", q=True, query=True, **kwargs):
    """
    This command defines a virtual device  Virtual devices act like real devices and are useful
    to manipulate/playback data when an command device is not connected to the computer
    
    :param axis: (C) Specifies the axis number of the channel  All children have their axis
    number determined by their parent's axis number and the width of the parent ch
    :type axis: int
    :param channel: (C) After a -create is started, channels may be added to the device
    definition  The channel string wil be the name of the channel being added to the devi
    :type channel: string
    :param clear: (C) The -clear option will end a device definition and throw away any defined
    channels
    :type clear: boolean
    :param create: (C) Start defining a virtual device  If a device is currently being defined,
    the -create flag will produce an error
    :type create: boolean
    :param device: (C) The -device flag ends the device definition  All of the channels between
    the -create flag and the -device flag are added to the specified device  If
    :type device: string
    :param parent: (C) Specified the parent channel of the channel being defined  If the
    channel does not exist, or is an incompatible type, the command will fail
    :type parent: string
    :param undefine: (C) Undefines the device specified with the -device flag
    :type undefine: boolean
    :param usage: (C) rotZ
    :type usage: string
    
    :returns: 
    :rtype: None
    """
    pass


def LayerRelationshipEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmSplinePreset(*args, **kwargs):
    """
    
    """
    pass


def CurveFlowOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def savePrefObjects(*args, **kwargs):
    """
    This command saves preference dependency nodes to "userPrefObjects.ma" in the user
    preference directory
    
    
    :returns: True if successful.
    :rtype: boolean
    """
    pass


def xgmSmoothBrushToolCmd(*args, **kwargs):
    """
    
    """
    pass


def DopeSheetEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleOppositeFlagOfSelectedShapes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmGroomTransfer(*args, **kwargs):
    """
    
    """
    pass


def xgmMakeGuideDynamic(*args, **kwargs):
    """
    
    """
    pass


def CVHardness(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreatePolygonTorusOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmCreateSplineDescription(*args, **kwargs):
    """
    
    """
    pass


def TimeEditorCreateOverrideLayer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RenderLayerRelationshipEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_modePoly(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyForceUV(*args, cameraProjection=True, createNewMap=True, flipHorizontal=True,
                flipVertical=True, g=True, local=True, normalize="", numItems=0,
                preserveAspectRatio=True, unitize=True, unshare=True, uvSetName="", **kwargs):
    """
    A set of functionalities can be called through this command  The input for this command is
    a set of faces  Based on the arguments passed, the UVs for these selected faces can be
    created
    
    :param cameraProjection: (C) Project the UVs based on the camera position/orientation
    :type cameraProjection: boolean
    :param createNewMap: (C) Create new map if it does not exist
    :type createNewMap: boolean
    :param flipHorizontal: (C) OBSOLETE flag  Use polyFlipUV instead
    :type flipHorizontal: boolean
    :param flipVertical: (C) OBSOLETE flag  Use polyFlipUV instead
    :type flipVertical: boolean
    :param g: (C) OBSOLETE flag
    :type g: boolean
    :param local: (C) OBSOLETE flag
    :type local: boolean
    :param normalize: (C) OBSOLETE flag  Use polyNormalizeUV instead
    :type normalize: string
    :param numItems: (C) This flag is only used for the best plane texturing of polygonal faces
     This flag should be followed by a selection list  If not specified, the selec
    :type numItems: int
    :param preserveAspectRatio: (C) OBSOLETE flag
    :type preserveAspectRatio: boolean
    :param unitize: (C) To unitize the UVs of the selected faces
    :type unitize: boolean
    :param unshare: (C) To unshare tye specified UV
    :type unshare: boolean
    :param uvSetName: (C) Specifies name of the uv set to work on
    :type uvSetName: string
    
    :returns: true/false
    :rtype: boolean
    """
    pass


def SelectEdgeLoop(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PlaybackBackward(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def hardwareRenderPanel(*args, camera="", control=True, copy="", createString=True,
                        defineTemplate="", docTag="", editString=True, exists=True,
                        glRenderEditor=True, init=True, isUnique=True, label="",
                        menuBarRepeatLast=True, menuBarVisible=True, needsInit=True, parent="",
                        popupMenuProcedure=None, replacePanel="", tearOff=True, tearOffCopy="",
                        tearOffRestore=True, unParent=True, useTemplate="", q=True, query=True,
                        e=True, edit=True, **kwargs):
    """
    This command creates, edit and queries hardware render panels which contain only a hardware
    render editor
    
    :param camera: (Q E) Query or edit the camera in a gl render panel
    :type camera: string
    :param control: (Q) Returns the top level control for this panel  Usually used for getting
    a parent to attach popup menus  CAUTION: panels may not have controls at times
    :type control: boolean
    :param copy: (E) Makes this panel a copy of the specified panel  Both panels must be of the
    same type
    :type copy: string
    :param createString: (E) Command string used to create a panel
    :type createString: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Attaches a tag to the Maya panel
    :type docTag: string
    :param editString: (E) Command string used to edit a panel
    :type editString: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param glRenderEditor: (Q) Query only  This flag returns the name of the gl render editor
    contained in the panel
    :type glRenderEditor: boolean
    :param init: (C E) Initializes the panel's default state  This is usually done
    automatically on file -new and file -open
    :type init: boolean
    :param isUnique: (Q) Returns true if only one instance of this panel type is allowed
    :type isUnique: boolean
    :param label: (Q E) Specifies the user readable label for the panel
    :type label: string
    :param menuBarRepeatLast: (C Q E) Controls whether clicking on the menu header with the
    middle mouse button would repeat the last selected menu item
    :type menuBarRepeatLast: boolean
    :param menuBarVisible: (C Q E) Controls whether the menu bar for the panel is displayed
    :type menuBarVisible: boolean
    :param needsInit: (Q E) (Internal) On Edit will mark the panel as requiring initialization 
    Query will return whether the panel is marked for initialization  Used during fil
    :type needsInit: boolean
    :param parent: (C) Specifies the parent layout for this panel
    :type parent: string
    :param popupMenuProcedure: (Q E) Specifies the procedure called for building the panel's
    popup menu(s)  The default value is "buildPanelPopupMenu"  The procedure should take one
    stri
    :type popupMenuProcedure: script
    :param replacePanel: (E) Will replace the specified panel with this panel  If the target
    panel is within the same layout it will perform a swap
    :type replacePanel: string
    :param tearOff: (Q E) Will tear off this panel into a separate window with a paneLayout as
    the parent of the panel  When queried this flag will return if the panel has bee
    :type tearOff: boolean
    :param tearOffCopy: (C) Will create this panel as a torn of copy of the specified source
    panel
    :type tearOffCopy: string
    :param tearOffRestore: (C E) Restores panel if it is torn off and focus is given to it  If
    docked, becomes the active panel in the docked window  This should be the default flag
    :type tearOffRestore: boolean
    :param unParent: (E) Specifies that the panel should be removed from its layout  This
    (obviously) cannot be used with query
    :type unParent: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: Panel name
    :rtype: string
    """
    pass


def cMuscleRayIntersect(*args, **kwargs):
    """
    
    """
    pass


def ToggleBackfaceCulling(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyPyramid(*args, axis=None, caching=True, constructionHistory=True, createUVs=2, name="",
                nodeState=0, numberOfSides=4, numderOfSides=4, object=True, sideLength=1.0,
                subdivisionsCaps=0, subdivisionsHeight=1, texture=True, q=True, query=True,
                e=True, edit=True, **kwargs):
    """
    The pyramid command creates a new polygonal pyramid
    
    :param axis: (C Q E) This flag specifies the primitive axis used to build the pyramid  Q:
    When queried, this flag returns a float[3]
    :type axis: [float, float, float]
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param createUVs: (C Q E) Create UVs or not  0: No UVs 1: No Normalization 2: Normalize 3:
    Normalize and Preserve Aspect Ratio Default: 2
    :type createUVs: int
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param numberOfSides: (C Q E) Number of sides of Pyramid  Default: 4
    :type numberOfSides: int
    :param numderOfSides: (C Q E) Number of sides of Pyramid  Default: 4
    :type numderOfSides: int
    :param object: (C) Create the result, or just the dependency node (where applicable)
    :type object: boolean
    :param sideLength: (C Q E) Side length of the Pyramid  Default: 1.0
    :type sideLength: float
    :param subdivisionsCaps: (C Q E) Subdivisions on bottom cap Default: 0
    :type subdivisionsCaps: int
    :param subdivisionsHeight: (C Q E) Subdivisions along the height  Default: 1
    :type subdivisionsHeight: int
    :param texture: (C Q E) Apply texture or not  Default: true
    :type texture: boolean
    
    :returns: Object name and node name.
    :rtype: string[]
    """
    pass


def PixelMoveRight(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def alignCtx(*args, align=True, anchorFirstObject=False, distribute=True, exists=True,
             history=True, image1="", image2="", image3="", name="", showAlignTouch=True,
             q=True, query=True, e=True, edit=True, **kwargs):
    """
    The alignCtx command creates a tool for aligning and distributing objects
    
    :param align: (C Q E) Align objects
    :type align: boolean
    :param anchorFirstObject: (C Q E) Anchor first or last selected object  Default false  Only
    applicable when aligning objects
    :type anchorFirstObject: boolean
    :param distribute: (C Q E) Distribute objects
    :type distribute: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param showAlignTouch: (C Q E) Show or hide align touching handles  Default true  Only
    applicable when aligning objects
    :type showAlignTouch: boolean
    
    :returns: (name of the new context)
    :rtype: string
    """
    pass


def paint3d(*args, **kwargs):
    """
    
    """
    pass


def FBXImportCameras(*args, **kwargs):
    """
    
    """
    pass


def geometryDeleteCacheFramesOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GetProperty2StateAttrNameFromHIKEffectorId(*args, **kwargs):
    """
    
    """
    pass


def RemoveSubdivProxyMirrorOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleFocalLength(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def menuSetPref(*args, exists=True, force=True, loadAll=True, removeAll=True, saveAll=True,
                saveBackup=True, version=True, q=True, query=True, e=True, edit=True,
                **kwargs):
    """
    Provides the functionality to save and load menuSets between sessions of Maya  For Internal
    Use Only!
    
    :param exists: (Q) Returns whether the menuSet preferences file exists or not
    :type exists: boolean
    :param force: (C E) Forces a specified operation to continue even if errors are encountered
    (such as invalid preferences)
    :type force: boolean
    :param loadAll: (C) Loads all the menuSets from the preferences file only if the
    preferences version matches, or the -force flag is enabled  On successful load, of a pre
    :type loadAll: boolean
    :param removeAll: (C) Removes all the menuSets from the preferences file (removes the whole
    file)
    :type removeAll: boolean
    :param saveAll: (C) Saves all the current menuSets into the preferences file
    :type saveAll: boolean
    :param saveBackup: (C) Saves a backup of the current menu set preferences file if one
    exists  This backup will be saved in the same location as the current preferences file
    :type saveBackup: boolean
    :param version: (Q) The base version string which is saved out to file  It is also checked
    upon loading in order to indicate changes in the default prefs since the prefs
    :type version: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def greaseRenderPlane(*args, **kwargs):
    """
    
    """
    pass


def polyCutUVCtx(*args, loopSpeed=0, mapBordersColor=None, showCheckerMap=True,
                 showTextureBorders=True, showUVShellColoring=True, steadyStroke=True,
                 steadyStrokeDistance=0.0, symmetry=0, q=True, query=True, e=True, edit=True,
                 **kwargs):
    """
    Create a new context to cut UVs on polygonal objects
    
    :param loopSpeed: (Q E) Edit the speed of loop cutting
    :type loopSpeed: int
    :param mapBordersColor: (Q E) Color of UV map border edges in 3d view
    :type mapBordersColor: [float, float, float]
    :param showCheckerMap: (Q E) Display checker map
    :type showCheckerMap: boolean
    :param showTextureBorders: (Q E) Display texture border edges
    :type showTextureBorders: boolean
    :param showUVShellColoring: (Q E) Turn on UV shell coloring or not
    :type showUVShellColoring: boolean
    :param steadyStroke: (Q E) Turn on steady stroke or not
    :type steadyStroke: boolean
    :param steadyStrokeDistance: (Q E) The distance for steady stroke
    :type steadyStrokeDistance: float
    :param symmetry: (Q E) Symmetric modeling
    :type symmetry: int
    
    :returns: Whether steady stroke is on or not, when querying the steadyStroke flag.
    :rtype: boolean
    """
    pass


def HideLattices(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def extrude(*args, caching=True, degreeAlongLength=1, direction=None, directionX=0,
            directionY=1, directionZ=0, extrudeType=2, fixedPath=False, length=1, nodeState=0,
            pivot=None, reverseSurfaceIfPathReversed=False, rotation=0.0, scale=1.0,
            subCurveSubSurface=False, useComponentPivot=0, useProfileNormal=False,
            constructionHistory=True, mergeItems=True, name="", object=True, polygon=0,
            range=True, rebuild=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command computes a surface given a profile curve and possibly a path curve  There are
    three ways to extrude a profile curve  The most basic method is called a "distance" extrude
    where direction and length are specified  No path curve is necessary in this case  The
    second method is called "flat" extrude  This method sweeps the profile curve dow
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param degreeAlongLength: (C Q E) Surface degree along the distance when a distance extrude
    is performed Default: 1
    :type degreeAlongLength: int
    :param direction: (C Q E) The direction in which to extrude  Use only for distance
    extrudeType and useProfileNormal off
    :type direction: [float, float, float]
    :param directionX: (C Q E) X of the direction Default: 0
    :type directionX: float
    :param directionY: (C Q E) Y of the direction Default: 1
    :type directionY: float
    :param directionZ: (C Q E) Z of the direction Default: 0
    :type directionZ: float
    :param extrudeType: (C Q E) The extrude type (distance-0, flat-1, or tube-2) Default: 2
    :type extrudeType: int
    :param fixedPath: (C Q E) If true, the resulting surface will be placed at the path curve 
    Otherwise, the resulting surface will be placed at the profile curve  Default: false
    :type fixedPath: boolean
    :param length: (C Q E) The distance to extrude  Use only for distance extrudeType Default:
    1
    :type length: float
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param pivot: (C Q E) The pivot point used for tube extrudeType
    :type pivot: [float, float, float]
    :param reverseSurfaceIfPathReversed: (C Q E) If true, extrude type is tube (2) and path has
    been internally reversed then computed surface is reversed in the direction corresponding
    to the path
    :type reverseSurfaceIfPathReversed: boolean
    :param rotation: (C Q E) Amount to rotate the profile curve as it sweeps along the path
    curve  Default: 0.0
    :type rotation: float
    :param scale: (C Q E) Amount to scale the profile curve as it sweeps along the path curve 
    Default: 1.0
    :type scale: float
    :param subCurveSubSurface: (C Q E) If true, curve range on the path will get applied to the
    resulting surface instead of cut before the extrude  Default: false
    :type subCurveSubSurface: boolean
    :param useComponentPivot: (C Q E) Use closest endpoint of the path - 0, component pivot - 1
    or the center of the bounding box of the profile - 2 Default: 0
    :type useComponentPivot: int
    :param useProfileNormal: (C Q E) If true, use the profile curve normal for the direction in
    which to extrude  Use only for distance or tube extrudeType  Default: false
    :type useProfileNormal: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param mergeItems: (C) Merge component results where possible  For example, instead of
    returning a[1] and a[2], return a[1:2]
    :type mergeItems: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param polygon: (C) The value of this argument controls the type of the object created by
    this operation 0: nurbs surface 1: polygon (use nurbsToPolygonsPref to set the
    :type polygon: int
    :param range: (C) Force a curve range on complete input curve
    :type range: boolean
    :param rebuild: (C) Rebuild the input curve(s) before using them in the operation  Use
    nurbsCurveRebuildPref to set the parameters for the conversion
    :type rebuild: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def CreateMotionTrail(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nucleusGetnParticleExample(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreatePolygonSoccerBall(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def convertUnit(*args, fromUnit="", toUnit="", **kwargs):
    """
    This command converts values between different units of measure  The command takes a string,
    because a string can incorporate unit names as well as values (see examples)
    
    :param fromUnit: (C) The unit to convert from  If not supplied, it is assumed to be the
    system default  The from unit may also be supplied as part of the value e.g  11.2m
    :type fromUnit: string
    :param toUnit: (C) The unit to convert to  If not supplied, it is assumed to be the system
    default
    :type toUnit: string
    
    :returns: or string
    :rtype: float
    """
    pass


def PaintOnPaintableObjects(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def camera(*args, aspectRatio=0.0, cameraScale=0.0, centerOfInterest=0.0, clippingPlanes=True,
           depthOfField=True, displayFieldChart=True, displayFilmGate=True,
           displayFilmOrigin=True, displayFilmPivot=True, displayGateMask=True,
           displayResolution=True, displaySafeAction=True, displaySafeTitle=True, fStop=0.0,
           farClipPlane=0.0, farFocusDistance=0.0, filmFit="", filmFitOffset=0.0,
           filmRollOrder="", filmRollValue=0.0, filmTranslateH=0.0, filmTranslateV=0.0,
           focalLength=0.0, focusDistance=0.0, homeCommand="", horizontalFieldOfView=0.0,
           horizontalFilmAperture=0.0, horizontalFilmOffset=0.0, horizontalPan=0.0,
           horizontalRollPivot=0.0, horizontalShake=0.0, journalCommand=True,
           lensSqueezeRatio=0.0, lockTransform=True, motionBlur=True, name="",
           nearClipPlane=0.0, nearFocusDistance=0.0, orthographic=True, orthographicWidth=0.0,
           overscan=0.0, panZoomEnabled=True, position=None, postScale=0.0, preScale=0.0,
           renderPanZoom=True, rotation=None, shakeEnabled=True, shakeOverscan=0.0,
           shakeOverscanEnabled=True, shutterAngle=0.0, startupCamera=True,
           stereoHorizontalImageTranslate=0.0, stereoHorizontalImageTranslateEnabled=True,
           verticalFieldOfView=0.0, verticalFilmAperture=0.0, verticalFilmOffset=0.0,
           verticalLock=True, verticalPan=0.0, verticalRollPivot=0.0, verticalShake=0.0,
           worldCenterOfInterest=None, worldUp=None, zoom=0.0, q=True, query=True, e=True,
           edit=True, **kwargs):
    """
    Create, edit, or query a camera with the specified properties    The resulting camera can
    be repositioned using the viewPlace command  Many of the camera settings only affect the
    resulting rendered image  E.g  the F/Stop, shutter speed, the film related options, etc 
    Scaling the camera icon does not change any camera properties
    
    :param aspectRatio: (C Q E) The ratio of the film back width to the film back height
    :type aspectRatio: float
    :param cameraScale: (C Q E) Scale the camera
    :type cameraScale: float
    :param centerOfInterest: (C Q E) Set the linear distance from the camera's eye point to the
    center of interest
    :type centerOfInterest: float
    :param clippingPlanes: (C Q E) Activate manual clipping planes
    :type clippingPlanes: boolean
    :param depthOfField: (C Q E) Determines whether a depth of field calculation is performed
    to give varying focus depending on the distance of the objects
    :type depthOfField: boolean
    :param displayFieldChart: (C Q E) Activate display of the video field chart when looking
    through the camera
    :type displayFieldChart: boolean
    :param displayFilmGate: (C Q E) Activate display of the film gate icons when looking
    through the camera
    :type displayFilmGate: boolean
    :param displayFilmOrigin: (C Q E) Activate the display of the film origin guide when
    looking through the camera
    :type displayFilmOrigin: boolean
    :param displayFilmPivot: (C Q E) Activate display of the film pivot guide when looking
    through the camera
    :type displayFilmPivot: boolean
    :param displayGateMask: (C Q E) Display the gate mask, file or resolution, as a shaded area
    to the edge of the viewport
    :type displayGateMask: boolean
    :param displayResolution: (C Q E) Activate display of the current rendering resolution (as
    defined in the render globals) when looking through the camera
    :type displayResolution: boolean
    :param displaySafeAction: (C Q E) Activate display of the video Safe Action guide when
    looking through the camera
    :type displaySafeAction: boolean
    :param displaySafeTitle: (C Q E) Activate display of the video Safe Title guide when
    looking through the camera
    :type displaySafeTitle: boolean
    :param fStop: (C Q E) A real lens normally contains a diaphragm or other stop which blocks
    some of the light that would otherwise pass through it  This stop is usually app
    :type fStop: float
    :param farClipPlane: (C Q E) Specify the distance to the far clipping plane
    :type farClipPlane: float
    :param farFocusDistance: (C Q E) Linear distance to the far focus plane
    :type farFocusDistance: float
    :param filmFit: (C Q E) This describes how the digital image (in pixels) relates to the
    film back  Since the film back is defined in terms of real numbers with some arbitrar
    :type filmFit: string
    :param filmFitOffset: (C Q E) Since we know from the above that the digital image may not
    match the film back exactly, we now have the question of how to position one relative to
    :type filmFitOffset: float
    :param filmRollOrder: (C Q E) Specifies how the roll is applied with respect to the pivot
    value  Rotate-Translate The film back is first rotated then translated by the pivot point
    :type filmRollOrder: string
    :param filmRollValue: (C Q E) This specifies that amount of rotation around the film back 
    The roll value is specified in degrees  The rotation occurs around the specified pivot p
    :type filmRollValue: float
    :param filmTranslateH: (C Q E) The horizontal film translation  Values are normalized to
    the viewing area
    :type filmTranslateH: float
    :param filmTranslateV: (C Q E) The vertical film translation  Values are normalized to the
    viewing area
    :type filmTranslateV: float
    :param focalLength: (C Q E) This is the distance along the lens axis between the lens and
    the film plane when "focal distance" is infinitely large  This is an optical property o
    :type focalLength: float
    :param focusDistance: (C Q E) Set the focus at a certain distance in front of the camera
    :type focusDistance: float
    :param homeCommand: (C Q E) Specify the command to execute when "viewSet -home" is applied
    to this camera  All occurances of "%camera" will be replaced with the cameras name bef
    :type homeCommand: string
    :param horizontalFieldOfView: (C Q E) This is the film back width as seen by the lens when
    focused at infinity (ie., focal length away) measured as an angle  Note that it has nothing
    to d
    :type horizontalFieldOfView: float
    :param horizontalFilmAperture: (C Q E) The horizontal width of the camera's film plane  The
    camera's film is located on the film plane  The extent of the film which will be exposed to
    an i
    :type horizontalFilmAperture: float
    :param horizontalFilmOffset: (C Q E) Horizontal offset from the center of the film back 
    Normally the film back will be centered on the lens axis  However, this need not be so 
    Film offs
    :type horizontalFilmOffset: float
    :param horizontalPan: (C Q E) Horizontal 2D camera pan (inches)
    :type horizontalPan: float
    :param horizontalRollPivot: (C Q E) The horizontal pivot point from the center of the film
    back  The pivot point is used during rotation of the film back  The pivot is the point
    where t
    :type horizontalRollPivot: float
    :param horizontalShake: (C Q E) Another horizontal offset from the center of the film back,
    which can be used and stored on the camera in addition to the horizonal film offset attri
    :type horizontalShake: float
    :param journalCommand: (C Q E) Journal interactive camera commands  Commands can be undone
    when a camera is journaled
    :type journalCommand: boolean
    :param lensSqueezeRatio: (C Q E) This is presently just an information field in the camera
    editor is meant to convey the horizontal distortion of the anamorphic lens normally used
    wi
    :type lensSqueezeRatio: float
    :param lockTransform: (C Q E) Lock the camera  When a camera is locked, its transformation
    information, that is, its Translate and Rotate properties cannot be adjusted, and the ce
    :type lockTransform: boolean
    :param motionBlur: (C Q E) Determines whether the camera's image is motion blured (as
    opposed to an object's image)  For example, if you want to blur the camera movement when y
    :type motionBlur: boolean
    :param name: (C Q E) Name of the camera
    :type name: string
    :param nearClipPlane: (C Q E) Specify the distance to the NEAR clipping plane
    :type nearClipPlane: float
    :param nearFocusDistance: (C Q E) Linear distance to the near focus plane
    :type nearFocusDistance: float
    :param orthographic: (C Q E) Activate the orthographic camera
    :type orthographic: boolean
    :param orthographicWidth: (C Q E) Set the orthographic projection width
    :type orthographicWidth: float
    :param overscan: (C Q E) Set the percent of overscan
    :type overscan: float
    :param panZoomEnabled: (C Q E) Toggle camera 2D pan and zoom
    :type panZoomEnabled: boolean
    :param position: (C Q E) Three linear values can be specified to translate the camera
    :type position: [float, float, float]
    :param postScale: (C Q E) The post-scale value  This value multiplied against the computed
    projection matrix  It is applied after the the film roll
    :type postScale: float
    :param preScale: (C Q E) The pre-scale value  The value is multiplied against the computed
    projection matrix  It is applied before the film roll
    :type preScale: float
    :param renderPanZoom: (C Q E) Toggle camera 2D pan and zoom in render
    :type renderPanZoom: boolean
    :param rotation: (C Q E) Three angular values can be specified to rotate the camera
    :type rotation: [float, float, float]
    :param shakeEnabled: (C Q E) Toggles the effect of the horizontal and vertical shake
    attributes
    :type shakeEnabled: boolean
    :param shakeOverscan: (C Q E) Controls the amount of overscan in the output rendered image 
    For use when adding film-based camera shake  Acts as a multiplier to the film aperture
    :type shakeOverscan: float
    :param shakeOverscanEnabled: (C Q E) Toggles the effect of the shake overscan attribute
    :type shakeOverscanEnabled: boolean
    :param shutterAngle: (C Q E) Specify the shutter angle (degrees)
    :type shutterAngle: float
    :param startupCamera: (C Q E) A startup camera is marked undeletable and implicit  This
    flag can be used to set or query the startup state of a camera  There must always be at
    lea
    :type startupCamera: boolean
    :param stereoHorizontalImageTranslate: (C Q E) A film-back offset for use in stereo camera
    rigs
    :type stereoHorizontalImageTranslate: float
    :param stereoHorizontalImageTranslateEnabled: (C Q E) Toggles the effect of the stereo HIT
    attribute
    :type stereoHorizontalImageTranslateEnabled: boolean
    :param verticalFieldOfView: (C Q E) Set the vertical field of view
    :type verticalFieldOfView: float
    :param verticalFilmAperture: (C Q E) The vertical height of the camera's film plane  This
    double precision parameter is always specified in inches
    :type verticalFilmAperture: float
    :param verticalFilmOffset: (C Q E) Vertical offset from the center of the film back  This
    double precision parameter is always specified in inches
    :type verticalFilmOffset: float
    :param verticalLock: (C Q E) Lock the size of the vertical film aperture
    :type verticalLock: boolean
    :param verticalPan: (C Q E) Vertical 2D camera pan (inches)
    :type verticalPan: float
    :param verticalRollPivot: (C Q E) Vertical pivot point used for rotating the film back 
    This double precision parameter corresponds to the normalized viewport  This value is used
    to c
    :type verticalRollPivot: float
    :param verticalShake: (C Q E) Vertical offset from the center of the film back  See
    horizontal shake attribute description  This is toggled by the shake enabled attribute
    :type verticalShake: float
    :param worldCenterOfInterest: (C Q E) Camera world center of interest point
    :type worldCenterOfInterest: [float, float, float]
    :param worldUp: (C Q E) Camera world up vector
    :type worldUp: [float, float, float]
    :param zoom: (C Q E) The percent over the film viewable frustum to display
    :type zoom: float
    
    :returns: (transform name and shape name)
    :rtype: string[]
    """
    pass


def ThreeRightSplitViewArrangement(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_DoCmd(*args, **kwargs):
    """
    
    """
    pass


def BrushAnimationMarkingMenuPopDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SnapToPixel(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TexSculptInvertPin(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def IncreaseGammaFine(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleFkIk(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PickColorDeactivate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sampleImage(*args, fastSample=True, resolution=None, **kwargs):
    """
    The sampleImage command is used to control parameters of sample images, such as swatches in
    the multilister  The fast option turns on or off some rendering cheats which speed up the
    render but may cause edges to look ragged  The resolution option specifies the width in
    pixels of the image which will be rendered for the specified node  Note that the
    
    :param fastSample: (C) If fast but rough rendering for sampleImage is to be used
    :type fastSample: boolean
    :param resolution: (C) The first argument to this flag specifies a resolution in pixels 
    The second argument specifies a dependency node  The effect of this flag is that fu
    :type resolution: [int, name]
    
    :returns: 
    :rtype: None
    """
    pass


def ctxCompletion(*args, **kwargs):
    """
    This command tells the current context to finish what it is doing and create any objects
    that is is working on
    
    
    :returns: 
    :rtype: None
    """
    pass


def intSlider(*args, annotation="", backgroundColor=None, changeCommand=None, defineTemplate="",
              docTag="", dragCallback=None, dragCommand=None, dropCallback=None, enable=True,
              enableBackground=True, enableKeyboardFocus=True, exists=True, fullPathName=True,
              height=0, highlightColor=None, horizontal=True, isObscured=True, manage=True,
              maxValue=0, minValue=0, noBackground=True, numberOfPopupMenus=True, parent="",
              popupMenuArray=True, preventOverride=True, statusBarMessage="", step=0,
              useTemplate="", value=0, visible=True, visibleChangeCommand=None, width=0, q=True,
              query=True, e=True, edit=True, **kwargs):
    """
    Create a slider control that accepts only integer values and is bound by a minimum and
    maximum value  The slider displays a marker indicating the current value of the slider
    relative to its minimum and maximum values  Click and drag the marker or on the slider
    itself to change the current value
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Command executed when the value changes  This command is not
    invoked when the value changes via the -v/value flag
    :type changeCommand: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dragCommand: (C E) Command executed when the value changes by dragging the slider's
    value marker
    :type dragCommand: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param horizontal: (C Q) Orientation of the slider  This flag is true by default, which
    corresponds to a horizontally oriented slider
    :type horizontal: boolean
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param maxValue: (C Q E) Upper limit of the slider
    :type maxValue: int
    :param minValue: (C Q E) Lower limit of the slider
    :type minValue: int
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param step: (C Q E) The step value represents the amount the value will increase or
    decrease when you click either side of the slider
    :type step: int
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param value: (C Q E) Value of the slider
    :type value: int
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def dR_increaseManipSize(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def iconTextRadioButton(*args, align="", annotation="", backgroundColor=None,
                        changeCommand=None, collection="", defineTemplate="", disabledImage="",
                        docTag="", dragCallback=None, dropCallback=None, enable=True,
                        enableBackground=True, enableKeyboardFocus=True, exists=True, flat=True,
                        flipX=True, flipY=True, font="", fullPathName=True, height=0,
                        highlightColor=None, highlightImage="", image="", image1="", image2="",
                        image3="", imageOverlayLabel="", isObscured=True, label="",
                        labelOffset=0, ltVersion="", manage=True, marginHeight=0, marginWidth=0,
                        noBackground=True, numberOfPopupMenus=True, offCommand=None,
                        onCommand=None, overlayLabelBackColor=None, overlayLabelColor=None,
                        parent="", popupMenuArray=True, preventOverride=True, rotation=0.0,
                        select=True, selectionHighlightImage="", selectionImage="",
                        statusBarMessage="", style="", useAlpha=True, useTemplate="",
                        version="", visible=True, visibleChangeCommand=None, width=0, q=True,
                        query=True, e=True, edit=True, **kwargs):
    """
    This control supports up to 3 icon images and 4 different display styles  The icon image
    displayed is the one that best fits the current size of the control given its current style
      This command creates a iconTextRadioButton that is added to the most recently created
    iconTextRadioCollection unless the -cl/cluster flag is used
    
    :param align: (C Q E) The label alignment  Alignment values are "left", "right", and
    "center"  By default, the label is aligned "center"  Currently only available when -st
    :type align: string
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C Q E) Command executed when the control's state is changed  Note
    that this flag should not be used in conjunction with onCommand and offCommand  That is, o
    :type changeCommand: script
    :param collection: (C) To explicitly add the control to the specified collection
    :type collection: string
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param disabledImage: (C Q E) Image used when the button is disabled  Image size must be
    the same as the image specified with the i/image flag  This is a Windows only flag
    :type disabledImage: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param flat: (C Q E) Sets whether the control will be a flat button (0 false, 1 true)
    :type flat: boolean
    :param flipX: (C Q E) Is the image flipped horizontally?
    :type flipX: boolean
    :param flipY: (C Q E) Is the image flipped vertically?
    :type flipY: boolean
    :param font: (C Q E) The font for the text  Valid values are "boldLabelFont",
    "smallBoldLabelFont", "tinyBoldLabelFont", "plainLabelFont", "smallPlainLabelFont",
    "oblique
    :type font: string
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param highlightImage: (C Q E) Highlight image displayed while the cursor is over the
    control  Image size must be the same as the image specified with the -i/image flag  This is
    a
    :type highlightImage: string
    :param image: (C Q E) If you are not providing images with different sizes then you may use
    this flag for the control's image  If the "iconOnly" style is set, the icon wil
    :type image: string
    :param image1: (C Q E) First of three possible icons  The icon that best fits the current
    size of the control will be displayed
    :type image1: string
    :param image2: (C Q E) Second of three possible icons  The icon that best fits the current
    size of the control will be displayed
    :type image2: string
    :param image3: (C Q E) Third of three possible icons  The icon that best fits the current
    size of the control will be displayed
    :type image3: string
    :param imageOverlayLabel: (C Q E) A short string, up to 6 characters, representing a label
    that will be displayed on top of the image
    :type imageOverlayLabel: string
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) The text that appears in the control
    :type label: string
    :param labelOffset: (C Q E) The label offset  Default is 0  Currently only available when
    -st/style is set to "iconAndTextCentered"
    :type labelOffset: int
    :param ltVersion: (C Q E) This flag is used to specify the Maya LT version that this
    control feature was introduced, if the version flag is not specified, or if the version fl
    :type ltVersion: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param marginHeight: (C Q E) The number of pixels above and below the control content  The
    default value is 1 pixel
    :type marginHeight: int
    :param marginWidth: (C Q E) The number of pixels on either side of the control content  The
    default value is 1 pixel
    :type marginWidth: int
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param offCommand: (C Q E) Command executed when the control is turned off
    :type offCommand: script
    :param onCommand: (C Q E) Command executed when the control is turned on
    :type onCommand: script
    :param overlayLabelBackColor: (C Q E) The RGBA color of the shadow behind the label defined
    by imageOverlayLabel  Default is 50% transparent black: 0 0 0 .5
    :type overlayLabelBackColor: [float, float, float, float]
    :param overlayLabelColor: (C Q E) The RGB color of the label defined by imageOverlayLabel 
    Default is a light grey: .8 .8 .8
    :type overlayLabelColor: [float, float, float]
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rotation: (C Q E) The rotation value of the image in radians
    :type rotation: float
    :param select: (C Q E) Will set this button as the selected one
    :type select: boolean
    :param selectionHighlightImage: (C Q E) Image displayed while the control is selected and
    the cursor is over the control  Image size must be the same as the image specified with the
    -i/imag
    :type selectionHighlightImage: string
    :param selectionImage: (C Q E) Image displayed while the control is selected  Image size
    must be the same as the image specified with the -i/image flag  This is a Windows only
    flag
    :type selectionImage: string
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param style: (C Q E) The draw style of the control  Valid styles are "iconOnly",
    "textOnly", "iconAndTextHorizontal", "iconAndTextVertical", and "iconAndTextCentered"  (N
    :type style: string
    :param useAlpha: (C Q E) Is the image using alpha channel?
    :type useAlpha: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param version: (C Q E) Specify the version that this control feature was introduced  The
    argument should be given as a string of the version number (e.g  "2013", "2014")  C
    :type version: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the iconTextRadioButton created.
    :rtype: string
    """
    pass


def OutlinerCollapseAllItems(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TensionOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def layerButton(*args, annotation="", backgroundColor=None, changeCommand=None, color=None,
                command=None, current=True, defineTemplate="", docTag="",
                doubleClickCommand=None, dragCallback=None, dropCallback=None, enable=True,
                enableBackground=True, enableKeyboardFocus=True, exists=True, fullPathName=True,
                height=0, hideOnPlaybackCommand=None, highlightColor=None, identification=0,
                isObscured=True, label="", labelWidth=True, layerHideOnPlayback=True,
                layerState="", layerVisible=True, manage=True, name="", noBackground=True,
                numberOfPopupMenus=True, parent="", popupMenuArray=True, preventOverride=True,
                renameCommand="", select=True, statusBarMessage="", transparent=True,
                typeCommand=None, useTemplate="", visible=True, visibleChangeCommand=None,
                visibleCommand=None, width=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Creates a layer bar button widget  This widget contains both the name of the layer to which
    it refers and a color swatch indicating it's color assignment  It is used primarily in the
    construction of the layerBar and layer Editor window, being the widget used for each layer
    in the respective lists
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Set the command to call on a change of any kind
    :type changeCommand: script
    :param color: (C E) Layer color, specified with normalized real numbers in R, G, B space
    :type color: [float, float, float]
    :param command: (C E) Set the command to call on a single click
    :type command: script
    :param current: (C E) Set this button to display as the current layer  The current layer is
    the one which the user has the option of adding all newly created objects into
    :type current: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param doubleClickCommand: (C E) Set the command to call on a double click
    :type doubleClickCommand: script
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param hideOnPlaybackCommand: (C E) Command that is called when the hide on playback
    indicator of the layer button is pressed
    :type hideOnPlaybackCommand: script
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param identification: (C Q E) This is the integer identification number associated with
    the layer
    :type identification: int
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) Label text for the button
    :type label: string
    :param labelWidth: (Q) Query the width of the label part so as to determine if button
    clicks are in the label part or the colour swatch part
    :type labelWidth: boolean
    :param layerHideOnPlayback: (C Q E) Indicates whether the layer is visible or invisible
    during the playback
    :type layerHideOnPlayback: boolean
    :param layerState: (C Q E) Describes the state of the layer  This may be one of normal,
    template, or reference
    :type layerState: string
    :param layerVisible: (C Q E) Indicates whether the layer is visible or invisible
    :type layerVisible: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param name: (C Q) Name of the layer
    :type name: string
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param renameCommand: (C E) Set the command to call when the layer gets renamed  The string
    '#1' will be substituted with the control's name and '#2' will be replaced with the l
    :type renameCommand: string
    :param select: (C Q E) Set this button to display as a selected layer
    :type select: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param transparent: (C Q E) Indicate whether the layer color is visible or transparent
    :type transparent: boolean
    :param typeCommand: (C E) Command that is called when the type indicator of the layer
    button is pressed
    :type typeCommand: script
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param visibleCommand: (C E) Command that is called when the visibility indicator of the
    layer button is pressed
    :type visibleCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def SmoothingDisplayShowBoth(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def layeredShaderPort(*args, annotation="", backgroundColor=None, defineTemplate="", docTag="",
                      dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
                      enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
                      highlightColor=None, isObscured=True, manage=True, noBackground=True,
                      node=None, numberOfPopupMenus=True, parent="", popupMenuArray=True,
                      preventOverride=True, selectedColorControl="",
                      selectedTransparencyControl="", statusBarMessage="", useTemplate="",
                      visible=True, visibleChangeCommand=None, width=0, q=True, query=True,
                      e=True, edit=True, **kwargs):
    """
    This command creates a 3dPort that displays an image representing the layered shader node
    specified
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param node: (C) Specifies the name of the newLayeredShader node this port will represent
    :type node: name
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param selectedColorControl: (C) Specifies the name of the UI-control that represents the
    currently selected layer's color
    :type selectedColorControl: string
    :param selectedTransparencyControl: (C) Specifies the name of the UI-control that
    represents the currently selected layer's transparency
    :type selectedTransparencyControl: string
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def createNurbsCircleCtx(*args, **kwargs):
    """
    
    """
    pass


def CreateSpring(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UniversalManip(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def visor(*args, addFolder=True, addNodes="", allowPanningInX=True, allowPanningInY=True,
          allowZooming=True, command="", deleteFolder="", editFolder="", folderList="", menu="",
          name="", nodeType="", openDirectories=True, openFolder=True, parent="", path="",
          popupMenuScript="", rebuild=True, refreshAllSwatches=True,
          refreshSelectedSwatches=True, refreshSwatch="", reset=True, restrictPanAndZoom=True,
          saveSwatches=True, scrollBar="", scrollPercent=0.0, selectedGadgets="",
          showDividers=True, showFiles=True, showFolders=True, showNodes=True, stateString=True,
          style="", transform="", type="", q=True, query=True, **kwargs):
    """
    Command for the creation and manipulation of a Visor UI element  The Visor is used to
    display the contents of a scene (rendering related nodes in particular), as well as files
    on disk which the user may wish to bring into the scene (shader and texture libraries for
    example)
    
    :param addFolder: (C Q) Add a new folder to the current visual browser
    :type addFolder: boolean
    :param addNodes: (C Q) Add dependency graph nodes by name to a user defined custom folder 
    The argument is a string encolsed in quotes with 1 one more node names seperated
    :type addNodes: string
    :param allowPanningInX: (C Q) Specifies whether or not the user should be able to pan the
    contents of the visor horizontally  Default is true
    :type allowPanningInX: boolean
    :param allowPanningInY: (C Q) Specifies whether or not the user should be able to pan the
    contents of the visor vertically  Default is true
    :type allowPanningInY: boolean
    :param allowZooming: (C Q) Specifies whether or not the user should be able to zoom the
    contents of the visor  Default is true
    :type allowZooming: boolean
    :param command: (C Q) Mel command which will return a list of nodes to add to a folder
    :type command: string
    :param deleteFolder: (C Q) Delete the specified folder and all of its children
    :type deleteFolder: string
    :param editFolder: (C Q) Edit the name and MEL command for an existing folder
    :type editFolder: string
    :param folderList: (Q) Return a string array of the folders in the visor
    :type folderList: string
    :param menu: (C Q) Set the name of the script to run to get a popup menu
    :type menu: string
    :param name: (C Q) Name of the new folder
    :type name: string
    :param nodeType: (C Q) A node type used by folders of type nodeTypeInDAG
    :type nodeType: string
    :param openDirectories: (C Q) When adding a new folder indicate if it sub directories will
    be show  The default is to not show sub directories
    :type openDirectories: boolean
    :param openFolder: (C Q) When adding a new folder indicate if it will be open or closed by
    default  The default is closed
    :type openFolder: boolean
    :param parent: (C Q) Parent folder of this folder
    :type parent: string
    :param path: (C Q) Path to a file system directory to be displayed in the folder
    :type path: string
    :param popupMenuScript: (C Q) Specifies the script to be called when the right mouse button
    is pressed in the visor  The name of the editor in which the right mouse button was pre
    :type popupMenuScript: string
    :param rebuild: (C Q) Rebuild the visor after interactively adding a folder
    :type rebuild: boolean
    :param refreshAllSwatches: (C Q) Refresh the swatches of all files currently displayed in
    this visor
    :type refreshAllSwatches: boolean
    :param refreshSelectedSwatches: (C Q) Refresh the swatches of all files currently selected
    in any visor
    :type refreshSelectedSwatches: boolean
    :param refreshSwatch: (C Q) Refresh the swatch of the file with the specified path
    :type refreshSwatch: string
    :param reset: (C Q) Clear all previously loaded folder descriptions in preperation for
    building a new visual browser
    :type reset: boolean
    :param restrictPanAndZoom: (C Q) Specifies whether the panning and zooming of the visor
    should be restricted to keep the contents in the top left corner of the visor when they are
    sm
    :type restrictPanAndZoom: boolean
    :param saveSwatches: (C Q) Save swatches to disk for currently displayed image files
    :type saveSwatches: boolean
    :param scrollBar: (C Q) Set the name of the scroll bar associated with visor
    :type scrollBar: string
    :param scrollPercent: (C Q) Set the percentage value for the scroll bar  Typically called
    from a a scroll bars callback
    :type scrollPercent: float
    :param selectedGadgets: (Q) Return a string array of the currently selected gadgets (files,
    folders, nodes) in the visor
    :type selectedGadgets: string
    :param showDividers: (C Q) Specifies whether or not the visor should show dividers  The
    default is true  If -showDividers is set to false, dividers will be drawn as folders ins
    :type showDividers: boolean
    :param showFiles: (C Q) Specifies whether or not the visor should show files  The default
    is true
    :type showFiles: boolean
    :param showFolders: (C Q) Specifies whether or not the visor should show folders  The
    default is true
    :type showFolders: boolean
    :param showNodes: (C Q) Specifies whether or not the visor should show nodes  The default
    is true
    :type showNodes: boolean
    :param stateString: (C Q) Return the MEL command string to save the folder setup in visor
    :type stateString: boolean
    :param style: (C Q) Set display style for the browser  Options are: outliner A single
    column with an outliner style icon and a text label singleColumn A single column wi
    :type style: string
    :param transform: (C Q) Name of a transform node used by folders of type nodeTypeInDAG
    :type transform: string
    :param type: (C Q) Type of the new folder  Options are: command A mel command that will
    return a list of depend nodes that will be displayed in the folder connectedNode
    :type type: string
    
    :returns: Command result
    :rtype: string
    """
    pass


def mateCtx(*args, **kwargs):
    """
    
    """
    pass


def soloMaterial(*args, attr="", last=True, node="", unsolo=True, q=True, query=True,
                 **kwargs):
    """
    Shows a preview of a specified material node output attribute
    
    :param attr: (C Q) The attr flag specifies a node attribute to solo
    :type attr: string
    :param last: (C Q) Whether to solo the last material node and attribute
    :type last: boolean
    :param node: (C Q) The node flag specifies the node to solo
    :type node: string
    :param unsolo: (C Q) Whether to remove soloing
    :type unsolo: boolean
    
    :returns: Success or Failure
    :rtype: boolean
    """
    pass


def CollapseSubdivSurfaceHierarchyOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleCompIDs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nucleusDisplayTextureNodes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def setKeyframeBlendshapeTargetWts(*args, **kwargs):
    """
    This command can be used to keyframe per-point blendshape target weights  It operates on
    the currently selected objects as follows  When the base object is selected, then the
    target weights are keyed for all targets  When only target shapes are selected, then the
    weights for thoses targets are keyframed
    
    
    :returns: number of vertices for which the targets weights are keyed
    :rtype: int
    """
    pass


def TanimLayer(*args, **kwargs):
    """
    
    """
    pass


def SubdivSmoothnessFine(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def softSelect(*args, compressUndo=0, enableFalseColor=0, softSelectColorCurve="",
               softSelectCurve="", softSelectDistance=0.0, softSelectEnabled=0,
               softSelectFalloff=0, softSelectReset=True, softSelectUVDistance=0.0, q=True,
               query=True, e=True, edit=True, **kwargs):
    """
    This command allows you to change the soft modelling options   Soft modelling is an option
    that allows for reflection of basic manipulator actions such as move, rotate, and scale
    
    :param compressUndo: (C Q E) Controls how soft selection settings behave in undo: 0 means
    all changes undo individually 1 means all consecutive changes undo as a group 2 means on
    :type compressUndo: int
    :param enableFalseColor: (C Q E) Set soft select color feedback on or off  When queried,
    returns an int indicating whether color feedback is currently enabled
    :type enableFalseColor: int
    :param softSelectColorCurve: (C Q E) Sets the color ramp used to display false color
    feedback for soft selected components in the viewport  The color curve is encoded as a
    string of comm
    :type softSelectColorCurve: string
    :param softSelectCurve: (C Q E) Sets the falloff curve used to calculate selection weights
    for components within the falloff distance  The curve is encoded as a string of comma sepa
    :type softSelectCurve: string
    :param softSelectDistance: (C Q E) Sets the falloff distance (radius) used for world and
    object space soft selection  When queried, returns a float indicating the current falloff
    dista
    :type softSelectDistance: float
    :param softSelectEnabled: (C Q E) Sets soft selection based modeling on or off  When
    queried, returns an int indicating the current state of the option
    :type softSelectEnabled: int
    :param softSelectFalloff: (C Q E) Sets the falloff mode: 0 for volume based falloff 1 for
    surface based falloff 2 for global falloff When queried, returns an int indicating the
    fallof
    :type softSelectFalloff: int
    :param softSelectReset: (C E) Resets soft selection to its default settings
    :type softSelectReset: boolean
    :param softSelectUVDistance: (C Q E) Sets the falloff distance (radius) used for UV space
    soft selection  When queried, returns a float indicating the current falloff distance
    :type softSelectUVDistance: float
    
    :returns: 
    :rtype: None
    """
    pass


def UnlockContainer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AlembicExportSelection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorCreatePoseClip(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def offsetCurveOnSurface(*args, caching=True, checkPoints=3, connectBreaks=2, cutLoop=False,
                         distance=1.0, nodeState=0, stitch=True, subdivisionDensity=5,
                         tolerance=0.01, constructionHistory=True, name="", object=True,
                         range=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The offsetCurveOnSurface command offsets a curve on surface resulting in another curve on
    surface  The connecting type for breaks in offsets is off (no connection), circular
    (connect with an arc) or linear (connect linearly resulting in a sharp corner)  If loop
    cutting is on then any loops in the offset curves are trimmed away and a sharp corner is
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param checkPoints: (C Q E) Checkpoints for fit quality per span  Not advisable to change
    this value  Default: 3
    :type checkPoints: int
    :param connectBreaks: (C Q E) Connect breaks method (between gaps): 0 - off, 1 - circular,
    2 - linear Default: 2
    :type connectBreaks: int
    :param cutLoop: (C Q E) Do loop cutting  Default: false
    :type cutLoop: boolean
    :param distance: (C Q E) Offset distance Default: 1.0
    :type distance: float
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param stitch: (C Q E) Stitch curve segments together  Not advisable to change this value 
    Default: true
    :type stitch: boolean
    :param subdivisionDensity: (C Q E) Maximum subdivision density per span Default: 5
    :type subdivisionDensity: int
    :param tolerance: (C Q E) Tolerance Default: 0.01
    :type tolerance: float
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param range: (C) Force a curve range on complete input curve
    :type range: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def AlembicExportSelectionOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteEdge(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowMeshKnifeToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def minimizeApp(*args, **kwargs):
    """
    This command minimizes (iconifies) all of the application's windows into a single desktop
    icon  To restore the application click on the desktop icon
    
    
    :returns: 
    :rtype: None
    """
    pass


def WaveOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def effector(*args, hide=True, name="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    The effector command is used to set the name or hidden flag for the effector  The standard
    edit (-e) and query (-q) flags are used for edit and query functions
    
    :param hide: (C Q E) Specifies whether to hide drawing of effector if attached to a handle
    :type hide: boolean
    :param name: (C Q E) Specifies the name of the effector
    :type name: string
    
    :returns: Command result
    :rtype: string
    """
    pass


def devicePanel(*args, control=True, copy="", createString=True, defineTemplate="", docTag="",
                editString=True, exists=True, init=True, isUnique=True, label="",
                menuBarRepeatLast=True, menuBarVisible=True, needsInit=True, parent="",
                popupMenuProcedure=None, replacePanel="", tearOff=True, tearOffCopy="",
                tearOffRestore=True, unParent=True, useTemplate="", q=True, query=True, e=True,
                edit=True, **kwargs):
    """
    This command is now obsolete  It is included only for the purpose of file compatibility  It
    creates a blank panel
    
    :param control: (Q) Returns the top level control for this panel  Usually used for getting
    a parent to attach popup menus  CAUTION: panels may not have controls at times
    :type control: boolean
    :param copy: (E) Makes this panel a copy of the specified panel  Both panels must be of the
    same type
    :type copy: string
    :param createString: (E) Command string used to create a panel
    :type createString: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Attaches a tag to the Maya panel
    :type docTag: string
    :param editString: (E) Command string used to edit a panel
    :type editString: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param init: (C E) Initializes the panel's default state  This is usually done
    automatically on file -new and file -open
    :type init: boolean
    :param isUnique: (Q) Returns true if only one instance of this panel type is allowed
    :type isUnique: boolean
    :param label: (Q E) Specifies the user readable label for the panel
    :type label: string
    :param menuBarRepeatLast: (C Q E) Controls whether clicking on the menu header with the
    middle mouse button would repeat the last selected menu item
    :type menuBarRepeatLast: boolean
    :param menuBarVisible: (C Q E) Controls whether the menu bar for the panel is displayed
    :type menuBarVisible: boolean
    :param needsInit: (Q E) (Internal) On Edit will mark the panel as requiring initialization 
    Query will return whether the panel is marked for initialization  Used during fil
    :type needsInit: boolean
    :param parent: (C) Specifies the parent layout for this panel
    :type parent: string
    :param popupMenuProcedure: (Q E) Specifies the procedure called for building the panel's
    popup menu(s)  The default value is "buildPanelPopupMenu"  The procedure should take one
    stri
    :type popupMenuProcedure: script
    :param replacePanel: (E) Will replace the specified panel with this panel  If the target
    panel is within the same layout it will perform a swap
    :type replacePanel: string
    :param tearOff: (Q E) Will tear off this panel into a separate window with a paneLayout as
    the parent of the panel  When queried this flag will return if the panel has bee
    :type tearOff: boolean
    :param tearOffCopy: (C) Will create this panel as a torn of copy of the specified source
    panel
    :type tearOffCopy: string
    :param tearOffRestore: (C E) Restores panel if it is torn off and focus is given to it  If
    docked, becomes the active panel in the docked window  This should be the default flag
    :type tearOffRestore: boolean
    :param unParent: (E) Specifies that the panel should be removed from its layout  This
    (obviously) cannot be used with query
    :type unParent: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: name of panel
    :rtype: string
    """
    pass


def SelectAllBrushes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def StitchTogetherOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MediumQualityDisplay(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXImportQuaternion(*args, **kwargs):
    """
    
    """
    pass


def PaintOnViewPlane(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSplineCacheReplaceOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nucleusGetEffectsAsset(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def timeControl(*args, animCurveNames=True, animLayerFilterOptions="", animLayerShowWeight=True,
                annotation="", backgroundColor=None, beginScrub=True, currentFrameColor=None,
                defineTemplate="", displaySound=True, docTag="", dragCallback=None,
                dropCallback=None, enable=True, enableBackground=True, enableKeyboardFocus=True,
                endScrub=True, exists=True, forceRedraw=True, forceRefresh=True,
                foregroundColor=None, fullPathName=True, globalTime=True,
                greasePencilSequenceNames=True, height=0, highlightColor=None, isObscured=True,
                mainListConnection="", manage=True, noBackground=True, numberOfPopupMenus=True,
                parent="", popupMenuArray=True, pressCommand=None, preventOverride=True,
                range=True, rangeArray=True, rangeVisible=True, releaseCommand=None,
                repeatChunkSize=1.0, repeatOnHold=True, resample=True,
                showGreaseFrames="active", showKeys="active", showKeysCombined=True, snap=True,
                sound="", statusBarMessage="", tickSize=0, tickSpan=0, useTemplate="",
                visible=True, visibleChangeCommand=None, waveform="top", width=0, q=True,
                query=True, e=True, edit=True, **kwargs):
    """
    This command creates a control that can be used for changing current time,
    displaying/editing keys, and displaying/scrubbing sound.
    
    :param animCurveNames: (C Q) When "showKeys" is not "none", querying this flag will return
    the names of all the animCurves for which keyframe ticks are being displayed  Query ret
    :type animCurveNames: boolean
    :param animLayerFilterOptions: (C Q E) Specifies whether a filter is to be applied when
    displaying animation layers  If so, the options can be "allAffecting" (no filter), "active"
    (only th
    :type animLayerFilterOptions: string
    :param animLayerShowWeight: (C Q E) Specifies or queries whether weights are to be shown
    when displaying animation layers
    :type animLayerShowWeight: boolean
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param beginScrub: (E) Set this widget up for sound scrubbing  Subsequent changes to
    current time will result in "sound scrubbing" behavior, until the "-endScrub" command i
    :type beginScrub: boolean
    :param currentFrameColor: (E) This flag is used to specify the rgba color of the current
    frame overlay rectangle in the timeControl
    :type currentFrameColor: [float, float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param displaySound: (Q E) Turn sound display off  Query returns int
    :type displaySound: boolean
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param endScrub: (E) End sound scubbing for this widget  This stops sound scrubbing
    behavior and should be issued before any subsequent "-beginScrub" flags
    :type endScrub: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param forceRedraw: (C E) Force a redraw of the time control UI  Similiar to forceRefresh
    but does not rebuild key information
    :type forceRedraw: boolean
    :param forceRefresh: (C E) Force a refresh of the time control UI
    :type forceRefresh: boolean
    :param foregroundColor: (E) This flag is used to specify the rgb color of the vertical
    lines and numeric text in the timeControl
    :type foregroundColor: [float, float, float]
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param globalTime: (C Q E) "true" means this widget controls and displays the global,
    dependency graph time  "false" means time changes here do NOT affect the dependency graph
    :type globalTime: boolean
    :param greasePencilSequenceNames: (Q) Returns the names of all grease pencil sequences that
    have frames being displayed in the time line  Query returns string[]
    :type greasePencilSequenceNames: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object that
    the time slider will use as its source of content  The time slider will only display keys
    for
    :type mainListConnection: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param pressCommand: (C E) script to run on mouse-down in this control
    :type pressCommand: script
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param range: (C Q) Returns string representing the currently highlighted range visible on
    the time slider  A range from 10 to 20 would be returned as "10:20"  When ther
    :type range: boolean
    :param rangeArray: (C Q) Returns a float array representing the currently highlighted range
    visible on the time slider  A range from 10 to 20 would be returned as { 10.0, 20.
    :type rangeArray: boolean
    :param rangeVisible: (C Q) Returns true if a currently highlighted range is visible on the
    time slider, false if no
    :type rangeVisible: boolean
    :param releaseCommand: (C E) script to run on mouse-up in this control
    :type releaseCommand: script
    :param repeatChunkSize: (Q E) How much sound (in the current time unit) is repeated when
    -repeatOnHold is true  Default is 1.0
    :type repeatChunkSize: float
    :param repeatOnHold: (Q E) Repeat sound during mouse-down events
    :type repeatOnHold: boolean
    :param resample: (E) Resample the sound display to fit the widget
    :type resample: boolean
    :param showGreaseFrames: (C Q E) "active" will show grease frames for the active camera 
    "none" shows no grease frames  "all" will show all grease frames  Default "active"  Query
    ret
    :type showGreaseFrames: string
    :param showKeys: (C Q E) "active" will show tick marks for keyframes on all active objects 
    "none" shows no tick marks  Any other name is taken as the name of a channel box w
    :type showKeys: string
    :param showKeysCombined: (C Q E) This flag can be used in conjunction with the showKeys
    flag to enable a combination of "active" + "channel box" behavior  Specifically, if channel
    bo
    :type showKeysCombined: boolean
    :param snap: (C Q E) "true" means this widget is constrained to having values that are
    integers representing the current time unit.  "false" means the current time indica
    :type snap: boolean
    :param sound: (Q E) Name of audio depend node whose data should display in the
    sound-display widget  Query returns string
    :type sound: string
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param tickSize: (C Q E) Specifies the width of keyframe ticks drawn in the time slider 
    The value will be clamped to the range [1, 63]
    :type tickSize: int
    :param tickSpan: (C Q E) Specifies the interval between keyframe ticks in the timeControl 
    For example, a value of 10, will place ticks at 0, 10, 20, etc
    :type tickSpan: int
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param waveform: (Q E) Determines what part of the sound waveform to display, when
    -displaySound is "true"  Valid values are "top", "bottom", and "both"  Default is "top"
    :type waveform: string
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Name of created or edited control
    :rtype: string
    """
    pass


def polySelectCtx(*args, exists=True, image1="", image2="", image3="", mode=0, q=True,
                  query=True, e=True, edit=True, **kwargs):
    """
    Create a new context to select polygon components
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param mode: (C Q E) Edge loop or Edge ring or Border edge mode
    :type mode: int
    
    :returns: 
    :rtype: None
    """
    pass


def dR_activeHandleZ(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_activeHandleY(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddEdgeDivisionsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BendCurvesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AlignCameraToPolygon(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def LatticeDeformKeysTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def timeEditorAnimSource(*args, addSource="", apply=True, bakeToAnimSource="",
                         calculateTiming=True, copyAnimation=True, drivenClips=True, export="",
                         isUnique=True, removeSource="", targetIndex="", targets=True,
                         addObjects="", addRelatedKG=True, addSelectedObjects=True,
                         attribute="", exclusive=True, importAllFbxTakes=True, importFbx="",
                         importFbxTakes="", importMayaFile="", importOption="",
                         importPopulateOption="", importedContainerNames="", includeRoot=True,
                         populateImportedAnimSources="", poseClip=True, recursively=True,
                         removeSceneAnimation=True, showAnimSourceRemapping=True, takeList="",
                         takesToImport="", type="", q=True, query=True, e=True, edit=True,
                         **kwargs):
    """
    Commands for managing animation sources
    
    :param addSource: (E) Add single new target attribute with its animation
    :type addSource: string
    :param apply: (E) Connect anim source's animation directly to the target objects  If the
    Time Editor is not muted, connect to scene storage instead
    :type apply: boolean
    :param bakeToAnimSource: (E) Create a new anim source with the same animation as this anim
    source  All non-curve inputs will be baked down, whereas curve sources will be shared
    :type bakeToAnimSource: string
    :param calculateTiming: (Q E) Adjust start/duration when adding/removing sources  If query
    it returns the [start,duration] pair
    :type calculateTiming: boolean
    :param copyAnimation: (E) Copy animation when adding source
    :type copyAnimation: boolean
    :param drivenClips: (Q) Return all clips driven by the given anim source
    :type drivenClips: boolean
    :param export: (E) Export given anim source and the animation curves to a specified Maya
    file
    :type export: string
    :param isUnique: (Q) Return true if the anim source node is only driving a single clip
    :type isUnique: boolean
    :param removeSource: (E) Remove single attribute
    :type removeSource: string
    :param targetIndex: (Q) Get target index
    :type targetIndex: string
    :param targets: (Q) Get a list of all targets in this anim source
    :type targets: boolean
    :param addObjects: (C Q E) Populate the given object(s) and their attributes to anim source
    to Time Editor  For multiple object, pass each name separated by semicolon  In query
    :type addObjects: string
    :param addRelatedKG: (C Q E) During population, determine if associated keying groups
    should be populated or not  Normally used for populating HIK  By default the value is
    false
    :type addRelatedKG: boolean
    :param addSelectedObjects: (C Q E) Populate the currently selected objects and their
    attributes to anim source or Time Editor  In query mode, return the number of attributes
    that will
    :type addSelectedObjects: boolean
    :param attribute: (C E M) Populate a specific attribute on a object
    :type attribute: string
    :param exclusive: (C E) Populate all types of animation sources which are not listed by
    "type" Flag
    :type exclusive: boolean
    :param importAllFbxTakes: (C) Import all FBX takes into the new anim sources (for
    timeEditorAnimSource command) or new containers (for timeEditorClip command)
    :type importAllFbxTakes: boolean
    :param importFbx: (C) Import an animation from FBX file into the new anim source (for
    timeEditorAnimSource command) or new container (for timeEditorClip command)
    :type importFbx: string
    :param importFbxTakes: (C) Import multiple FBX takes (separated by semicolons) into the new
    anim sources (for timeEditorAnimSource command) or new containers (for timeEditorCli
    :type importFbxTakes: string
    :param importMayaFile: (C) Import an animation from Maya file into the new anim sources
    (for timeEditorAnimSource command) or new containers (for timeEditorClip command)
    :type importMayaFile: string
    :param importOption: (E) Option for importing animation source  Specify either 'connect' or
    'generate'  connect: Only connect with nodes already existing in the scene  Import
    :type importOption: string
    :param importPopulateOption: (E) Option for population when importing
    :type importPopulateOption: string
    :param importedContainerNames: (C) Internal use only  To be used along with
    populateImportedAnimSources to specify names for the created containers
    :type importedContainerNames: string
    :param includeRoot: (C E) Populate transform (Translate, Rotate, Scale) of hierarchy root
    nodes
    :type includeRoot: boolean
    :param populateImportedAnimSources: (C) Internal use only  Populate the Time Editor with
    clips using the Animation Sources specified (use ; as a delimiter for multiple anim
    sources)
    :type populateImportedAnimSources: string
    :param poseClip: (C) Populate as pose clip with current attribute values
    :type poseClip: boolean
    :param recursively: (C E) Populate selection recursively, adding all the children
    :type recursively: boolean
    :param removeSceneAnimation: (C E) If true, remove animation from scene when creating clips
    or anim sources  Only Time Editor will drive the removed scene animation
    :type removeSceneAnimation: boolean
    :param showAnimSourceRemapping: (C) Show a remapping dialog when the imported anim source
    attributes do not match the scene attributes
    :type showAnimSourceRemapping: boolean
    :param takeList: (C) Internal use only  To be used along with populateImportedAnimSources
    to specify the imported take names
    :type takeList: string
    :param takesToImport: (C) Internal use only  To be used along with
    populateImportedAnimSources to specify the imported take indices
    :type takesToImport: string
    :param type: (C Q E M) Only populate the specified type of animation source
    :type type: string
    
    :returns: Command result
    :rtype: string
    """
    pass


def HypershadeToggleAttrFilter(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportTangents(*args, **kwargs):
    """
    
    """
    pass


def CurveFilletOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def particleRenderInfo(*args, attrList=0, attrListAll=True, name=0, renderTypeCount=True,
                       q=True, query=True, **kwargs):
    """
    This action provides information access to the particle render subclasses  These are
    derived from TdynRenderBase  This action is used primarily by the Attribute Editor to
    gather information about attributes used for rendering
    
    :param attrList: (Q) Return the list of attributes used by this render type
    :type attrList: int
    :param attrListAll: (Q) Return a complete list of all render attributes used by the
    particle object  This also includes the per particle attributes
    :type attrListAll: boolean
    :param name: (Q) Return the name of the render subclass using the render type
    :type name: int
    :param renderTypeCount: (Q) Return the count of registered render classes for particle
    :type renderTypeCount: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def cMuscleAbout(*args, **kwargs):
    """
    
    """
    pass


def sbs_GetGlobalTextureHeight(*args, **kwargs):
    """
    
    """
    pass


def MoveNormalToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PostInfinityCycle(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ChangeNormalSize(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyOutput(*args, allValues=True, color=True, colorDesc=True, edge=True, edgeFace=True,
               face=True, faceNorm=True, force=True, group=True, noOutput=True, normDesc=True,
               outputFile="", triangle=True, uvDesc=True, uvValue=True, vert=True,
               vertEdge=True, vertNorm=True, **kwargs):
    """
    Dumps a description of internal memory representation of poly objects  If no objects are
    specified in the command line, then the objects from the active list are used  If
    information on the geometry in the history of a poly shape is desired, then the plug of
    interest needs to be specified in the command line  Default behaviour is to print only a
    su
    
    :param allValues: (C) Shortcut for setting all the flags above
    :type allValues: boolean
    :param color: (C) Prints the color per vertex  In case of multiple sets, all sets are
    printed
    :type color: boolean
    :param colorDesc: (C) Print the color per vertex description  Each integer is an entry in
    the color array
    :type colorDesc: boolean
    :param edge: (C) Print the edge description
    :type edge: boolean
    :param edgeFace: (C) Prints the edge to face adjascency list  Only available if the
    information is already computed on the object
    :type edgeFace: boolean
    :param face: (C) Print the faces description
    :type face: boolean
    :param faceNorm: (C) Prints the normals per face  Only available if the information is
    already computed on the object
    :type faceNorm: boolean
    :param force: (C) Force evaluation of missing pieces before printing
    :type force: boolean
    :param group: (C) Print the groups of the object
    :type group: boolean
    :param noOutput: (C) Dont output any data  Would be useful if you want to just evaluate the
    data, for testing purposes
    :type noOutput: boolean
    :param normDesc: (C) Prints the normals per vertex description  Each integer is an entry in
    the vertNorm array  Only available if the information is already computed on t
    :type normDesc: boolean
    :param outputFile: (C) Location of the output file
    :type outputFile: string
    :param triangle: (C) Prints the triangles per face  Only available if the information is
    already computed on the object
    :type triangle: boolean
    :param uvDesc: (C) Print the UV description  Each integer is an entry in the uvValue array
    :type uvDesc: boolean
    :param uvValue: (C) Prints the UV positions  In case of multiple UV sets, all sets are
    printed
    :type uvValue: boolean
    :param vert: (C) Prints the vertex positions
    :type vert: boolean
    :param vertEdge: (C) Prints the vertex to edge adjascency list  Only available if the
    information is already computed on the object
    :type vertEdge: boolean
    :param vertNorm: (C) Prints the normals per vertex  Only available if the information is
    already computed on the object
    :type vertNorm: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def sbs_GetEnumValue(*args, **kwargs):
    """
    
    """
    pass


def FireOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorGhostTrackToggle(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def format(*args, stringArg="", **kwargs):
    """
    This command takes a format string, where the format string contains format specifiers  The
    format specifiers have a number associated with them relating to which parameter they
    represent to allow for alternate ordering of the passed-in values for other languages by
    merely changing the format string
    
    :param stringArg: (C M) Specify the arguments for the format string
    :type stringArg: string
    
    :returns: Command result
    :rtype: string
    """
    pass


def swatchRefresh(*args, **kwargs):
    """
    The swatchRefresh command causes image source node swatches to be refreshed on screen  The
    purpose of this command is to provide a mechanism to trigger a swatch refresh in cases that
    are not subject to dirty propagation in the dependency graph  This command only works with
    imageSource-derived node types  Invoking this command with no arguments will
    
    
    :returns: true if all arguments are valid image source nodes and the operation succeded.
    :rtype: boolean
    """
    pass


def PickWalkUp(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateSubdivCone(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def colorManagementFileRules(*args, addRule="", colorSpace="", down="", evaluate="",
                             extension="", listRules=True, load=True, moveUp="", pattern="",
                             remove="", restoreDefaults=True, save=True, q=True, query=True,
                             e=True, edit=True, **kwargs):
    """
    This non-undoable action manages the list of rules that Maya uses to assign an initial
    input color space to dependency graph nodes that read in color information from a file 
    Rules are structured in a chain of responsibility, from highest priority rule to lowest
    priority rule, each rule matching a file path pattern and extension  If a rule matches 
    
    :param addRule: (C E) Add a rule with the argument name to the list of rules, as the
    highest-priority rule  If this flag is used, the pattern, extension, and colorSpace fl
    :type addRule: string
    :param colorSpace: (C Q E) The input color space for the rule  If the rule matches a file
    path, this is the color space that is returned  This color space must match an existin
    :type colorSpace: string
    :param down: (C E) Move the rule with the argument name down one position towards lower
    priority
    :type down: string
    :param evaluate: (C E) Evaluates the list of rules and returns the input color space name
    that corresponds to the argument file path
    :type evaluate: string
    :param extension: (C Q E) The file extension for the rule is case insensitive
    :type extension: string
    :param listRules: (C E) Returns an array of rule name strings, in order, from
    lowest-priority (rule 0) to highest-priority (last rule in array)
    :type listRules: boolean
    :param load: (C E) Read the rules from Maya preferences  Any existing rules are cleared
    :type load: boolean
    :param moveUp: (C E) Move the rule with the argument name up one position towards higher
    priority
    :type moveUp: string
    :param pattern: (C Q E) The file path pattern for the rule  This is the substring to match
    in the file path, expressed as a glob pattern: for example, '*' matches all files
    :type pattern: string
    :param remove: (C E) Remove the rule with the argument name from the list of rules
    :type remove: string
    :param restoreDefaults: (C E) Restore the list of rules to the default ones only
    :type restoreDefaults: boolean
    :param save: (C E) Save the rules to Maya preferences
    :type save: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def attributeName(*args, leaf=True, long=True, nice=True, short=True, **kwargs):
    """
    This command takes one "node.attribute"-style specifier on the command line and returns
    either the attribute's long, short, or nice name  (The "nice" name, or UI name, is the name
    used to display the attribute in Maya's interface, and may be localized when running Maya
    in a language other than English.) If more than one "node.attribute" specifier i
    
    :param leaf: (C) When false, shows parent multi attributes (like "controlPoints[2].xValue")
     When true, shows only the leaf-level attribute name (like "xValue")  Defa
    :type leaf: boolean
    :param long: (C) Returns names in "long name" format like "translateX"
    :type long: boolean
    :param nice: (C) Returns names in "nice name" format like "Translate X"
    :type nice: boolean
    :param short: (C) Returns names in "short name" format like "tx"
    :type short: boolean
    
    :returns: Command result
    :rtype: string
    """
    pass


def OptimzeUVsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Air(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleKeepWireCulling(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateBezierCurveToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def EnableExpressions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateExpressionClip(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddBoatLocatorOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def groupParts(*args, **kwargs):
    """
    
    """
    pass


def xgmBrushManip(*args, **kwargs):
    """
    
    """
    pass


def XgmSplineCacheCreate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeAutoSizeNodes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_scalePress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateNURBSTorusOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def rotate(*args, absolute=True, centerPivot=True, componentSpace=True,
           constrainAlongNormal=True, deletePriorHistory=True, euler=True, forceOrderXYZ=True,
           objectCenterPivot=True, objectSpace=True, orientAxes=None, pivot=None,
           preserveChildPosition=False, preserveGeometryPosition=False, preserveUV=False,
           reflection=True, reflectionAboutBBox=True, reflectionAboutOrigin=True,
           reflectionAboutX=True, reflectionAboutY=True, reflectionAboutZ=True,
           reflectionTolerance=0.0, relative=True, rotateX=True, rotateXY=True, rotateXYZ=True,
           rotateXZ=True, rotateY=True, rotateYZ=True, rotateZ=True, symNegative=True,
           translate=True, worldSpace=True, xformConstraint="", **kwargs):
    """
    The rotate command is used to change the rotation of geometric objects  The rotation values
    are specified as Euler angles (rx, ry, rz)  The values are interpreted based on the current
    working unit for Angular measurements  Most often this is degrees   The default behaviour,
    when no objects or flags are passed, is to do a absolute rotate on each cur
    
    :param absolute: (C) Perform an absolute operation
    :type absolute: boolean
    :param centerPivot: (C) Let the pivot be the center of the bounding box of all objects
    :type centerPivot: boolean
    :param componentSpace: (C) Rotate in local component space
    :type componentSpace: boolean
    :param constrainAlongNormal: (C) When true, transform constraints are applied along the
    vertex normal first and only use the closest point when no intersection is found along the
    nor
    :type constrainAlongNormal: boolean
    :param deletePriorHistory: (C) If true then delete the history prior to the current
    operation
    :type deletePriorHistory: boolean
    :param euler: (C) Modifer for -relative flag that specifies rotation values should be added
    to current XYZ rotation values
    :type euler: boolean
    :param forceOrderXYZ: (C) When true, euler rotation value will be understood in XYZ
    rotation order not per transform node basis
    :type forceOrderXYZ: boolean
    :param objectCenterPivot: (C) Let the pivot be the center of the bounding box of each
    object
    :type objectCenterPivot: boolean
    :param objectSpace: (C) Perform rotation about object-space axis
    :type objectSpace: boolean
    :param orientAxes: (C) Euler axis for orientation
    :type orientAxes: [float, float, float]
    :param pivot: (C) Define the pivot point for the transformation
    :type pivot: [float, float, float]
    :param preserveChildPosition: (C) When true, transforming an object will apply an opposite
    transform to its child transform to keep them at the same world-space position  Default is
    f
    :type preserveChildPosition: boolean
    :param preserveGeometryPosition: (C) When true, transforming an object will apply an
    opposite transform to its geometry points to keep them at the same world-space position 
    Default is f
    :type preserveGeometryPosition: boolean
    :param preserveUV: (C) When true, UV values on rotated components are projected across the
    rotation in 3d space  For small edits, this will freeze the world space texture m
    :type preserveUV: boolean
    :param reflection: (C) To move the corresponding symmetric components also
    :type reflection: boolean
    :param reflectionAboutBBox: (C) Sets the position of the reflection axis at the geometry
    bounding box
    :type reflectionAboutBBox: boolean
    :param reflectionAboutOrigin: (C) Sets the position of the reflection axis at the origin
    :type reflectionAboutOrigin: boolean
    :param reflectionAboutX: (C) Specifies the X=0 as reflection plane
    :type reflectionAboutX: boolean
    :param reflectionAboutY: (C) Specifies the Y=0 as reflection plane
    :type reflectionAboutY: boolean
    :param reflectionAboutZ: (C) Specifies the Z=0 as reflection plane
    :type reflectionAboutZ: boolean
    :param reflectionTolerance: (C) Specifies the tolerance to findout the corresponding
    reflected components
    :type reflectionTolerance: float
    :param relative: (C) Perform a operation relative to the object's current position
    :type relative: boolean
    :param rotateX: (C) Rotate in X direction
    :type rotateX: boolean
    :param rotateXY: (C) Rotate in X and Y direction
    :type rotateXY: boolean
    :param rotateXYZ: (C) Rotate in all directions (default)
    :type rotateXYZ: boolean
    :param rotateXZ: (C) Rotate in X and Z direction
    :type rotateXZ: boolean
    :param rotateY: (C) Rotate in Y direction
    :type rotateY: boolean
    :param rotateYZ: (C) Rotate in Y and Z direction
    :type rotateYZ: boolean
    :param rotateZ: (C) Rotate in Z direction
    :type rotateZ: boolean
    :param symNegative: (C) When set the component transformation is flipped so it is relative
    to the negative side of the symmetry plane  The default (no flag) is to transform
    :type symNegative: boolean
    :param translate: (C) When true, the command will modify the node's translate attribute
    instead of its rotateTranslate attribute, when rotating around a pivot other than t
    :type translate: boolean
    :param worldSpace: (C) Perform rotation about global world-space axis
    :type worldSpace: boolean
    :param xformConstraint: (C) Apply a transform constraint to moving components  none - no
    constraint surface - constrain components to the surface edge - constrain components to
    :type xformConstraint: string
    
    :returns: 
    :rtype: None
    """
    pass


def xgmCutBrushToolCmd(*args, **kwargs):
    """
    
    """
    pass


def SetFullBodyIKKeysKeyToPin(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteTimeWarp(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateBezierCurveTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MergeUV(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def buildBookmarkMenu(*args, editor="", type="", **kwargs):
    """
    This command handles building the "dynamic" Bookmark menu, to show all bookmarks ("sets")
    of a specified type ("sets -text")  menuName is the string returned by the "menu" command
    
    :param editor: (C) Name of the editor which this menu belongs to
    :type editor: string
    :param type: (C) Type of bookmark (sets -text) to display
    :type type: string
    
    :returns: 
    :rtype: None
    """
    pass


def MatchUVsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def flushIdleQueue(*args, **kwargs):
    """
    
    """
    pass


def SymmetrizeUVOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def createCurveWarp(*args, **kwargs):
    """
    
    """
    pass


def SinglePerspectiveViewLayout(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExtrudeVertexOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SubdivSmoothnessHullOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def EmitFromObjectOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GetHairExample(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def createNurbsTorusCtx(*args, **kwargs):
    """
    
    """
    pass


def dbpeek(*args, allObjects=True, argument="", count=0, evaluationGraph=True, operation="",
           outputFile="", q=True, query=True, **kwargs):
    """
    The dbpeek command is used to analyze the Maya data for information of interest  See a
    description of the flags for details on what types of things can be analyzed
    
    :param allObjects: (C Q) Ignore any specified or selected objects and peek into all
    applicable objects  The definition of "allObjects" will vary based on the peek operation b
    :type allObjects: boolean
    :param argument: (C Q M) Specify one or more arguments to be passed to the operation  The
    acceptable values for the argument string are documented in the flag to which they w
    :type argument: string
    :param count: (C Q) Specify a count to be used by the test  Different tests make different
    use of the count, query the operation to find out how it interprets the value
    :type count: int
    :param evaluationGraph: (C Q) Ignore any nodes that are not explicitly part of the
    evaluation graph  Usually this means nodes that are affected either directly or indirectly
    by an
    :type evaluationGraph: boolean
    :param operation: (C Q) Specify the peeking operation to perform  The various operations
    are registered at run time and can be listed by querying this flag without a value
    :type operation: string
    :param outputFile: (C Q) Specify the location of a file to which the information is to be
    dumped  Default will return the value from the command  Use the special names stdout
    :type outputFile: string
    
    :returns: Query of operation yields a string array with available operations
    :rtype: string[]
    """
    pass


def HypershadeOpenOutlinerWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MoveUVTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DisableMemoryCaching(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleMultiColorFeedback(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolyMergeEdges(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def propModCtx(*args, animCurve="", animCurveFalloff=None, animCurveParam="", direction=None,
               exists=True, image1="", image2="", image3="", linear=0.0, linearParam=None,
               nurbsCurve="", powerCutoff=10.0, powerCutoffParam=None, powerDegree=3,
               powerDegreeParam=3, script="", scriptParam="", type=1, worldspace=True, q=True,
               query=True, e=True, edit=True, **kwargs):
    """
    Controls the proportional move context
    
    :param animCurve: (C Q E) Name of the anim curve to use as a drop-off curve  Only the 0 ->
    side of the curve will be used and the distance will be mapped to "seconds"  The pro
    :type animCurve: string
    :param animCurveFalloff: (C Q E) The profile of the curve will be used as the profile for
    propmod function in both U and V  This will be scaled in U, V according to the paramters
    pro
    :type animCurveFalloff: [float, float]
    :param animCurveParam: (C Q E) Name of the anim curve to use as a drop-off curve  Only the
    0 -> side of the curve will be used and the distance will be mapped to "seconds", where 1
    :type animCurveParam: string
    :param direction: (C Q E) Direction along which to compute the distance for the distance
    based drop-off functions  The default is (1 1 1)
    :type direction: [float, float, float]
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param linear: (C Q E) If using linear drop-off function, this is its slope  The default of
    -0.1 means the point at the locator moves with it and the point 10 units away do
    :type linear: float
    :param linearParam: (C Q E) If using parametric linear drop-off function, these specify its
    limits along the U and V directions
    :type linearParam: [float, float]
    :param nurbsCurve: (C Q E) Name of the nurbs curve to use as a drop-off curve  The closest
    point distance would be used as the drop off percentage
    :type nurbsCurve: string
    :param powerCutoff: (C Q E) If using the power drop-off function, this is its distance
    cutoff value  The default is 10.0
    :type powerCutoff: float
    :param powerCutoffParam: (C Q E) If using the power drop-off function, these specify one of
    it's limits, 0 for U, and 1 and V  The default cutoff is 10.0
    :type powerCutoffParam: [float, float]
    :param powerDegree: (C Q E) If using the power drop-off function, this is its degree  The
    default is 3
    :type powerDegree: float
    :param powerDegreeParam: (C Q E) If using the power drop-off function, this is its degree 
    The default is 3
    :type powerDegreeParam: float
    :param script: (C Q E) The name of the script to use to compute the drop-off  The script
    takes 6 floats as input - first 3 are the position of the move locator, the next 3
    :type script: string
    :param scriptParam: (C Q E) The name of the script to use to compute the drop-off  The
    script takes 4 floats as input - first 2 are the parametric position of the move locator,
    :type scriptParam: string
    :param type: (C Q E) Choose the type for the drop-off function  Legal values are 1 for
    linear, 2 for power, 3 for script, 4 for anim curve  The default is 1
    :type type: int
    :param worldspace: (C Q E) Set the space in which the tool works  True for world space,
    false for parametric space
    :type worldspace: boolean
    
    :returns: Name of the new context created
    :rtype: string
    """
    pass


def displayAffected(*args, q=True, query=True, **kwargs):
    """
    Turns on/off the special coloring of objects that are affected by the objects that are
    currently in the selection list   If one of the curves in a loft were selected and this
    feature were turned on, then the lofted surface would be highlighted because it is affected
    by the loft curve
    
    
    :returns: Affected display count
    :rtype: int
    """
    pass


def marker(*args, attach=True, detach=True, frontTwist=0, orientationMarker=True,
           positionMarker=True, sideTwist=0, time=None, upTwist=0, valueU=0.0, q=True,
           query=True, e=True, edit=True, **kwargs):
    """
    The marker command creates one or two markers, on a motion path curve, at the specified
    time and location  The optionnal string argument is the parent object name.
    
    :param attach: (C) This flag specifies to attach the selected 3D position markers to their
    parent geometry
    :type attach: boolean
    :param detach: (C) This flag specifies to detach the selected position markers from their
    parent geometry to the 3D space
    :type detach: boolean
    :param frontTwist: (Q) This flag specifies the amount of twist angle about the front vector
    for the marker  Default is 0  When queried, this flag returns a angle
    :type frontTwist: float
    :param orientationMarker: (Q) This flag specifies creation of an orientation marker 
    Default is not set.  When queried, this flag returns a boolean
    :type orientationMarker: boolean
    :param positionMarker: (Q) This flag specifies creation of a position marker  Default is
    set  When queried, this flag returns a boolean
    :type positionMarker: boolean
    :param sideTwist: (Q) This flag specifies the amount of twist angle about the side vector
    for the marker  Default is 0  When queried, this flag returns a angle
    :type sideTwist: float
    :param time: (Q) This flag specifies the time for the marker  Default is the current time 
    When queried, this flag returns a time
    :type time: time
    :param upTwist: (Q) This flag specifies the amount of twist angle about the up vector for
    the marker  Default is 0  When queried, this flag returns a angle
    :type upTwist: float
    :param valueU: (Q) This flag specifies the location of the position marker w.r.t  the
    parent geometry u parameterization  Default is the value at current time  When que
    :type valueU: float
    
    :returns: (name of the created markers)
    :rtype: string[]
    """
    pass


def TogglePanelMenubar(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ClearInitialState(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowNURBSSurfaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def InitialFluidStatesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorGraphRemoveUnselected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyEditUV(*args, angle=0.0, pivotU=0.0, pivotV=0.0, relative=True, rotateRatio=1.0,
               rotation=True, scale=True, scaleU=0.0, scaleV=0.0, uValue=0.0, uvSetName="",
               vValue=0.0, q=True, query=True, **kwargs):
    """
    Command edits uvs on polygonal objects  When used with the query flag, it returns the uv
    values associated with the specified components
    
    :param angle: (C Q) Specifies the angle value (in degrees) that the uv values are to be
    rotated by
    :type angle: float
    :param pivotU: (C Q) Specifies the pivot value, in the u direction, about which the scale
    or rotate is to be performed
    :type pivotU: float
    :param pivotV: (C Q) Specifies the pivot value, in the v direction, about which the scale
    or rotate is to be performed
    :type pivotV: float
    :param relative: (C Q) Specifies whether this command is editing the values relative to the
    currently existing values  Default is true;
    :type relative: boolean
    :param rotateRatio: (C Q) Specifies the ratio value that the uv values are to be rotated by
    Default is 1.0
    :type rotateRatio: float
    :param rotation: (C Q) Specifies whether this command is editing the values with rotation
    values
    :type rotation: boolean
    :param scale: (C Q) Specifies whether this command is editing the values with scale values
    :type scale: boolean
    :param scaleU: (C Q) Specifies the scale value in the u direction
    :type scaleU: float
    :param scaleV: (C Q) Specifies the scale value in the v direction
    :type scaleV: float
    :param uValue: (C Q) Specifies the value, in the u direction - absolute if relative flag is
    false.
    :type uValue: float
    :param uvSetName: (C Q) Specifies the name of the uv set to edit uvs on  If not specified
    will use the current uv set if it exists
    :type uvSetName: string
    :param vValue: (C Q) Specifies the value, in the v direction - absolute if relative flag is
    false.
    :type vValue: float
    
    :returns: Success or Failure.
    :rtype: boolean
    """
    pass


def PaintRandom(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ReversePolygonNormals(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmBakeGuideVertices(*args, **kwargs):
    """
    
    """
    pass


def ToggleCameraNames(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def scale(*args, absolute=True, centerPivot=True, componentSpace=True,
          constrainAlongNormal=True, deletePriorHistory=True, distanceOnly=True,
          localSpace=True, objectCenterPivot=True, objectSpace=True, orientAxes=None,
          pivot=None, preserveChildPosition=False, preserveGeometryPosition=False,
          preserveUV=False, reflection=True, reflectionAboutBBox=True,
          reflectionAboutOrigin=True, reflectionAboutX=True, reflectionAboutY=True,
          reflectionAboutZ=True, reflectionTolerance=0.0, relative=True, scaleX=True,
          scaleXY=True, scaleXYZ=True, scaleXZ=True, scaleY=True, scaleYZ=True, scaleZ=True,
          symNegative=True, worldSpace=True, xformConstraint="", **kwargs):
    """
    The scale command is used to change the sizes of geometric objects   The default behaviour,
    when no objects or flags are passed, is to do a relative scale on each currently selected
    object object using each object's existing scale pivot point
    
    :param absolute: (C) Perform an absolute operation
    :type absolute: boolean
    :param centerPivot: (C) Let the pivot be the center of the bounding box of all objects
    :type centerPivot: boolean
    :param componentSpace: (C) Move in local component space
    :type componentSpace: boolean
    :param constrainAlongNormal: (C) When true, transform constraints are applied along the
    vertex normal first and only use the closest point when no intersection is found along the
    nor
    :type constrainAlongNormal: boolean
    :param deletePriorHistory: (C) If true then delete the history prior to the current
    operation
    :type deletePriorHistory: boolean
    :param distanceOnly: (C) Scale only the distance between the objects
    :type distanceOnly: boolean
    :param localSpace: (C) Use local space for scaling
    :type localSpace: boolean
    :param objectCenterPivot: (C) Let the pivot be the center of the bounding box of each
    object
    :type objectCenterPivot: boolean
    :param objectSpace: (C) Use object space for scaling
    :type objectSpace: boolean
    :param orientAxes: (C) Use the angles for the orient axes
    :type orientAxes: [float, float, float]
    :param pivot: (C) Define the pivot point for the transformation
    :type pivot: [float, float, float]
    :param preserveChildPosition: (C) When true, transforming an object will apply an opposite
    transform to its child transform to keep them at the same world-space position  Default is
    f
    :type preserveChildPosition: boolean
    :param preserveGeometryPosition: (C) When true, transforming an object will apply an
    opposite transform to its geometry points to keep them at the same world-space position 
    Default is f
    :type preserveGeometryPosition: boolean
    :param preserveUV: (C) When true, UV values on scaled components are projected along the
    axis of scaling in 3d space  For small edits, this will freeze the world space text
    :type preserveUV: boolean
    :param reflection: (C) To move the corresponding symmetric components also
    :type reflection: boolean
    :param reflectionAboutBBox: (C) Sets the position of the reflection axis at the geometry
    bounding box
    :type reflectionAboutBBox: boolean
    :param reflectionAboutOrigin: (C) Sets the position of the reflection axis at the origin
    :type reflectionAboutOrigin: boolean
    :param reflectionAboutX: (C) Specifies the X=0 as reflection plane
    :type reflectionAboutX: boolean
    :param reflectionAboutY: (C) Specifies the Y=0 as reflection plane
    :type reflectionAboutY: boolean
    :param reflectionAboutZ: (C) Specifies the Z=0 as reflection plane
    :type reflectionAboutZ: boolean
    :param reflectionTolerance: (C) Specifies the tolerance to findout the corresponding
    reflected components
    :type reflectionTolerance: float
    :param relative: (C) Perform a operation relative to the object's current position
    :type relative: boolean
    :param scaleX: (C) Scale in X direction
    :type scaleX: boolean
    :param scaleXY: (C) Scale in X and Y direction
    :type scaleXY: boolean
    :param scaleXYZ: (C) Scale in all directions (default)
    :type scaleXYZ: boolean
    :param scaleXZ: (C) Scale in X and Z direction
    :type scaleXZ: boolean
    :param scaleY: (C) Scale in Y direction
    :type scaleY: boolean
    :param scaleYZ: (C) Scale in Y and Z direction
    :type scaleYZ: boolean
    :param scaleZ: (C) Scale in Z direction
    :type scaleZ: boolean
    :param symNegative: (C) When set the component transformation is flipped so it is relative
    to the negative side of the symmetry plane  The default (no flag) is to transform
    :type symNegative: boolean
    :param worldSpace: (C) Use world space for scaling
    :type worldSpace: boolean
    :param xformConstraint: (C) Apply a transform constraint to moving components  none - no
    constraint surface - constrain components to the surface edge - constrain components to
    :type xformConstraint: string
    
    :returns: 
    :rtype: None
    """
    pass


def Redo(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddBifrostFoam(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Fire(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def affects(*args, type="", **kwargs):
    """
    This command returns the list of attributes on a node or node type which affect the named
    attribute
    
    :param type: (C) static node type from which to get 'affects' information
    :type type: string
    
    :returns: List of affected/affecting attributes
    :rtype: string
    """
    pass


def LODGenerateMeshes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def softModContext(*args, **kwargs):
    """
    
    """
    pass


def graphDollyCtx(*args, exists=True, history=True, image1="", image2="", image3="", name="",
                  q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command can be used to create a dolly context for the graph editor
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: Context name
    :rtype: string
    """
    pass


def CreateVolumeLight(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_extrudeRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def palettePort(*args, actualTotal=0, annotation="", backgroundColor=None, changeCommand=None,
                colorEditable=True, colorEdited=None, defineTemplate="", dimensions=None,
                docTag="", dragCallback=None, dropCallback=None, editable=True, enable=True,
                enableBackground=True, enableKeyboardFocus=True, exists=True, fullPathName=True,
                height=0, highlightColor=None, hsvValue=None, isObscured=True, manage=True,
                noBackground=True, numberOfPopupMenus=True, parent="", popupMenuArray=True,
                preventOverride=True, redraw=True, rgbValue=None, setCurCell=0,
                statusBarMessage="", topDown=True, transparent=0, useTemplate="", visible=True,
                visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
                **kwargs):
    """
    This command creates an array of color cells  It could be used to to store an retrieve some
    colors you want to manage during your working session
    
    :param actualTotal: (C Q) Set the actual number of palette entries  This number must be
    greater than zero, but not be greater than maximum number of palette entries defined by
    :type actualTotal: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) This command string will be executed when a color in the
    palette is changed
    :type changeCommand: script
    :param colorEditable: (C Q E) If true then the user can modify the current index's color
    :type colorEditable: boolean
    :param colorEdited: (C E) This command string will be executed when a color in the palette
    is edited
    :type colorEdited: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param dimensions: (C Q) Set the dimensions of the array
    :type dimensions: [int, int]
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param editable: (C Q E) If true then the user can change the current color
    :type editable: boolean
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param hsvValue: (C Q E) Set a color for a given cell, using HSV format  On query return
    the color of the current cell
    :type hsvValue: [int, int, float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param redraw: (C E) Forces a redraw of the array
    :type redraw: boolean
    :param rgbValue: (C Q E) Set a color for a given cell, using RGB format  On query return
    the color of the current cell
    :type rgbValue: [int, float, float, float]
    :param setCurCell: (C Q E) Set the current cell in the array to the given index  Returns
    the current cell when queried
    :type setCurCell: int
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param topDown: (C) If this flag is true, it indicates that first entry should appear in
    top left as opposed to the bottom left
    :type topDown: boolean
    :param transparent: (C Q E) Set a given cell to be the transparent color  A cell value of
    -1 indicates that no cell is transparent  On query returns the current transparent cell
    :type transparent: int
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the palettePort created
    :rtype: string
    """
    pass


def freeFormFillet(*args, bias=0.5, caching=True, depth=0.5, nodeState=0, positionTolerance=0.1,
                   tangentTolerance=0.1, constructionHistory=True, name="", object=True,
                   polygon=0, range=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a free form surface fillet across two surface trim edges or isoparms
    or curve on surface  The fillet surface creation has blend controls in the form of bias and
    depth  The bias value scales the tangents at the two ends across the two selected curves 
    The depth values controls the curvature of the fillet across the two selected 
    
    :param bias: (C Q E) Bias value for fillet Default: 0.5
    :type bias: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param depth: (C Q E) Depth value for fillet Default: 0.5
    :type depth: float
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param positionTolerance: (C Q E) C(0) Tolerance For Filleted Surface creation Default:
    0.1
    :type positionTolerance: float
    :param tangentTolerance: (C Q E) G(1) continuity Tolerance For Filleted Surface creation
    Default: 0.1
    :type tangentTolerance: float
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param polygon: (C) The value of this argument controls the type of the object created by
    this operation 0: nurbs surface 1: polygon (use nurbsToPolygonsPref to set the
    :type polygon: int
    :param range: (C) Force a curve range on complete input curve
    :type range: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def dropoffLocator(*args, **kwargs):
    """
    This command adds one or more dropoff locators to a wire curve, one for each selected curve
    point  The dropoff locators can be used to provide localized tuning of the wire deformation
    about the curve point   The arguments are two floats, the envelope and percentage, followed
    by the wire node name and then by the curve point(s)
    
    
    :returns: Locator name(s)
    :rtype: string[]
    """
    pass


def vnn(*args, **kwargs):
    """
    
    """
    pass


def DeleteAllRigidConstraints(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DisplayShadingMarkingMenuPopDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetPreferredAngleOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def evalDeferred(*args, evaluateNext=True, list=True, lowPriority=True, lowestPriority=True,
                 **kwargs):
    """
    This command takes the string it is given and evaluates it during the next available idle
    time  It is useful for attaching commands to controls that can change or delete the control
    
    :param evaluateNext: (C) Specified that the command to be executed should be ran with the
    highest priority, ideally queued up next
    :type evaluateNext: boolean
    :param list: (C) Return a list of the command strings that are currently pending on the
    idle queue  By default, it will return the list of commands for all priorities
    :type list: boolean
    :param lowPriority: (C) Specified that the command to be executed should be deferred with
    the low priority  That is, it will be executed whenever Maya is idle
    :type lowPriority: boolean
    :param lowestPriority: (C) Specified that the command to be executed should be deferred
    with the lowest priority  That is, it will be executed when no other idle events are sch
    :type lowestPriority: boolean
    
    :returns: Command result
    :rtype: string[]
    """
    pass


def messageLine(*args, annotation="", backgroundColor=None, defineTemplate="", docTag="",
                dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
                enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
                highlightColor=None, isObscured=True, manage=True, noBackground=True,
                numberOfPopupMenus=True, parent="", popupMenuArray=True, preventOverride=True,
                statusBarMessage="", useTemplate="", visible=True, visibleChangeCommand=None,
                width=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a message line where tool feedback is shown
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: : Full path name to the control.
    :rtype: string
    """
    pass


def nurbsSelect(*args, borderSelection=True, bottomBorder=True, growSelection=0,
                leftBorder=True, rightBorder=True, shrinkSelection=0, topBorder=True,
                **kwargs):
    """
    Performs selection operations on NURBS objects.
    
    :param borderSelection: (C) Extract the border of the current CV selection
    :type borderSelection: boolean
    :param bottomBorder: (C) Selects the bottom border of the surface (V=0)
    :type bottomBorder: boolean
    :param growSelection: (C) Grows the CV selection by the given number of CV
    :type growSelection: int
    :param leftBorder: (C) Selects the left border of the surface (U=0)
    :type leftBorder: boolean
    :param rightBorder: (C) Selects the right border of the surface (U=MAX)
    :type rightBorder: boolean
    :param shrinkSelection: (C) Shrinks the CV selection by the given number of CV
    :type shrinkSelection: int
    :param topBorder: (C) Selects the top border of the patches (V=MAX)
    :type topBorder: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def geometryDeleteCacheFrames(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectAllNCloths(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polySelectEditCtxDataCmd(*args, **kwargs):
    """
    
    """
    pass


def copyAttr(*args, attribute="", containerParentChild=True, inConnections=True,
             keepSourceConnections=True, outConnections=True, renameTargetContainer=True,
             values=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Given two nodes, transfer the connections and/or the values from the first node to the
    second for all attributes whose names and data types match  When values are transferred,
    they are transferred directly  They are not mapped or modified in any way  The
    transferAttributes command can be used to transfer and remap some mesh attributes  The
    attribut
    
    :param attribute: (C M) The name of the attribute(s) for which connections and/or values
    will be transferred  If no attributes are specified, then all attributes will be tra
    :type attribute: string
    :param containerParentChild: (C) For use when copying from one container to another only 
    This option indicates that the published parent and/or child relationships on the original
    c
    :type containerParentChild: boolean
    :param inConnections: (C) Indicates that incoming connections should be transferred
    :type inConnections: boolean
    :param keepSourceConnections: (C) For use with the outConnections flag only  Indicates that
    the connections should be maintained on the first node, in addition to making them to the
    s
    :type keepSourceConnections: boolean
    :param outConnections: (C) Indicates that outgoing connections should be transferred
    :type outConnections: boolean
    :param renameTargetContainer: (C) For use when copying from one container to another only 
    This option will rename the target container to the name of the original container, and
    rena
    :type renameTargetContainer: boolean
    :param values: (C) Indicates that values should be transferred
    :type values: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def nClothReplaceFramesOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GetFluidExample(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ResampleCurve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetInitialState(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MediumPolygonNormals(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateNURBSCircleOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def WrinkleToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def detachCurve(*args, caching=True, keep=True, nodeState=0, parameter=0.0,
                constructionHistory=True, curveOnSurface=True, name="", object=True,
                replaceOriginal=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The detachCurve command detaches a curve into pieces, given a list of parameter values  You
    can also specify which pieces to keep and which to discard using the "-k" flag  The names
    of the newly detached curve(s) is returned  If history is on, then the name of the
    resulting dependency node is also returned   You can use this command to open a perio
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param keep: (C Q E M) Whether or not to keep a detached piece  This multi attribute should
    be one element larger than the parameter multi attribute  Default: true
    :type keep: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param parameter: (C Q E M) Parameter values to detach at Default: 0.0
    :type parameter: float
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param curveOnSurface: (C) If possible, create 2D curve as a result
    :type curveOnSurface: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def insertKnotSurface(*args, addKnots=True, caching=True, direction=1, insertBetween=False,
                      nodeState=0, numberOfKnots=1, parameter=0.0, constructionHistory=True,
                      name="", object=True, replaceOriginal=True, q=True, query=True, e=True,
                      edit=True, **kwargs):
    """
    The insertKnotSurface command inserts knots (aka isoparms) into a surface given a list of
    parameter values  The number of knots to add at each parameter value and whether the knots
    are added or complemented can be specified  The name of the surface is returned and if
    history is on, the name of the resulting dependency node is also returned   You mu
    
    :param addKnots: (C Q E) Whether to add knots or complement  Complement means knots will be
    added to reach the specified number of knots  Default: true
    :type addKnots: boolean
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param direction: (C Q E) Direction in which to insert knot: 0 - V direction, 1 - U
    direction Default: 1
    :type direction: int
    :param insertBetween: (C Q E) If set to true, and there is more than one parameter value
    specified, the knots will get inserted at equally spaced intervals between the given param
    :type insertBetween: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param numberOfKnots: (C Q E M) How many knots to insert Default: 1
    :type numberOfKnots: int
    :param parameter: (C Q E M) Parameter value(s) where knots are added Default: 0.0
    :type parameter: float
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def dR_multiCutTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def deleteNclothCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MergeUVOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBIKReachKeyingOptionSimple(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NCreateEmitterOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def WeightedTangents(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ParentBaseWire(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolygonCopyOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmPlaceBrushToolCmd(*args, **kwargs):
    """
    
    """
    pass


def CreateNURBSSquareOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CutUVsWithoutHotkey(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PickWalkStopAtTransform(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyPinUV(*args, createHistory=True, operation=0, unpinned=True, uvSetName="", value=0.0,
              q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command is used to pin and unpin UVs  A "pinned" UV is one which should not be
    modified   Each UV has an associated pin weight, that defaults to 0.0 meaning that the UV
    is not pinned  If pin weight is set to 1.0 then it becomes fully pinned and UV tools should
    not modify that UV  If the pin weight is set to a value between 0.0 and 1.0 then UV 
    
    :param createHistory: (C Q E) For objects that have no construction history, this flag can
    be used to force the creation of construction history for pinning  By default, history i
    :type createHistory: boolean
    :param operation: (C Q E) Operation to perform  Valid values are: 0: Set pin weights on the
    selected UVs  1: Set pin weights to zero for the selected UVs  2: Remove pin weight
    :type operation: int
    :param unpinned: (Q E) List all selected UVs which are not pinned
    :type unpinned: boolean
    :param uvSetName: (C Q E) Specifies the name of the UV set to edit UVs on  If not specified
    the current UV set will be used if it exists
    :type uvSetName: string
    :param value: (C Q E M) Specifies the pin value for the selected UV components  When
    specified multiple times, the values are assigned respectively to the specified UVs
    :type value: float
    
    :returns: Success or Failure.
    :rtype: boolean
    """
    pass


def dR_softSelDistanceTypeVolume(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectEdgeMask(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def artSelect(*args, **kwargs):
    """
    
    """
    pass


def progressWindow(*args, endProgress=True, isCancelled=True, isInterruptable=True, maxValue=0,
                   minValue=0, progress=0, status="", step=0, title="", q=True, query=True,
                   e=True, edit=True, **kwargs):
    """
    The progressWindow command creates a window containing a status message, a graphical
    progress gauge, and optionally a "Hit ESC to Cancel" label for interruptable operations 
    Only one progress window is allowed on screen at a time  While the window is visible, the
    busy cursor is shown
    
    :param endProgress: (C) Terminates the progress window  No other flags can be used at the
    same time  This is normally issued through MEL in response to the -ic/isCancelled f
    :type endProgress: boolean
    :param isCancelled: (Q) Returns true if the user has tried to cancel the operation  Returns
    false otherwise
    :type isCancelled: boolean
    :param isInterruptable: (C Q E) Returns true if the progress window should respond to
    attempts to cancel the operation  The cancel button is disabled if this is set to true
    :type isInterruptable: boolean
    :param maxValue: (C Q E) The maximum or "ending" value of the progress indicator  If the
    progress value is greater than the -max/maxValue, the progress value will be set to t
    :type maxValue: int
    :param minValue: (C Q E) The minimum or "starting" value of the progress indicator  If the
    progress value is less than the -min/minValue, the progress value will be set to th
    :type minValue: int
    :param progress: (C Q E) The amount of progress currently shown on the control  The value
    will always be between min and max  Default is equal to the minimum when the control
    :type progress: int
    :param status: (C Q E) The status text appearing above the progress gauge
    :type status: string
    :param step: (E) Increments the -pr/progress value by the amount specified
    :type step: int
    :param title: (C Q E) The window title
    :type title: string
    
    :returns: Returns true if the window was successfully
    created, and false if the window
    could not be created (possibly
    because one is already showing).
    :rtype: boolean
    """
    pass


def SubdivSurfacePolygonProxyMode(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AlignCurve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def manipRotateLimitsCtx(*args, exists=True, history=True, image1="", image2="", image3="",
                         name="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    Create a context for the rotate limits manipulator
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: Name of newly created context
    :rtype: string
    """
    pass


def ogsRender(*args, activeMultisampleType="", activeRenderOverride="",
              activeRenderTargetFormat="", availableFloatingPointTargetFormat=True,
              availableMultisampleType=True, availableRenderOverrides=True, camera="",
              currentFrame=True, currentView=True, enableFloatingPointRenderTarget=True,
              enableMultisample=True, frame=0.0, height=0, layer=None, noRenderView=True,
              width=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Renders an image or a sequence using the OGS rendering engine
    
    :param activeMultisampleType: (Q E) Query the current active multisample type
    :type activeMultisampleType: string
    :param activeRenderOverride: (Q E) Set or query the current active render override
    :type activeRenderOverride: string
    :param activeRenderTargetFormat: (Q E) Query the current active floating point target
    format
    :type activeRenderTargetFormat: string
    :param availableFloatingPointTargetFormat: (Q E) Returns the names of available floating
    point render target format
    :type availableFloatingPointTargetFormat: boolean
    :param availableMultisampleType: (Q E) Returns the names of available multisample type
    :type availableMultisampleType: boolean
    :param availableRenderOverrides: (Q E) Returns the names of available render overrides
    :type availableRenderOverrides: boolean
    :param camera: (C Q E) Specify the camera to use  Use the first available camera if the
    camera given is not found
    :type camera: string
    :param currentFrame: (C Q E) Render the current frame
    :type currentFrame: boolean
    :param currentView: (C Q E) When turned on, only the current view will be rendered
    :type currentView: boolean
    :param enableFloatingPointRenderTarget: (Q E) Enable/disable floating point render target
    :type enableFloatingPointRenderTarget: boolean
    :param enableMultisample: (Q E) Enable/disable multisample
    :type enableMultisample: boolean
    :param frame: (C E) Specify the frame to render
    :type frame: float
    :param height: (C Q E) The height flag pass the height to the ogsRender command  If not
    used, the height is taken from the render globals settings
    :type height: int
    :param layer: (C Q E) Render the specified render layer  Only this render layer will be
    rendered, regardless of the renderable attribute value of the render layer  The lay
    :type layer: name
    :param noRenderView: (C Q E) When turned on, the render view is not updated after image
    computation
    :type noRenderView: boolean
    :param width: (C Q E) The width flag pass the width to the ogsRender command  If not used,
    the width is taken from the render globals settings
    :type width: int
    
    :returns: Query result
    :rtype: boolean
    """
    pass


def ResolveInterpenetration(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PickWalkOut(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyTriangulate(*args, caching=True, constructionHistory=True, name="", nodeState=0, q=True,
                    query=True, e=True, edit=True, **kwargs):
    """
    Triangulation breaks polygons down into triangles, ensuring that all faces are planar and
    non-holed  Triangulation of models can be beneficial in many areas
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def dR_convertSelectionToUV(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ModifyUVVectorPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportUseSceneName(*args, **kwargs):
    """
    
    """
    pass


def ProfilerToolHideSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def shotTrack(*args, insertTrack=0, lock=True, mute=True, numTracks=0, removeEmptyTracks=True,
              removeTrack=0, selfmute=True, solo=True, swapTracks=None, title="", track=0,
              unsolo=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command is used for inserting and removing tracks related to the shots displayed in
    the Sequencer  It can also be used to modify the track state, for example, to lock or mute
    a track
    
    :param insertTrack: (C) This flag is used to insert a new empty track at the track index
    specified
    :type insertTrack: int
    :param lock: (C Q E) This flag specifies whether shots on a track are to be locked or not
    :type lock: boolean
    :param mute: (C Q E) This flag specifies whether shots on a track are to be muted or not
    :type mute: boolean
    :param numTracks: (Q) To query the number of tracks
    :type numTracks: int
    :param removeEmptyTracks: (C) This flag is used to remove all tracks that have no clips
    :type removeEmptyTracks: boolean
    :param removeTrack: (C) This flag is used to remove the track with the specified index  The
    track must have no clips on it before it can be removed
    :type removeTrack: int
    :param selfmute: (C Q E) This flag specifies whether shots on a track are to be muted or
    not (unlike mute, this disregards soloing)
    :type selfmute: boolean
    :param solo: (C Q E) This flag specifies whether shots on a track are to be soloed or not
    :type solo: boolean
    :param swapTracks: (C) This flag is used to swap the contents of two specified tracks
    :type swapTracks: [int, int]
    :param title: (C Q E) This flag specifies the title for the track
    :type title: string
    :param track: (C Q E) Specify the track on which to operate by using the track's
    trackNumber  In query mode, this flag needs a value
    :type track: int
    :param unsolo: (Q) This flag specifies whether shots on a track are to be unsoloed or not
    :type unsolo: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def playbackOptions(*args, animationEndTime=None, animationStartTime=None, blockingAnim=True,
                    by=1.0, framesPerSecond=True, loop="", maxPlaybackSpeed=0.0, maxTime=None,
                    minTime=None, playbackSpeed=0.0, view="", q=True, query=True, e=True,
                    edit=True, **kwargs):
    """
    This command sets/queries certain values associated with playback: looping style, start/end
    times, etc  Only commands modifying the -minTime/maxTime, the
    -animationStartTime/animationEndTime, or the -by value are undoable
    
    :param animationEndTime: (C Q E) Sets the end time of the animation  Query returns a float
    :type animationEndTime: time
    :param animationStartTime: (C Q E) Sets the start time of the animation  Query returns a
    float
    :type animationStartTime: time
    :param blockingAnim: (C Q) All tangents playback as stepped so that animation can be viewed
    in pure pose-to-pose form
    :type blockingAnim: boolean
    :param by: (C Q E) Increment between times viewed during playback  (Default 1.0)
    :type by: float
    :param framesPerSecond: (C Q) Queries the actual playback rate  Query returns a float
    :type framesPerSecond: boolean
    :param loop: (C Q E) Controls if and how playback repeats  Valid values are "once,"
    "continuous," and "oscillate." Query returns string
    :type loop: string
    :param maxPlaybackSpeed: (C Q E) Sets the desired maximum playback speed  Query returns a
    float  The maxPlaybackSpeed is only used by Maya when your playbackSpeed is 0 (play every
    fr
    :type maxPlaybackSpeed: float
    :param maxTime: (C Q E) Sets the end of the playback time range  Query returns a float
    :type maxTime: time
    :param minTime: (C Q E) Sets the start of the playback time range  Query returns a float
    :type minTime: time
    :param playbackSpeed: (C Q E) Sets the desired playback speed  Query returns a float
    :type playbackSpeed: float
    :param view: (C Q E) Controls how many modelling views update during playback  Valid values
    are "all" and "active"  Query returns a string
    :type view: string
    
    :returns: or float
    Query of edited option.
    :rtype: string
    """
    pass


def SmoothBindSkin(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ResetLattice(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def colorIndexSliderGrp(*args, adjustableColumn=0, adjustableColumn2=0, adjustableColumn3=0,
                        adjustableColumn4=0, adjustableColumn5=0, adjustableColumn6=0,
                        annotation="", backgroundColor=None, changeCommand=None,
                        columnAlign=None, columnAlign2=None, columnAlign3=None,
                        columnAlign4=None, columnAlign5=None, columnAlign6=None,
                        columnAttach=None, columnAttach2=None, columnAttach3=None,
                        columnAttach4=None, columnAttach5=None, columnAttach6=None,
                        columnOffset2=None, columnOffset3=None, columnOffset4=None,
                        columnOffset5=None, columnOffset6=None, columnWidth=None,
                        columnWidth1=0, columnWidth2=None, columnWidth3=None, columnWidth4=None,
                        columnWidth5=None, columnWidth6=None, defineTemplate="", docTag="",
                        dragCallback=None, dragCommand=None, dropCallback=None, enable=True,
                        enableBackground=True, enableKeyboardFocus=True, exists=True,
                        extraLabel="", forceDragRefresh=True, fullPathName=True, height=0,
                        highlightColor=None, invisible=0, isObscured=True, label="",
                        manage=True, maxValue=0, minValue=0, noBackground=True,
                        numberOfPopupMenus=True, parent="", popupMenuArray=True,
                        preventOverride=True, rowAttach=None, statusBarMessage="",
                        useTemplate="", value=0, visible=True, visibleChangeCommand=None,
                        width=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    All of the group commands position their individual controls in columns starting at column
    1  The layout of each control (ie  column) can be customized using the -cw/columnWidth,
    -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumn flags  By
    default, columns are left aligned with no offset and are 100 pixels wide  Only o
    
    :param adjustableColumn: (C E) Specifies which column has an adjustable size that changes
    with the sizing of the layout  The column value is a 1-based index  Passing 0 as argument
    :type adjustableColumn: int
    :param adjustableColumn2: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly two columns
    :type adjustableColumn2: int
    :param adjustableColumn3: (C E) Specifies that the column has an adjustable size that
    changes with the size of the parent layout  Ignored if there are not exactly three columns
    :type adjustableColumn3: int
    :param adjustableColumn4: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly four columns
    :type adjustableColumn4: int
    :param adjustableColumn5: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly five columns
    :type adjustableColumn5: int
    :param adjustableColumn6: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly six columns
    :type adjustableColumn6: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Command executed when the value changes  This command is not
    invoked when the value changes via the -v/value flag
    :type changeCommand: script
    :param columnAlign: (C E M) Arguments are : column number, alignment type  Possible
    alignments are: left | right | center  Specifies alignment type for the specified column
    :type columnAlign: [int, string]
    :param columnAlign2: (C E) Sets the text alignment of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "center"
    :type columnAlign2: [string, string]
    :param columnAlign3: (C E) Sets the text alignment for all three columns  Ignored if there
    are not exactly three columns  Valid values are "left", "right", and "center"
    :type columnAlign3: [string, string, string]
    :param columnAlign4: (C E) Sets the text alignment for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "center"
    :type columnAlign4: [string, string, string, string]
    :param columnAlign5: (C E) Sets the text alignment for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "center"
    :type columnAlign5: [string, string, string, string, string]
    :param columnAlign6: (C E) Sets the text alignment for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "center"
    :type columnAlign6: [string, string, string, string, string, string]
    :param columnAttach: (C E M) Arguments are : column number, attachment type, and offset 
    Possible attachments are: left | right | both  Specifies column attachment types and offe
    :type columnAttach: [int, string, int]
    :param columnAttach2: (C E) Sets the attachment type of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "both"
    :type columnAttach2: [string, string]
    :param columnAttach3: (C E) Sets the attachment type for all three columns  Ignored if
    there are not exactly three columns  Valid values are "left", "right", and "both"
    :type columnAttach3: [string, string, string]
    :param columnAttach4: (C E) Sets the attachment type for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "both"
    :type columnAttach4: [string, string, string, string]
    :param columnAttach5: (C E) Sets the attachment type for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "both"
    :type columnAttach5: [string, string, string, string, string]
    :param columnAttach6: (C E) Sets the attachment type for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "both"
    :type columnAttach6: [string, string, string, string, string, string]
    :param columnOffset2: (C E) This flag is used in conjunction with the -columnAttach2 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the tw
    :type columnOffset2: [int, int]
    :param columnOffset3: (C E) This flag is used in conjunction with the -columnAttach3 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the th
    :type columnOffset3: [int, int, int]
    :param columnOffset4: (C E) This flag is used in conjunction with the -columnAttach4 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fo
    :type columnOffset4: [int, int, int, int]
    :param columnOffset5: (C E) This flag is used in conjunction with the -columnAttach5 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fi
    :type columnOffset5: [int, int, int, int, int]
    :param columnOffset6: (C E) This flag is used in conjunction with the -columnAttach6 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the si
    :type columnOffset6: [int, int, int, int, int, int]
    :param columnWidth: (C E M) Arguments are : column number, column width  Sets the width of
    the specified column where the first parameter specifies the column (1 based index) an
    :type columnWidth: [int, int]
    :param columnWidth1: (C E) Sets the width of the first column  Ignored if there is not
    exactly one column
    :type columnWidth1: int
    :param columnWidth2: (C E) Sets the column widths of both columns  Ignored if there are not
    exactly two columns
    :type columnWidth2: [int, int]
    :param columnWidth3: (C E) Sets the column widths for all 3 columns  Ignored if there are
    not exactly 3 columns
    :type columnWidth3: [int, int, int]
    :param columnWidth4: (C E) Sets the column widths for all 4 columns  Ignored if there are
    not exactly 4 columns
    :type columnWidth4: [int, int, int, int]
    :param columnWidth5: (C E) Sets the column widths for all 5 columns  Ignored if there are
    not exactly 5 columns
    :type columnWidth5: [int, int, int, int, int]
    :param columnWidth6: (C E) Sets the column widths for all 6 columns  Ignored if there are
    not exactly 6 columns
    :type columnWidth6: [int, int, int, int, int, int]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dragCommand: (C E) Command executed when the value changes by dragging the slider's
    value marker
    :type dragCommand: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param extraLabel: (C Q E) Sets the string to be the text for the extra label
    :type extraLabel: string
    :param forceDragRefresh: (C Q E) If used then force refresh on drag
    :type forceDragRefresh: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param invisible: (C Q E) Set the invisible color index
    :type invisible: int
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) Label text for the group
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param maxValue: (C Q E) Maximum color index
    :type maxValue: int
    :param minValue: (C Q E) Minimum color index
    :type minValue: int
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rowAttach: (C E M) Arguments are : column, attachment type, offset  Possible
    attachments are: top | bottom | both  Specifies attachment types and offsets for the
    entire
    :type rowAttach: [int, string, int]
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param value: (C Q E) Color index
    :type value: int
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def dR_pointSnapPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SurfaceBooleanIntersectTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def curveAddPtCtx(*args, exists=True, image1="", image2="", image3="", q=True, query=True,
                  e=True, edit=True, **kwargs):
    """
    The curveAddPtCtx command creates a new curve add points context, which adds either control
    vertices (CVs) or edit points to an existing curve
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    
    :returns: (name of the new context)
    :rtype: string
    """
    pass


def CloseFrontWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def createDisplayLayer(*args, empty=True, makeCurrent=True, name="", noRecurse=True, number=0,
                       **kwargs):
    """
    Create a new display layer  The display layer number will be assigned based on the first
    unassigned number not less than the base index number found in the display layer global
    parameters  Normally all objects and their descendants will be added to the new display
    layer but if the '-nr' flag is specified then only the objects themselves will be add
    
    :param empty: (C) If set then create an empty display layer  ie  Do not add the selected
    items to the new display layer
    :type empty: boolean
    :param makeCurrent: (C) If set then make the new display layer the current one
    :type makeCurrent: boolean
    :param name: (C) Name of the new display layer being created
    :type name: string
    :param noRecurse: (C) If set then only add selected objects to the display layer  Otherwise
    all descendants of the selected objects will also be added
    :type noRecurse: boolean
    :param number: (C) Number for the new display layer being created
    :type number: int
    
    :returns: Name of display layer node that was created
    :rtype: string
    """
    pass


def nClothCreate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSplinePresetExport(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleChannelBox(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectAllClusters(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PresetBlendingWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateShot(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExpandSelectedComponents(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def querySubdiv(*args, action=0, level=0, relative=True, **kwargs):
    """
    Queries a subdivision surface based on a set of query parameters and updates the selection
    list with the results
    
    :param action: (C) Specifies the query parameter: 1 = find all tweaked verticies at level 2
    = find all sharpened vertices at level 3 = find all sharpened edges at level
    :type action: int
    :param level: (C) Specify the level of the subdivision surface on which to perform the
    operation
    :type level: int
    :param relative: (C) If set, level flag refers to the level relative to the current
    component display level
    :type relative: boolean
    
    :returns: Command result
    :rtype: boolean
    """
    pass


def PolyCreaseToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Drag(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_extrudePress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExtrudeEdge(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateNURBSSphere(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MakeBoats(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TransplantHair(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dagObjectHit(*args, **kwargs):
    """
    
    """
    pass


def AddSelectionAsInBetweenTargetShapeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_slideSurface(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowStrokeControlCurves(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MergeMultipleEdgesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowControllers(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateOceanWakeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OneClickSetCallback(*args, **kwargs):
    """
    
    """
    pass


def curveMoveEPCtx(*args, exists=True, image1="", image2="", image3="", q=True, query=True,
                   e=True, edit=True, **kwargs):
    """
    The curveMoveEPCtx command creates a new context for moving curve edit points using a
    manipulator  Edit points can only be moved one at a time
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    
    :returns: (name of the new context)
    :rtype: string
    """
    pass


def artAttrSkinPaint(*args, **kwargs):
    """
    
    """
    pass


def editorTemplate(*args, addAdskAssetControls=True, addComponents=True, addControl=True,
                   addDynamicControl=True, addExtraControls=True, addSeparator=True,
                   annotateFieldOnly=True, annotation="", beginLayout="", beginNoOptimize=True,
                   beginScrollLayout=True, callCustom=True, collapse=True, debugMode=True,
                   dimControl=None, endLayout=True, endNoOptimize=True, endScrollLayout=True,
                   extraControlsLabel="", interruptOptimize=True, label="",
                   listExtraAttributes="", preventOverride=True, queryControl=None,
                   queryLabel=None, queryName=None, removeControl=None, suppress="", **kwargs):
    """
    The editorTemplate command allows the user to specify the conceptual layout of an attribute
    editor and leave the details of exactly which UI elements are used in the final result to
    the automatic dialog generation mechanism
    
    :param addAdskAssetControls: (C) Adds controls for dynamic attributes of adskMaterial nodes
    and organizes them in a layout according to the XML ui description specified in the asset
    :type addAdskAssetControls: boolean
    :param addComponents: (C) This flag will add a frameLayout with a channel box which will
    display any selected components for the object
    :type addComponents: boolean
    :param addControl: (C) The first argument is the name of the attribute for which you wish
    to add a control  You can assume that when the editor is created from the template
    :type addControl: boolean
    :param addDynamicControl: (C) As -addControl with the exception that the attribute for
    which the control is to be created/attached is dynamic  [Note: -addControl will also work
    fo
    :type addDynamicControl: boolean
    :param addExtraControls: (C) By default, if there are attributes of a node which you do not
    -addControl or -suppress, then controls will be created automatically and appended to
    :type addExtraControls: boolean
    :param addSeparator: (C) Adds a separator to the template
    :type addSeparator: boolean
    :param annotateFieldOnly: (C) This flag can only be used with the -annotation flag  By
    default, for any Attribute Editor controlGroups created by the -addControl flag, the
    -annota
    :type annotateFieldOnly: boolean
    :param annotation: (C) This flag can only be used with the -addControl or the
    -addDynamicControl flags  The string will be used as an annotation on the controls created
    in
    :type annotation: string
    :param beginLayout: (C) Begins a layout in the template with the title specified by the
    string argument  Items between this flag and its corresponding -endLayout flag will b
    :type beginLayout: string
    :param beginNoOptimize: (C) Specifies that the layout of items between this flag and its
    corresponding -endNoOptimize flag is not to be optimized to minimize space
    :type beginNoOptimize: boolean
    :param beginScrollLayout: (C) Begins a scrollLayout  Items between this flag and its
    corresponding -endScrollLayout flag will be contained within the layout
    :type beginScrollLayout: boolean
    :param callCustom: (C) Specifies that at this point in the template when building the
    dialog, the procedure specified by the first argument is to be called to create some U
    :type callCustom: boolean
    :param collapse: (C) This flag is only valid when used in conjunction with a
    -bl/beginLayout flag  It is used to specify the initial expand/collapse state of the
    layout
    :type collapse: boolean
    :param debugMode: (C) Set debugging mode for the template
    :type debugMode: boolean
    :param dimControl: (C) This flag is only useful AFTER a control has already been created
    (using the -addControl flag)  The first argument is the node name and the second is
    :type dimControl: [string, string, boolean]
    :param endLayout: (C) Ends a layout in the template started by -beginLayout
    :type endLayout: boolean
    :param endNoOptimize: (C) Ends a set of non-optimized items
    :type endNoOptimize: boolean
    :param endScrollLayout: (C) Ends a scrollLayout
    :type endScrollLayout: boolean
    :param extraControlsLabel: (C) By default the label is "Extra Attributes"  Specify an
    alternate label or an empty string to hide the label  This flag must be used in conjuction
    wit
    :type extraControlsLabel: string
    :param interruptOptimize: (C) Enforces a division between two sets of items whose layouts
    may be optimized
    :type interruptOptimize: boolean
    :param label: (C) This flag can only be used with the -addControl or the -addDynamicControl
    flags  And it must be specified FIRST  The string will override the name of
    :type label: string
    :param listExtraAttributes: (C) List extra attributes.This flag is only useful AFTER a
    control has already been created (using the -addControl flag)  The first argument is the
    node
    :type listExtraAttributes: string
    :param preventOverride: (C) If true, this flag disallows overriding the control's attribute
    via the control's right mouse button menu
    :type preventOverride: boolean
    :param queryControl: (C) This flag is only useful AFTER a control has already been created
    (using the -addControl flag)  The first argument is the node name and the second is
    :type queryControl: [string, string]
    :param queryLabel: (C) This flag is only useful AFTER a control has already been created
    (using the -addControl flag)  The first argument is the node name and the second is
    :type queryLabel: [string, string]
    :param queryName: (C) This flag is only useful AFTER a control has already been created
    (using the -addControl flag)  The first argument is the node name and the second is
    :type queryName: [string, string]
    :param removeControl: (C) This flag is obsolete and should no longer be used
    :type removeControl: [string, string]
    :param suppress: (C) Prevent a control for the attribute specified by the string argument
    from appearing in the editor created from the template
    :type suppress: string
    
    :returns: For queryControl, the appropriate attribute type will be
    returned.
    string
    array
    For listExtraAttributes, extra attributes will be returned.
    :rtype: string
    """
    pass


def turbulence(*args, attenuation=0.0, frequency=0.0, magnitude=0.0, maxDistance=0.0, name="",
               noiseLevel=0, noiseRatio=0.0, perVertex=True, phase=0.0, phaseX=0.0, phaseY=0.0,
               phaseZ=0.0, position=None, torusSectionRadius=0.0, volumeExclusion=True,
               volumeOffset=None, volumeShape="", volumeSweep=0.0, q=True, query=True, e=True,
               edit=True, **kwargs):
    """
    For each listed object, the command creates a new field  The field has a shape which lives
    in the DAG and it has an associated dependency node  The field is added to the list of
    fields owned by the object  Use connectDynamic to cause the field to affect a dynamic
    object  Note that if more than one object is listed, a separate field is created for e
    
    :param attenuation: (Q E) Attentuation rate of field
    :type attenuation: float
    :param frequency: (Q E) Frequency of turbulence field  This determines how often motion is
    disrupted
    :type frequency: float
    :param magnitude: (Q E) Strength of field
    :type magnitude: float
    :param maxDistance: (Q E) Maximum distance at which field is exerted  -1 indicates that the
    field has no maximum distance
    :type maxDistance: float
    :param name: (Q E) name of field
    :type name: string
    :param noiseLevel: (Q E) If the noiseLevel parameter is greater than zero, the field will
    do multiple lookups in the table  Each additional lookup is weighted using noiseRati
    :type noiseLevel: int
    :param noiseRatio: (Q E) If noiseLevel is greater than zero, then noiseRatio is the
    relative magnitude for each consecutive noise evaluation  These are cumulative: for exampl
    :type noiseRatio: float
    :param perVertex: (Q E) Per-vertex application  If this flag is set true, then each
    individual point (CV, particle, vertex,etc.) of the chosen object exerts an identical cop
    :type perVertex: boolean
    :param phase: (Q E) Phase shift of turbulence field  This influences the direction of the
    disruption  This flag is obsolete and is retained only for backward compatibili
    :type phase: float
    :param phaseX: (Q E) X component of phase shift of turbulence field  This influences the
    direction of the disruption
    :type phaseX: float
    :param phaseY: (Q E) Y component of phase shift of turbulence field  This influences the
    direction of the disruption
    :type phaseY: float
    :param phaseZ: (Q E) Z component of phase shift of turbulence field  This influences the
    direction of the disruption
    :type phaseZ: float
    :param position: (Q E M) Position in space (x,y,z) where you want to place a gravity field 
    The gravity then emanates from this position in space rather than from an object
    :type position: [float, float, float]
    :param torusSectionRadius: (Q E) Section radius for a torus volume  Applies only to torus 
    Similar to the section radius in the torus modelling primitive
    :type torusSectionRadius: float
    :param volumeExclusion: (Q E) Volume exclusion of the field  If true, points outside the
    volume (defined by the volume shape attribute) are affected, If false, points inside the v
    :type volumeExclusion: boolean
    :param volumeOffset: (Q E) Volume offset of the field  Volume offset translates the field's
    volume by the specified amount from the actual field location  This is in the field'
    :type volumeOffset: [float, float, float]
    :param volumeShape: (Q E) Volume shape of the field  Sets/edits/queries the field's volume
    shape attribute  If set to any value other than "none", determines a 3-D volume with
    :type volumeShape: string
    :param volumeSweep: (Q E) Volume sweep of the field  Applies only to sphere, cone, cylinder,
    and torus  Similar effect to the sweep attribute in modelling
    :type volumeSweep: float
    
    :returns: Command result
    :rtype: string
    """
    pass


def CreateCreaseSetOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def flexor(*args, atBones=True, atJoints=True, deformerCommand="", list=True, name="",
           noScale=True, toSkeleton=True, type="", q=True, query=True, e=True, edit=True,
           **kwargs):
    """
    This command creates a flexor  A flexor a deformer plus a set of driving attributes  For
    example, a flexor might be a sculpt object that is driven by a joint's x rotation and a
    cube's y position
    
    :param atBones: (C) Add a flexor at bones  Flexor will be added at each of the selected
    bones, or at all bones in the selected skeleton if the -ts flag is also specified
    :type atBones: boolean
    :param atJoints: (C) Add a flexor at joints  Flexor will be added at each of the selected
    joints, or at all joints in the selected skeleton if the -ts flag is specified
    :type atJoints: boolean
    :param deformerCommand: (C) String representing underlying deformer command string
    :type deformerCommand: string
    :param list: (Q) List all possible types of flexors  Query mode only
    :type list: boolean
    :param name: (C) This flag is obsolete
    :type name: string
    :param noScale: (C) Do not auto-scale the flexor to the size of the nearby geometry
    :type noScale: boolean
    :param toSkeleton: (C) Specifies that flexors will be added to the entire skeleton rather
    than just to the selected joints/bones  This flag is used in conjunction with the
    :type toSkeleton: boolean
    :param type: (C) Specifies which type of flexor  To see list of valid types, use the
    "flexor -query -list" command
    :type type: string
    
    :returns: (the names of the new flexor nodes)
    :rtype: string[]
    """
    pass


def NodeEditorToggleZoomOut(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_contextChanged(*args, **kwargs):
    """
    
    """
    pass


def NodeEditorShapeMenuStateAllExceptShadingGroupMembers(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmCombBrushContext(*args, **kwargs):
    """
    
    """
    pass


def PolygonApplyColorOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def texWinToolCtx(*args, alternateContext=True, boxzoom=True, dolly=True, exists=True,
                  history=True, image1="", image2="", image3="", name="", toolName="",
                  track=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This class creates a context for the View Tools "track", "dolly", and "box zoom" in the
    texture window
    
    :param alternateContext: (C Q) Set the ALT+MMB and ALT+SHIFT+MMB to refer to this context
    :type alternateContext: boolean
    :param boxzoom: (C Q E) Perform Box Zoom
    :type boxzoom: boolean
    :param dolly: (C Q E) Dollies the view
    :type dolly: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param toolName: (C Q) Name of the specific tool to which this command refers
    :type toolName: string
    :param track: (C Q E) Tracks the view
    :type track: boolean
    
    :returns: Context name
    :rtype: string
    """
    pass


def CreatePolygonPyramid(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmCurveToGuide(*args, **kwargs):
    """
    
    """
    pass


def ExtendFluidOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def bevel(*args, bevelShapeType=1, caching=True, cornerType=2, depth=0.5, extrudeDepth=1.0,
          nodeState=0, tolerance=0.01, width=0.5, constructionHistory=True, joinSurfaces=True,
          name="", numberOfSides=4, object=True, polygon=0, range=True, q=True, query=True,
          e=True, edit=True, **kwargs):
    """
    The bevel command creates a new bevel surface for the specified curve  The curve can be any
    nurbs curves
    
    :param bevelShapeType: (C Q E) Shape type: 1 - straight cut, 2 - curve out, 3 - curve in
    Default: 1
    :type bevelShapeType: int
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param cornerType: (C Q E) Corner type: 1 - linear, 2 - circular Default: 2
    :type cornerType: int
    :param depth: (C Q E) The depth for bevel Default: 0.5
    :type depth: float
    :param extrudeDepth: (C Q E) The extrude depth for bevel Default: 1.0
    :type extrudeDepth: float
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param tolerance: (C Q E) The tolerance for bevel offsets Default: 0.01
    :type tolerance: float
    :param width: (C Q E) The width for bevel Default: 0.5
    :type width: float
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param joinSurfaces: (C Q E) Attach bevelled surfaces into one surface for each input curve
     Default:true
    :type joinSurfaces: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param numberOfSides: (C Q E) How to apply the bevel  1 - no bevels 2 - bevel at start only
    3 - bevel at end only 4 - bevel at start and end Default: 4
    :type numberOfSides: int
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param polygon: (C) The value of this argument controls the type of the object created by
    this operation 0: nurbs surface 1: polygon (use nurbsToPolygonsPref to set the
    :type polygon: int
    :param range: (C) Force a curve range on complete input curve
    :type range: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def appendListItem(*args, **kwargs):
    """
    
    """
    pass


def MakePondMotorBoatsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetRigidBodyInterpenetration(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetMeshBulgeTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PublishChildAnchor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SmoothSkinWeightsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def bifMeshExport(*args, **kwargs):
    """
    
    """
    pass


def TimeEditorAddToSoloSelectedTracks(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nClothMergeCacheOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeRefreshSelectedSwatchesOnDisk(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def torus(*args, axis=None, caching=True, degree=3, endSweep=2, heightRatio=2.0,
          minorSweep=6.2831853, nodeState=0, pivot=None, radius=1.0, sections=8, spans=1,
          startSweep=0, tolerance=0.01, useTolerance=False, constructionHistory=True, name="",
          object=True, polygon=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The torus command creates a new torus and/or a dependency node that creates one, and
    returns their names
    
    :param axis: (C Q E) The primitive's axis
    :type axis: [float, float, float]
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param degree: (C Q E) The degree of the resulting surface: 1 - linear, 3 - cubic Default:
    3
    :type degree: int
    :param endSweep: (C Q E) The angle at which to end the surface of revolution  Default is
    2Pi radians, or 360 degrees  Default: 6.2831853
    :type endSweep: float
    :param heightRatio: (C Q E) Ratio of "height" to "width" Default: 2.0
    :type heightRatio: float
    :param minorSweep: (C Q E) The sweep angle for the minor circle in the torus Default:
    6.2831853
    :type minorSweep: float
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param pivot: (C Q E) The primitive's pivot point
    :type pivot: [float, float, float]
    :param radius: (C Q E) The radius of the object Default: 1.0
    :type radius: float
    :param sections: (C Q E) The number of sections determines the resolution of the surface in
    the sweep direction  Used only if useTolerance is false  Default: 8
    :type sections: int
    :param spans: (C Q E) The number of spans determines the resolution of the surface in the
    opposite direction  Default: 1
    :type spans: int
    :param startSweep: (C Q E) The angle at which to start the surface of revolution Default:
    0
    :type startSweep: float
    :param tolerance: (C Q E) The tolerance with which to build the surface  Used only if
    useTolerance is true Default: 0.01
    :type tolerance: float
    :param useTolerance: (C Q E) Use the specified tolerance to determine resolution  Otherwise
    number of sections will be used  Default: false
    :type useTolerance: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param polygon: (C) The value of this argument controls the type of the object created by
    this operation 0: nurbs surface 1: polygon (use nurbsToPolygonsPref to set the
    :type polygon: int
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def deviceEditor(*args, control=True, defineTemplate="", docTag="", exists=True, filter="",
                 forceMainConnection="", highlightConnection="", lockMainConnection=True,
                 mainListConnection="", panel="", parent="", selectionConnection="",
                 stateString=True, takePath="", unParent=True, unlockMainConnection=True,
                 updateMainConnection=True, useTemplate="", q=True, query=True, e=True,
                 edit=True, **kwargs):
    """
    This creates an editor for creating/modifying attachments to input devices
    
    :param control: (Q) Query only  Returns the top level control for this editor  Usually used
    for getting a parent to attach popup menus  Caution: It is possible for an ed
    :type control: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Attaches a tag to the editor
    :type docTag: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param filter: (C Q E) Specifies the name of an itemFilter object to be used with this
    editor  This filters the information coming onto the main list of the editor
    :type filter: string
    :param forceMainConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type forceMainConnection: string
    :param highlightConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its highlight list  Not all editors have a highlight list 
    F
    :type highlightConnection: string
    :param lockMainConnection: (C E) Locks the current list of objects within the
    mainConnection, so that only those objects are displayed within the editor  Further changes
    to the origi
    :type lockMainConnection: boolean
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type mainListConnection: string
    :param panel: (C Q) Specifies the panel for this editor  By default if an editor is created
    in the create callback of a scripted panel it will belong to that panel  If a
    :type panel: string
    :param parent: (C Q E) Specifies the parent layout for this editor  This flag will only
    have an effect if the editor is currently un-parented
    :type parent: string
    :param selectionConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its own selection list  As the user selects things in this
    e
    :type selectionConnection: string
    :param stateString: (Q) Query only flag  Returns the MEL command that will create an editor
    to match the current editor state  The returned command string uses the string va
    :type stateString: boolean
    :param takePath: (Q E) The path used for writing/reading take data through the editor
    :type takePath: string
    :param unParent: (C E) Specifies that the editor should be removed from its layout  This
    cannot be used in query mode
    :type unParent: boolean
    :param unlockMainConnection: (C E) Unlocks the mainConnection, effectively restoring the
    original mainConnection (if it is still available), and dynamic updates
    :type unlockMainConnection: boolean
    :param updateMainConnection: (C E) Causes a locked mainConnection to be updated from the
    orginal mainConnection, but preserves the lock state
    :type updateMainConnection: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: name of the editor
    :rtype: string
    """
    pass


def TimeEditorWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateExpressionClipOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SewUVsWithoutHotkey(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectComponentToolMarkingMenu(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BifMeshImport(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RebuildSurfacesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def attrColorSliderGrp(*args, adjustableColumn=0, adjustableColumn2=0, adjustableColumn3=0,
                       adjustableColumn4=0, adjustableColumn5=0, adjustableColumn6=0,
                       annotation="", attrNavDecision=None, attribute="", backgroundColor=None,
                       columnAlign=None, columnAlign2=None, columnAlign3=None,
                       columnAlign4=None, columnAlign5=None, columnAlign6=None,
                       columnAttach=None, columnAttach2=None, columnAttach3=None,
                       columnAttach4=None, columnAttach5=None, columnAttach6=None,
                       columnOffset2=None, columnOffset3=None, columnOffset4=None,
                       columnOffset5=None, columnOffset6=None, columnWidth=None, columnWidth1=0,
                       columnWidth2=None, columnWidth3=None, columnWidth4=None,
                       columnWidth5=None, columnWidth6=None, defineTemplate="", docTag="",
                       dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
                       enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
                       highlightColor=None, hsvValue=None, isObscured=True, label="",
                       manage=True, noBackground=True, numberOfPopupMenus=True, parent="",
                       popupMenuArray=True, preventOverride=True, rgbValue=None, rowAttach=None,
                       showButton=True, statusBarMessage="", useTemplate="", visible=True,
                       visibleChangeCommand=None, width=0, q=True, query=True, e=True,
                       edit=True, **kwargs):
    """
    All of the group commands position their individual controls in columns starting at column
    1  The layout of each control (ie  column) can be customized using the -cw/columnWidth,
    -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumn flags  By
    default, columns are left aligned with no offset and are 100 pixels wide  Only o
    
    :param adjustableColumn: (C E) Specifies which column has an adjustable size that changes
    with the sizing of the layout  The column value is a 1-based index  Passing 0 as argument
    :type adjustableColumn: int
    :param adjustableColumn2: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly two columns
    :type adjustableColumn2: int
    :param adjustableColumn3: (C E) Specifies that the column has an adjustable size that
    changes with the size of the parent layout  Ignored if there are not exactly three columns
    :type adjustableColumn3: int
    :param adjustableColumn4: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly four columns
    :type adjustableColumn4: int
    :param adjustableColumn5: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly five columns
    :type adjustableColumn5: int
    :param adjustableColumn6: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly six columns
    :type adjustableColumn6: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param attrNavDecision: (C Q E) The first argument is the name of an attribute  The button
    will be attached to the attribute so the button can be kept in synch with the attribute  T
    :type attrNavDecision: [name, string]
    :param attribute: (C Q E) The name of a unique attribute of type 3double  This newly
    created field will be attached to the attribute, so that modifications to one will change
    :type attribute: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param columnAlign: (C E M) Arguments are : column number, alignment type  Possible
    alignments are: left | right | center  Specifies alignment type for the specified column
    :type columnAlign: [int, string]
    :param columnAlign2: (C E) Sets the text alignment of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "center"
    :type columnAlign2: [string, string]
    :param columnAlign3: (C E) Sets the text alignment for all three columns  Ignored if there
    are not exactly three columns  Valid values are "left", "right", and "center"
    :type columnAlign3: [string, string, string]
    :param columnAlign4: (C E) Sets the text alignment for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "center"
    :type columnAlign4: [string, string, string, string]
    :param columnAlign5: (C E) Sets the text alignment for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "center"
    :type columnAlign5: [string, string, string, string, string]
    :param columnAlign6: (C E) Sets the text alignment for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "center"
    :type columnAlign6: [string, string, string, string, string, string]
    :param columnAttach: (C E M) Arguments are : column number, attachment type, and offset 
    Possible attachments are: left | right | both  Specifies column attachment types and offe
    :type columnAttach: [int, string, int]
    :param columnAttach2: (C E) Sets the attachment type of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "both"
    :type columnAttach2: [string, string]
    :param columnAttach3: (C E) Sets the attachment type for all three columns  Ignored if
    there are not exactly three columns  Valid values are "left", "right", and "both"
    :type columnAttach3: [string, string, string]
    :param columnAttach4: (C E) Sets the attachment type for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "both"
    :type columnAttach4: [string, string, string, string]
    :param columnAttach5: (C E) Sets the attachment type for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "both"
    :type columnAttach5: [string, string, string, string, string]
    :param columnAttach6: (C E) Sets the attachment type for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "both"
    :type columnAttach6: [string, string, string, string, string, string]
    :param columnOffset2: (C E) This flag is used in conjunction with the -columnAttach2 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the tw
    :type columnOffset2: [int, int]
    :param columnOffset3: (C E) This flag is used in conjunction with the -columnAttach3 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the th
    :type columnOffset3: [int, int, int]
    :param columnOffset4: (C E) This flag is used in conjunction with the -columnAttach4 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fo
    :type columnOffset4: [int, int, int, int]
    :param columnOffset5: (C E) This flag is used in conjunction with the -columnAttach5 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fi
    :type columnOffset5: [int, int, int, int, int]
    :param columnOffset6: (C E) This flag is used in conjunction with the -columnAttach6 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the si
    :type columnOffset6: [int, int, int, int, int, int]
    :param columnWidth: (C E M) Arguments are : column number, column width  Sets the width of
    the specified column where the first parameter specifies the column (1 based index) an
    :type columnWidth: [int, int]
    :param columnWidth1: (C E) Sets the width of the first column  Ignored if there is not
    exactly one column
    :type columnWidth1: int
    :param columnWidth2: (C E) Sets the column widths of both columns  Ignored if there are not
    exactly two columns
    :type columnWidth2: [int, int]
    :param columnWidth3: (C E) Sets the column widths for all 3 columns  Ignored if there are
    not exactly 3 columns
    :type columnWidth3: [int, int, int]
    :param columnWidth4: (C E) Sets the column widths for all 4 columns  Ignored if there are
    not exactly 4 columns
    :type columnWidth4: [int, int, int, int]
    :param columnWidth5: (C E) Sets the column widths for all 5 columns  Ignored if there are
    not exactly 5 columns
    :type columnWidth5: [int, int, int, int, int]
    :param columnWidth6: (C E) Sets the column widths for all 6 columns  Ignored if there are
    not exactly 6 columns
    :type columnWidth6: [int, int, int, int, int, int]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param hsvValue: (C Q E) Specifies the color in hsv style
    :type hsvValue: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) By default, the label of this field will be the name of the attribute
     This flag can be used to override that name with whatever the user wants
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rgbValue: (C Q E) Specifies the color in rgb style
    :type rgbValue: [float, float, float]
    :param rowAttach: (C E M) Arguments are : column, attachment type, offset  Possible
    attachments are: top | bottom | both  Specifies attachment types and offsets for the
    entire
    :type rowAttach: [int, string, int]
    :param showButton: (C Q E) Control the display of the texture link button  True by default
    (show it)
    :type showButton: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: (the name of the created group)
    :rtype: string
    """
    pass


def cMuscleRelaxSetup(*args, **kwargs):
    """
    
    """
    pass


def shadingGeometryRelCtx(*args, exists=True, history=True, image1="", image2="", image3="",
                          name="", offCommand="", onCommand="", shadingCentric=True, q=True,
                          query=True, e=True, edit=True, **kwargs):
    """
    This command creates a context that can be used for associating geometry to shading groups 
    You can put the context into shading-centric mode by using the -shadingCentric flag and
    specifying true  This means that the shading group is selected first then geometry
    associated with the shading group are highlighted  Subsequent selections result in
    assi
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param offCommand: (C Q E) command to be issued when context is turned on
    :type offCommand: string
    :param onCommand: (C Q E) command to be issued when context is turned on
    :type onCommand: string
    :param shadingCentric: (C Q E) shading-centric mode
    :type shadingCentric: boolean
    
    :returns: Name of the context created.
    :rtype: string
    """
    pass


def warning(*args, noContext=True, showLineNumber=True, **kwargs):
    """
    The warning command is provided so that the user can issue warning messages from his/her
    scripts  The string argument is displayed in the command window (or stdout if running in
    batch mode) after being prefixed with a warning message heading and surrounded by the
    appropriate language separators (# for Python, // for Mel)
    
    :param noContext: (C) Do not include the context information with the warning message
    :type noContext: boolean
    :param showLineNumber: (C) Obsolete  Will be deleted in the next version of Maya  Use the
    checkbox in the script editor that enables line number display instead
    :type showLineNumber: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def attachFluidCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def LockTangentWeight(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def arnoldListAttributes(*args, **kwargs):
    """
    
    """
    pass


def FireworksOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def componentEditor(*args, control=True, defineTemplate="", docTag="", exists=True, filter="",
                    floatField="", floatSlider="", forceMainConnection="", hidePathName=True,
                    hideZeroColumns=True, highlightConnection="", lockInput=True,
                    lockMainConnection=True, mainListConnection="", newTab=None,
                    operationCount=True, operationLabels=True, operationType=0, panel="",
                    parent="", precision=0, removeTab="", selected=True, selectionConnection="",
                    setOperationLabel=None, showObjects=True, showSelected=True, sortAlpha=True,
                    stateString=True, unParent=True, unlockMainConnection=True,
                    updateMainConnection=True, useTemplate="", q=True, query=True, e=True,
                    edit=True, **kwargs):
    """
    This command creates a new component editor in the current layout
    
    :param control: (Q) Query only  Returns the top level control for this editor  Usually used
    for getting a parent to attach popup menus  Caution: It is possible for an ed
    :type control: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Attaches a tag to the editor
    :type docTag: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param filter: (C Q E) Specifies the name of an itemFilter object to be used with this
    editor  This filters the information coming onto the main list of the editor
    :type filter: string
    :param floatField: (C Q E) assigns a float field that the component editor will use for
    editing groups of values
    :type floatField: string
    :param floatSlider: (C Q E) assigns a float slider that the component editor will use for
    editing groups of values
    :type floatSlider: string
    :param forceMainConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type forceMainConnection: string
    :param hidePathName: (C Q E) Hides path name of displayed element  By default this flag is
    set to false
    :type hidePathName: boolean
    :param hideZeroColumns: (C Q E) Hides columns whose elements are all zero  By default this
    flag is set to false
    :type hideZeroColumns: boolean
    :param highlightConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its highlight list  Not all editors have a highlight list 
    F
    :type highlightConnection: string
    :param lockInput: (C Q E) Prevents the editor from responding to changes in the active list
     Independent of selection connection
    :type lockInput: boolean
    :param lockMainConnection: (C E) Locks the current list of objects within the
    mainConnection, so that only those objects are displayed within the editor  Further changes
    to the origi
    :type lockMainConnection: boolean
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type mainListConnection: string
    :param newTab: (C E) Creates a new tab, named by the first argument, based on an existing
    tab, given as the second argument using elements from a set, given in the third
    :type newTab: [string, string, string]
    :param operationCount: (Q) returns the total number of operation types known to the
    component editor
    :type operationCount: boolean
    :param operationLabels: (Q) returns a string array containing the names for all operation
    types known to the editor
    :type operationLabels: boolean
    :param operationType: (C Q E) Tells the editor which of its known operation types it should
    be performing  This is a 0-based index
    :type operationType: int
    :param panel: (C Q) Specifies the panel for this editor  By default if an editor is created
    in the create callback of a scripted panel it will belong to that panel  If a
    :type panel: string
    :param parent: (C Q E) Specifies the parent layout for this editor  This flag will only
    have an effect if the editor is currently un-parented
    :type parent: string
    :param precision: (C Q E) Specifies the maximum number of digits displayed to the right of
    the decimal place  Can be 0 to 20
    :type precision: int
    :param removeTab: (E) Removes the tab based on the set provided
    :type removeTab: string
    :param selected: (Q) Returns a list of strings, containing the labels of the currently
    selected columns
    :type selected: boolean
    :param selectionConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its own selection list  As the user selects things in this
    e
    :type selectionConnection: string
    :param setOperationLabel: (E) uses the string as the new name for the existing operation
    type specified by the integer index  Note that there is no messaging system which allows U
    :type setOperationLabel: [int, string]
    :param showObjects: (C) Restricts the display to columns that are in the current active
    list
    :type showObjects: boolean
    :param showSelected: (C E) Restricts the display to those columns which are currently
    selected  By default this flag is set to false, so all columns are selected  The results f
    :type showSelected: boolean
    :param sortAlpha: (C Q E) Controls alphabetical (true), or hierarchical sorting of columns
    :type sortAlpha: boolean
    :param stateString: (Q) Query only flag  Returns the MEL command that will create an editor
    to match the current editor state  The returned command string uses the string va
    :type stateString: boolean
    :param unParent: (C E) Specifies that the editor should be removed from its layout  This
    cannot be used in query mode
    :type unParent: boolean
    :param unlockMainConnection: (C E) Unlocks the mainConnection, effectively restoring the
    original mainConnection (if it is still available), and dynamic updates
    :type unlockMainConnection: boolean
    :param updateMainConnection: (C E) Causes a locked mainConnection to be updated from the
    orginal mainConnection, but preserves the lock state
    :type updateMainConnection: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: The panel name
    :rtype: string
    """
    pass


def RevolveOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def rampColorPort(*args, annotation="", backgroundColor=None, defineTemplate="", docTag="",
                  dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
                  enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
                  highlightColor=None, isObscured=True, manage=True, noBackground=True,
                  node=None, numberOfPopupMenus=True, parent="", popupMenuArray=True,
                  preventOverride=True, selectedColorControl="", selectedInterpControl="",
                  selectedPositionControl="", statusBarMessage="", useTemplate="",
                  verticalLayout=True, visible=True, visibleChangeCommand=None, width=0, q=True,
                  query=True, e=True, edit=True, **kwargs):
    """
    This command creates a control that displays an image representing the ramp node specified,
    and supports editing of that node
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param node: (C) Specifies the name of the newRamp texture node this port will represent
    :type node: name
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param selectedColorControl: (C E) Set the name of the control (if any) which is to be used
    to show the color of the currently selected entry in the ramp  This control will
    automatical
    :type selectedColorControl: string
    :param selectedInterpControl: (C E) Set the name of the control (if any) which is to be
    used to show the interpolation of the currently selected entry in the ramp  This control
    will aut
    :type selectedInterpControl: string
    :param selectedPositionControl: (C E) Set the name of the control (if any) which is to be
    used to show the position of the currently selected entry in the ramp  This control will
    automati
    :type selectedPositionControl: string
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param verticalLayout: (C Q E) Set the preview's layout
    :type verticalLayout: boolean
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the port created or modified
    :rtype: string
    """
    pass


def TogglePolyUVsCreateShader(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmPreview(*args, **kwargs):
    """
    
    """
    pass


def clipEditorCurrentTimeCtx(*args, exists=True, history=True, image1="", image2="", image3="",
                             name="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a context which may be used to change current time within the track
    area of a clip editor
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: Context name
    :rtype: string
    """
    pass


def HideHotbox(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SmoothPolygon(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteChannelsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def textManip(*args, visible=True, q=True, query=True, **kwargs):
    """
    Shows/hides the text manip
    
    :param visible: (C Q) Shows/hides the text manip
    :type visible: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def fluidMergeCacheOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateBlendShapeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def isDescendentPulling(*args, **kwargs):
    """
    
    """
    pass


def GroupOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SendToUnitySetProject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MergeVertexTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def lsThroughFilter(*args, item="", nodeArray=True, reverse=True, selection=True, sort="",
                    **kwargs):
    """
    List all objects in the world that pass a given filter
    
    :param item: (C M) Run the filter on specified node(s), using the fast version of this
    command
    :type item: string
    :param nodeArray: (C) Fast version that runs an entire array of nodes through the filter at
    one time
    :type nodeArray: boolean
    :param reverse: (C) Only available in conjunction with nodeArray flag  Reverses the order
    of nodes in the returned arrays if true
    :type reverse: boolean
    :param selection: (C) Run the filter on selected nodes only, using the fast version of this
    command
    :type selection: boolean
    :param sort: (C) Only available in conjunction with nodeArray flag  Orders the nodes in the
    returned array  Current options are: "byName", "byType", and "byTime"
    :type sort: string
    
    :returns: List of nodes passing the filter
    :rtype: string[]
    """
    pass


def dolly(*args, absolute=True, distance=0.0, dollyTowardsCenter=True, orthoScale=0.0,
          relative=True, **kwargs):
    """
    The dolly command moves a camera along the viewing direction in the world space  The
    viewing-direction and up-direction of the camera are not altered  There are two modes of
    operation:   Relative mode: for a perspective camera, the camera is moved along its viewing
    direction, and the distance of travel is computed with respect to the current positi
    
    :param absolute: (C) This flag modifies the behavior of the distance and orthoScale flags 
    When used in conjunction with the distance flag, the distance argument specifie
    :type absolute: boolean
    :param distance: (C) Unit distance to dolly a perspective camera
    :type distance: float
    :param dollyTowardsCenter: (C) This flag controls whether the dolly is performed towards
    the center of the view (if true), or towards the point where the user clicks (if false) 
    By
    :type dollyTowardsCenter: boolean
    :param orthoScale: (C) Scale to change the ortho width of an orthographic camera
    :type orthoScale: float
    :param relative: (C) This flag modifies the behavior of the distance and orthoScale flags 
    When used in conjunction with the distance flag, the camera eye and center of i
    :type relative: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def ExportDeformerWeightsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def fitBspline(*args, caching=True, nodeState=0, tolerance=0.1, constructionHistory=True,
               name="", object=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The fitBspline command fits the CVs from an input curve and and returns a 3D curve
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param tolerance: (C Q E) Tolerance for the fit  The resulting curve will be kept within
    tolerance of the given points  Default: 0.1
    :type tolerance: float
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def ReverseSurfaceDirection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def suitePrefs(*args, applyToSuite="", installedAsSuite=True, isCompleteSuite=True, **kwargs):
    """
    This command sets the mouse and keyboard interaction mode for Maya and other Suites
    applications (if Maya is part of a Suites install)
    
    :param applyToSuite: (C) Apply the mouse and keyboard interaction settings for the given
    application to all applications in the Suite (if Maya is part of a Suites install)  V
    :type applyToSuite: string
    :param installedAsSuite: (C) Returns true if Maya is part of a Suites install, false
    otherwise
    :type installedAsSuite: boolean
    :param isCompleteSuite: (C) Returns true if the Suites install contains all Entertainment
    Creation Suite products, false otherwise
    :type isCompleteSuite: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def MoveInfluence(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SmoothHairCurves(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def U3DBrushPressureOn(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShrinkLoopPolygonSelectionRegion(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AssumePreferredAngle(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectCurveCVsLast(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def InteractivePlayback(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HIKBodyPartMode(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def keyframeStats(*args, adjustableColumn=0, adjustableColumn2=0, adjustableColumn3=0,
                  adjustableColumn4=0, adjustableColumn5=0, adjustableColumn6=0, animEditor="",
                  annotation="", backgroundColor=None, classicMode=True, columnAlign=None,
                  columnAlign2=None, columnAlign3=None, columnAlign4=None, columnAlign5=None,
                  columnAlign6=None, columnAttach=None, columnAttach2=None, columnAttach3=None,
                  columnAttach4=None, columnAttach5=None, columnAttach6=None,
                  columnOffset2=None, columnOffset3=None, columnOffset4=None,
                  columnOffset5=None, columnOffset6=None, columnWidth=None, columnWidth1=0,
                  columnWidth2=None, columnWidth3=None, columnWidth4=None, columnWidth5=None,
                  columnWidth6=None, defineTemplate="", docTag="", dragCallback=None,
                  dropCallback=None, enable=True, enableBackground=True,
                  enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
                  highlightColor=None, isObscured=True, manage=True, noBackground=True,
                  numberOfPopupMenus=True, parent="", popupMenuArray=True, precision=3,
                  preventOverride=True, rowAttach=None, statusBarMessage="", timeAnnotation="",
                  useTemplate="", valueAnnotation="", visible=True, visibleChangeCommand=None,
                  width=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    All of the group commands position their individual controls in columns starting at column
    1  The layout of each control (ie  column) can be customized using the -cw/columnWidth,
    -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumn flags  By
    default, columns are left aligned with no offset and are 100 pixels wide  Only o
    
    :param adjustableColumn: (C E) Specifies which column has an adjustable size that changes
    with the sizing of the layout  The column value is a 1-based index  Passing 0 as argument
    :type adjustableColumn: int
    :param adjustableColumn2: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly two columns
    :type adjustableColumn2: int
    :param adjustableColumn3: (C E) Specifies that the column has an adjustable size that
    changes with the size of the parent layout  Ignored if there are not exactly three columns
    :type adjustableColumn3: int
    :param adjustableColumn4: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly four columns
    :type adjustableColumn4: int
    :param adjustableColumn5: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly five columns
    :type adjustableColumn5: int
    :param adjustableColumn6: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly six columns
    :type adjustableColumn6: int
    :param animEditor: (Q E) The name of the animation editor which is associated with the
    control
    :type animEditor: string
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param classicMode: (Q E) Edit display mode  True means stats only, otherwise show time
    value
    :type classicMode: boolean
    :param columnAlign: (C E M) Arguments are : column number, alignment type  Possible
    alignments are: left | right | center  Specifies alignment type for the specified column
    :type columnAlign: [int, string]
    :param columnAlign2: (C E) Sets the text alignment of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "center"
    :type columnAlign2: [string, string]
    :param columnAlign3: (C E) Sets the text alignment for all three columns  Ignored if there
    are not exactly three columns  Valid values are "left", "right", and "center"
    :type columnAlign3: [string, string, string]
    :param columnAlign4: (C E) Sets the text alignment for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "center"
    :type columnAlign4: [string, string, string, string]
    :param columnAlign5: (C E) Sets the text alignment for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "center"
    :type columnAlign5: [string, string, string, string, string]
    :param columnAlign6: (C E) Sets the text alignment for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "center"
    :type columnAlign6: [string, string, string, string, string, string]
    :param columnAttach: (C E M) Arguments are : column number, attachment type, and offset 
    Possible attachments are: left | right | both  Specifies column attachment types and offe
    :type columnAttach: [int, string, int]
    :param columnAttach2: (C E) Sets the attachment type of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "both"
    :type columnAttach2: [string, string]
    :param columnAttach3: (C E) Sets the attachment type for all three columns  Ignored if
    there are not exactly three columns  Valid values are "left", "right", and "both"
    :type columnAttach3: [string, string, string]
    :param columnAttach4: (C E) Sets the attachment type for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "both"
    :type columnAttach4: [string, string, string, string]
    :param columnAttach5: (C E) Sets the attachment type for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "both"
    :type columnAttach5: [string, string, string, string, string]
    :param columnAttach6: (C E) Sets the attachment type for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "both"
    :type columnAttach6: [string, string, string, string, string, string]
    :param columnOffset2: (C E) This flag is used in conjunction with the -columnAttach2 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the tw
    :type columnOffset2: [int, int]
    :param columnOffset3: (C E) This flag is used in conjunction with the -columnAttach3 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the th
    :type columnOffset3: [int, int, int]
    :param columnOffset4: (C E) This flag is used in conjunction with the -columnAttach4 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fo
    :type columnOffset4: [int, int, int, int]
    :param columnOffset5: (C E) This flag is used in conjunction with the -columnAttach5 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fi
    :type columnOffset5: [int, int, int, int, int]
    :param columnOffset6: (C E) This flag is used in conjunction with the -columnAttach6 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the si
    :type columnOffset6: [int, int, int, int, int, int]
    :param columnWidth: (C E M) Arguments are : column number, column width  Sets the width of
    the specified column where the first parameter specifies the column (1 based index) an
    :type columnWidth: [int, int]
    :param columnWidth1: (C E) Sets the width of the first column  Ignored if there is not
    exactly one column
    :type columnWidth1: int
    :param columnWidth2: (C E) Sets the column widths of both columns  Ignored if there are not
    exactly two columns
    :type columnWidth2: [int, int]
    :param columnWidth3: (C E) Sets the column widths for all 3 columns  Ignored if there are
    not exactly 3 columns
    :type columnWidth3: [int, int, int]
    :param columnWidth4: (C E) Sets the column widths for all 4 columns  Ignored if there are
    not exactly 4 columns
    :type columnWidth4: [int, int, int, int]
    :param columnWidth5: (C E) Sets the column widths for all 5 columns  Ignored if there are
    not exactly 5 columns
    :type columnWidth5: [int, int, int, int, int]
    :param columnWidth6: (C E) Sets the column widths for all 6 columns  Ignored if there are
    not exactly 6 columns
    :type columnWidth6: [int, int, int, int, int, int]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param precision: (Q E) Controls the number of digits to the right of the decimal point
    that will be displayed for float-valued channels  Default is 3  Queried, returns an i
    :type precision: int
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rowAttach: (C E M) Arguments are : column, attachment type, offset  Possible
    attachments are: top | bottom | both  Specifies attachment types and offsets for the
    entire
    :type rowAttach: [int, string, int]
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param timeAnnotation: (C Q E) Annotate the time field with an extra string value
    :type timeAnnotation: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param valueAnnotation: (C Q E) Annotate the value field with an extra string value
    :type valueAnnotation: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the stats control.
    :rtype: string
    """
    pass


def polyMergeUV(*args, caching=True, constructionHistory=True, distance=0.0, name="",
                nodeState=0, uvSetName="", worldSpace=True, q=True, query=True, e=True,
                edit=True, **kwargs):
    """
    Merge UVs of an object based on their distance  UVs are merge only if they belong to the
    same 3D vertex
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param distance: (C Q E) This flag specifies the maximum distance to merge UVs  C: Default
    is 0.0  Q: When queried, this flag returns a double
    :type distance: float
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param uvSetName: (C) Name of the UV set to be created
    :type uvSetName: string
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def NURBSSmoothnessHull(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AverageVertex(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyWedgeFace(*args, axis=None, caching=True, center=None, constructionHistory=True,
                  divisions=0, edge=0, name="", nodeState=0, wedgeAngle=0.0, worldSpace=True,
                  q=True, query=True, e=True, edit=True, **kwargs):
    """
    Extrude faces about an axis  The axis is the average of all the selected edges  If the
    edges are not aligned, the wedge may not look intuitive  To separately wedge faces about
    different wedge axes, the command should be issued as many times as the wedge axes  (as in
    the second example)
    
    :param axis: (C) This flag (along with -center) can be used instead of the -edge flag to
    specify the axis about which the wedge is performed  The flag expects three c
    :type axis: [float, float, float]
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param center: (C) This flag (along with -axis) can be used instead of the -edge flag to
    specify the location about which the wedge is performed  The flag expects three
    :type center: [float, float, float]
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param divisions: (C) This flag specifies the number of subdivisions along the extrusion
    :type divisions: int
    :param edge: (C M) This flag specifies the edgeId that should be used to perform the wedge
    about  Multiple edges can be specified  The wedge operation is performed abou
    :type edge: int
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param wedgeAngle: (C) This flag specifies the angle of rotation
    :type wedgeAngle: float
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def drag(*args, attenuation=0.0, directionX=0.0, directionY=0.0, directionZ=0.0, magnitude=0.0,
         maxDistance=0.0, name="", perVertex=True, position=None, torusSectionRadius=0.0,
         useDirection=True, volumeExclusion=True, volumeOffset=None, volumeShape="",
         volumeSweep=0.0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    For each listed object, the command creates a new field  The field has a shape which lives
    in the DAG and it has an associated dependency node  The field is added to the list of
    fields owned by the object  Use connectDynamic to cause the field to affect a dynamic
    object  Note that if more than one object is listed, a separate field is created for e
    
    :param attenuation: (Q E) Attentuation rate of field
    :type attenuation: float
    :param directionX: (Q E) X-component of direction
    :type directionX: float
    :param directionY: (Q E) Y-component of direction
    :type directionY: float
    :param directionZ: (Q E) Z-component of direction
    :type directionZ: float
    :param magnitude: (Q E) Strength of field
    :type magnitude: float
    :param maxDistance: (Q E) Maximum distance at which field is exerted  -1 indicates that the
    field has no maximum distance
    :type maxDistance: float
    :param name: (Q E) name of field
    :type name: string
    :param perVertex: (Q E) Per-vertex application  If this flag is set true, then each
    individual point (CV, particle, vertex,etc.) of the chosen object exerts an identical cop
    :type perVertex: boolean
    :param position: (Q E M) Position in space (x,y,z) where you want to place a gravity field 
    The gravity then emanates from this position in space rather than from an object
    :type position: [float, float, float]
    :param torusSectionRadius: (Q E) Section radius for a torus volume  Applies only to torus 
    Similar to the section radius in the torus modelling primitive
    :type torusSectionRadius: float
    :param useDirection: (Q E) Enable/disable direction  Drag will use -dx/-dy/-dz arguments if
    and only if this flag is set true
    :type useDirection: boolean
    :param volumeExclusion: (Q E) Volume exclusion of the field  If true, points outside the
    volume (defined by the volume shape attribute) are affected, If false, points inside the v
    :type volumeExclusion: boolean
    :param volumeOffset: (Q E) Volume offset of the field  Volume offset translates the field's
    volume by the specified amount from the actual field location  This is in the field'
    :type volumeOffset: [float, float, float]
    :param volumeShape: (Q E) Volume shape of the field  Sets/edits/queries the field's volume
    shape attribute  If set to any value other than "none", determines a 3-D volume with
    :type volumeShape: string
    :param volumeSweep: (Q E) Volume sweep of the field  Applies only to sphere, cone, cylinder,
    and torus  Similar effect to the sweep attribute in modelling
    :type volumeSweep: float
    
    :returns: Command result
    :rtype: string
    """
    pass


def HypershadeToggleZoomIn(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def currentTimeCtx(*args, exists=True, history=True, image1="", image2="", image3="", name="",
                   q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a context which may be used to change current time within the graph
    editor
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: Context name
    :rtype: string
    """
    pass


def adskAsset(*args, **kwargs):
    """
    
    """
    pass


def NodeEditorGraphRemoveUpstream(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def wrinkle(*args, axis=None, branchCount=2, branchDepth=0, center=None, crease="",
            dropoffDistance=0.0, envelope=1.0, randomness=0.2, style="", thickness=1.0,
            uvSpace=None, wrinkleCount=3, wrinkleIntensity=0.5, **kwargs):
    """
    The wrinkle command is used to create a network of wrinkles on a surface  It automatically
    creates a network of wrinkle curves that control a wire deformer  The wrinkle curves are
    attached to a cluster deformer
    
    :param axis: (C) Specifies the plane of the wrinkle
    :type axis: [float, float, float]
    :param branchCount: (C) Specifies the number of branches per wrinkle  Default is 2
    :type branchCount: int
    :param branchDepth: (C) Specifies the depth of the branching  Default is 0
    :type branchDepth: int
    :param center: (C) Specifies the center of the wrinkle
    :type center: [float, float, float]
    :param crease: (C M) Specifies an existing curve to serve as the wrinkle
    :type crease: string
    :param dropoffDistance: (C) Specifies the dropoff distance around the center
    :type dropoffDistance: float
    :param envelope: (C) The envelope globally attenuates the amount of deformation  Default is
    1.0
    :type envelope: float
    :param randomness: (C) Amount of randomness  Default is 0.2
    :type randomness: float
    :param style: (C) Specifies the wrinkle style  Valid values are "radial" or "tangential"
    :type style: string
    :param thickness: (C) Wrinkle thickness  Default is 1.0
    :type thickness: float
    :param uvSpace: (C) 1/2 length, 1/2 breadth, rotation angle, center u, v definition of a
    patch in uv space where the wrinkle is to be constructed
    :type uvSpace: [float, float, float, float, float]
    :param wrinkleCount: (C) Specifies the number of wrinkle lines to be generated  Default is
    3
    :type wrinkleCount: int
    :param wrinkleIntensity: (C) Increasing the intensity makes it more wrinkly  Default is
    0.5
    :type wrinkleIntensity: float
    
    :returns: List of clusters created followed by list of wire deformers created.
    :rtype: string[]
    """
    pass


def MoveNearestPickedKeyToolActivate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def InteractiveSplitTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DetachSurfaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RerootSkeleton(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GraphDeleteOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleStatusLine(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def hudButton(*args, allowOverlap=True, block=0, blockAlignment="", blockSize="",
              buttonShape="", buttonWidth=0, label="", labelFontSize="", padding=0,
              pressCommand=None, releaseCommand=None, section=0, visible=True, q=True,
              query=True, e=True, edit=True, **kwargs):
    """
    This command creates a Heads-up Display (HUD) button control which is placed in a 2D
    inactive overlay plane on the 3D viewport  It is to be used to provide hands-on interaction
    designated by a user script  The HUD button is derived from a generic HUD object and thus
    inherits a similar workflow   Although this command provides much of the same funct
    
    :param allowOverlap: (C Q E) Sets the Heads-Up Display to be visible regardless of
    overlapping section widths/limitations (see -s/section flag description for more details)
    :type allowOverlap: boolean
    :param block: (C Q E) Denotes the individual block that the HUD will reside in, within a
    section  Each section is composed of a single column of blocks  The total number o
    :type block: int
    :param blockAlignment: (C Q E) Specifies the alignment of the block within its respective
    column  Available alignments are: "center", "left" and "right"  The default alignment is "
    :type blockAlignment: string
    :param blockSize: (C Q E) Sets the height of each block  Available heights are: small,
    medium and large  In pixel measurements, each corresponds to a 20, 35 or 50 pixel height
    :type blockSize: string
    :param buttonShape: (C Q E) Specifies the shape of the button  Available button shapes are:
    "rectangle" and "roundRectangle"  The first will draw a rectangular button, while the
    :type buttonShape: string
    :param buttonWidth: (C Q E) Specifies the width of the button
    :type buttonWidth: int
    :param label: (C Q E) Text label of the HUD button
    :type label: string
    :param labelFontSize: (C Q E) Sets the font size of the label  Available sizes are: small
    and large
    :type labelFontSize: string
    :param padding: (C Q E) Specifies the width of both the left and right margins of a block 
    Default value is 15 pixels
    :type padding: int
    :param pressCommand: (C Q E) Specifies the procedure or script to run during a mouse click
    event
    :type pressCommand: script
    :param releaseCommand: (C Q E) Specifies the procedure or script to run during a mouse
    release event
    :type releaseCommand: script
    :param section: (C Q E) Defines the section the HUD will appear in  There are 10 sections
    divided across the screen  Five columns and two rows make up the ten element matrix
    :type section: int
    :param visible: (C Q E) Sets the visibility of the Heads-Up Display on and off
    :type visible: boolean
    
    :returns: ID number of the Heads-Up Display (HUD).
    :rtype: int
    """
    pass


def FBXExportBakeComplexAnimation(*args, **kwargs):
    """
    
    """
    pass


def dgcontrol(*args, **kwargs):
    """
    
    """
    pass


def xgmSetAttr(*args, **kwargs):
    """
    
    """
    pass


def orbit(*args, horizontalAngle=0.0, pivotPoint=None, rotationAngles=None, verticalAngle=0.0,
          **kwargs):
    """
    The orbit command revolves the camera(s) horizontally and/or vertically in the perspective
    window  The rotation axis is with respect to the camera    To revolve horizontally: the
    rotation axis is the camera up direction vector  To revolve vertically: the rotation axis
    is the camera left direction vector    When both the horizontal and the vertical 
    
    :param horizontalAngle: (C) Angle to revolve horizontally
    :type horizontalAngle: float
    :param pivotPoint: (C) Used as the pivot point in the world space
    :type pivotPoint: [float, float, float]
    :param rotationAngles: (C) Angle to revolve horizontally and vertically
    :type rotationAngles: [float, float]
    :param verticalAngle: (C) Angle to revolve vertically
    :type verticalAngle: float
    
    :returns: 
    :rtype: None
    """
    pass


def renderSetupPostApply(*args, **kwargs):
    """
    
    """
    pass


def defineDataServer(*args, device="", server="", undefine=True, **kwargs):
    """
    Connects to the specified data servername, creating a named device which then can be
    attached to device handlers   When the device is defined, it queries queries the server for
    data axis information  The "CapChannels" present are represented as axis in form
    "channelName"."usage" for scalar channels and "channelName"."component" for compound
    channel
    
    :param device: (C) specified the device name to be given to the server connection  device
    name must be unique or the command fails
    :type device: string
    :param server: (C) specifies the name of the server with which the define device connects,
    and can be specifiied in two ways name -- the name of the server socket Serve
    :type server: string
    :param undefine: (C) undefines (destroys) the dataServer device, closing the connection
    with the server
    :type undefine: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def PolygonSoftenHarden(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowDynamicsUI(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FrameSelectedWithoutChildrenInAllViews(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NURBSToPolygonsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def renderSetupHighlight(*args, **kwargs):
    """
    
    """
    pass


def InsertIsoparmsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeDuplicateWithoutNetwork(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_scaleTweakTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXImportMergeBackNullPivots(*args, **kwargs):
    """
    
    """
    pass


def SelectEdgeRingSp(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dgdebug(*args, **kwargs):
    """
    
    """
    pass


def wire(*args, after=True, afterReference=True, before=True, crossingEffect=0,
         deformerTools=True, dropoffDistance=None, envelope=1.0, exclusive="",
         frontOfChain=True, geometry="", geometryIndices=True, groupWithBase=False, holder=None,
         ignoreSelected=True, includeHiddenSelections=False, localInfluence=0, name="",
         parallel=True, prune=True, remove=True, split=True, wire="", wireCount=0, q=True,
         query=True, e=True, edit=True, **kwargs):
    """
    This command creates a wire deformer
    
    :param after: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type after: boolean
    :param afterReference: (C E) The -afterReference flag is used to specify deformer ordering
    in a hybrid way that choses between -before and -after automatically  If the geometry b
    :type afterReference: boolean
    :param before: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type before: boolean
    :param crossingEffect: (C Q E) Set the amount of convolution effect  Varies from fully
    convolved at 0 to a simple additive effect at 1 (which is what you get with the filter
    off)
    :type crossingEffect: float
    :param deformerTools: (Q) Returns the name of the deformer tool objects (if any) as string
    string ..
    :type deformerTools: boolean
    :param dropoffDistance: (C Q E M) Set the dropoff distance (second parameter) for the wire
    at index (first parameter)
    :type dropoffDistance: [int, float]
    :param envelope: (C Q E) Set the envelope value for the deformer  Default is 1.0
    :type envelope: float
    :param exclusive: (C Q) Puts the deformation set in a deform partition
    :type exclusive: string
    :param frontOfChain: (C E) This command is used to specify that the new deformer node
    should be placed ahead (upstream) of existing deformer and skin nodes in the shape's histo
    :type frontOfChain: boolean
    :param geometry: (Q E M) The specified object will be added to the list of objects being
    deformed by this deformer object, unless the -rm flag is also specified  When queried
    :type geometry: string
    :param geometryIndices: (Q) Complements the -geometry flag in query mode  Returns the multi
    index of each geometry
    :type geometryIndices: boolean
    :param groupWithBase: (C) Groups the wire with the base wire so that they can easily be
    moved together to create a ripple effect  Default is false
    :type groupWithBase: boolean
    :param holder: (C Q E M) Set the specified curve or surface (second parameter as a holder
    for the wire at index (first parameter)
    :type holder: [int, string]
    :param ignoreSelected: (C) Tells the command to not deform objects on the current selection
    list
    :type ignoreSelected: boolean
    :param includeHiddenSelections: (C) Apply the deformer to any visible and hidden objects in
    the selection list  Default is false
    :type includeHiddenSelections: boolean
    :param localInfluence: (C Q E) Set the local control a wire has with respect to other wires
    irrespective of whether it is deforming the surface  Varies from no local effect at 0 to
    :type localInfluence: float
    :param name: (C) Used to specify the name of the node being created
    :type name: string
    :param parallel: (C E) Inserts the new deformer in a parallel chain to any existing
    deformers in the history of the object  A blendShape is inserted to blend the parallel r
    :type parallel: boolean
    :param prune: (E) Removes any points not being deformed by the deformer in its current
    configuration from the deformer set
    :type prune: boolean
    :param remove: (E M) Specifies that objects listed after the -g flag should be removed from
    this deformer
    :type remove: boolean
    :param split: (C E) Branches off a new chain in the dependency graph instead of
    inserting/appending the deformer into/onto an existing chain  Works in create mode (and e
    :type split: boolean
    :param wire: (C Q E M) Specify or query the wire curve name
    :type wire: string
    :param wireCount: (C Q E) Set the number of wires
    :type wireCount: int
    
    :returns: The wire node name and the wire curve name
    :rtype: string[]
    """
    pass


def FBXImportUnlockNormals(*args, **kwargs):
    """
    
    """
    pass


def geometryExportCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleMeshUVBorders(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowPlanes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyMergeFacetCtx(*args, activeNodes=True, exists=True, image1="", image2="", image3="",
                      immediate=True, name="", previous=True, reset=True, toolNode=True,
                      caching=True, constructionHistory=True, firstFacet=0, mergeMode=0,
                      nodeState=0, secondFacet=0, q=True, query=True, e=True, edit=True,
                      **kwargs):
    """
    The second face becomes a hole in the first face.
    
    :param activeNodes: (Q) Return the active nodes in the tool
    :type activeNodes: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param immediate: (E) Acts on the object not the tool defaults
    :type immediate: boolean
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param previous: (E) Reset to previously stored values
    :type previous: boolean
    :param reset: (E) Reset to default values
    :type reset: boolean
    :param toolNode: (Q) Return the node used for tool defaults
    :type toolNode: boolean
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param firstFacet: (C Q E) The number of the first (outer) face to merge
    :type firstFacet: int
    :param mergeMode: (C Q E) This flag specifies how faces are merged: 0: moves second face to
    first one 1: moves both faces to average 2: moves first face to second one 3, 4, 5:
    :type mergeMode: int
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param secondFacet: (C Q E) The number of the second (hole) face to merge
    :type secondFacet: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def ParticleCollisionEvents(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def stitchSurfaceCtx(*args, **kwargs):
    """
    
    """
    pass


def toggle(*args, above=True, below=True, boundary=True, boundingBox=True, controlVertex=True,
           doNotWrite=True, editPoint=True, extent=True, facet=True, geometry=True, gl=True,
           highPrecisionNurbs=True, hull=True, latticePoint=True, latticeShape=True,
           localAxis=True, newCurve=True, newPolymesh=True, newSurface=True, normal=True,
           origin=True, point=True, pointDisplay=True, pointFacet=True, rotatePivot=True,
           scalePivot=True, selectHandle=True, state=True, surfaceFace=True, template=True,
           uvCoords=True, vertex=True, q=True, query=True, **kwargs):
    """
    The toggle command is used to toggle the display of various object features for objects
    which have these components  For example, CV and edit point display may be toggled for
    those listed NURB curves or surfaces   Note: This command is not undoable
    
    :param above: (C) Toggle state for all objects above listed objects
    :type above: boolean
    :param below: (C) Toggle state for all objects below listed objects
    :type below: boolean
    :param boundary: (C Q) Toggle boundary display of listed mesh objects
    :type boundary: boolean
    :param boundingBox: (C Q) Toggle or query the bounding box display of listed objects
    :type boundingBox: boolean
    :param controlVertex: (C Q) Toggle CV display of listed curves and surfaces
    :type controlVertex: boolean
    :param doNotWrite: (C Q) Toggle the "this should be written to the file" state
    :type doNotWrite: boolean
    :param editPoint: (C Q) Toggle edit point display of listed curves and surfaces
    :type editPoint: boolean
    :param extent: (C Q) Toggle display of extents of listed mesh objects
    :type extent: boolean
    :param facet: (C Q) For use with normal flag  Set the normal display style to facet
    display
    :type facet: boolean
    :param geometry: (C Q) Toggle geometry display of listed objects
    :type geometry: boolean
    :param gl: (C) Toggle state for all objects
    :type gl: boolean
    :param highPrecisionNurbs: (C Q) Toggle high precision display for Nurbs
    :type highPrecisionNurbs: boolean
    :param hull: (C Q) Toggle hull display of listed curves and surfaces
    :type hull: boolean
    :param latticePoint: (C Q) Toggle point display of listed lattices
    :type latticePoint: boolean
    :param latticeShape: (C Q) Toggle display of listed lattices
    :type latticeShape: boolean
    :param localAxis: (C Q) Toggle local axis display of listed objects
    :type localAxis: boolean
    :param newCurve: (C Q) Set component display state of new curve objects
    :type newCurve: boolean
    :param newPolymesh: (C Q) Set component display state of new polymesh objects
    :type newPolymesh: boolean
    :param newSurface: (C Q) Set component display state of new surface objects
    :type newSurface: boolean
    :param normal: (C Q) Toggle display of normals of listed surface and mesh objects
    :type normal: boolean
    :param origin: (C Q) Toggle origin display of listed surfaces
    :type origin: boolean
    :param point: (C Q) For use with normal flag  Set the normal display style to vertex
    display
    :type point: boolean
    :param pointDisplay: (C Q) Toggle point display of listed surfaces
    :type pointDisplay: boolean
    :param pointFacet: (C Q) For use with normal flag  Set the normal display style to vertex
    and face display
    :type pointFacet: boolean
    :param rotatePivot: (C Q) Toggle rotate pivot display of listed objects
    :type rotatePivot: boolean
    :param scalePivot: (C Q) Toggle scale pivot display of listed objects
    :type scalePivot: boolean
    :param selectHandle: (C Q) Toggle select handle display of listed objects
    :type selectHandle: boolean
    :param state: (C) Explicitly set the state to true or false instead of toggling the state 
    Can not be queried
    :type state: boolean
    :param surfaceFace: (C Q) Toggle surface face handle display of listed surfaces
    :type surfaceFace: boolean
    :param template: (C Q) Toggle template state of listed objects
    :type template: boolean
    :param uvCoords: (C Q) Toggle display uv coords of listed mesh objects
    :type uvCoords: boolean
    :param vertex: (C Q) Toggle vertex display of listed mesh objects
    :type vertex: boolean
    
    :returns: when in the query mode. none otherwise.
    :rtype: boolean
    """
    pass


def IntersectCurveOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def menuEditor(*args, annotation="", backgroundColor=None, cellHeight=0, cellWidth=0,
               cellWidthHeight=None, checkBoxPresent=None, checkBoxState=None, childArray=True,
               command=None, defineTemplate="", delete=None, docTag="", dragCallback=None,
               dropCallback=None, enable=True, enableBackground=True, enableKeyboardFocus=True,
               exists=True, fullPathName=True, height=0, highlightColor=None,
               iconMenuCallback="", image=None, isObscured=True, label=None, manage=True,
               menuItemTypes=True, noBackground=True, numberOfChildren=True,
               numberOfPopupMenus=True, optionBoxCommand=None, optionBoxPresent=None, parent="",
               popupMenuArray=True, preventOverride=True, radioButtonPresent=None,
               radioButtonState=None, separator=None, statusBarMessage="", style="",
               subMenuAt=None, subMenuEditorWindow="", subMenuEditorsOpen=True, subMenuOf=None,
               topLevelMenu="", useTemplate="", visible=True, visibleChangeCommand=None,
               width=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    A menuEditor displays the contents of a popup menu and allows the menu's items to be edited
     Menu items are represented by labelled icons which can be dragged around within the editor
    to change the menu's layout  Various objects can be dragged and dropped into the menuEditor
    to create new menu items: toolButtons from the shelf or toolbox, shelfButt
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param cellHeight: (Q E) The height of the icons in the menuEditor
    :type cellHeight: int
    :param cellWidth: (Q E) The width of the icons in the menuEditor
    :type cellWidth: int
    :param cellWidthHeight: (E) The width and height of the icons in the menuEditor
    :type cellWidthHeight: [int, int]
    :param checkBoxPresent: (Q E) This controls whether a menu item has a check box or not  The
    arguments are a flag indicating presence, followed by the position of the menu item  Th
    :type checkBoxPresent: [boolean, string, int]
    :param checkBoxState: (Q E) The state of the check box associated with a menu item  The
    arguments are a flag indicating state, followed by the position of the menu item  This fl
    :type checkBoxState: [boolean, string, int]
    :param childArray: (Q) Returns a string array of the names of the layout's immediate
    children
    :type childArray: boolean
    :param command: (Q E) The command or script executed by a menu item  The arguments are the
    command string or script name, followed by the position of the menu item  This f
    :type command: [string, string, int]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param delete: (E) Deletes the menu item at the given position, removing it from the menu 
    If the menu item has a submenu, and a sub-menuEditor is open and attached to
    :type delete: [string, int]
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param iconMenuCallback: (C) This is the name of a MEL callback procedure that is called to
    create the popup menus attached to icons in the menuEditor  The callback is called onc
    :type iconMenuCallback: string
    :param image: (Q E) The filename of the icon associated with a menu item  This icon is
    displayed by the menuEditor to represent the menu item  The arguments are the icon
    :type image: [string, string, int]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (Q E) The label of a menu item  The arguments are the label text, followed by
    the position of the menu item  If queried, an array of strings is returned co
    :type label: [string, string, int]
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param menuItemTypes: (Q) This is a query only flag  Returns an array of strings indicating
    the type of contents in each cell of the menuEditor  Cells can be "vacant", or may
    :type menuItemTypes: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfChildren: (Q) Returns in an int the number of immediate children of the
    layout
    :type numberOfChildren: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param optionBoxCommand: (Q E) The command or script executed by a menu item's associated
    option box item  The arguments are the command string or script name, followed by the posi
    :type optionBoxCommand: [string, string, int]
    :param optionBoxPresent: (Q E) This controls whether a menu item has an associated option
    box item or not  The arguments are a flag indicating presence, followed by the position of
    :type optionBoxPresent: [boolean, string, int]
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param radioButtonPresent: (Q E) This controls whether a menu item has a radio button or
    not  The arguments are a flag indicating presence, followed by the position of the menu
    item
    :type radioButtonPresent: [boolean, string, int]
    :param radioButtonState: (Q E) The state of the radio button associated with a menu item 
    The arguments are a flag indicating state, followed by the position of the menu item  This
    :type radioButtonState: [boolean, string, int]
    :param separator: (Q E) In edit mode this adds a separator to the menuEditor at the
    specified position  The parameters are the radialPosition and the overflowRow  If queried
    :type separator: [string, int]
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param style: (Q E) This is the style of icons within the menuEditor  Valid styles are
    "iconOnly", "textOnly", "iconAndTextHorizontal" and "iconAndTextVertical"
    :type style: string
    :param subMenuAt: (E) Creates a submenu item at the given position  A submenu item created
    within the radial portion of a menu will overwrite whatever item (if any) is cur
    :type subMenuAt: [string, int]
    :param subMenuEditorWindow: (C) The name of the window which contains a sub-menuEditor 
    Only use when creatitg a sub-menuEditor  This window will automatically be closed if a
    parent
    :type subMenuEditorWindow: string
    :param subMenuEditorsOpen: (Q) This is a query only flag  Returns an array of booleans,
    each of which indicates if a sub-menuEditor is open and attached to the menu item in a
    parti
    :type subMenuEditorsOpen: boolean
    :param subMenuOf: (C) Attaches a sub-menuEditor to its parent menuEditor  Only use when
    creatitg a sub-menuEditor  The arguments are the name of the parent menuEditor, fol
    :type subMenuOf: [string, string, int]
    :param topLevelMenu: (Q E) The popup menu to attach to the editor  All editing operations
    performed in the editor (i.e  inserting/deleting/moving an item) will be immediately r
    :type topLevelMenu: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the editor.
    :rtype: string
    """
    pass


def XgmSetNoiseBrushToolOption(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def autoKeyframe(*args, addAttr=None, characterOption="standard", listAttr=True, noReset=True,
                 state=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    With no flags, this command will set keyframes on all attributes that have been modified
    since an "autoKeyframe -state on" command was issued  To stop keeping track of modified
    attributes, use "autoKeyframe -state off"  autoKeyframe does not create new animation
    curves  An attribute must have already been keyframed (with the setKeyframe command) fo
    
    :param addAttr: (E) Add to the list of plugs (node.attribute) that autoKeyframe is
    currently considering for auto keying  This list is transient and short-lived, and is
    :type addAttr: name
    :param characterOption: (C Q E) Valid options are: "standard", "all"  Dictates whether when
    auto-keying characters the auto-key works as usual or whether it keys all of the characte
    :type characterOption: string
    :param listAttr: (Q) Returns the list of plugs (node.attribute) that autoKeyframe is
    currently considering for auto keying  This list is transient and short-lived, and is
    :type listAttr: boolean
    :param noReset: (C E) Must be used in conjunction with the state/st flag  When noReset/nr
    is specified, the list of plugs to be autokeyed is not cleared when the state cha
    :type noReset: boolean
    :param state: (C Q E) turns on/off remembering of modified attributes
    :type state: boolean
    
    :returns: Number of keyframes set.
    :rtype: int
    """
    pass


def ThreeLeftSplitViewArrangement(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_customPivotToolPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def itemFilterRender(*args, **kwargs):
    """
    
    """
    pass


def SoftModToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeShapeMenuStateAllExceptShadingGroupMembers(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DragOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeSelectLights(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_quadDrawTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dockControl(*args, allowedArea="all", annotation="", area="", backgroundColor=None,
                closeCommand=None, content="", defineTemplate="", docTag="", dockStation="",
                dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
                enableKeyboardFocus=True, enablePopupOption=True, exists=True, fixedHeight=True,
                fixedWidth=True, floatChangeCommand=None, floating=True, fullPathName=True,
                height=0, highlightColor=None, isObscured=True, label="", manage=True,
                moveable=True, noBackground=True, numberOfPopupMenus=True, parent="",
                popupMenuArray=True, preventOverride=True, r=True, retain=True, sizeable=True,
                splitLayout="", state="", statusBarMessage="", useTemplate="", visible=True,
                visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
                **kwargs):
    """
    Create a dockable control, also known as tool palette or utility window  Dock controls are
    secondary windows placed in the dock area around the central control in a main window  Dock
    windows can be moved inside their current area, moved into new areas and floated (e.g 
    undocked)  Dock control consists of a title bar and the content area  The titleb
    
    :param allowedArea: (C Q E M) Areas where the dock control may be placed  Valid values are
    "top", "left", "bottom", "right" and "all"  The default is "all"
    :type allowedArea: string
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param area: (C Q E) The initial dock area for this dock control  This is a required flag
    :type area: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param closeCommand: (C E) Script executed after the dock control is closed
    :type closeCommand: script
    :param content: (C Q) The name of the control that is the content of this dock control 
    This is a required flag
    :type content: string
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dockStation: (C) The name of the control the window can be docked into  If this is
    not set it is assumed to be the main window
    :type dockStation: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param enablePopupOption: (C Q E) Whether or not the menu option for the dock control in
    the UI Elements popup menu is enabled
    :type enablePopupOption: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fixedHeight: (C Q E) Whether or not the dockControl height may be interactively
    resized
    :type fixedHeight: boolean
    :param fixedWidth: (C Q E) Whether or not the dockControl width may be interactively
    resized
    :type fixedWidth: boolean
    :param floatChangeCommand: (C E) The script executed when the floating state of the dock
    widget changes
    :type floatChangeCommand: script
    :param floating: (C Q E) Whether the dock widget is floating  A floating dock widget is
    presented to the user as an independent window "on top" of main window, instead of bei
    :type floating: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) The label text  The default label is the name of the control
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param moveable: (C Q E) Control over whether or not the dockControl may be
    undocked/redocked
    :type moveable: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param r: (Q E) Whether the dock widget is visible and either floating or at the top of its
    dock widget area
    :type r: boolean
    :param retain: (C Q E) Control over whether or not the window and its contents are deleted
    when closed  The default is true  The window and its contents are retained when c
    :type retain: boolean
    :param sizeable: (C Q E) Whether or not the dockControl width may be interactively resized 
    Deprecated!! Use the fixedWidth flag instead
    :type sizeable: boolean
    :param splitLayout: (C) When two windows are added to a single docking area they are by
    default tabbed together  Setting a value for splitLayout will allow it to be placed n
    :type splitLayout: string
    :param state: (C Q E) When queried this flag will return a string holding the dock control
    state information  This string is a hexadecimal representation of a binary strin
    :type state: string
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def Parent(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PaintEffectsGlobalSettings(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def menuBarLayout(*args, annotation="", backgroundColor=None, childArray=True,
                  defineTemplate="", docTag="", dragCallback=None, dropCallback=None,
                  enable=True, enableBackground=True, enableKeyboardFocus=True, exists=True,
                  fullPathName=True, height=0, highlightColor=None, isObscured=True,
                  manage=True, menuArray=True, menuBarVisible=True, menuIndex=None,
                  noBackground=True, numberOfChildren=True, numberOfMenus=True,
                  numberOfPopupMenus=True, parent="", popupMenuArray=True, preventOverride=True,
                  statusBarMessage="", useTemplate="", visible=True, visibleChangeCommand=None,
                  width=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Create a layout containing a menu bar  The menu bar will appear and behave similar to any
    menu bar created with the 'window -menuBar true' command  Menus may be created with a
    menuBarLayout as their parent  Child controls are simply positioned to fill the
    menuBarLayout area beneath the menu bar consequently, some other layout should be used as
    the 
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param childArray: (Q) Returns a string array of the names of the layout's immediate
    children
    :type childArray: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param menuArray: (Q) Return a string array containing the names of the menus in the
    layout's menu bar
    :type menuArray: boolean
    :param menuBarVisible: (C Q E) Visibility of the menu bar
    :type menuBarVisible: boolean
    :param menuIndex: (E) Sets the index of a specified menu
    :type menuIndex: [string, int]
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfChildren: (Q) Returns in an int the number of immediate children of the
    layout
    :type numberOfChildren: boolean
    :param numberOfMenus: (Q) Return the number of menus attached to the layout's menu bar
    :type numberOfMenus: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def BevelPlus(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeDisplayAsExtraLargeSwatches(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GPUBuiltInDeformerControl(*args, **kwargs):
    """
    
    """
    pass


def PolygonClearClipboardOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def getFileList(*args, filespec="", folder="", **kwargs):
    """
    Returns a list of files matching an optional wildcard pattern  Note that this command works
    directly on raw system files and does not go through standard Maya file path resolution
    
    :param filespec: (C) wildcard specifier for search
    :type filespec: string
    :param folder: (C) return a directory listing
    :type folder: string
    
    :returns: an array of file names
    :rtype: string[]
    """
    pass


def ShowAllPolyComponents(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyPrimitiveMisc(*args, **kwargs):
    """
    
    """
    pass


def AddEdgeDivisions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SubdivToNURBS(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RemoveSubdivProxyMirror(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polySplitEdge(*args, operation=0, caching=True, constructionHistory=True, name="",
                  nodeState=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Split Edges.
    
    :param operation: (C Q E) 0 means use a Non-Manifold method, 1 means use a Manifold method
    :type operation: int
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def UVSnapTogether(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FluidEmitterOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleSoftEdges(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def regionSelectKeyCtx(*args, bottomManip=0.0, exists=True, history=True, image1="", image2="",
                       image3="", leftManip=0.0, name="", rightManip=0.0, topManip=0.0, q=True,
                       query=True, e=True, edit=True, **kwargs):
    """
    This command creates a context which may be used to scale keyframes within the graph editor
    using the region select tool
    
    :param bottomManip: (Q) Get a point located inside the bottom manipulator of the region box,
    in screen space
    :type bottomManip: float
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param leftManip: (Q) Get a point located inside the left manipulator of the region box, in
    screen space
    :type leftManip: float
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param rightManip: (Q) Get a point located inside the right manipulator of the region box,
    in screen space
    :type rightManip: float
    :param topManip: (Q) Get a point located inside the top manipulator of the region box, in
    screen space
    :type topManip: float
    
    :returns: Manip values, when queried
    :rtype: float
    """
    pass


def EnableSelectedIKHandles(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DefaultQualityDisplay(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def attrEnumOptionMenu(*args, annotation="", attribute=None, backgroundColor=None,
                       changeCommand=None, defineTemplate="", docTag="", dragCallback=None,
                       dropCallback=None, enable=True, enableBackground=True,
                       enableKeyboardFocus=True, enumeratedItem=None, exists=True,
                       fullPathName=True, height=0, highlightColor=None, isObscured=True,
                       label="", manage=True, noBackground=True, numberOfPopupMenus=True,
                       parent="", popupMenuArray=True, preventOverride=True,
                       statusBarMessage="", useTemplate="", visible=True,
                       visibleChangeCommand=None, width=0, q=True, query=True, e=True,
                       edit=True, **kwargs):
    """
    This command creates an enumerated attribute control  It is usually an option menu
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param attribute: (C E) Attribute that the menu controls
    :type attribute: name
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) The command string is executed when the value of the option
    menu changes
    :type changeCommand: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param enumeratedItem: (C M) Enumerated item and the corresponding string  If this flag is
    not supplied when the control is created, then the command will try to read the values
    :type enumeratedItem: [int, string]
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) The label text
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The full name of the control.
    :rtype: string
    """
    pass


def SelectAllMarkingMenu(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UVNormalBasedProjection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorRenameActiveTab(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmNop(*args, **kwargs):
    """
    
    """
    pass


def OrientJoint(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def rollCtx(*args, alternateContext=True, exists=True, history=True, image1="", image2="",
            image3="", name="", rollScale=0.0, toolName="", q=True, query=True, e=True,
            edit=True, **kwargs):
    """
    Create, edit, or query a roll context
    
    :param alternateContext: (C Q) Set the ALT+MMB and ALT+SHIFT+MMB to refer to this context
    :type alternateContext: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param rollScale: (C Q E) In degrees of rotation per 100 pixels of cursor drag
    :type rollScale: float
    :param toolName: (C Q) Name of the specific tool to which this command refers
    :type toolName: string
    
    :returns: The name of the context
    :rtype: string
    """
    pass


def SetMeshEraseTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_overlayAppendMeshTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MatchTransform(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PaintSetMembershipTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetMeshFreezeTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ModifyLowerRadiusPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_bridgePress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AimConstraintOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def button(*args, actOnPress=True, actionIsSubstitute=True, align="", annotation="",
           backgroundColor=None, command=None, defineTemplate="", docTag="", dragCallback=None,
           dropCallback=None, enable=True, enableBackground=True, enableKeyboardFocus=True,
           exists=True, fullPathName=True, height=0, highlightColor=None, isObscured=True,
           label="", manage=True, noBackground=True, numberOfPopupMenus=True, parent="",
           popupMenuArray=True, preventOverride=True, recomputeSize=True, statusBarMessage="",
           useTemplate="", visible=True, visibleChangeCommand=None, width=0, q=True, query=True,
           e=True, edit=True, **kwargs):
    """
    Create a button control capable of displaying a textual label and executing a command when
    selected by the user
    
    :param actOnPress: (C Q E) If true then the command specified by the command flag will be
    executed when a mouse button is pressed  If false then that command will be executed a
    :type actOnPress: boolean
    :param actionIsSubstitute: (C Q E) This flag is obsolete and should no longer be used
    :type actionIsSubstitute: boolean
    :param align: (C Q E) This flag is obsolete and should no longer be used  The button label
    will always be center-aligned
    :type align: string
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param command: (C Q E) Command executed when the control is pressed
    :type command: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) The label text  The default label is the name of the control
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param recomputeSize: (C Q E) If true then the control will recompute it's size to just fit
    the size of the label  If false then the control size will remain fixed as you change t
    :type recomputeSize: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def Create2DContainerEmitter(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Unfold3DuvUpdateCommand(*args, **kwargs):
    """
    
    """
    pass


def nClothReplaceCacheOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CoarseLevelComponentDisplay(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nurbsCopyUVSet(*args, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This is only a sample command for debugging purposes, which makes a copy of the implicit st
    parameterization on a nurbs surface to be the 1st explicit uvset
    
    
    :returns: Success or Failure.
    :rtype: boolean
    """
    pass


def XgmSplineCacheDeleteOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RotateUVs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def webBrowserPrefs(*args, **kwargs):
    """
    
    """
    pass


def webBrowser(*args, annotation="", back=True, backgroundColor=None, defineTemplate="",
               docTag="", dragCallback=None, dropCallback=None, enable=True,
               enableBackground=True, enableKeyboardFocus=True, exists=True, find="",
               forward=True, fullPathName=True, height=0, highlightColor=None, home=True,
               isObscured=True, manage=True, matchCase=True, matchWholeWorld=True,
               noBackground=True, numberOfPopupMenus=True, openURL="", parent="",
               popupMenuArray=True, preventOverride=True, reload=True, searchForward=True,
               statusBarMessage="", stop=True, urlChangedCb="", useTemplate="", visible=True,
               visibleChangeCommand=None, width=0, wrap=True, q=True, query=True, e=True,
               edit=True, **kwargs):
    """
    This command is obsolete and will be removed in next version of Maya  The internal web
    browser of Maya has been replaced by a plug-in which allows your own browser to connect
    with Maya  Please refer help for information on how to setup communication of Maya with
    external web browser application
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param back: (C) Go back a page
    :type back: boolean
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param find: (C) Find text in a page
    :type find: string
    :param forward: (C) Go forward a page
    :type forward: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param home: (C) Go to the home page
    :type home: boolean
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param matchCase: (C) True if the match should respect the case
    :type matchCase: boolean
    :param matchWholeWorld: (C) True if the match should check the whole world
    :type matchWholeWorld: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param openURL: (C Q E) Open the named URL
    :type openURL: string
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param reload: (C) Reload the current page
    :type reload: boolean
    :param searchForward: (C) True if search should be going forward from the current location
    :type searchForward: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param stop: (C) Stop loading a page
    :type stop: boolean
    :param urlChangedCb: (C) Command to call when the URL changes
    :type urlChangedCb: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    :param wrap: (C) Set to true if the page should wrap
    :type wrap: boolean
    
    :returns: Full path name to the control
    :rtype: string
    """
    pass


def createPolyPrismCtx(*args, **kwargs):
    """
    
    """
    pass


def CreateLattice(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BothProxySubdivDisplay(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BlendShapeEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GetOceanPondExample(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def attributeMenu(*args, beginMenu=True, editor="", finishMenu=True, inputs=True, plug=None,
                  regPulldownMenuCommand="", unregPulldownMenuCommand=0, **kwargs):
    """
    Action to generate popup connection menus for Hypershade  This command is used internally
    by the Hypershade panel
    
    :param beginMenu: (C) If true the menu will be used to start a connection edit so it will
    list all available attributes for either inputs or outputs  If false the menu wil
    :type beginMenu: boolean
    :param editor: (C) Name of the Hypergraph, Hypershade or Visor editor for which this menu
    is being built  This argument is no longer mandatory  If it is omitted, the in
    :type editor: string
    :param finishMenu: (C) finishes the menu
    :type finishMenu: boolean
    :param inputs: (C) If true only attributes which can be used as inputs will be listed  If
    false only attributes which can be used as outputs will be listed
    :type inputs: boolean
    :param plug: (C) If inputs is false then we are completing a connection and the name of the
    plug at the other end of the connection must be supplied
    :type plug: name
    :param regPulldownMenuCommand: (C) This flag will register a callback that allows the user
    to define their own popup menu for a specific node type for use in the Hypershade and
    Hypergr
    :type regPulldownMenuCommand: string
    :param unregPulldownMenuCommand: (C) This flag will unregister a callback procedure that
    was registered with the -regPulldownMenuCommand flag  The argument should be the integer
    identifi
    :type unregPulldownMenuCommand: int
    
    :returns: Command result
    :rtype: string
    """
    pass


def UVAutomaticProjectionOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OutlinerUnhide(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def floatScrollBar(*args, annotation="", backgroundColor=None, changeCommand=None,
                   defineTemplate="", docTag="", dragCallback=None, dragCommand=None,
                   dropCallback=None, enable=True, enableBackground=True,
                   enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
                   highlightColor=None, horizontal=True, isObscured=True, largeStep=0.0,
                   manage=True, maxValue=0.0, minValue=0.0, noBackground=True,
                   numberOfPopupMenus=True, parent="", popupMenuArray=True,
                   preventOverride=True, statusBarMessage="", step=0.0, useTemplate="",
                   value=0.0, visible=True, visibleChangeCommand=None, width=0, q=True,
                   query=True, e=True, edit=True, **kwargs):
    """
    Create a scroll bar control that accepts only float values and is bound by a minimum and
    maximum value  The scroll bar displays a marker indicating the current value of the scroll
    bar relative to its minimum and maximum values  Click and drag the marker or on the scroll
    bar itself to change the current value
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Command executed when the value changes  This command is not
    invoked when the value changes via the -v/value flag
    :type changeCommand: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dragCommand: (C E) Command executed when the value changes by dragging the scroll
    bar's value marker
    :type dragCommand: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param horizontal: (C Q) Orientation of the slider  This flag is true by default, which
    corresponds to a horizontally oriented slider
    :type horizontal: boolean
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param largeStep: (C Q E) Larger increment for the scroll bar, ie  the increment used when
    the press is between the arrow button and the thumb
    :type largeStep: float
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param maxValue: (C Q E) Upper limit of the scroll bar
    :type maxValue: float
    :param minValue: (C Q E) Lower limit of the scroll bar
    :type minValue: float
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param step: (C Q E) Smaller increment for the scroll bar, ie  the increment used when the
    arrow buttons are pressed
    :type step: float
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param value: (C Q E) Value of the scroll bar
    :type value: float
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def ViewImage(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddBifrostFoamMask(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateSubdivSphere(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeShowAllAttrs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteAllDynamicConstraints(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def createEditor(*args, noCloseOnDelete=True, queueForDelete=True, **kwargs):
    """
    This command creates a property sheet for any dependency node  The second argument is the
    name of the node, and the first is the name of a layout into which the property sheet
    controls should be placed   The property sheets created by this command can by
    user-customized using the editorTemplate command
    
    :param noCloseOnDelete: (C) If this flag is set then don't close the editor when the data
    is deleted
    :type noCloseOnDelete: boolean
    :param queueForDelete: (C) The specified layout is put on a queue  When the queue is full,
    layouts past the end of the queue are automatically deleted  If the layout is already
    :type queueForDelete: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def ExportOfflineFile(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def surface(*args, degreeU=0, degreeV=0, formU="", formV="", knotU=0.0, knotV=0.0, name="",
            objectSpace=True, point=None, pointWeight=None, worldSpace=True, **kwargs):
    """
    The cmd creates a NURBS spline surface (rational or non rational)  The surface is created
    by specifying control vertices (CV's) and knot sequences in the U and V direction  You
    cannot query the properties of the surface using this command  See examples below
    
    :param degreeU: (C) Degree in surface U direction  Default is degree 3
    :type degreeU: int
    :param degreeV: (C) Degree in surface V direction  Default is degree 3
    :type degreeV: int
    :param formU: (C) The string for open is "open" , for closed is "closed" or for periodic is
    "periodic" in U
    :type formU: string
    :param formV: (C) The string for open is "open" , for closed is "closed" or for periodic is
    "periodic" in V
    :type formV: string
    :param knotU: (C M) Knot value(s) in U direction  One flag per knot value  There must be
    (numberOfPointsInU + degreeInU - 1) knots and the knot vector must be non-decrea
    :type knotU: float
    :param knotV: (C M) Knot value(s) in V direction  One flag per knot value  There must be
    (numberOfPointsInV + degreeInV - 1) knots and the knot vector must be non-decrea
    :type knotV: float
    :param name: (C) Name to use for new transforms
    :type name: string
    :param objectSpace: (C) Should the operation happen in objectSpace?
    :type objectSpace: boolean
    :param point: (C M) To specify non rational CV with (x, y, z) values  "linear" means that
    this flag can take values with units  Note that you must specify (degree+1) sur
    :type point: [float, float, float]
    :param pointWeight: (C M) To specify rational CV with (x, y, z, w) values  "linear" means
    that this flag can take values with units  Note that you must specify (degree+1) surf
    :type pointWeight: [float, float, float, float]
    :param worldSpace: (C) Should the operation happen in worldSpace?
    :type worldSpace: boolean
    
    :returns: The path to the new surface
    :rtype: string
    """
    pass


def NURBSSmoothnessHullOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BrushPresetBlendShape(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def makeSingleSurface(*args, caching=True, constructionHistory=True, name="", nodeState=0,
                      object=True, stitchTolerance=0.1, q=True, query=True, e=True, edit=True,
                      **kwargs):
    """
    This command performs a stitch and tessellate operation
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param stitchTolerance: (E) Stitch tolerance  Default: 0.1
    :type stitchTolerance: float
    
    :returns: Object name and node name.
    :rtype: string[]
    """
    pass


def BridgeEdge(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def LatticeDeformKeysToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ArtPaintSkinWeightsTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateUVShellAlongBorder(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateMotionTrailOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectAllImagePlanes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def InsertKnot(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeOpenModelEditorWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SurfaceBooleanUnionTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AttachSurfacesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_renderGlobalsTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Squash(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DecreaseGammaCoarse(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateBlendShape(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectAllRigidBodies(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CopyUVsToUVSet(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nexCtx(*args, **kwargs):
    """
    
    """
    pass


def SelectAllFluids(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def rotationInterpolation(*args, convert="", q=True, query=True, **kwargs):
    """
    The rotationInterpolation command converts the rotation curves to the desired rotation
    interpolation representation  For example, an Euler-angled representation can be converted
    to Quaternion
    
    :param convert: (C Q) Specifies the rotation interpolation mode for the curves after
    converting  Possible choices are "none" (unsynchronized Euler-angled curves which are
    :type convert: string
    
    :returns: 
    :rtype: None
    """
    pass


def arnoldExportAss(*args, **kwargs):
    """
    
    """
    pass


def refineSubdivSelectionList(*args, **kwargs):
    """
    Refines a subdivision surface set of components based on the selection list  The selected
    components are subdivided  The selection list after the command is the newly created
    components at the finer subdivision level
    
    
    :returns: Command result
    :rtype: boolean
    """
    pass


def CreateImagePlaneOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def deviceManager(*args, attachment=True, axisCoordChanges=True, axisIndex=0, axisName=True,
                  axisOffset=True, axisScale=True, deviceIndex=0, deviceNameFromIndex=0,
                  numAxis=True, numDevices=True, q=True, query=True, e=True, edit=True,
                  **kwargs):
    """
    This command queriers the internal device manager for information on attached devices
    
    :param attachment: (Q) Returns the plugs that a device and axis are attached to  Expects
    the -deviceIndex and axisIndex to be used in conjunction
    :type attachment: boolean
    :param axisCoordChanges: (Q) Returns whether the axis coordinate changes  Expects the
    -deviceIndex and -axisIndex flags to be used in conjunction
    :type axisCoordChanges: boolean
    :param axisIndex: (C Q E) Used usually in conjunction with other flags, to indicate the
    index of the axis
    :type axisIndex: int
    :param axisName: (Q) Returns the name of the axis  Expects the -deviceIndex and -axisIndex
    flags to be used in conjunction
    :type axisName: boolean
    :param axisOffset: (Q) Returns the offset of the axis  Expects the -deviceIndex and
    -axisIndex flags to be used in conjunction
    :type axisOffset: boolean
    :param axisScale: (Q) Returns the scale of the axis  Expects the -deviceIndex and
    -axisIndex flags to be used in conjunction
    :type axisScale: boolean
    :param deviceIndex: (C Q E) Used usually in conjunction with other flags, to indicate the
    index of the device
    :type deviceIndex: int
    :param deviceNameFromIndex: (Q) Returns the name of the device with the given index
    :type deviceNameFromIndex: int
    :param numAxis: (Q) Returns the number of axis this device has  Expects the -deviceIndex
    flag to be used
    :type numAxis: boolean
    :param numDevices: (Q) Returns the number of devices currently attached
    :type numDevices: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def DuplicateEdgesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_objectHideTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_paintPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def poseEditor(*args, control=True, defineTemplate="", docTag="", exists=True, filter="",
               forceMainConnection="", highlightConnection="", lockMainConnection=True,
               mainListConnection="", panel="", parent="", selectionConnection="",
               stateString=True, unParent=True, unlockMainConnection=True,
               updateMainConnection=True, useTemplate="", q=True, query=True, e=True, edit=True,
               **kwargs):
    """
    This command creates an editor that derives from the base editor class that has controls
    for deformer and control nodes
    
    :param control: (Q) Query only  Returns the top level control for this editor  Usually used
    for getting a parent to attach popup menus  Caution: It is possible for an ed
    :type control: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Attaches a tag to the editor
    :type docTag: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param filter: (C Q E) Specifies the name of an itemFilter object to be used with this
    editor  This filters the information coming onto the main list of the editor
    :type filter: string
    :param forceMainConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type forceMainConnection: string
    :param highlightConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its highlight list  Not all editors have a highlight list 
    F
    :type highlightConnection: string
    :param lockMainConnection: (C E) Locks the current list of objects within the
    mainConnection, so that only those objects are displayed within the editor  Further changes
    to the origi
    :type lockMainConnection: boolean
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type mainListConnection: string
    :param panel: (C Q) Specifies the panel for this editor  By default if an editor is created
    in the create callback of a scripted panel it will belong to that panel  If a
    :type panel: string
    :param parent: (C Q E) Specifies the parent layout for this editor  This flag will only
    have an effect if the editor is currently un-parented
    :type parent: string
    :param selectionConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its own selection list  As the user selects things in this
    e
    :type selectionConnection: string
    :param stateString: (Q) Query only flag  Returns the MEL command that will create an editor
    to match the current editor state  The returned command string uses the string va
    :type stateString: boolean
    :param unParent: (C E) Specifies that the editor should be removed from its layout  This
    cannot be used in query mode
    :type unParent: boolean
    :param unlockMainConnection: (C E) Unlocks the mainConnection, effectively restoring the
    original mainConnection (if it is still available), and dynamic updates
    :type unlockMainConnection: boolean
    :param updateMainConnection: (C E) Causes a locked mainConnection to be updated from the
    orginal mainConnection, but preserves the lock state
    :type updateMainConnection: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: The name of the editor
    :rtype: string
    """
    pass


def EnableGlobalStitch(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyExtrudeFacet(*args, attraction=0.0, caching=True, constructionHistory=True,
                     createCurve=True, divisions=1, gain=1.0, gravity=None, gravityX=0.0,
                     gravityY=0.0, gravityZ=0.0, inputCurve=None, keepFacesTogether=True,
                     keepFacetTogether=True, localCenter=0, localDirection=None,
                     localDirectionX=0.0, localDirectionY=0.0, localDirectionZ=0.0,
                     localRotate=None, localRotateX=0.0, localRotateY=0.0, localRotateZ=0.0,
                     localScale=None, localScaleX=0.0, localScaleY=0.0, localScaleZ=0.0,
                     localTranslate=None, localTranslateX=0.0, localTranslateY=0.0,
                     localTranslateZ=0.0, magnX=0.0, magnY=0.0, magnZ=0.0, magnet=None, name="",
                     nodeState=0, offset=0.0, pivot=None, pivotX=0.0, pivotY=0.0, pivotZ=0.0,
                     random=0.0, reverseAllFaces=True, rotate=None, rotateX=0.0, rotateY=0.0,
                     rotateZ=0.0, scale=None, scaleX=0.0, scaleY=0.0, scaleZ=0.0,
                     smoothingAngle=0.0, taper=1.0, taperCurve_FloatValue=0.0,
                     taperCurve_Interp=0, taperCurve_Position=0.0, thickness=0.0,
                     translate=None, translateX=0.0, translateY=0.0, translateZ=0.0, twist=0.0,
                     weight=0.0, worldSpace=True, q=True, query=True, e=True, edit=True,
                     **kwargs):
    """
    Extrude faces  Faces can be extruded separately or together, and manipulations can be
    performed either in world or object space
    
    :param attraction: (C Q E) Attraction, related to magnet  The range is [-2.0, 2.0] 
    Default: 0.0
    :type attraction: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param createCurve: (C) If true then the operation can create a curve
    :type createCurve: boolean
    :param divisions: (C Q E) How many divisions should the extrusion be broken-up into 
    Default: 1
    :type divisions: int
    :param gain: (C Q E M) Gain factor per component  Can be painted using Artisan  Default:
    1.0
    :type gain: float
    :param gravity: (C Q E) The gravity vector  Default: 0.0, -1.0, 0.0
    :type gravity: [float, float, float]
    :param gravityX: (C Q E) Gravity X coord
    :type gravityX: float
    :param gravityY: (C Q E) Gravity Y coord
    :type gravityY: float
    :param gravityZ: (C Q E) Gravity Z coord
    :type gravityZ: float
    :param inputCurve: (C) This flag specifies the name of the curve to be used as input for
    the operation
    :type inputCurve: name
    :param keepFacesTogether: (C Q E) How to extrude faces  If "on", faces are pulled together
    (connected ones stay connected), otherwise they are pulled independently  Default: true
    :type keepFacesTogether: boolean
    :param keepFacetTogether: (C Q E) How to extrude edges  If "on", extruded faces produced
    from the edges being extruded will be kept together  Otherwise they are pulled
    independently
    :type keepFacetTogether: boolean
    :param localCenter: (C Q E) Local center on the edge : 0=Middle point, 1=Start point, 2=End
    point  Default: 0
    :type localCenter: int
    :param localDirection: (C Q E) Direction to determine X axis for local space  Default: 1.0,
    0.0, 0.0
    :type localDirection: [float, float, float]
    :param localDirectionX: (C Q E) X coord of the X axis
    :type localDirectionX: float
    :param localDirectionY: (C Q E) Y coord of the X axis
    :type localDirectionY: float
    :param localDirectionZ: (C Q E) Z coord of the X axis
    :type localDirectionZ: float
    :param localRotate: (C Q E) The local rotations  Default: 0.0, 0.0, 0.0
    :type localRotate: [float, float, float]
    :param localRotateX: (C Q E) Local rotate X coord  The range is [0, 360]
    :type localRotateX: float
    :param localRotateY: (C Q E) Local rotate Y coord  The range is [0, 360]
    :type localRotateY: float
    :param localRotateZ: (C Q E) Local rotate Z coord : Rotation along the normal  The range is
    [0, 360]
    :type localRotateZ: float
    :param localScale: (C Q E) Local Scale  Default: 1.0, 1.0, 1.0
    :type localScale: [float, float, float]
    :param localScaleX: (C Q E) Scale X coord
    :type localScaleX: float
    :param localScaleY: (C Q E) Scale Y coord
    :type localScaleY: float
    :param localScaleZ: (C Q E) Scale Z coord
    :type localScaleZ: float
    :param localTranslate: (C Q E) Local translate  Default: 0.0, 0.0, 0.0
    :type localTranslate: [float, float, float]
    :param localTranslateX: (C Q E) Local translation X coord
    :type localTranslateX: float
    :param localTranslateY: (C Q E) Local translation Y coord
    :type localTranslateY: float
    :param localTranslateZ: (C Q E) Local translation Z coord : Move along the normal
    :type localTranslateZ: float
    :param magnX: (C Q E) Magnet X coord
    :type magnX: float
    :param magnY: (C Q E) Magnet Y coord
    :type magnY: float
    :param magnZ: (C Q E) Magnet Z coord
    :type magnZ: float
    :param magnet: (C Q E) The magnet vector  Default: 0.0, 0.0, 0.0
    :type magnet: [float, float, float]
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param offset: (C Q E) Local offset  Faces are moved this distance towards the inside of
    the face  Default: 0.0
    :type offset: float
    :param pivot: (C Q E) The pivot for scaling and rotation  Default: 0.0, 0.0, 0.0
    :type pivot: [float, float, float]
    :param pivotX: (C Q E) Pivot X coord
    :type pivotX: float
    :param pivotY: (C Q E) Pivot Y coord
    :type pivotY: float
    :param pivotZ: (C Q E) Pivot Z coord
    :type pivotZ: float
    :param random: (C Q E) Random value for all parameters  Default: 0.0
    :type random: float
    :param reverseAllFaces: (C Q E) If "on", original faces are reversed in case of extruding
    all faces  Default: true
    :type reverseAllFaces: boolean
    :param rotate: (C Q E) Rotation angles around X, Y, Z  Default: 0.0, 0.0, 0.0
    :type rotate: [float, float, float]
    :param rotateX: (C Q E) Rotation angle around X
    :type rotateX: float
    :param rotateY: (C Q E) Rotation angle around Y
    :type rotateY: float
    :param rotateZ: (C Q E) Rotation angle around Z
    :type rotateZ: float
    :param scale: (C Q E) Scaling vector  Default: 1.0, 1.0, 1.0
    :type scale: [float, float, float]
    :param scaleX: (C Q E) Scale X coord
    :type scaleX: float
    :param scaleY: (C Q E) Scale Y coord
    :type scaleY: float
    :param scaleZ: (C Q E) Scale Z coord
    :type scaleZ: float
    :param smoothingAngle: (C Q E) Angle below which new edges will be smoothed Default:
    kPi/6.0
    :type smoothingAngle: float
    :param taper: (C Q E) Taper or Scale along the extrusion path Default: 1.0
    :type taper: float
    :param taperCurve_FloatValue: (C Q E) ?????
    :type taperCurve_FloatValue: float
    :param taperCurve_Interp: (C Q E) ????? Default: 0
    :type taperCurve_Interp: int
    :param taperCurve_Position: (C Q E) ?????
    :type taperCurve_Position: float
    :param thickness: (C Q E) Faces are moved outwards from their original position to give the
    object a consistent thickess  Default: 0.0f
    :type thickness: float
    :param translate: (C Q E) Translation vector  Default: 0.0, 0.0, 0.0
    :type translate: [float, float, float]
    :param translateX: (C Q E) Translation X coord
    :type translateX: float
    :param translateY: (C Q E) Translation Y coord
    :type translateY: float
    :param translateZ: (C Q E) Translation Z coord
    :type translateZ: float
    :param twist: (C Q E) Twist or Rotation along the extrusion path Default: 0.0
    :type twist: float
    :param weight: (C Q E) The weight, related to gravity  Default: 0.0
    :type weight: float
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def BrushPresetBlendShadingOff(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DisableSelectedIKHandles(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SaveSceneOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def StraightenCurves(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Create3DContainerOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NextGreasePencilFrame(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_selectModeMarquee(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def applyAttrPattern(*args, nodeType="", patternName="", **kwargs):
    """
    Take the attribute structure described by a pre-defined pattern and apply it either to a
    node (as dynamic attributes) or a node type (as extension attributes)  The same pattern can
    be applied more than once to different nodes or node types as the operation duplicates the
    attribute structure described by the pattern  See the 'createAttrPatterns' com
    
    :param nodeType: (C) Name of the node type to which the attribute pattern is to be applied 
    This flag will cause a new extension attribute tree to be created, making the
    :type nodeType: string
    :param patternName: (C) The name of the pattern to apply  The pattern with this name must
    have been previously created using the createAttrPatterns command
    :type patternName: string
    
    :returns: Number of nodes or node types to which the attribute were added
    :rtype: int
    """
    pass


def MakeCollideHair(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BreakTangent(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SnapKeysOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorShowConnectedAttrs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def InTangentFlat(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideIKHandles(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideDeformers(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_quadDrawPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSetCutBrushToolOption(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyEditUVShell(*args, angle=0.0, pivotU=0.0, pivotV=0.0, relative=True, rotateRatio=1.0,
                    rotation=True, scale=True, scaleU=0.0, scaleV=0.0, uValue=0.0, uvSetName="",
                    vValue=0.0, q=True, query=True, **kwargs):
    """
    Command edits uv shells on polygonal objects  When used with the query flag, it returns the
    transformation values associated with the specified components
    
    :param angle: (C Q) Specifies the angle value (in degrees) that the uv values are to be
    rotated by
    :type angle: float
    :param pivotU: (C Q) Specifies the pivot value, in the u direction, about which the scale
    or rotate is to be performed
    :type pivotU: float
    :param pivotV: (C Q) Specifies the pivot value, in the v direction, about which the scale
    or rotate is to be performed
    :type pivotV: float
    :param relative: (C Q) Specifies whether this command is editing the values relative to the
    currently existing values  Default is true;
    :type relative: boolean
    :param rotateRatio: (C Q) Specifies the ratio value that the uv values are to be rotated by
    Default is 1.0
    :type rotateRatio: float
    :param rotation: (C Q) Specifies whether this command is editing the values with rotation
    values
    :type rotation: boolean
    :param scale: (C Q) Specifies whether this command is editing the values with scale values
    :type scale: boolean
    :param scaleU: (C Q) Specifies the scale value in the u direction
    :type scaleU: float
    :param scaleV: (C Q) Specifies the scale value in the v direction
    :type scaleV: float
    :param uValue: (C Q) Specifies the value, in the u direction - absolute if relative flag is
    false.
    :type uValue: float
    :param uvSetName: (C Q) Specifies the name of the uv set to edit uvs on  If not specified
    will use the current uv set if it exists
    :type uvSetName: string
    :param vValue: (C Q) Specifies the value, in the v direction - absolute if relative flag is
    false.
    :type vValue: float
    
    :returns: Success or Failure.
    :rtype: boolean
    """
    pass


def CreateConstructionPlaneOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def menu(*args, allowOptionBoxes=True, defineTemplate="", deleteAllItems=True, docTag="",
         enable=True, exists=True, familyImage="", helpMenu=True, itemArray=True, label="",
         ltVersion="", mnemonic="", numberOfItems=True, parent="", postMenuCommand=None,
         postMenuCommandOnce=True, scrollable=True, tearOff=True, useTemplate="", version="",
         visible=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a new menu and adds it to the default window's menubar if no parent is
    specified  The menu can be enabled/disabled  Note that this command may also be used on
    menu objects created using the command menuItem -sm/subMenu true
    
    :param allowOptionBoxes: (C Q) Deprecated  All menus now always allow option boxes 
    Indicate whether the menu will be able to support option box menu items
    :type allowOptionBoxes: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param deleteAllItems: (C E) Delete all the items in this menu
    :type deleteAllItems: boolean
    :param docTag: (C Q E) Attaches a tag to the menu
    :type docTag: string
    :param enable: (C Q E) Enables/disables the menu
    :type enable: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param familyImage: (C Q E) The filename of the icon associated with the menu  This icon
    will be used if a menu item does not have an icon image defined
    :type familyImage: string
    :param helpMenu: (C Q E) Indicates that this menu is the help menu and will be the right
    most menu in the menu bar  On Unix systems the help menu is also right justified in t
    :type helpMenu: boolean
    :param itemArray: (Q) Return string array of the menu item names
    :type itemArray: boolean
    :param label: (C Q E) The text that is displayed for the menu  If no label is supplied then
    the menuName will be used
    :type label: string
    :param ltVersion: (C Q E) This flag is used to specify the Maya LT version that this
    control feature was introduced, if the version flag is not specified, or if the version fl
    :type ltVersion: string
    :param mnemonic: (C Q E) Set the Alt key to post that menu  The character specified must
    match the case of its corresponding character in the menu item text, but selection fr
    :type mnemonic: string
    :param numberOfItems: (Q) Return number of items in the menu
    :type numberOfItems: boolean
    :param parent: (C) Specify the window that the menu will appear in
    :type parent: string
    :param postMenuCommand: (C E) Specify a script to be executed when the menu is about to be
    shown
    :type postMenuCommand: script
    :param postMenuCommandOnce: (C Q E) Indicate the -pmc/postMenuCommand should only be
    invoked once  Default value is false, ie  the -pmc/postMenuCommand is invoked every time
    the menu is
    :type postMenuCommandOnce: boolean
    :param scrollable: (C Q E) Make the popup menus support scrolling  Default value is false
    :type scrollable: boolean
    :param tearOff: (C) Makes the menu tear-off-able
    :type tearOff: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param version: (C Q E) Specify the version that this menu feature was introduced  The
    argument should be given as a string of the version number (e.g  "2014", "2015")  Curr
    :type version: string
    :param visible: (C Q E) Shows/hides the menu
    :type visible: boolean
    
    :returns: Full path name to the menu.
    :rtype: string
    """
    pass


def timeField(*args, annotation="", backgroundColor=None, changeCommand=None, defineTemplate="",
              docTag="", dragCallback=None, dragCommand=None, dropCallback=None, editable=True,
              enable=True, enableBackground=True, enableKeyboardFocus=True, enterCommand=None,
              exists=True, fullPathName=True, height=0, highlightColor=None, isObscured=True,
              manage=True, noBackground=True, numberOfPopupMenus=True, parent="",
              popupMenuArray=True, precision=0, preventOverride=True, receiveFocusCommand=None,
              statusBarMessage="", step=None, useTemplate="", value=None, visible=True,
              visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
              **kwargs):
    """
    Create a field control that accepts only time values  An invisible slider is attached to
    the field and accessed by holding down the Ctrl modifier key while pressing one of the
    mouse buttons  Dragging the invisible slider to the right with the middle mouse button
    increases the field value by the amount specified with the -s/step flag, while dragging
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Command executed when the field changes  This command is not
    invoked when the value changes via the -v/value flag
    :type changeCommand: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dragCommand: (C E) Command executed when dragging in the field
    :type dragCommand: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param editable: (C Q E) The edit state of the field  By default, this flag is set to true
    and the field value may be changed by typing into it  If false then the field canno
    :type editable: boolean
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param enterCommand: (C E) Command executed when the keypad 'Enter' key is pressed
    :type enterCommand: script
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param precision: (C Q E) Number of digits to the right of the decimal place
    :type precision: int
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param receiveFocusCommand: (C E) Command executed when the field receives focus
    :type receiveFocusCommand: script
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param step: (C Q E) Increment for the invisible slider  The field value will change by
    this amount when the invisible slider is dragged
    :type step: time
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param value: (C Q E) Value of the field
    :type value: time
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def WalkTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def StraightenUVBorderOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DuplicateSpecial(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CopyUVs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddBifrostEmitter(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FluidGradients(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateShotOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def interactionStyle(*args, **kwargs):
    """
    
    """
    pass


def SaveSceneAsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetShrinkWrapTarget(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowMeshEraseToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectTimeWarp(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def artFluidAttr(*args, **kwargs):
    """
    
    """
    pass


def TangentsFixed(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def redo(*args, **kwargs):
    """
    Takes the most recently undone command from the undo list and redoes it
    
    
    :returns: 
    :rtype: None
    """
    pass


def nurbsToPolygonsPref(*args, chordHeight=0.0, chordHeightRatio=0.0, delta3D=0.0,
                        edgeSwap=True, format=0, fraction=0.0, matchRenderTessellation=0,
                        merge=0, mergeTolerance=0.0, minEdgeLen=0.0, polyCount=0, polyType=0,
                        uNumber=0, uType=0, useChordHeight=True, useChordHeightRatio=True,
                        vNumber=0, vType=0, q=True, query=True, **kwargs):
    """
    This command sets the values used by the nurbs-to-polygons (or "tesselate") preference 
    This preference is used by Maya menu items and is saved between Maya sessions  To query any
    of the flags, use the "-query" flag  For more information on the flags, see the node
    documentation for the "nurbsTessellate" node
    
    :param chordHeight: (C Q) 
    :type chordHeight: float
    :param chordHeightRatio: (C Q) 
    :type chordHeightRatio: float
    :param delta3D: (C Q) 
    :type delta3D: float
    :param edgeSwap: (C Q) 
    :type edgeSwap: boolean
    :param format: (C Q) Valid values are 0, 1 and 2
    :type format: int
    :param fraction: (C Q) 
    :type fraction: float
    :param matchRenderTessellation: (C Q) 
    :type matchRenderTessellation: int
    :param merge: (C Q) 
    :type merge: int
    :param mergeTolerance: (C Q) 
    :type mergeTolerance: float
    :param minEdgeLen: (C Q) 
    :type minEdgeLen: float
    :param polyCount: (C Q) 
    :type polyCount: int
    :param polyType: (C Q) 
    :type polyType: int
    :param uNumber: (C Q) 
    :type uNumber: int
    :param uType: (C Q) 
    :type uType: int
    :param useChordHeight: (C Q) 
    :type useChordHeight: boolean
    :param useChordHeightRatio: (C Q) 
    :type useChordHeightRatio: boolean
    :param vNumber: (C Q) 
    :type vNumber: int
    :param vType: (C Q) 
    :type vType: int
    
    :returns: 
    :rtype: None
    """
    pass


def CreateNURBSTorus(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nSoft(*args, convert=True, duplicate=True, duplicateHistory=True, goal=0.0,
          hideOriginal=True, q=True, query=True, **kwargs):
    """
    Makes a nSoft body from the object(s) passed on the command line or in the selection list 
    The geometry can be a NURBS, polygonal, lattice object  The resulting nSoft body is made up
    of a hierarchy with a particle shape and a geometry shape, thus:     T   / \   T G   /   P 
       Dynamics are applied to the particle shape and the resulting particle po
    
    :param convert: (C) This tells the command that you want the original object to be the
    actual deformed object  The particle shape portion of the nSoft body will be inser
    :type convert: boolean
    :param duplicate: (C) This tells the command that you want to make a copy of the original
    object and use the copy as the deforming geometry  Input connections to the origi
    :type duplicate: boolean
    :param duplicateHistory: (C) This is the same as -d, except that upstream history, is
    duplicated as well, instead of just input connections  This flag and -d are mutually
    exclusi
    :type duplicateHistory: boolean
    :param goal: (C) This is the same as -d, but in addition it tells the command that you want
    the resulting nSoft body to try to follow the original geometry, using the
    :type goal: float
    :param hideOriginal: (C) This flag is used only when duplicating (-d, -g, or -dh)  If set
    to true, whichever of the two objects is NOT the nSoft object will be hidden  In oth
    :type hideOriginal: boolean
    
    :returns: array
    :rtype: string
    """
    pass


def GraphEditorUnlockChannel(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OutlinerToggleAutoExpandLayers(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def fluidEmitter(*args, cycleEmission="", cycleInterval=0, densityEmissionRate=0.0,
                 fluidDropoff=0.0, fuelEmissionRate=0.0, heatEmissionRate=0.0, maxDistance=0.0,
                 minDistance=0.0, name="", position=None, rate=0.0, torusSectionRadius=0.0,
                 type="", volumeOffset=None, volumeShape="", volumeSweep=0.0, q=True,
                 query=True, e=True, edit=True, **kwargs):
    """
    Creates, edits or queries an auxiliary dynamics object (for example, a field or emitter) 
    Creates an emitter object  If object names are provided or if objects are selected, applies
    the emitter to the named/selected object(s)in the scene  Fluid will then be emitted from
    each  If no objects are named or selected, or if the -pos option is specified, 
    
    :param cycleEmission: (Q E) Possible values are "none" and "frame." Cycling emission
    restarts the random number stream after a specified interval  This can either be a number
    of
    :type cycleEmission: string
    :param cycleInterval: (Q E) Specifies the number of frames or particles between restarts of
    the random number stream  See cycleEmission  Has no effect if cycleEmission is set to
    :type cycleInterval: int
    :param densityEmissionRate: (Q E) Rate at which density is emitted
    :type densityEmissionRate: float
    :param fluidDropoff: (Q E) Fluid Emission Dropoff in volume
    :type fluidDropoff: float
    :param fuelEmissionRate: (Q E) Rate at which is emitted
    :type fuelEmissionRate: float
    :param heatEmissionRate: (Q E) Rate at which density is emitted
    :type heatEmissionRate: float
    :param maxDistance: (Q E) Maximum distance at which emission ends
    :type maxDistance: float
    :param minDistance: (Q E) Minimum distance at which emission starts
    :type minDistance: float
    :param name: (C Q E) Object name
    :type name: string
    :param position: (C Q E M) world-space position
    :type position: [float, float, float]
    :param rate: (Q E) Rate at which particles emitted (can be non-integer)  For point emission
    this is rate per point per unit time  For surface emission it is rate per sq
    :type rate: float
    :param torusSectionRadius: (Q E) Section radius for a torus volume  Applies only to torus 
    Similar to the section radius in the torus modelling primitive
    :type torusSectionRadius: float
    :param type: (Q E) Type of emitter  The choices are omni | dir | direction | surf | surface
    | curve | curv  The default is omni  The full definition of these types are:
    :type type: string
    :param volumeOffset: (Q E) Volume offset of the emitter  Volume offset translates the
    emission volume by the specified amount from the actual emitter location  This is in the e
    :type volumeOffset: [float, float, float]
    :param volumeShape: (Q E) Volume shape of the emitter  Sets/edits/queries the field's
    volume shape attribute  If set to any value other than "none", determines a 3-D volume wi
    :type volumeShape: string
    :param volumeSweep: (Q E) Volume sweep of the emitter  Applies only to sphere, cone,
    cylinder, and torus  Similar effect to the sweep attribute in modelling
    :type volumeSweep: float
    
    :returns: Command result
    :rtype: string
    """
    pass


def StitchTogether(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def geometryAppendCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleUVEditorUVStatisticsHUDOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def writeTake(*args, angle="", device="", linear="", noTime=True, precision=6, take="",
              virtualDevice="", **kwargs):
    """
    This action writes a take from a device with recorded data to a take (.mov) file  The
    writeTake action can also write the virtual definition of a device   See also: recordDevice,
    readTake, defineVirtualDevice
    
    :param angle: (C) Sets the angular unit used in the take  Valid strings are
    [deg|degree|rad|radian]  C: The default is the current user angular unit
    :type angle: string
    :param device: (C) Specifies the device that contains the take  This is a required argument
     If the device does not contain a take, the action will fail
    :type device: string
    :param linear: (C) Sets the linear unit used in the take  Valid strings are
    [mm|millimeter|cm|centimeter|m|meter|km|kilometer|in|inch|ft|foot|yd|yard|mi|mile] C: The
    de
    :type linear: string
    :param noTime: (C) The take (.mov) file will not contain time stamps  C: The default is to
    put time stamps in the take file
    :type noTime: boolean
    :param precision: (C) Sets the number of digits to the right of the decimal place in the
    take file  C: The default is 6
    :type precision: int
    :param take: (C) Write out the take to a file with the specified name
    :type take: string
    :param virtualDevice: (C) Writes out the virtual device definition to a mel script with the
    specified file name
    :type virtualDevice: string
    
    :returns: 
    :rtype: None
    """
    pass


def attachDeviceAttr(*args, attribute="", axis="", camera=True, cameraRotate=True,
                     cameraTranslate=True, clutch="", device="", selection=True, q=True,
                     query=True, **kwargs):
    """
    This command associates a device/axis pair with a node/attribute pair  When the device axis
    moves, the value of the attribute is set to the value of the axis  This value can be scaled
    and offset using the setAttrScale command
    
    :param attribute: (C M) specify the attribute to attach to
    :type attribute: string
    :param axis: (C) specify the axis to attach from
    :type axis: string
    :param camera: (C) This flag attaches the device/axis to the current camera  The mapping
    between device axes and camera controls is uses a heuristic based on the device
    :type camera: boolean
    :param cameraRotate: (C) This flag attaches the device/axis to the current cameras rotation
    controls
    :type cameraRotate: boolean
    :param cameraTranslate: (C) This flag attaches the device/axis to the current cameras
    translate controls
    :type cameraTranslate: boolean
    :param clutch: (C) specify a clutch button  This button must be down for the command string
    to be executed  If no clutch is specified the command string is executed eve
    :type clutch: string
    :param device: (C) specify which device to assign the command string
    :type device: string
    :param selection: (C) This flag attaches to the nodes in the selection list  This is
    different from the default arguments of the command since changing the selection will
    :type selection: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def ToggleCurveSelection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BakeNonDefHistory(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def LoadHIKCharacterState(*args, **kwargs):
    """
    
    """
    pass


def xgmPresetSnapshotContext(*args, **kwargs):
    """
    
    """
    pass


def saveToolSettings(*args, **kwargs):
    """
    This command causes all the tools not on the shelf to save their settings as optionVars 
    This is called automatically by the system when Maya exits
    
    
    :returns: 
    :rtype: None
    """
    pass


def pointOnSurface(*args, caching=True, constructionHistory=True, nodeState=0, normal=True,
                   normalizedNormal=True, normalizedTangentU=True, normalizedTangentV=True,
                   parameterU=0.0, parameterV=0.0, position=True, tangentU=True, tangentV=True,
                   turnOnPercentage=False, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command returns information for a point on a surface  If no flag is specified, this
    command assumes p/position by default  If more than one flag is specifed, then a string
    array is returned
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param normal: (C Q E) Returns the (x,y,z) normal of the specified point on the surface
    :type normal: boolean
    :param normalizedNormal: (C Q E) Returns the (x,y,z) normalized normal of the specified
    point on the surface
    :type normalizedNormal: boolean
    :param normalizedTangentU: (C Q E) Returns the (x,y,z) normalized U tangent of the
    specified point on the surface
    :type normalizedTangentU: boolean
    :param normalizedTangentV: (C Q E) Returns the (x,y,z) normalized V tangent of the
    specified point on the surface
    :type normalizedTangentV: boolean
    :param parameterU: (Q E) The U parameter value on surface Default: 0.0
    :type parameterU: float
    :param parameterV: (Q E) The V parameter value on surface Default: 0.0
    :type parameterV: float
    :param position: (C Q E) Returns the (x,y,z) positon of the specified point on the surface
    :type position: boolean
    :param tangentU: (C Q E) Returns the (x,y,z) U tangent of the specified point on the
    surface
    :type tangentU: boolean
    :param tangentV: (C Q E) Returns the (x,y,z) V tangent of the specified point on the
    surface
    :type tangentV: boolean
    :param turnOnPercentage: (Q E) Whether the parameter is normalized (0,1) or not Default:
    false
    :type turnOnPercentage: boolean
    
    :returns: Vector query result
    :rtype: float[3]
    """
    pass


def DeleteSelectedContainers(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExtendCurve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def getClassification(*args, satisfies="", **kwargs):
    """
    Returns the classification string for a given node type   Classification strings look like
    file pathnames ("shader/reflective" or "texture/2D", for example)  Multiple classifications
    can be combined into a single compound classification string by joining the individual
    classifications with ':'  For example, the classification string
    "shader/reflect
    
    :param satisfies: (C) Returns true if the given node type's classification satisfies the
    classification string which is passed with the flag  A non-compound classification
    :type satisfies: string
    
    :returns: Returns the classification strings for the given node type, or
    an empty array if
    the node type is not classified.
    :rtype: string[]
    """
    pass


def vnnCopy(*args, **kwargs):
    """
    
    """
    pass


def InsertKeyToolActivate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def duplicateCurve(*args, caching=True, constructionHistory=True, local=True, maxValue=1.0,
                   mergeItems=True, minValue=1.0, name="", nodeState=0, range=True,
                   relative=False, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The duplicateCurve command takes a curve on a surface and and returns the 3D curve  The
    curve on a surface could be isoparam component, trimmed edge or curve on surface object
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param local: (C) Copy the transform of the surface and connect to the local space version
    instead
    :type local: boolean
    :param maxValue: (C Q E) Maximum parameter value for the curve segment  Must be greater
    than or equal to the minValue attribute  If relative is true, then this attribute has
    :type maxValue: float
    :param mergeItems: (C) Merge component results where possible  For example, instead of
    returning a[1] and a[2], return a[1:2]
    :type mergeItems: boolean
    :param minValue: (C Q E) Minimum parameter value for the curve segment If relative is true,
    then this attribute has minimum value of 0.0  Default: 1.0
    :type minValue: float
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param range: (C) Force a curve range on complete input curve
    :type range: boolean
    :param relative: (C Q E) True means use a relative parameter range, from 0.0 to 1.0 
    Otherwise, the parameter values are absolute values  Default: false
    :type relative: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def panel(*args, control=True, copy="", createString=True, defineTemplate="", docTag="",
          editString=True, exists=True, init=True, isUnique=True, label="",
          menuBarRepeatLast=True, menuBarVisible=True, needsInit=True, parent="",
          popupMenuProcedure=None, replacePanel="", tearOff=True, tearOffCopy="",
          tearOffRestore=True, unParent=True, useTemplate="", q=True, query=True, e=True,
          edit=True, **kwargs):
    """
    This command allows editing or querying properties of any panels  Not all of the common
    properites of panels can be used with this command  Flags such as -tearOff and
    -replacePanel require that you use the explicit panel command  The command 'getPanel
    -typeOf panelName' will return the explicit type of a panel
    
    :param control: (Q) Returns the top level control for this panel  Usually used for getting
    a parent to attach popup menus  CAUTION: panels may not have controls at times
    :type control: boolean
    :param copy: (E) Makes this panel a copy of the specified panel  Both panels must be of the
    same type
    :type copy: string
    :param createString: (E) Command string used to create a panel
    :type createString: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Attaches a tag to the Maya panel
    :type docTag: string
    :param editString: (E) Command string used to edit a panel
    :type editString: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param init: (C E) Initializes the panel's default state  This is usually done
    automatically on file -new and file -open
    :type init: boolean
    :param isUnique: (Q) Returns true if only one instance of this panel type is allowed
    :type isUnique: boolean
    :param label: (Q E) Specifies the user readable label for the panel
    :type label: string
    :param menuBarRepeatLast: (C Q E) Controls whether clicking on the menu header with the
    middle mouse button would repeat the last selected menu item
    :type menuBarRepeatLast: boolean
    :param menuBarVisible: (C Q E) Controls whether the menu bar for the panel is displayed
    :type menuBarVisible: boolean
    :param needsInit: (Q E) (Internal) On Edit will mark the panel as requiring initialization 
    Query will return whether the panel is marked for initialization  Used during fil
    :type needsInit: boolean
    :param parent: (C) Specifies the parent layout for this panel
    :type parent: string
    :param popupMenuProcedure: (Q E) Specifies the procedure called for building the panel's
    popup menu(s)  The default value is "buildPanelPopupMenu"  The procedure should take one
    stri
    :type popupMenuProcedure: script
    :param replacePanel: (E) Will replace the specified panel with this panel  If the target
    panel is within the same layout it will perform a swap
    :type replacePanel: string
    :param tearOff: (Q E) Will tear off this panel into a separate window with a paneLayout as
    the parent of the panel  When queried this flag will return if the panel has bee
    :type tearOff: boolean
    :param tearOffCopy: (C) Will create this panel as a torn of copy of the specified source
    panel
    :type tearOffCopy: string
    :param tearOffRestore: (C E) Restores panel if it is torn off and focus is given to it  If
    docked, becomes the active panel in the docked window  This should be the default flag
    :type tearOffRestore: boolean
    :param unParent: (E) Specifies that the panel should be removed from its layout  This
    (obviously) cannot be used with query
    :type unParent: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: 
    :rtype: None
    """
    pass


def nClothAppendOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PasteUVs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleSurfaceOrigin(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PaintVertexColorToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreatePlatonicSolidOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def diskCache(*args, append=True, cacheType="", close="", closeAll=True, delete="",
              deleteAll=True, empty="", emptyAll=True, enabledCachesOnly=True, endTime=None,
              frameRangeType="", overSample=True, samplingRate=0, startTime=None, tempDir=True,
              q=True, query=True, **kwargs):
    """
    Command to create, clear, or close disk cache(s)
    
    :param append: (C Q) Append at the end and not to flush the existing cache
    :type append: boolean
    :param cacheType: (C Q) Specifies the type of cache to overwrite  "mcfp" for particle
    playback cache, "mcfi" for particle initial cache  "mcj" for jiggle cache  This option
    :type cacheType: string
    :param close: (C Q) Close the cache given the disk cache node name  If
    -eco/enabledCachesOnly is "true" only enabled disk cache nodes are affected
    :type close: string
    :param closeAll: (C Q) Close all disk cache files  If -eco/enabledCachesOnly is "true" only
    enabled disk cache nodes are affected
    :type closeAll: boolean
    :param delete: (C Q) Delete the cache given the disk cache node name  If
    -eco/enabledCachesOnly is "true" only enabled disk cache nodes are affected
    :type delete: string
    :param deleteAll: (C Q) Delete all disk cache files  If -eco/enabledCachesOnly is "true"
    only enabled disk cache nodes are affected
    :type deleteAll: boolean
    :param empty: (C Q) Clear the content of the disk cache with the given disk cache node name
     If -eco/enabledCachesOnly is "true" only enabled disk cache nodes are affect
    :type empty: string
    :param emptyAll: (C Q) Clear the content of all disk caches  If -eco/enabledCachesOnly is
    "true" only enabled disk cache nodes are affected
    :type emptyAll: boolean
    :param enabledCachesOnly: (C Q) When present, this flag restricts the -ea/emptyAll, so that
    only "enabled" disk caches (i.e., disk cache nodes with the ".enable" attribute set to "t
    :type enabledCachesOnly: boolean
    :param endTime: (C Q) Specifies the end frame of the cache range
    :type endTime: time
    :param frameRangeType: (C Q) Specifies the type of frame range to use, namely "Render
    Globals", "Time Slider", and "Start/End"  In the case of "Time Slider", startFrame and
    endFr
    :type frameRangeType: string
    :param overSample: (C Q) Over sample if true  Otherwise, under sample
    :type overSample: boolean
    :param samplingRate: (C Q) Specifies how frequently to sample relative to each frame  When
    over-sampling (-overSample has been specified), this parameter determines how many ti
    :type samplingRate: int
    :param startTime: (C Q) Specifies the start frame of the cache range
    :type startTime: time
    :param tempDir: (C Q) Query-only flag for the location of temporary diskCache files
    :type tempDir: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def sbs_AffectTheseAttributes(*args, **kwargs):
    """
    
    """
    pass


def SetRigidBodyCollision(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateText(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_softSelStickyPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GoToMinFrame(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def renderSetupLegacyLayer(*args, **kwargs):
    """
    
    """
    pass


def ToggleVertexNormalDisplay(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def bezierCurveToNurbs(*args, **kwargs):
    """
    The bezierCurveToNurbs command attempts to convert an existing NURBS curve to a Bezier
    curve
    
    
    :returns: (object name and node name)
    :rtype: string[]
    """
    pass


def mirrorShape(*args, **kwargs):
    """
    
    """
    pass


def assignViewportFactories(*args, materialFactory="", nodeType="", textureFactory="", q=True,
                            query=True, e=True, edit=True, **kwargs):
    """
    Sets viewport factories for displays as materials or textures
    
    :param materialFactory: (C Q E) Set or query the materialFactory for the node type
    :type materialFactory: string
    :param nodeType: (C Q E) The node type
    :type nodeType: string
    :param textureFactory: (C Q E) Set or query the textureFactory for the node type
    :type textureFactory: string
    
    :returns: 
    :rtype: None
    """
    pass


def CopySelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ConvertSelectionToEdgePerimeter(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeOpenConnectWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteAllChannels(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PixelMoveLeft(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def attrNavigationControlGrp(*args, adjustableColumn=0, adjustableColumn2=0,
                             adjustableColumn3=0, adjustableColumn4=0, adjustableColumn5=0,
                             adjustableColumn6=0, annotation="", attrNavDecision=None,
                             attribute=None, backgroundColor=None, columnAlign=None,
                             columnAlign2=None, columnAlign3=None, columnAlign4=None,
                             columnAlign5=None, columnAlign6=None, columnAttach=None,
                             columnAttach2=None, columnAttach3=None, columnAttach4=None,
                             columnAttach5=None, columnAttach6=None, columnOffset2=None,
                             columnOffset3=None, columnOffset4=None, columnOffset5=None,
                             columnOffset6=None, columnWidth=None, columnWidth1=0,
                             columnWidth2=None, columnWidth3=None, columnWidth4=None,
                             columnWidth5=None, columnWidth6=None, connectAttrToDropped=None,
                             connectNodeToDropped=None, connectToExisting=None, createNew=None,
                             defaultTraversal=None, defineTemplate="", delete="",
                             disconnect=None, docTag="", dragCallback=None, dropCallback=None,
                             enable=True, enableBackground=True, enableKeyboardFocus=True,
                             exists=True, extraButton=True, extraButtonCommand=None,
                             extraButtonIcon="", fullPathName=True, height=0,
                             highlightColor=None, ignore=None, ignoreNotSupported=True,
                             isObscured=True, label="", manage=True, noBackground=True,
                             noIgnorableMenu=True, noKeyableMenu=True, numberOfPopupMenus=True,
                             parent="", popupMenuArray=True, preventOverride=True,
                             relatedNodes=None, rowAttach=None, statusBarMessage="",
                             unignore=None, useTemplate="", visible=True,
                             visibleChangeCommand=None, width=0, q=True, query=True, e=True,
                             edit=True, **kwargs):
    """
    All of the group commands position their individual controls in columns starting at column
    1  The layout of each control (ie  column) can be customized using the -cw/columnWidth,
    -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumn flags  By
    default, columns are left aligned with no offset and are 100 pixels wide  Only o
    
    :param adjustableColumn: (C E) Specifies which column has an adjustable size that changes
    with the sizing of the layout  The column value is a 1-based index  Passing 0 as argument
    :type adjustableColumn: int
    :param adjustableColumn2: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly two columns
    :type adjustableColumn2: int
    :param adjustableColumn3: (C E) Specifies that the column has an adjustable size that
    changes with the size of the parent layout  Ignored if there are not exactly three columns
    :type adjustableColumn3: int
    :param adjustableColumn4: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly four columns
    :type adjustableColumn4: int
    :param adjustableColumn5: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly five columns
    :type adjustableColumn5: int
    :param adjustableColumn6: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly six columns
    :type adjustableColumn6: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param attrNavDecision: (C Q E) The first argument is the name of an attribute  The button
    will be attached to the attribute so the button can be kept in synch with the attribute  T
    :type attrNavDecision: [name, string]
    :param attribute: (C Q E) The name of an attribute  The button will be attached to the
    attribute so the button can be kept in synch with the attribute
    :type attribute: name
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param columnAlign: (C E M) Arguments are : column number, alignment type  Possible
    alignments are: left | right | center  Specifies alignment type for the specified column
    :type columnAlign: [int, string]
    :param columnAlign2: (C E) Sets the text alignment of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "center"
    :type columnAlign2: [string, string]
    :param columnAlign3: (C E) Sets the text alignment for all three columns  Ignored if there
    are not exactly three columns  Valid values are "left", "right", and "center"
    :type columnAlign3: [string, string, string]
    :param columnAlign4: (C E) Sets the text alignment for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "center"
    :type columnAlign4: [string, string, string, string]
    :param columnAlign5: (C E) Sets the text alignment for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "center"
    :type columnAlign5: [string, string, string, string, string]
    :param columnAlign6: (C E) Sets the text alignment for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "center"
    :type columnAlign6: [string, string, string, string, string, string]
    :param columnAttach: (C E M) Arguments are : column number, attachment type, and offset 
    Possible attachments are: left | right | both  Specifies column attachment types and offe
    :type columnAttach: [int, string, int]
    :param columnAttach2: (C E) Sets the attachment type of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "both"
    :type columnAttach2: [string, string]
    :param columnAttach3: (C E) Sets the attachment type for all three columns  Ignored if
    there are not exactly three columns  Valid values are "left", "right", and "both"
    :type columnAttach3: [string, string, string]
    :param columnAttach4: (C E) Sets the attachment type for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "both"
    :type columnAttach4: [string, string, string, string]
    :param columnAttach5: (C E) Sets the attachment type for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "both"
    :type columnAttach5: [string, string, string, string, string]
    :param columnAttach6: (C E) Sets the attachment type for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "both"
    :type columnAttach6: [string, string, string, string, string, string]
    :param columnOffset2: (C E) This flag is used in conjunction with the -columnAttach2 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the tw
    :type columnOffset2: [int, int]
    :param columnOffset3: (C E) This flag is used in conjunction with the -columnAttach3 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the th
    :type columnOffset3: [int, int, int]
    :param columnOffset4: (C E) This flag is used in conjunction with the -columnAttach4 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fo
    :type columnOffset4: [int, int, int, int]
    :param columnOffset5: (C E) This flag is used in conjunction with the -columnAttach5 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fi
    :type columnOffset5: [int, int, int, int, int]
    :param columnOffset6: (C E) This flag is used in conjunction with the -columnAttach6 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the si
    :type columnOffset6: [int, int, int, int, int, int]
    :param columnWidth: (C E M) Arguments are : column number, column width  Sets the width of
    the specified column where the first parameter specifies the column (1 based index) an
    :type columnWidth: [int, int]
    :param columnWidth1: (C E) Sets the width of the first column  Ignored if there is not
    exactly one column
    :type columnWidth1: int
    :param columnWidth2: (C E) Sets the column widths of both columns  Ignored if there are not
    exactly two columns
    :type columnWidth2: [int, int]
    :param columnWidth3: (C E) Sets the column widths for all 3 columns  Ignored if there are
    not exactly 3 columns
    :type columnWidth3: [int, int, int]
    :param columnWidth4: (C E) Sets the column widths for all 4 columns  Ignored if there are
    not exactly 4 columns
    :type columnWidth4: [int, int, int, int]
    :param columnWidth5: (C E) Sets the column widths for all 5 columns  Ignored if there are
    not exactly 5 columns
    :type columnWidth5: [int, int, int, int, int]
    :param columnWidth6: (C E) Sets the column widths for all 6 columns  Ignored if there are
    not exactly 6 columns
    :type columnWidth6: [int, int, int, int, int, int]
    :param connectAttrToDropped: (C Q E) The script to execute when a node is dragged and
    dropped onto an attribute (multilister dnd attribute editor)  Your script should take in
    two argumen
    :type connectAttrToDropped: script
    :param connectNodeToDropped: (C Q E) The script to execute when a node is dragged and
    dropped onto a node (the multilister issues this)  Your script should take in two
    arguments: the sou
    :type connectNodeToDropped: script
    :param connectToExisting: (C Q E) The script to execute when a connection should be made to
    an existing node
    :type connectToExisting: script
    :param createNew: (C Q E) The script to execute when a new "connection" is requested
    :type createNew: script
    :param defaultTraversal: (C Q E) The script to execute to find out the name of the default
    traversal node  The script you attach should be able to take in one argument (the
    attribute
    :type defaultTraversal: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param delete: (C Q E) The script to execute when the connection (and the node connected
    to) should be deleted
    :type delete: string
    :param disconnect: (C Q E) The script to execute when a "disconnection" is requested
    :type disconnect: script
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param extraButton: (C) Add an extra icon button to the last of this control
    :type extraButton: boolean
    :param extraButtonCommand: (C E) The command string is executed when the extra button is
    clicked
    :type extraButtonCommand: script
    :param extraButtonIcon: (C Q E) The icon file name of the extra button
    :type extraButtonIcon: string
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param ignore: (C Q E) The script to execute when the connection should be ignored
    :type ignore: script
    :param ignoreNotSupported: () Obsolete flag; has no effect
    :type ignoreNotSupported: boolean
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) Text for the control
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param noIgnorableMenu: (C E) Not show ignorable related popup menu when right click the
    label
    :type noIgnorableMenu: boolean
    :param noKeyableMenu: (C E) Not show keyable related popup menu when right click the label
    :type noKeyableMenu: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param relatedNodes: (C Q E) The script to execute to find out what the related nodes are 
    The script you attach should be able to take in one argument (the attribute) and return
    :type relatedNodes: script
    :param rowAttach: (C E M) Arguments are : column, attachment type, offset  Possible
    attachments are: top | bottom | both  Specifies attachment types and offsets for the
    entire
    :type rowAttach: [int, string, int]
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param unignore: (C Q E) The script to execute when the connection should be unignored
    :type unignore: script
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def ContentBrowserLayout(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def viewCamera(*args, move=None, sideView=True, topView=True, **kwargs):
    """
    The viewCamera command is used to position a camera to look directly at the side or top of
    another camera  This is primarily useful for the user when he or she is setting
    depth-of-field and clipping planes, if they are being used   The default behaviour: If no
    other flags are specified, the camera in the active panel is moved and the -t is presumed
    
    :param move: (C) Specifies which camera needs to move
    :type move: name
    :param sideView: (C) Position camera to look at the side of the target camera
    :type sideView: boolean
    :param topView: (C) Position camera to look at the top of the target camera (default)
    :type topView: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def FBXPopSettings(*args, **kwargs):
    """
    
    """
    pass


def CreateSubCharacter(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CylindricalProjectionOptions(*args, **kwargs):
    """
    unknown
    """
    pass


def GoToPreviousDrivenKey(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeGraphRemoveUnselected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateNURBSCube(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateSet(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyCollapseTweaks(*args, hasVertexTweaks=True, q=True, query=True, **kwargs):
    """
    A command that updates a mesh's vertex tweaks by applying its tweak data (stored on the
    mesh node) onto its respective vertex data   This command is only useful in cases where no
    construction history is associated with the shape node   If a mesh name is not specified as
    input, a singly selected mesh (if any) will have its tweaked vertices baked
    
    :param hasVertexTweaks: (C Q) Determines whether an individual mesh has vertex tweaks
    :type hasVertexTweaks: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def SelectMeshUVShell(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_coordSpaceLocal(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def attachSurface(*args, blendBias=0.5, blendKnotInsertion=False, caching=True, directionU=True,
                  keepMultipleKnots=True, method=0, nodeState=0, parameter=0.1, reverse1=False,
                  reverse2=False, swap1=False, swap2=False, twist=False,
                  constructionHistory=True, name="", object=True, replaceOriginal=True, q=True,
                  query=True, e=True, edit=True, **kwargs):
    """
    This attach command is used to attach surfaces  Once the surfaces are attached, there will
    be multiple knots at the joined point(s)  These can be kept or removed if the user wishes  
    The end of the first surface is attached to the start of the second surface in the
    specified direction   Note: if the command is done with Keep Original off there will
    
    :param blendBias: (C Q E) Skew the result toward the first or the second curve depending on
    the blend factory being smaller or larger than 0.5  Default: 0.5
    :type blendBias: float
    :param blendKnotInsertion: (C Q E) If set to true, insert a knot in one of the original
    curves (relative position given by the parameter attribute below) in order to produce a
    slightly
    :type blendKnotInsertion: boolean
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param directionU: (C Q E) If true attach in U direction of surface and V direction
    otherwise  Default: true
    :type directionU: boolean
    :param keepMultipleKnots: (C Q E) If true, keep multiple knots at the join parameter 
    Otherwise remove them  Default: true
    :type keepMultipleKnots: boolean
    :param method: (C Q E) Attach method (connect-0, blend-1) Default: 0
    :type method: int
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param parameter: (C Q E) The parameter value for the positioning of the newly inserted
    knot  Default: 0.1
    :type parameter: float
    :param reverse1: (C Q E) If true, reverse the direction (specified by directionU) of the
    first input surface before doing attach  Otherwise, do nothing to the first input sur
    :type reverse1: boolean
    :param reverse2: (C Q E) If true, reverse the direction (specified by directionU) of the
    second input surface before doing attach  Otherwise, do nothing to the second input s
    :type reverse2: boolean
    :param swap1: (C Q E) If true, swap the UV directions of the first input surface before
    doing attach  Otherwise, do nothing to the first input surface before attaching  NO
    :type swap1: boolean
    :param swap2: (C Q E) If true, swap the UV directions of the second input surface before
    doing attach  Otherwise, do nothing to the second input surface before attaching
    :type swap2: boolean
    :param twist: (C Q E) If true, reverse the second surface in the opposite direction
    (specified by directionU) before doing attach  This will avoid twists in the attached s
    :type twist: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def polySubdivideFacet(*args, divisions=1, divisionsU=0, divisionsV=0, mode=0, subdMethod=0,
                       caching=True, constructionHistory=True, name="", nodeState=0, q=True,
                       query=True, e=True, edit=True, **kwargs):
    """
    Subdivides a face into quads or triangles   In quad mode, a center point is introduced at
    the center of each face and midpoints are inserted on all the edges of each face  New faces
    (all quadrilaterals) are built by adding edges from the midpoints towards the center  In
    triangle mode, only the center point is created; new faces (all triangles) are 
    
    :param divisions: (C Q E) This number specifies how many times to recursively subdivide the
    selected faces  For example, with divisions set to 3 in quad mode, each initial qua
    :type divisions: int
    :param divisionsU: (C Q E) The number of subdivision steps to perform along the U direction
     A square face will be subdivided into 4^(divisions) faces in quad mode, 4*3^(divisi
    :type divisionsU: int
    :param divisionsV: (C Q E) The number of subdivision steps to perform along the V direction
     A square face will be subdivided into 4^(divisions) faces in quad mode, 4*3^(divisi
    :type divisionsV: int
    :param mode: (C Q E) The subdivision mode  0: subdivision into quads 1: subdivision into
    triangles C: Default is 0  Q: When queried, this flag returns an int
    :type mode: int
    :param subdMethod: (C Q E) Type of subdivision to use: 0 - exponential - traditional
    subdivision 1 - linear - number of faces per edge grows linearly
    :type subdMethod: int
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def convertIffToPsd(*args, iffFileName="", psdFileName="", xResolution=0, yResolution=0, q=True,
                    query=True, **kwargs):
    """
    Converts iff file to PSD file of given size
    
    :param iffFileName: (C Q) Input iff file name
    :type iffFileName: string
    :param psdFileName: (C Q) Output file name
    :type psdFileName: string
    :param xResolution: (C Q) X resolution of the image
    :type xResolution: int
    :param yResolution: (C Q) Y resolution of the image
    :type yResolution: int
    
    :returns: 
    :rtype: None
    """
    pass


def control(*args, annotation="", backgroundColor=None, defineTemplate="", docTag="",
            dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
            enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
            highlightColor=None, isObscured=True, manage=True, noBackground=True,
            numberOfPopupMenus=True, parent="", popupMenuArray=True, preventOverride=True,
            statusBarMessage="", useTemplate="", visible=True, visibleChangeCommand=None,
            width=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command allows you to edit or query the properties of any control
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: 
    :rtype: None
    """
    pass


def ShowJoints(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def uiTemplate(*args, defineTemplate="", exists=True, useTemplate="", q=True, query=True,
               e=True, edit=True, **kwargs):
    """
    This command creates a new command template object  Template objects can hold default flag
    arguments for multiple UI commands  The command arguments are specified with the individual
    commands using the -defineTemplate flag and the desired flags and arguments  See also
    setUITemplate
    
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: The name of the uiTemplate created.
    :rtype: string
    """
    pass


def GraphPaste(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UnfoldUVOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolySelectTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleFBIKEffectorsPinState(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def LongPolygonNormals(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmSelectBrushContext(*args, **kwargs):
    """
    
    """
    pass


def ShareColorInstances(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UVCylindricProjection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleSurfaceFaceCenters(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AssignNewMaterial(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CloudImportExport(*args, **kwargs):
    """
    
    """
    pass


def dR_showHelp(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def fluidDeleteCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BatchBake(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NormalConstraint(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def boneLattice(*args, after=True, afterReference=True, before=True, bicep=0.0,
                deformerTools=True, exclusive="", frontOfChain=True, geometry="",
                geometryIndices=True, ignoreSelected=True, includeHiddenSelections=False,
                joint="", lengthIn=0.0, lengthOut=0.0, name="", parallel=True, prune=True,
                remove=True, split=True, transform="", tricep=0.0, widthLeft=0.0,
                widthRight=0.0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates/edits/queries a boneLattice deformer  The name of the created/edited
    object is returned  Usually you would make use of this functionality through the higher
    level flexor command
    
    :param after: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type after: boolean
    :param afterReference: (C E) The -afterReference flag is used to specify deformer ordering
    in a hybrid way that choses between -before and -after automatically  If the geometry b
    :type afterReference: boolean
    :param before: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type before: boolean
    :param bicep: (C Q E) Affects the bulging of lattice points on the inside of the bend 
    Positive/negative values cause the points to bulge outwards/inwards  Default value i
    :type bicep: float
    :param deformerTools: (Q) Returns the name of the deformer tool objects (if any) as string
    string ..
    :type deformerTools: boolean
    :param exclusive: (C Q) Puts the deformation set in a deform partition
    :type exclusive: string
    :param frontOfChain: (C E) This command is used to specify that the new deformer node
    should be placed ahead (upstream) of existing deformer and skin nodes in the shape's histo
    :type frontOfChain: boolean
    :param geometry: (Q E M) The specified object will be added to the list of objects being
    deformed by this deformer object, unless the -rm flag is also specified  When queried
    :type geometry: string
    :param geometryIndices: (Q) Complements the -geometry flag in query mode  Returns the multi
    index of each geometry
    :type geometryIndices: boolean
    :param ignoreSelected: (C) Tells the command to not deform objects on the current selection
    list
    :type ignoreSelected: boolean
    :param includeHiddenSelections: (C) Apply the deformer to any visible and hidden objects in
    the selection list  Default is false
    :type includeHiddenSelections: boolean
    :param joint: (C Q E) Specifies which joint will be used to drive the bulging behaviors
    :type joint: string
    :param lengthIn: (C Q E) Affects the location of lattice points along the upper half of the
    bone  Positive/negative values cause the points to move away/towards the center of
    :type lengthIn: float
    :param lengthOut: (C Q E) Affects the location of lattice points along the lower half of
    the bone  Positive/negative values cause the points to move away/towards the center of
    :type lengthOut: float
    :param name: (C) Used to specify the name of the node being created
    :type name: string
    :param parallel: (C E) Inserts the new deformer in a parallel chain to any existing
    deformers in the history of the object  A blendShape is inserted to blend the parallel r
    :type parallel: boolean
    :param prune: (E) Removes any points not being deformed by the deformer in its current
    configuration from the deformer set
    :type prune: boolean
    :param remove: (E M) Specifies that objects listed after the -g flag should be removed from
    this deformer
    :type remove: boolean
    :param split: (C E) Branches off a new chain in the dependency graph instead of
    inserting/appending the deformer into/onto an existing chain  Works in create mode (and e
    :type split: boolean
    :param transform: (C) Specifies which dag node is being used to rigidly transform the
    lattice which this node is going to deform  If this flag is not specified an identity
    :type transform: string
    :param tricep: (C Q E) Affects the bulging of lattice points on the outside of the bend 
    Positive/negative values cause the points to bulge outwards/inwards  Default value
    :type tricep: float
    :param widthLeft: (C Q E) Affects the bulging of lattice points on the left side of the
    bend  Positive/negative values cause the points to bulge outwards/inwards  Default valu
    :type widthLeft: float
    :param widthRight: (C Q E) Affects the bulging of lattice points on the right side of the
    bend  Positive/negative values cause the points to bulge outwards/inwards  Default val
    :type widthRight: float
    
    :returns: Name of bone lattice algorithm node created/edited.
    :rtype: string
    """
    pass


def smoothCurve(*args, caching=True, nodeState=0, smoothness=10.0, constructionHistory=True,
                name="", object=True, replaceOriginal=True, q=True, query=True, e=True,
                edit=True, **kwargs):
    """
    The smooth command smooths the curve at the given control points
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param smoothness: (C Q E) smoothness factor Default: 10.0
    :type smoothness: float
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def dR_convertSelectionToEdge(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def radioMenuItemCollection(*args, defineTemplate="", exists=True, gl=True, parent="",
                            useTemplate="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a radioMenuItemCollection  Attach radio menu items to radio menu item
    collection objects to get radio button behaviour  Radio menu item collections will be
    parented to the current menu if no parent is specified with the -p/parent flag  As children
    of the menu they will be deleted when the menu is deleted  Collections may also s
    
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param gl: (C Q) Set the collection to have no parent menu  Global collections must be
    explicitly deleted
    :type gl: boolean
    :param parent: (C) The parent of the collection  The collection will be deleted along with
    the parent
    :type parent: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: Full path name to the collection.
    :rtype: string
    """
    pass


def CreateQuickSelectSet(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DecreaseManipulatorSize(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nurbsToPoly(*args, caching=True, constructionHistory=True, curvatureTolerance=2,
                explicitTessellationAttributes=True, name="", nodeState=0, object=True,
                smoothEdge=False, smoothEdgeRatio=0.99, uDivisionsFactor=1.5,
                vDivisionsFactor=1.5, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command tesselates a NURBS surface and produces a polygonal surface  The name of the
    new polygonal surface is returned  If construction history is ON, then the name of the new
    dependency node is returned as well
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param curvatureTolerance: (C Q E) Presets for level of secondary criteria curvature
    tolerance: 0 = highest tolerance, 1 = high tolerance, 2 = medium tolerance, 3 = no
    tolerance Defaul
    :type curvatureTolerance: int
    :param explicitTessellationAttributes: (C Q E) specify advanced or novice mode for
    tessellation parameters Default: true
    :type explicitTessellationAttributes: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param smoothEdge: (C Q E) Specifies if the decision to continue tessellation should be
    based on the nurbs edge smoothness Default: false
    :type smoothEdge: boolean
    :param smoothEdgeRatio: (C Q E) Specifies the edge smooth ratio  The higher the value, the
    smoother the edge will be  Default: 0.99
    :type smoothEdgeRatio: float
    :param uDivisionsFactor: (C Q E) Specifies the tessellation increase factor in U for novice
    mode Default: 1.5
    :type uDivisionsFactor: float
    :param vDivisionsFactor: (C Q E) Specifies the tessellation increase factor in V for novice
    mode Default: 1.5
    :type vDivisionsFactor: float
    
    :returns: The polygon and optionally the dependency node name.
    :rtype: string[]
    """
    pass


def subdListComponentConversion(*args, border=True, fromEdge=True, fromFace=True, fromUV=True,
                                fromVertex=True, internal=True, toEdge=True, toFace=True,
                                toUV=True, toVertex=True, uvShell=True, uvShellBorder=True,
                                **kwargs):
    """
    This command converts subdivision surface components from one or more types to another one
    or more types, and returns the list of the conversion  It does not change the currently
    selected objects   Use the "-in/internal" flag to specify conversion to "connected" vs 
    "contained" components  For example, if the internal flag is specified when convert
    
    :param border: (C) Convert to a border
    :type border: boolean
    :param fromEdge: (C) Indicates the component type to convert from: Edges
    :type fromEdge: boolean
    :param fromFace: (C) Indicates the component type to convert from: Faces
    :type fromFace: boolean
    :param fromUV: (C) Indicates the component type to convert from: UVs
    :type fromUV: boolean
    :param fromVertex: (C) Indicates the component type to convert from: Vertex
    :type fromVertex: boolean
    :param internal: (C) Applicable when converting from "smaller" component types to larger
    ones  Specifies conversion to "connected" vs  "contained" components  See example
    :type internal: boolean
    :param toEdge: (C) Indicates the component type to convert to: Edges
    :type toEdge: boolean
    :param toFace: (C) Indicates the component type to convert to: Faces
    :type toFace: boolean
    :param toUV: (C) Indicates the component type to convert to: UVs
    :type toUV: boolean
    :param toVertex: (C) Indicates the component type to convert to: Vertices
    :type toVertex: boolean
    :param uvShell: (C) Will return UV components within the same UV shell  Only works with
    -tuv and -fuv flags
    :type uvShell: boolean
    :param uvShellBorder: (C) Will return UV components on the border within the same UV shell 
    Only works with -tuv and -fuv flags
    :type uvShellBorder: boolean
    
    :returns: List of subdivision surface components
    :rtype: string[]
    """
    pass


def HideDynamicConstraints(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def namespace(*args, absoluteName=True, addNamespace="", collapseAncestors="",
              deleteNamespaceContent=True, exists="", force=True, isRootNamespace="",
              mergeNamespaceWithOther="", mergeNamespaceWithParent=True,
              mergeNamespaceWithRoot=True, moveNamespace=None, parent="", recurse=True,
              relativeNames=True, removeNamespace="", rename=None, setNamespace="",
              validateName="", q=True, query=True, **kwargs):
    """
    This command allows a namespace to be created, set or removed   A namespace is a simple
    grouping of objects under a given name  Namespaces are primarily used to resolve name-clash
    issues in Maya, where a new object has the same name as an existing object (from importing
    a file, for example)  Using namespaces, you can have two objects with the same 
    
    :param absoluteName: (C Q) This is a general flag which can be used to specify the desired
    format for the namespace(s) returned by the command  The absolute name of the namespa
    :type absoluteName: boolean
    :param addNamespace: (C) Create a new namespace with the given name  Both qualified names
    ("A:B") and unqualified names ("A") are acceptable  If any of the higher-level names
    :type addNamespace: string
    :param collapseAncestors: (C) Delete all empty ancestors of the given namespace  An empty
    namespace is a a namespace that does not contain any objects or other nested namespaces
    :type collapseAncestors: string
    :param deleteNamespaceContent: (C) Used with the 'rm/removeNamespace' flag to indicate that
    when removing a namespace the contents of the namespace will also be removed
    :type deleteNamespaceContent: boolean
    :param exists: (Q) Returns true if the specified namespace exists, false if not
    :type exists: string
    :param force: (C) Used with 'mv/moveNamespace' to force the move operation to ignore name
    clashes
    :type force: boolean
    :param isRootNamespace: (Q) Returns true if the specified namespace is root, false if not
    :type isRootNamespace: string
    :param mergeNamespaceWithOther: (C) Used with the 'rm/removeNamespace' flag  When removing
    a namespace, move the rest of the namespace content to the specified namespace
    :type mergeNamespaceWithOther: string
    :param mergeNamespaceWithParent: (C) Used with the 'rm/removeNamespace' flag  When removing
    a namespace, move the rest of the namespace content to the parent namespace
    :type mergeNamespaceWithParent: boolean
    :param mergeNamespaceWithRoot: (C) Used with the 'rm/removeNamespace' flag  When removing a
    namespace, move the rest of the namespace content to the root namespace
    :type mergeNamespaceWithRoot: boolean
    :param moveNamespace: (C) Move the contents of the first namespace into the second
    namespace  Child namespaces will also be moved  Attempting to move a namespace containing
    re
    :type moveNamespace: [string, string]
    :param parent: (C) Used with the 'addNamespace' or 'rename' flags to specifiy the parent of
    the new namespace  The full namespace parent path is required  When using 'a
    :type parent: string
    :param recurse: (Q) Can be used with the 'exists' flag to recursively look for the
    specified namespace
    :type recurse: boolean
    :param relativeNames: (C Q) Turns on relative name lookup, which causes name lookups within
    Maya to be relative to the current namespace  By default this is off, meaning that na
    :type relativeNames: boolean
    :param removeNamespace: (C) Deletes the given namespace  The namespace must be empty for it
    to be deleted
    :type removeNamespace: string
    :param rename: (C) Rename the first namespace to second namespace name  Child namespaces
    will also be renamed  Both names are relative to the current namespace  Use the
    :type rename: [string, string]
    :param setNamespace: (C) Sets the current namespace
    :type setNamespace: string
    :param validateName: (C) Convert the specified name to a valid name to make it contain no
    illegal characters  The leading illegal characters will be removed and other illegal
    :type validateName: string
    
    :returns: Command result
    :rtype: string
    """
    pass


def ProjectCurveOnMesh(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Wave(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteAllSounds(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RenderGlobalsWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyCylinder(*args, axis=None, caching=True, constructionHistory=True, createUVs=2,
                 height=2.0, name="", nodeState=0, object=True, radius=1.0, roundCap=False,
                 subdivisionsAxis=20, subdivisionsCaps=0, subdivisionsHeight=1,
                 subdivisionsX=20, subdivisionsY=1, subdivisionsZ=1, texture=2, q=True,
                 query=True, e=True, edit=True, **kwargs):
    """
    The cylinder command creates a new polygonal cylinder
    
    :param axis: (C Q E) This flag specifies the primitive axis used to build the cylinder  Q:
    When queried, this flag returns a float[3]
    :type axis: [float, float, float]
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param createUVs: (C Q E) Create UVs or not  0: No UVs 1: No Normalization 2: Normalize 3:
    Normalize and Preserve Aspect Ratio Default: 2
    :type createUVs: int
    :param height: (C Q E) Height of the cylinder  Default: 2.0
    :type height: float
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param object: (C) Create the result, or just the dependency node (where applicable)
    :type object: boolean
    :param radius: (C Q E) Radius of the cylinder  Default: 1.0
    :type radius: float
    :param roundCap: (C Q E) To indicate whether we need a round cap Default: false
    :type roundCap: boolean
    :param subdivisionsAxis: (C Q E) Subdivisions around the axis  Default: 20
    :type subdivisionsAxis: int
    :param subdivisionsCaps: (C Q E) Subdivisions on the caps Default: 0
    :type subdivisionsCaps: int
    :param subdivisionsHeight: (C Q E) Subdivisions along the height  Default: 1
    :type subdivisionsHeight: int
    :param subdivisionsX: (C Q E) This specifies the number of subdivisions in the X direction
    for the cylinder  C: Default is 20  Q: When queried, this flag returns an int
    :type subdivisionsX: int
    :param subdivisionsY: (C Q E) This flag specifies the number of subdivisions in the Y
    direction for the cylinder  C: Default is 1  Q: When queried, this flag returns an int
    :type subdivisionsY: int
    :param subdivisionsZ: (C Q E) This flag specifies the number of subdivisions in the Z
    direction for the cylinder  C: Default is 1  Q: When queried, this flag returns an int
    :type subdivisionsZ: int
    :param texture: (C Q E) What texture mechanism to be applied 0=No textures, 1=Object,
    2=Faces Default: 2
    :type texture: int
    
    :returns: Object name and node name.
    :rtype: string[]
    """
    pass


def InTangentPlateau(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RelaxUVShellOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyMergeVertex(*args, alwaysMergeTwoVertices=False, caching=True, constructionHistory=True,
                    distance=0.0, mergeToComponents="", name="", nodeState=0, texture=True,
                    worldSpace=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Merge vertices within a given threshold.
    
    :param alwaysMergeTwoVertices: (C Q E) This flag specifies whether to always merge if only
    two vertices are selected regardless of distance  C: Default is false  Q: When queried,
    this flag
    :type alwaysMergeTwoVertices: boolean
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param distance: (C Q E) This flag specifies the distance within which vertices will be
    merged  C: Default is 0.0 (i.e  vertices are coincident)  Q: When queried, this flag r
    :type distance: float
    :param mergeToComponents: (C Q E) Optionally defines the position to merge all of the
    vertices to  If set, the distance flag will be ignored, and instead the center point of the
    set c
    :type mergeToComponents: string
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param texture: (C Q E) This flag specifies whether the texture is sewn in addition to the
    3d edge C: Default is true  Q: When queried, this flag returns a boolean
    :type texture: boolean
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def geometryReplaceCacheFrames(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PluginManager(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SplitPolygonToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OneClickSetupMotionBuilderCharacterStream(*args, **kwargs):
    """
    
    """
    pass


def tension(*args, after=True, afterReference=True, before=True, deformerTools=True, envelope=1,
            exclusive="", frontOfChain=True, geometry="", geometryIndices=True,
            ignoreSelected=True, includeHiddenSelections=False, inwardConstraint=0.0, name="",
            outwardConstraint=0.0, parallel=True, pinBorderVertices=True, prune=True,
            remove=True, smoothingIterations=10, smoothingStep=0.5, split=True, q=True,
            query=True, e=True, edit=True, **kwargs):
    """
    This command is used to create, edit and query tension nodes
    
    :param after: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type after: boolean
    :param afterReference: (C E) The -afterReference flag is used to specify deformer ordering
    in a hybrid way that choses between -before and -after automatically  If the geometry b
    :type afterReference: boolean
    :param before: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type before: boolean
    :param deformerTools: (Q) Returns the name of the deformer tool objects (if any) as string
    string ..
    :type deformerTools: boolean
    :param envelope: (C Q E) Envelope of the tension node  The envelope determines the percent
    of deformation  Value is clamped to [0, 1] range  Default is 1
    :type envelope: float
    :param exclusive: (C Q) Puts the deformation set in a deform partition
    :type exclusive: string
    :param frontOfChain: (C E) This command is used to specify that the new deformer node
    should be placed ahead (upstream) of existing deformer and skin nodes in the shape's histo
    :type frontOfChain: boolean
    :param geometry: (Q E M) The specified object will be added to the list of objects being
    deformed by this deformer object, unless the -rm flag is also specified  When queried
    :type geometry: string
    :param geometryIndices: (Q) Complements the -geometry flag in query mode  Returns the multi
    index of each geometry
    :type geometryIndices: boolean
    :param ignoreSelected: (C) Tells the command to not deform objects on the current selection
    list
    :type ignoreSelected: boolean
    :param includeHiddenSelections: (C) Apply the deformer to any visible and hidden objects in
    the selection list  Default is false
    :type includeHiddenSelections: boolean
    :param inwardConstraint: (C Q E) Constrains the movement of the vertex to not move inward
    from the input deforming shape to preserve the contour  Value is in the [0,1] range 
    Default
    :type inwardConstraint: float
    :param name: (C) Used to specify the name of the node being created
    :type name: string
    :param outwardConstraint: (C Q E) Constrains the movement of the vertex to not move outward
    from the input deforming shape to preserve the contour  Value is in the [0,1] range
    :type outwardConstraint: float
    :param parallel: (C E) Inserts the new deformer in a parallel chain to any existing
    deformers in the history of the object  A blendShape is inserted to blend the parallel r
    :type parallel: boolean
    :param pinBorderVertices: (C Q E) If enabled, vertices on mesh borders will be pinned to
    their current position during smoothing  Default is true
    :type pinBorderVertices: boolean
    :param prune: (E) Removes any points not being deformed by the deformer in its current
    configuration from the deformer set
    :type prune: boolean
    :param remove: (E M) Specifies that objects listed after the -g flag should be removed from
    this deformer
    :type remove: boolean
    :param smoothingIterations: (C Q E) Number of smoothing iterations performed by the tension
    node  Default is 10
    :type smoothingIterations: int
    :param smoothingStep: (C Q E) Step amount used per smoothing iteration  Value is clamped to
    [0, 1] range  A higher value may lead to instabilities but converges faster compared to
    :type smoothingStep: float
    :param split: (C E) Branches off a new chain in the dependency graph instead of
    inserting/appending the deformer into/onto an existing chain  Works in create mode (and e
    :type split: boolean
    
    :returns: Tension deformer node name
    :rtype: string
    """
    pass


def select(*args, add=True, addFirst=True, all=True, allDagObjects=True,
           allDependencyNodes=True, clear=True, containerCentric=True, deselect=True,
           hierarchy=True, noExpand=True, replace=True, symmetry=True, symmetrySide=0,
           toggle=True, visible=True, **kwargs):
    """
    This command is used to put objects onto or off of the active list  If none of the five
    flags [-add, -af, -r, -d, -tgl] are specified, the default is to replace the objects on the
    active list with the given list of objects   When selecting a set as in "select set1", the
    behaviour is for all the members of the set to become selected instead of the s
    
    :param add: (C) Indicates that the specified items should be added to the active list
    without removing existing items from the active list
    :type add: boolean
    :param addFirst: (C) Indicates that the specified items should be added to the front of the
    active list without removing existing items from the active list
    :type addFirst: boolean
    :param all: (C) Indicates that all deletable root level dag objects and all deletable
    non-dag dependency nodes should be selected
    :type all: boolean
    :param allDagObjects: (C) Indicates that all deletable root level dag objects should be
    selected
    :type allDagObjects: boolean
    :param allDependencyNodes: (C) Indicates that all deletable dependency nodes including all
    deletable dag objects should be selected
    :type allDependencyNodes: boolean
    :param clear: (C) Clears the active list  This is more efficient than "select -d;"  Also
    "select -d;" will not remove sets from the active list unless the "-ne" flag i
    :type clear: boolean
    :param containerCentric: (C) Specifies that the same selection rules as apply to selection
    in the main viewport will also be applied to the select command  In particular, if the
    :type containerCentric: boolean
    :param deselect: (C) Indicates that the specified items should be removed from the active
    list if they are on the active list
    :type deselect: boolean
    :param hierarchy: (C) Indicates that all children, grandchildren, ..  of the specified dag
    objects should also be selected
    :type hierarchy: boolean
    :param noExpand: (C) Indicates that any set which is among the specified items should not
    be expanded to its list of members  This allows sets to be selected as opposed t
    :type noExpand: boolean
    :param replace: (C) Indicates that the specified items should replace the existing items on
    the active list
    :type replace: boolean
    :param symmetry: (C) Specifies that components should be selected symmetrically using the
    current symmetricModelling command settings  If symmetric modeling is not enable
    :type symmetry: boolean
    :param symmetrySide: (C) Indicates that components involved in the current symmetry object
    should be selected, according to the supplied parameter  Valid values for the param
    :type symmetrySide: int
    :param toggle: (C) Indicates that those items on the given list which are on the active
    list should be removed from the active list and those items on the given list wh
    :type toggle: boolean
    :param visible: (C) Indicates that of the specified items only those that are visible
    should be affected
    :type visible: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def CreateConstructionPlane(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateNSoftBodyOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def displayColor(*args, active=True, create=True, dormant=True, list=True, queryIndex=0,
                 resetToFactory=True, resetToSaved=True, q=True, query=True, **kwargs):
    """
    This command changes or queries the display color for anything in the application that
    allows the user to set its color  The color is defined by a color index into either the
    dormant or active color palette  These colors are part of the UI and not part of the saved
    data for a model  This command is not undoable
    
    :param active: (C) Specifies the color index applies to active color palette  name
    Specifies the name of color to change  index The color index for the color
    :type active: boolean
    :param create: (C) Creates a new display color which can be queried or set  If is used only
    when saving color preferences
    :type create: boolean
    :param dormant: (C) Specifies the color index applies to dormant color palette  If neither
    of the dormant or active flags is specified, dormant is the default
    :type dormant: boolean
    :param list: (C) Writes out a list of all color names and their value
    :type list: boolean
    :param queryIndex: (C) Allows you to obtain a list of color names with the given color
    indices
    :type queryIndex: int
    :param resetToFactory: (C) Resets all display colors to their factory defaults
    :type resetToFactory: boolean
    :param resetToSaved: (C) Resets all display colors to their saved values
    :type resetToSaved: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def attributeInfo(*args, allAttributes=True, bool=True, enumerated=True, hidden=True,
                  inherited=True, internal=True, leaf=True, logicalAnd=True, multi=True,
                  short=True, userInterface=True, writable=True, type="", **kwargs):
    """
    This command lists all of the attributes that are marked with certain flags  Combinations
    of flags may be specified and all will be considered  (The method of combination depends on
    the state of the "logicalAnd/and" flag.) When the "allAttributes/all" flag is specified,
    attributes of all types will be listed
    
    :param allAttributes: (C) Show all attributes associated with the node regardless of type 
    Use of this flag overrides any other attribute type flags and logical operation that
    :type allAttributes: boolean
    :param bool: (C) Show the attributes that are of type boolean  Use the 'on' state to get
    only boolean attributes; the 'off' state to ignore boolean attributes
    :type bool: boolean
    :param enumerated: (C) Show the attributes that are of type enumerated  Use the 'on' state
    to get only enumerated attributes; the 'off' state to ignore enumerated attribute
    :type enumerated: boolean
    :param hidden: (C) Show the attributes that are marked as hidden  Use the 'on' state to get
    hidden attributes; the 'off' state to get non-hidden attributes
    :type hidden: boolean
    :param inherited: (C) Filter the attributes based on whether they belong to the node type
    directly or have been inherited from a root type (e.g  meshShape/direct or dagObj
    :type inherited: boolean
    :param internal: (C) Show the attributes that are marked as internal to the node  Use the
    'on' state to get internal attributes; the 'off' state to get non-internal attri
    :type internal: boolean
    :param leaf: (C) Show the attributes that are complex leaves (ie  that have parent
    attributes and have no children themselves)  Use the 'on' state to get leaf attribu
    :type leaf: boolean
    :param logicalAnd: (C) The default is to take the logical 'or' of the above conditions 
    Specifying this flag switches to the logical 'and' instead
    :type logicalAnd: boolean
    :param multi: (C) Show the attributes that are multis  Use the 'on' state to get multi
    attributes; the 'off' state to get non-multi attributes
    :type multi: boolean
    :param short: (C) Show the short attribute names instead of the long names
    :type short: boolean
    :param userInterface: (C) Show the UI-friendly attribute names instead of the Maya ASCII
    names  Takes precedence over the -s/-short flag if both are specified
    :type userInterface: boolean
    :param writable: (C) Show the attributes that are writable (ie  can have input connections)
     Use the 'on' state to get writable attributes; the 'off' state to get non-wri
    :type writable: boolean
    :param type: (C) static node type from which to get 'affects' information
    :type type: string
    
    :returns: List of attributes matching criteria
    :rtype: string[]
    """
    pass


def ToggleUVEditorIsolateSelectHUD(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def offsetCurve(*args, caching=True, connectBreaks=2, cutLoop=False, cutRadius=0.0,
                distance=1.0, nodeState=0, normal=None, reparameterize=False, stitch=True,
                subdivisionDensity=5, tolerance=0.01, useGivenNormal=True,
                constructionHistory=True, name="", object=True, range=True, q=True, query=True,
                e=True, edit=True, **kwargs):
    """
    The offset command creates new offset curves from the selected curves  The connecting type
    for breaks in offsets is off (no connection), circular (connect with an arc) or linear
    (connect linearly resulting in a sharp corner)  If loop cutting is on then any loops in the
    offset curves are trimmed away  For the default cut radius of 0.0 a sharp corner
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param connectBreaks: (C Q E) Connect breaks method (between gaps): 0 - off, 1 - circular,
    2 - linear Default: 2
    :type connectBreaks: int
    :param cutLoop: (C Q E) Do loop cutting  Default: false
    :type cutLoop: boolean
    :param cutRadius: (C Q E) Loop cut radius  Only used if cutLoop attribute is set true 
    Default: 0.0
    :type cutRadius: float
    :param distance: (C Q E) Offset distance Default: 1.0
    :type distance: float
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param normal: (C Q E) Offset plane normal
    :type normal: [float, float, float]
    :param reparameterize: (C Q E) Do reparameterization  It is not advisable to change this
    value  Default: false
    :type reparameterize: boolean
    :param stitch: (C Q E) Stitch curve segments together  It is not advisable to change this
    value  Default: true
    :type stitch: boolean
    :param subdivisionDensity: (C Q E) Maximum subdivision density per span Default: 5
    :type subdivisionDensity: int
    :param tolerance: (C Q E) Tolerance Default: 0.01
    :type tolerance: float
    :param useGivenNormal: (C Q E) Use the given normal (or, alternativelly, geometry normal)
    Default: 1
    :type useGivenNormal: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param range: (C) Force a curve range on complete input curve
    :type range: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def DetachSkeleton(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def prepareRender(*args, defaultTraversalSet="", deregister="", invokePostRender=True,
                  invokePostRenderFrame=True, invokePostRenderLayer=True, invokePreRender=True,
                  invokePreRenderFrame=True, invokePreRenderLayer=True, invokeSettingsUI=True,
                  label="", listTraversalSets=True, postRender=None, postRenderFrame=None,
                  postRenderLayer=None, preRender=None, preRenderFrame=None,
                  preRenderLayer=None, restore=True, saveAssemblyConfig=True, settingsUI=None,
                  setup=True, traversalSet="", traversalSetInit=None, q=True, query=True,
                  e=True, edit=True, **kwargs):
    """
    This command is used to register, manage and invoke render traversals  Render traversals
    are used to configure a scene to prepare it for rendering  This command has special support
    for scene assembly nodes  To render scene assembly nodes, a rendering traversal can
    activate an appropriate representation, for each assembly node in the scene  When ren
    
    :param defaultTraversalSet: (Q E) Set or query the default traversal set  The prepareRender
    command performs operations on the default traversal set, unless the -traversalSet flag is
    :type defaultTraversalSet: string
    :param deregister: (E) Deregister a registered traversal set  If the deregistered traversal
    set is the default traversal set, the new default traversal set will be the "nul
    :type deregister: string
    :param invokePostRender: (C) Invoke the postRender render traversal for a given traversal
    set  The traversal set will be the default traversal set, unless the -traversalSet flag
    :type invokePostRender: boolean
    :param invokePostRenderFrame: (C) Invoke the postRenderFrame render traversal for a given
    traversal set  The traversal set will be the default traversal set, unless the
    -traversalSet
    :type invokePostRenderFrame: boolean
    :param invokePostRenderLayer: (C) Invoke the postRenderLayer render traversal for a given
    traversal set  The traversal set will be the default traversal set, unless the
    -traversalSet
    :type invokePostRenderLayer: boolean
    :param invokePreRender: (C) Invoke the preRender render traversal for a given traversal set
     The traversal set will be the default traversal set, unless the -traversalSet flag i
    :type invokePreRender: boolean
    :param invokePreRenderFrame: (C) Invoke the preRenderFrame render traversal for a given
    traversal set  The traversal set will be the default traversal set, unless the
    -traversalSet f
    :type invokePreRenderFrame: boolean
    :param invokePreRenderLayer: (C) Invoke the preRenderLayer render traversal for a given
    traversal set  The traversal set will be the default traversal set, unless the
    -traversalSet f
    :type invokePreRenderLayer: boolean
    :param invokeSettingsUI: (C) Invoke the settings UI callback to populate a layout with UI
    controls, for a given traversal set  The current UI parent will be a form layout, which
    :type invokeSettingsUI: boolean
    :param label: (Q E) Set or query the label for a given traversal set  The label is used for
    UI display purposes, and can be localized  The traversal set will be the defa
    :type label: string
    :param listTraversalSets: (Q) Query the supported render traversal sets
    :type listTraversalSets: boolean
    :param postRender: (Q E) Set or query the postRender render traversal for a given traversal
    set  This traversal is run after a render  The traversal set will be the default t
    :type postRender: script
    :param postRenderFrame: (Q E) Set or query the postRenderFrame render traversal for a given
    traversal set  This traversal is run after the render of a single frame, with a render
    :type postRenderFrame: script
    :param postRenderLayer: (Q E) Set or query the postRenderLayer render traversal for a given
    traversal set  This traversal is run after a render layer is rendered, within a render
    :type postRenderLayer: script
    :param preRender: (Q E) Set or query the preRender render traversal for a given traversal
    set  This traversal is run before a render  The traversal set will be the default t
    :type preRender: script
    :param preRenderFrame: (Q E) Set or query the preRenderFrame render traversal for a given
    traversal set  This traversal is run before the render of a single frame, with a render
    :type preRenderFrame: script
    :param preRenderLayer: (Q E) Set or query the preRenderLayer render traversal for a given
    traversal set  This traversal is run before a render layer is rendered, within a render
    :type preRenderLayer: script
    :param restore: (C) Clean up after rendering, including restoring the assembly active
    representation configuration for the whole scene, if the saveAssemblyConfig flag fo
    :type restore: boolean
    :param saveAssemblyConfig: (Q E) Set or query whether or not the assembly active
    representation configuration for the whole scene should be saved for a given traversal set 
    The trave
    :type saveAssemblyConfig: boolean
    :param settingsUI: (Q E) Set or query the settings UI callback for a given traversal set 
    The traversal set will be the default traversal set, unless the -traversalSet flag i
    :type settingsUI: script
    :param setup: (C) Setup render preparation, including saving the assembly active
    representation configuration for the whole scene, if the saveAssemblyConfig flag for t
    :type setup: boolean
    :param traversalSet: (C Q E) Set or query properties for the specified registered traversal
    set  In query mode, this flag needs a value
    :type traversalSet: string
    :param traversalSetInit: (Q E) Set or query the traversal set initialisation callback for a
    given traversal set  The traversal set will be the default traversal set, unless the -tr
    :type traversalSetInit: script
    
    :returns: 
    :rtype: None
    """
    pass


def DeleteAllParticles(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleAutoFrame(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def clipSchedule(*args, allAbsolute=True, allRelative=True, blend=None, blendNode=None,
                 blendUsingNode="", character=True, clipIndex=0, cycle=0.0,
                 defaultAbsolute=True, enable=True, group=True, groupIndex=0, groupName="",
                 hold=None, insertTrack=0, instance="", listCurves=True, listPairs=True,
                 lock=True, mute=True, name="", postCycle=0.0, preCycle=0.0, remove=True,
                 removeBlend=None, removeEmptyTracks=True, removeTrack=0,
                 rotationsAbsolute=True, scale=0.0, shift=0, shiftIndex=0, solo=True,
                 sourceClipName=True, sourceEnd=None, sourceStart=None, start=None, track=0,
                 weight=0.0, weightStyle=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command is used to create, edit and query clips and blends in the Trax editor  It
    operates on the clipScheduler node attached to the character  In query mode, if no flags
    are specified, returns an array of strings in this form: (clipName,clipIndex,clipStart,
    clipSourceStart,clipSourceEnd,clipScale,clipPreCycle,clipPostCycle,clipHold)
    
    :param allAbsolute: (Q E) Set all channels to be calculated with absolute offsets  This
    flag cannot be used in conjunction with the ar/allRelative, ra/rotationsAbsolute or da/
    :type allAbsolute: boolean
    :param allRelative: (Q E) Set all channels to be calculated with relative offsets  This
    flag cannot be used in conjunction with the aa/allAbsolute, ra/rotationsAbsolute or da/
    :type allRelative: boolean
    :param blend: (C Q) This flag is used to blend two clips, whose indices are provided as
    flag arguments
    :type blend: [int, int]
    :param blendNode: (Q) This query only flag list all of the blend nodes associated with the
    blend defined by the two clip indices  This flag returns a string array  In quer
    :type blendNode: [int, int]
    :param blendUsingNode: (C) This flag is used to blend using an existing blend node  It is
    used in conjunction with the blend flag  The blend flag specifies the clip indices for
    :type blendUsingNode: string
    :param character: (Q) This flag is used to query which characters this scheduler controls 
    It returns an array of strings
    :type character: boolean
    :param clipIndex: (C Q) Specify the index of the clip to schedule  In query mode, returns
    an array of strings in this form: (clipName,index,start,sourceStart,sourceEnd,scale
    :type clipIndex: int
    :param cycle: (C Q) This flag is now obsolete  Use the postCycle flag instead
    :type cycle: float
    :param defaultAbsolute: (Q E) Sets all top-level channels except rotations in the clip to
    relative, and the remaining channels to absolute  This is the default during clip creatio
    :type defaultAbsolute: boolean
    :param enable: (C Q) This flag is used to enable or disable a clip  It must be used in
    conjunction with the ci/clipIndex flag  The specified clip will be enabled or disab
    :type enable: boolean
    :param group: (C) This flag is used to add (true) or remove (false) a list of clips
    (specified with groupIndex) into a group
    :type group: boolean
    :param groupIndex: (C M) This flag specifies a multiple number of clips to be added or
    removed from a group
    :type groupIndex: int
    :param groupName: (C Q) This flag is used to specify the group that should be added to  If
    no group by that name exists and new group is created with that name  By default i
    :type groupName: string
    :param hold: (C Q) Specify how long to hold the last value of the clip after its normal or
    cycled end
    :type hold: time
    :param insertTrack: (C) This flag is used to insert a new empty track at the track index
    specified
    :type insertTrack: int
    :param instance: (C) Create an instanced copy of the named clip  An instanced clip is one
    that is linked to an original clip  Thus, changes to the animation curve of the
    :type instance: string
    :param listCurves: (C Q) This flag is used to list the animation curves associated with a
    clip  It should be used in conjunction with the clipIndex flag, which specifies the
    :type listCurves: boolean
    :param listPairs: (Q) This query only flag returns a string array containing the channels
    in a character that are used by a clip and the names of the animation curves that
    :type listPairs: boolean
    :param lock: (Q E) This flag specifies whether clips on a track are to be locked or not 
    Must be used in conjuction with the track flag
    :type lock: boolean
    :param mute: (Q E) This flag specifies whether clips on a track are to be muted or not 
    Must be used in conjuction with the track flag
    :type mute: boolean
    :param name: (C Q) This flag is used to query the name of the clip node associated with the
    specified clip index, or to specify the name of the instanced clip during in
    :type name: string
    :param postCycle: (C Q) Specify the number of times to repeat the clip after its normal
    end
    :type postCycle: float
    :param preCycle: (C Q) Specify the number of times to repeat the clip before its normal
    start
    :type preCycle: float
    :param remove: (C) This flag is used to remove a clip from the timeline  It must be used in
    conjunction with the ci/clipIndex flag  The specified clip will be removed f
    :type remove: boolean
    :param removeBlend: (C) This flag is used to remove an existing blend between two clips,
    whose indices are provided as flag arguments
    :type removeBlend: [int, int]
    :param removeEmptyTracks: (C) This flag is used to remove all tracks that have no clips
    :type removeEmptyTracks: boolean
    :param removeTrack: (C) This flag is used to remove the track with the specified index  The
    track must have no clips on it before it can be removed
    :type removeTrack: int
    :param rotationsAbsolute: (Q E) Set all channels except rotations to be calculated with
    relative offsets  Rotation channels will be calculated with absolute offsets  This flag
    canno
    :type rotationsAbsolute: boolean
    :param scale: (C Q) Specify the amount to scale the clip  Values must be greater than 0
    :type scale: float
    :param shift: (C) This flag allows multiple clips to be shifted by a certain number of
    tracks and works in conjunction with the shiftIndex flag  The flag specifies the
    :type shift: int
    :param shiftIndex: (C M) This flag allows multiple clips to be shifted by a certain number
    of tracks and works in conjunction with the shiftAmount flag  The flag specifies th
    :type shiftIndex: int
    :param solo: (Q E) This flag specifies whether clips on a track are to be soloed or not 
    Must be used in conjuction with the track flag
    :type solo: boolean
    :param sourceClipName: (C Q) This flag is used to query the name of the source clip node
    associated with the specified clip index
    :type sourceClipName: boolean
    :param sourceEnd: (C Q) Specify where to end in the source clip's animation curves
    :type sourceEnd: time
    :param sourceStart: (C Q) Specify where to start in the source clip's animation curves
    :type sourceStart: time
    :param start: (C Q) Specify the placement of the start of the clip
    :type start: time
    :param track: (C Q) Specify the track to operate on  For example, which track to place a
    clip on, which track to mute/lock/solo  In query mode, it may be used in conjuct
    :type track: int
    :param weight: (C Q) This flag is used in to set or query the weight of the clip associated
    with the specified clip index
    :type weight: float
    :param weightStyle: (C Q) This flag is used to set or query the weightStyle attribute of
    the clip associated with the specified clip index
    :type weightStyle: int
    
    :returns: Clip name
    :rtype: string
    """
    pass


def dR_selectModeRaycast(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def commandLogging(*args, historySize=0, logCommands=True, logFile="", recordCommands=True,
                   resetLogFile=True, q=True, query=True, **kwargs):
    """
    This command controls logging of Maya commands, in memory and on disk   Note that if
    commands are logged in memory, they will be available to the crash reporter and appear in
    crash logs
    
    :param historySize: (C Q) Sets the number of entries in the in-memory command history
    :type historySize: int
    :param logCommands: (C Q) Enables or disables the on-disk logging of commands
    :type logCommands: boolean
    :param logFile: (C Q) Sets the filename to use for the on-disk log  If logging is active,
    the current file will be closed before the new one is opened
    :type logFile: string
    :param recordCommands: (C Q) Enables or disables the in-memory logging of commands
    :type recordCommands: boolean
    :param resetLogFile: (C Q) Reset the log filename to the default ('mayaCommandLog.txt' in
    the application folder, alongside 'Maya.env' and the default projects folder)
    :type resetLogFile: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def Planar(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PublishParentAnchorOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateVolumeCube(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def cMuscleWeightMirror(*args, **kwargs):
    """
    
    """
    pass


def OutlinerToggleIgnoreHidden(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeRenameTab(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nurbsCurveRebuildPref(*args, **kwargs):
    """
    
    """
    pass


def ShowBatchRender(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RecentCommandsWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GraphEditorValueLinesToggle(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeExpandAsset(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddWireOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def showWindow(*args, **kwargs):
    """
    Make a window visible  If no window is specified then the current window (most recently
    created) is used  See also the window command's vis/visible flag   If the specified window
    is iconified, it will be opened
    
    
    :returns: 
    :rtype: None
    """
    pass


def HypershadeGraphMaterialsOnSelectedObjects(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def cMuscleBindSticky(*args, **kwargs):
    """
    
    """
    pass


def WhatsNewHighlightingOn(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def LockCamera(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleLocalRotationAxes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RetimeKeysTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UniformOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def hikGlobals(*args, releaseAllPinning=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Sets global HumanIK flags for the application
    
    :param releaseAllPinning: (Q E) Sets the global release all pinning hik flag  When this
    flag is set, all pinning states are ignored
    :type releaseAllPinning: boolean
    
    :returns: Giving the state of the option
    :rtype: boolean
    """
    pass


def mute(*args, disable=True, force=True, q=True, query=True, **kwargs):
    """
    The mute command is used to disable and enable playback on a channel  When a channel is
    muted, it retains the value that it was at prior to being muted
    
    :param disable: (C) Disable muting on the channels
    :type disable: boolean
    :param force: (C) Forceable disable of muting on the channels  If there are keys on the
    mute channel, the animation and mute node will both be removed  If this flag is
    :type force: boolean
    
    :returns: Name(s) of the mute node(s)
    :rtype: string[]
    """
    pass


def TimeEditorDeleteSelectedTracks(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SubdivSmoothnessFineOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreatePolygonPipe(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleUVShellBorder(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateJiggleDeformer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSetGrabBrushTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetAsCombinationTargetOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sbs_EditSubstance(*args, **kwargs):
    """
    
    """
    pass


def RedoPreviousRender(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def InsertEdgeLoopTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Ungroup(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyAppendFacetCtx(*args, append=True, exists=True, image1="", image2="", image3="",
                       isRotateAvailable=True, maximumNumberOfPoints=0, planarConstraint=True,
                       rotate=0.0, subdivision=1, texture=1, q=True, query=True, e=True,
                       edit=True, **kwargs):
    """
    Create a new context to append facets on polygonal objects
    
    :param append: (C Q E) Allows to switch to polyCreateFacetCtx tool
    :type append: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param isRotateAvailable: (Q) Tells if the control associated to rotate flag is available 
    If several edges are already selected and they are not aligned (thus there is no "rotati
    :type isRotateAvailable: boolean
    :param maximumNumberOfPoints: (C Q E) Allows the ability to set a upper bound on the number
    of points in interactively place before polygon is created  A value less than 2 will mean
    that
    :type maximumNumberOfPoints: int
    :param planarConstraint: (C Q E) Allows/avoid new facet to be non-planar  If on, all new
    points will be projected onto current facet plane  Selected edges will be checked as well
    :type planarConstraint: boolean
    :param rotate: (C Q E) Rotate current facet around the first edge selected
    :type rotate: float
    :param subdivision: (C Q E) Number of sub-edges created for each new edge  Default is 1
    :type subdivision: int
    :param texture: (C Q E) Number of textures  Default is 1
    :type texture: int
    
    :returns: 
    :rtype: None
    """
    pass


def sbs_AffectedByAllInputs(*args, **kwargs):
    """
    
    """
    pass


def setXformManip(*args, showUnits=True, suppress=True, useRotatePivot=True, worldSpace=True,
                  q=True, query=True, **kwargs):
    """
    This command changes some of the settings of the xform manip, to control its appearance
    
    :param showUnits: (Q) If set to true, the xform manip displays current units; otherwise,
    the manip hides them
    :type showUnits: boolean
    :param suppress: (Q) If set to true, the xform manip is suppressed and therefore not
    visible or usable
    :type suppress: boolean
    :param useRotatePivot: (Q) If set to true, the xform manip uses the rotate pivot; otherwise,
    the manip uses the bounding-box center  Defaults false
    :type useRotatePivot: boolean
    :param worldSpace: (Q) If set to true, the xform manip is always in world space  If false,
    the manip is in object space  (Note: when multiple objects are selected the manip
    :type worldSpace: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def MakePondMotorBoats(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def EditTexture(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectEdgeRing(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MergeToCenter(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyUVSet(*args, allUVSets=True, allUVSetsIndices=True, allUVSetsWithCount=True, copy=True,
              create=True, currentLastUVSet=True, currentPerInstanceUVSet=True,
              currentUVSet=True, delete=True, genNewUVSet=True, newUVSet="", perInstance=True,
              projections=True, rename=True, reorder=True, shareInstances=True, unshared=True,
              uvSet="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    Command to do the following to uv sets: - delete an existing uv set  - rename an existing
    uv set  - create a new empty uv set  - copy the values from one uv set to a another
    pre-existing uv set  - reorder two uv sets - set the current uv set to a pre-existing uv
    set  - modify sharing between instances of per-instance uv sets - query the current uv 
    
    :param allUVSets: (Q E) This flag when used in in a query will return a list of all of the
    uv set names
    :type allUVSets: boolean
    :param allUVSetsIndices: (Q E) This flag when queried will return a list of the logical
    plug indices of all the uv sets in the sparse uv set array
    :type allUVSetsIndices: boolean
    :param allUVSetsWithCount: (Q E) This flag when used in a query will return a list of all
    of the uv set family names, with a count appended to the perInstance sets indicating the
    num
    :type allUVSetsWithCount: boolean
    :param copy: (C Q E) This flag when used will result in the copying of the uv set
    corresponding to name specified with the uvSet flag to the uvset corresponding to the na
    :type copy: boolean
    :param create: (C Q E) This flag when used will result in the creation of an empty uv set
    corresponding to the name specified with the uvSet flag  If a uvSet with that name
    :type create: boolean
    :param currentLastUVSet: (C Q E) This flag when used will set the current uv set that the
    object needs to work on, to be the last uv set added to the object  If no uv set exists
    for
    :type currentLastUVSet: boolean
    :param currentPerInstanceUVSet: (Q E) This is a query-only flag for use when the current uv
    set is a per-instance uv set family  This returns the member of the set family that
    corresponds
    :type currentPerInstanceUVSet: boolean
    :param currentUVSet: (C Q E) This flag when used will set the current uv set that the
    object needs to work on, to be the uv set corresponding to the name specified with the
    uvSet
    :type currentUVSet: boolean
    :param delete: (C Q E) This flag when used will result in the deletion of the uv set
    corresponding to the name specified with the uvSet flag
    :type delete: boolean
    :param genNewUVSet: (Q E) This is a query-only flag to generate a new unique name
    :type genNewUVSet: boolean
    :param newUVSet: (C Q E) Specifies the name that the uv set corresponding to the name
    specified with the uvSet flag, needs to be renamed to
    :type newUVSet: string
    :param perInstance: (C Q E) This flag can be used in conjunction with the create flag to
    indicate whether or not the uv set is per-instance  When you create a per-instance uv se
    :type perInstance: boolean
    :param projections: (Q E) This flag when used in a query will return a list of polygon uv
    projection node names  The order of the list is from most-recently-applied to least-r
    :type projections: boolean
    :param rename: (C Q E) This flag when used will result in the renaming of the uv set
    corresponding to the name specified with the uvSet flag to the name specified using the
    :type rename: boolean
    :param reorder: (C Q E) This flag when used will result in the reordering of two uv sets
    corresponding to name specified with the uvSet flag, and the uvset corresponding to
    :type reorder: boolean
    :param shareInstances: (C Q E) This flag is used to modify the sharing of per-instance uv
    sets within a given uv set family so that all selected instances share the specified set
    :type shareInstances: boolean
    :param unshared: (C Q E) This flag can be used in conjunction with the create and
    perInstance flags to indicate that the newly created per-instance set should be created
    with
    :type unshared: boolean
    :param uvSet: (C Q E) Specifies the name of the uv set that this command needs to work on 
    This flag has to be specified for this command to do anything meaningful other t
    :type uvSet: string
    
    :returns: Success or Failure.
    :rtype: boolean
    """
    pass


def HideNParticles(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeOpenMaterialViewerWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowMeshSmoothToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def setDefaultShadingGroup(*args, q=True, query=True, **kwargs):
    """
    The setDefaultShadingGroup command is used to change which shading group is considered the
    current default shading group  Subsequently created objects will be assigned to the new
    default group
    
    
    :returns: 
    :rtype: None
    """
    pass


def spotLightPreviewPort(*args, annotation="", backgroundColor=None, defineTemplate="",
                         docTag="", dragCallback=None, dropCallback=None, enable=True,
                         enableBackground=True, enableKeyboardFocus=True, exists=True,
                         fullPathName=True, height=0, highlightColor=None, isObscured=True,
                         manage=True, noBackground=True, numberOfPopupMenus=True, parent="",
                         popupMenuArray=True, preventOverride=True, spotLight=None,
                         statusBarMessage="", useTemplate="", visible=True,
                         visibleChangeCommand=None, width=0, widthHeight=None, q=True,
                         query=True, e=True, edit=True, **kwargs):
    """
    This command creates a 3dPort that displays an image representing the illumination provided
    by the spotLight  It is a picture of a plane being illuminated by a light   The optional
    argument is the name of the 3dPort
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param spotLight: (C) Name of the spotLight
    :type spotLight: name
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    :param widthHeight: (C) The width and height of the port
    :type widthHeight: [int, int]
    
    :returns: - the name of the port created or modified
    :rtype: string
    """
    pass


def ToggleMeshPoints(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NormalConstraintOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CopyUVsToUVSetOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SplitVertex(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def addDynamic(*args, **kwargs):
    """
    Makes the "object" specified as second argument the source of an existing field or emitter
    specified as the first argument  In practical terms, what this means is that a field will
    emanate its force from its owner object, and an emitter will emit from its owner object  
    addDynamic makes the specified field or emitter a child of the owner's transfor
    
    
    :returns: The name of the source object and the field or emitter which was
    attached to it.
    :rtype: string
    """
    pass


def ShowSculptObjects(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def EnableMemoryCaching(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorCreateAdditiveLayer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Sine(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RedoViewChange(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RebuildCurve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dagPose(*args, addToPose=True, atPose=True, bindPose=True, g=True, members=True, name="",
            remove=True, reset=True, restore=True, save=True, selection=True, worldParent=True,
            q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command is used to save and restore the matrix information for a dag hierarchy 
    Specifically, the data stored will restore the translate, rotate, scale, scale pivot,
    rotate pivot, rotation order, and (for joints) joint order for all the objects on the
    hierarchy  Data for other attributes is not stored by this command   This command can also
    be
    
    :param addToPose: (C) Allows adding the selected items to the dagPose
    :type addToPose: boolean
    :param atPose: (Q) Query whether the hierarchy is at same position as the pose  Names of
    hierarchy members that are not at the pose position will be returned  An empty
    :type atPose: boolean
    :param bindPose: (C Q) Used to specify the bindPose for the selected hierarchy  Each
    hierarchy can have only a single bindPose, which is saved automatically at the time of
    :type bindPose: boolean
    :param g: (C) This flag can be used in conjunction with the restore flag to signal that the
    members of the pose should be restored to the global pose  The global p
    :type g: boolean
    :param members: (Q) Query the members of the specified pose  The pose should be specified
    using the selection list, the -bp/-bindPose or the -n/-name flag
    :type members: boolean
    :param name: (C Q) Specify the name of the pose  This can be used during create, restore,
    reset, remove, and query operations to specify the pose to be created or acted
    :type name: string
    :param remove: (C) Remove the selected joints from the specified pose
    :type remove: boolean
    :param reset: (C) Reset the pose on the selected joints  If you are resetting pose data for
    a bindPose, take care  It is appropriate to use the -rs/-reset flag if a jo
    :type reset: boolean
    :param restore: (C) Restore the hierarchy to a saved pose  To specify the pose, select the
    pose node, or use the -bp/-bindPose or -n/-name flag
    :type restore: boolean
    :param save: (C) Save a dagPose for the selected dag hierarchy  The name of the new pose
    will be returned
    :type save: boolean
    :param selection: (C Q) Whether or not to store a pose for all items in the hierarchy, or
    for only the selected items
    :type selection: boolean
    :param worldParent: (C) Indicates that the selected pose member should be recalculated as
    if it is parented to the world  This is typically used when you plan to reparent th
    :type worldParent: boolean
    
    :returns: Name of pose
    :rtype: string
    """
    pass


def CreateTextureReferenceObject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FluidGradientsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectSurfacePointsMask(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def python(*args, **kwargs):
    """
    
    """
    pass


def createPolyCubeCtx(*args, **kwargs):
    """
    
    """
    pass


def FBXImportShowUI(*args, **kwargs):
    """
    
    """
    pass


def ShowSubdivSurfaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ikfkDisplayMethod(*args, display="", q=True, query=True, **kwargs):
    """
    The ikfkDisplayMethod command is used to specify how ik/fk blending should be shown
    
    :param display: (C Q) Specify how ik/fk blending should be shown when the handle is
    selected  Possible choices are "none" (do not display any blending), "ik" (only show ik
    :type display: string
    
    :returns: 
    :rtype: None
    """
    pass


def ShowMeshFoamyToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def getProcArguments(*args, **kwargs):
    """
    
    """
    pass


def bufferCurve(*args, animation="keysOrObjects.", attribute="", controlPoints=False,
                exists=True, float=None, hierarchy="", includeUpperBound=True, index=0,
                overwrite=True, shape=True, swap=True, time=None, useReferencedCurve=True,
                q=True, query=True, **kwargs):
    """
    This command operates on a keyset  A keyset is defined as a group of keys within a
    specified time range on one or more animation curves   The animation curves comprising a
    keyset depend on the value of the "-animation" flag:  keysOrObjects: Any active keys, when
    no target objects or -attribute flags appear on the command line, or All animation curv
    
    :param animation: (C) Where this command should get the animation to act on  Valid values
    are "objects," "keys," and "keysOrObjects" Default: "keysOrObjects." (See Descrip
    :type animation: string
    :param attribute: (C M) List of attributes to select In query mode, this flag needs a
    value
    :type attribute: string
    :param controlPoints: (C) This flag explicitly specifies whether or not to include the
    control points of a shape (see "-s" flag) in the list of attributes  Default: false  (No
    :type controlPoints: boolean
    :param exists: (Q) Returns true if a buffer curve currently exists on the specified
    attribute; false otherwise
    :type exists: boolean
    :param float: (C M) value uniquely representing a non-time-based key (or key range) on a
    time-based animCurve  Valid floatRange include single values (-f 10) or a string
    :type float: floatrange
    :param hierarchy: (C) Hierarchy expansion options  Valid values are "above," "below," "both,
    " and "none." (Not valid for "pasteKey" cmd.) In query mode, this flag needs a
    :type hierarchy: string
    :param includeUpperBound: (C) When the -t/time or -f/float flags represent a range of keys,
    this flag determines whether the keys at the upper bound of the range are included in t
    :type includeUpperBound: boolean
    :param index: (C M) index of a key on an animCurve In query mode, this flag needs a value
    :type index: int
    :param overwrite: (C) Create a buffer curve  "true" means create a buffer curve whether or
    not one already existed  "false" means if a buffer curve exists already then lea
    :type overwrite: boolean
    :param shape: (C) Consider attributes of shapes below transforms as well, except
    "controlPoints"  Default: true  (Not valid for "pasteKey" cmd.) In query mode, this fl
    :type shape: boolean
    :param swap: (C) For animated attributes which have buffer curves, swap the buffer curve
    with the current animation curve
    :type swap: boolean
    :param time: (C M) time uniquely representing a key (or key range) on a time-based
    animCurve  See the code examples below on how to format for a single frame or frame r
    :type time: timerange
    :param useReferencedCurve: (C Q) In create mode, sets the buffer curve to the referenced
    curve  Curves which are not from file references will ignore this flag  In query mode,
    return
    :type useReferencedCurve: boolean
    
    :returns: Number of buffer curves
    :rtype: int
    """
    pass


def transferAttributes(*args, after=True, afterReference=True, before=True, colorBorders=0,
                       deformerTools=True, exclusive="", flipUVs=0, frontOfChain=True,
                       geometry="", geometryIndices=True, ignoreSelected=True,
                       includeHiddenSelections=False, matchChoice=0, name="", parallel=True,
                       prune=True, remove=True, sampleSpace=0, searchMethod=0, searchScaleX=0.0,
                       searchScaleY=0.0, searchScaleZ=0.0, sourceColorSet="", sourceUvSet="",
                       sourceUvSpace="", split=True, targetColorSet="", targetUvSet="",
                       targetUvSpace="", transferColors=0, transferNormals=0,
                       transferPositions=0, transferUVs=0, q=True, query=True, e=True,
                       edit=True, **kwargs):
    """
    Samples the attributes of a source surface (first argument) and transfers them onto a
    target surface (second argument)
    
    :param after: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type after: boolean
    :param afterReference: (C E) The -afterReference flag is used to specify deformer ordering
    in a hybrid way that choses between -before and -after automatically  If the geometry b
    :type afterReference: boolean
    :param before: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type before: boolean
    :param colorBorders: (C E) Controls whether color borders are preserved when transferring
    color data  If this is non-zero, any color borders will be mapped onto the nearest edg
    :type colorBorders: int
    :param deformerTools: (Q) Returns the name of the deformer tool objects (if any) as string
    string ..
    :type deformerTools: boolean
    :param exclusive: (C Q) Puts the deformation set in a deform partition
    :type exclusive: string
    :param flipUVs: (C E) Controls how sampled UV data is flipped before being transferred to
    the target  0 means no flipping; 1 means UV data is flipped in the U direction; 2
    :type flipUVs: int
    :param frontOfChain: (C E) This command is used to specify that the new deformer node
    should be placed ahead (upstream) of existing deformer and skin nodes in the shape's histo
    :type frontOfChain: boolean
    :param geometry: (Q E M) The specified object will be added to the list of objects being
    deformed by this deformer object, unless the -rm flag is also specified  When queried
    :type geometry: string
    :param geometryIndices: (Q) Complements the -geometry flag in query mode  Returns the multi
    index of each geometry
    :type geometryIndices: boolean
    :param ignoreSelected: (C) Tells the command to not deform objects on the current selection
    list
    :type ignoreSelected: boolean
    :param includeHiddenSelections: (C) Apply the deformer to any visible and hidden objects in
    the selection list  Default is false
    :type includeHiddenSelections: boolean
    :param matchChoice: (C E) When using topological component matching, selects between
    possible matches  If the meshes involved in the transfer operation have symmetries in thei
    :type matchChoice: int
    :param name: (C) Used to specify the name of the node being created
    :type name: string
    :param parallel: (C E) Inserts the new deformer in a parallel chain to any existing
    deformers in the history of the object  A blendShape is inserted to blend the parallel r
    :type parallel: boolean
    :param prune: (E) Removes any points not being deformed by the deformer in its current
    configuration from the deformer set
    :type prune: boolean
    :param remove: (E M) Specifies that objects listed after the -g flag should be removed from
    this deformer
    :type remove: boolean
    :param sampleSpace: (C E) Selects which space the attribute transfer is performed in  0 is
    world space, 1 is model space, 4 is component-based, 5 is topology-based  The defaul
    :type sampleSpace: int
    :param searchMethod: (C E) Specifies which search method to use when correlating points  0
    is closest along normal, 3 is closest to point  The default is closest to point
    :type searchMethod: int
    :param searchScaleX: (C E) Specifies an optional scale that should be applied to the x-axis
    of the target model before transferring data  A value of 1.0 (the default) means no
    :type searchScaleX: float
    :param searchScaleY: (C E) Specifies an optional scale that should be applied to the y-axis
    of the target model before transferring data  A value of 1.0 (the default) means no
    :type searchScaleY: float
    :param searchScaleZ: (C E) Specifies an optional scale that should be applied to the z-axis
    of the target model before transferring data  A value of 1.0 (the default) means no
    :type searchScaleZ: float
    :param sourceColorSet: (C) Specifies the name of a single color set on the source
    surface(s) that should be transferred to the target  This value is only used when the
    operatio
    :type sourceColorSet: string
    :param sourceUvSet: (C) Specifies the name of a single UV set on the source surface(s) that
    should be transferred to the target  This value is only used when the operation i
    :type sourceUvSet: string
    :param sourceUvSpace: (C) Specifies the name of the UV set on the source surface(s) that
    should be used as the transfer space  This value is only used when the operation is co
    :type sourceUvSpace: string
    :param split: (C E) Branches off a new chain in the dependency graph instead of
    inserting/appending the deformer into/onto an existing chain  Works in create mode (and e
    :type split: boolean
    :param targetColorSet: (C) Specifies the name of a single color set on the target surface
    that should be receive the sampled color data  This value is only used when the operat
    :type targetColorSet: string
    :param targetUvSet: (C) Specifies the name of a single UV set on the target surface that
    should be receive the sampled UV data  This value is only used when the operation is
    :type targetUvSet: string
    :param targetUvSpace: (C) Specifies the name of the UV set on the target surface( that
    should be used as the transfer space  This value is only used when the operation is conf
    :type targetUvSpace: string
    :param transferColors: (C E) Controls color set transfer  0 means no color sets are
    transferred, 1 means that a single color set (specified by sourceColorSet and
    targetColorSet)
    :type transferColors: int
    :param transferNormals: (C E) A non-zero value indicates vertex normals should be sampled
    and written into user normals on the target surface
    :type transferNormals: int
    :param transferPositions: (C E) A non-zero value indicates vertex position should be
    sampled, causing the target surface to "wrap" to the source surface(s)
    :type transferPositions: int
    :param transferUVs: (C E) Controls UV set transfer  0 means no UV sets are transferred, 1
    means that a single UV set (specified by sourceUVSet and targetUVSet) is transferred,
    :type transferUVs: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def SwapBufferCurve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def iprEngine(*args, copy="", defineTemplate="", diagnostics=True, estimatedMemory=True,
              exists=True, iprImage="", motionVectorFile=True, object=None, region=None,
              relatedFiles=True, releaseIprImage=True, resolution=True, scanlineIncrement="",
              showProgressBar=True, startTuning=True, stopTuning=True, underPixel=None,
              update=True, updateDepthOfField=True, updateLightGlow=True, updateMotionBlur=True,
              updatePort="", updateShaderGlow=True, updateShading=True, updateShadowMaps=True,
              useTemplate="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    Command to create or edit an iprEngine  A iprEngine is an object that watches for changes
    to shading networks and automatically reshades to generate an up-to-date image
    
    :param copy: (E) Copies the deep raster file, as well as its related files, to the new
    location
    :type copy: string
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param diagnostics: (E) The diagnostics should be shown
    :type diagnostics: boolean
    :param estimatedMemory: (Q) Displays the estimated memory being used by IPR
    :type estimatedMemory: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param iprImage: (C Q E) Specify the ipr image to use
    :type iprImage: string
    :param motionVectorFile: (Q) Returns the name of the motion vector file used by IPR
    :type motionVectorFile: boolean
    :param object: (C Q E) The objects to be tuned
    :type object: name
    :param region: (C Q E) The coordinates of the region to be tuned  The integers are in the
    sequence left bottom right top or x1,y2 x2,y2
    :type region: [int, int, int, int]
    :param relatedFiles: (Q) Returns the names for the related files, e.g, the
    non-glow-non-blur image, the motion vector file, and the depth-map files
    :type relatedFiles: boolean
    :param releaseIprImage: (E) The ipr image should be released and memory should be freed
    :type releaseIprImage: boolean
    :param resolution: (Q) The width and height of the ipr file
    :type resolution: boolean
    :param scanlineIncrement: (C Q E) Set the scanline increment percentage  If the height of
    the region being update is 240 pixels, and the scanlineIncrement is 10% then the image will
    r
    :type scanlineIncrement: string
    :param showProgressBar: (C Q E) Show progress bar during tuning
    :type showProgressBar: boolean
    :param startTuning: (C Q E) An ipr image has been specified and now changes to shading
    networks should force an image to be produced
    :type startTuning: boolean
    :param stopTuning: (C Q E) Tuning should cease but ipr image should not be closed
    :type stopTuning: boolean
    :param underPixel: (E) Get list of objects under the pixel sprcified
    :type underPixel: [int, int]
    :param update: (C E) Force an update
    :type update: boolean
    :param updateDepthOfField: (C E) Force a refresh of depth-of-field
    :type updateDepthOfField: boolean
    :param updateLightGlow: (C Q E) Automatically update when light glow changes
    :type updateLightGlow: boolean
    :param updateMotionBlur: (C Q E) Automatically update when 2.5D motion blur changes
    :type updateMotionBlur: boolean
    :param updatePort: (C Q E) The name of the port that is to be updated when pixel values are
    recomputed  (not currently supported)
    :type updatePort: string
    :param updateShaderGlow: (C Q E) Automatically update when shader glow changes
    :type updateShaderGlow: boolean
    :param updateShading: (C Q E) Automatically update shading
    :type updateShading: boolean
    :param updateShadowMaps: (C E) Force the shadow maps to be generated and an update to
    occur
    :type updateShadowMaps: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: - the name of the ipr engine created or modified
    :rtype: string
    """
    pass


def UnghostObject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def pointPosition(*args, local=True, world=True, **kwargs):
    """
    This command returns the world or local space position for any type of point object  Valid
    selection items are: - curve and surface CVs - poly vertices - lattice points - particles -
    curve and surface edit points - curve and surface parameter points - poly uvs -
    rotate/scale/joint pivots - selection handles - locators, param locators and arc length
    
    :param local: (C) Return the point in local space coordinates
    :type local: boolean
    :param world: (C) Return the point in world space coordinates
    :type world: boolean
    
    :returns: Command result
    :rtype: float[]
    """
    pass


def TangetConstraint(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def KeyframeTangentMarkingMenu(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def annotate(*args, point=None, text="", **kwargs):
    """
    This command is used to create an annotation to be attached to the specified objects at the
    specified point
    
    :param point: (C) Specifies the point about which the annotation text is to be centered
    :type point: [float, float, float]
    :param text: (C) Specifies the annotation text
    :type text: string
    
    :returns: Annotation added
    :rtype: string
    """
    pass


def geometryReplaceCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShapeEditorSelectNone(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def subdToNurbs(*args, **kwargs):
    """
    
    """
    pass


def UVCameraBasedProjectionOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CommandShell(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SculptGeometryToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeTestTexture(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def LoadHIKCharacterDefinition(*args, **kwargs):
    """
    
    """
    pass


def nClothAppend(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def reference(*args, **kwargs):
    """
    
    """
    pass


def FloatSelectedObjectsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateOceanWake(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def scriptNode(*args, afterScript="", beforeScript="", executeAfter=True, executeBefore=True,
               ignoreReferenceEdits=True, name="", scriptType=0, sourceType="", q=True,
               query=True, e=True, edit=True, **kwargs):
    """
    scriptNodes contain scripts that are executed when a file is loaded or when the script node
    is deleted  If a script modifies a referenced node, the changes will be tracked as
    reference edits unless the scriptNode was created with the ignoreReferenceEdits flag  The
    scriptNode command is used to create, edit, query, and test scriptNodes
    
    :param afterScript: (C Q E) The script executed when the script node is deleted  C: The
    default is an empty string  Q: When queried, this flag returns a string
    :type afterScript: string
    :param beforeScript: (C Q E) The script executed during file load  C: The default is an
    empty string  Q: When queried, this flag returns a string
    :type beforeScript: string
    :param executeAfter: (C) Execute the script stored in the .after attribute of the
    scriptNode  This script is normally executed when the script node is deleted
    :type executeAfter: boolean
    :param executeBefore: (C) Execute the script stored in the .before attribute of the
    scriptNode  This script is normally executed when the file is loaded
    :type executeBefore: boolean
    :param ignoreReferenceEdits: (C) Sets whether changes made to referenced nodes during the
    execution of the script should be recorded as reference edits  This flag must be set when
    th
    :type ignoreReferenceEdits: boolean
    :param name: (C) When creating a new scriptNode, this flag specifies the name of the node 
    If a non-unique name is used, the name will be modified to ensure uniquenes
    :type name: string
    :param scriptType: (C Q E) Execute on time changed
    :type scriptType: int
    :param sourceType: (C Q E) Sets the language type for both the attached scripts  Valid
    values are "mel" (enabled by default), and "python"
    :type sourceType: string
    
    :returns: 
    :rtype: None
    """
    pass


def debugVar(*args, **kwargs):
    """
    
    """
    pass


def CreateAreaLight(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OpenCloseSurfacesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def wireContext(*args, crossingEffect=0, deformationOrder="", dropoffDistance=0.0, envelope=1.0,
                exclusive=True, exclusivePartition="", exists=True, groupWithBase=False,
                history=True, holder=False, image1="", image2="", image3="", localInfluence=0,
                name="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a tool that can be used to create a wire deformer
    
    :param crossingEffect: (C Q E) Set the amount of convolution filter effect  Varies from
    fully convolved at 0 to a simple additive effect at 1  Default is 0
    :type crossingEffect: float
    :param deformationOrder: (C Q E) Set the appropriate flag that determines the position in
    in the deformation hierarchy
    :type deformationOrder: string
    :param dropoffDistance: (C Q E) Set the dropoff Distance for the wires
    :type dropoffDistance: float
    :param envelope: (C Q E) Set the envelope value for the deformer  Default is 1.0
    :type envelope: float
    :param exclusive: (C Q E) Set exclusive mode on or off
    :type exclusive: boolean
    :param exclusivePartition: (C Q E) Set the name of an exclusive partition
    :type exclusivePartition: string
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param groupWithBase: (C Q E) Groups the wire with the base wire so that they can easily be
    moved together to create a ripple effect  Default is false
    :type groupWithBase: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param holder: (C E) Controls whether the user can specify holders for the wires from the
    wire context  A holder is a curve that you can use to limit the wire's deformati
    :type holder: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param localInfluence: (C Q E) Set the amount of local influence a wire has with respect to
    other wires  Default is 0
    :type localInfluence: float
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: The name of the context created
    :rtype: string
    """
    pass


def OutlinerToggleReferenceNodes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PerspTextureLayout(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def rowLayout(*args, adjustableColumn=0, adjustableColumn1=0, adjustableColumn2=0,
              adjustableColumn3=0, adjustableColumn4=0, adjustableColumn5=0,
              adjustableColumn6=0, annotation="", backgroundColor=None, childArray=True,
              columnAlign=None, columnAlign1="", columnAlign2=None, columnAlign3=None,
              columnAlign4=None, columnAlign5=None, columnAlign6=None, columnAttach=None,
              columnAttach1="", columnAttach2=None, columnAttach3=None, columnAttach4=None,
              columnAttach5=None, columnAttach6=None, columnOffset1=0, columnOffset2=None,
              columnOffset3=None, columnOffset4=None, columnOffset5=None, columnOffset6=None,
              columnWidth=None, columnWidth1=0, columnWidth2=None, columnWidth3=None,
              columnWidth4=None, columnWidth5=None, columnWidth6=None, defineTemplate="",
              docTag="", dragCallback=None, dropCallback=None, enable=True,
              enableBackground=True, enableKeyboardFocus=True, exists=True, fullPathName=True,
              height=0, highlightColor=None, isObscured=True, manage=True, noBackground=True,
              numberOfChildren=True, numberOfColumns=0, numberOfPopupMenus=True, parent="",
              popupMenuArray=True, preventOverride=True, rowAttach=None, statusBarMessage="",
              useTemplate="", visible=True, visibleChangeCommand=None, width=0, q=True,
              query=True, e=True, edit=True, **kwargs):
    """
    This command creates a layout capable of positioning children into a single horizontal row
    
    :param adjustableColumn: (C E) Specifies which column has an adjustable size that changes
    with the sizing of the layout
    :type adjustableColumn: int
    :param adjustableColumn1: (C) Specifies that the first column has an adjustable size that
    changes with the size of the parent layout  Ignored if there isn't exactly one column
    :type adjustableColumn1: int
    :param adjustableColumn2: (C) Specifies which of the two columns has an adjustable size
    that changes with the size of the parent layout  Ignored if there isn't exactly two
    columns
    :type adjustableColumn2: int
    :param adjustableColumn3: (C) Specifies which of the three columns has an adjustable size
    that changes with the size of the parent layout  Ignored if there isn't exactly three col
    :type adjustableColumn3: int
    :param adjustableColumn4: (C) Specifies which of the four columns has an adjustable size
    that changes with the size of the parent layout  Ignored if there isn't exactly four colum
    :type adjustableColumn4: int
    :param adjustableColumn5: (C) Specifies which of the five columns has an adjustable size
    that changes with the size of the parent layout  Ignored if there isn't exactly five colum
    :type adjustableColumn5: int
    :param adjustableColumn6: (C) Specifies which of the six columns has an adjustable size
    that changes with the size of the parent layout  Ignored if there isn't exactly six
    columns
    :type adjustableColumn6: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param childArray: (Q) Returns a string array of the names of the layout's immediate
    children
    :type childArray: boolean
    :param columnAlign: (C E M) Text alignment for the specified column  Valid values are
    "left", "right", and "center"
    :type columnAlign: [int, string]
    :param columnAlign1: (C) Text alignment for the first column  Valid values are "left",
    "right", and "center"  Ignored if there isn't exactly one column
    :type columnAlign1: string
    :param columnAlign2: (C) Text alignment for both columns  Valid values are "left", "right",
    and "center"  Ignored if there isn't exactly two columns
    :type columnAlign2: [string, string]
    :param columnAlign3: (C) Text alignment for all three columns  Valid values are "left",
    "right", and "center"  Ignored if there isn't exactly three columns
    :type columnAlign3: [string, string, string]
    :param columnAlign4: (C) Text alignment for all four columns  Valid values are "left",
    "right", and "center"  Ignored if there isn't exactly four columns
    :type columnAlign4: [string, string, string, string]
    :param columnAlign5: (C) Text alignment for all five columns  Valid values are "left",
    "right", and "center"  Ignored if there isn't exactly five columns
    :type columnAlign5: [string, string, string, string, string]
    :param columnAlign6: (C) Text alignment for all six columns  Valid values are "left",
    "right", and "center"  Ignored if there isn't exactly six columns
    :type columnAlign6: [string, string, string, string, string, string]
    :param columnAttach: (C E M) Horizontally attach a particular column  The first argument is
    a 1-based index specifying the column  The second argument is the attachment, valid va
    :type columnAttach: [int, string, int]
    :param columnAttach1: (C) Attachment type for the first column  Ignored if there isn't
    exactly one column  Valid values are "left", "right", and "both"
    :type columnAttach1: string
    :param columnAttach2: (C) Attachment type for both columns  Ignored if there isn't exactly
    two columns  Valid values are "left", "right", and "both"
    :type columnAttach2: [string, string]
    :param columnAttach3: (C) Attachment type for all three columns  Ignored if there isn't
    exactly three columns  Valid values are "left", "right", and "both"
    :type columnAttach3: [string, string, string]
    :param columnAttach4: (C) Attachment type for all four columns  Ignored if there isn't
    exactly four columns  Valid values are "left", "right", and "both"
    :type columnAttach4: [string, string, string, string]
    :param columnAttach5: (C) Attachment type for all five columns  Ignored if there isn't
    exactly five columns  Valid values are "left", "right", and "both"
    :type columnAttach5: [string, string, string, string, string]
    :param columnAttach6: (C) Attachment type for all six columns  Ignored if there isn't
    exactly six columns  Valid values are "left", "right", and "both"
    :type columnAttach6: [string, string, string, string, string, string]
    :param columnOffset1: (C) Used in conjunction with the -columnAttach1 flag  If that flag is
    not used then this flag will be ignored  Sets the offset for the first column  The
    :type columnOffset1: int
    :param columnOffset2: (C) Used in conjunction with the -columnAttach2 flag  If that flag is
    not used then this flag will be ignored  Sets the offset for both columns  The offs
    :type columnOffset2: [int, int]
    :param columnOffset3: (C) Used in conjunction with the -columnAttach3 flag  If that flag is
    not used then this flag will be ignored  Sets the offset for all three columns  The
    :type columnOffset3: [int, int, int]
    :param columnOffset4: (C) Used in conjunction with the -columnAttach4 flag  If that flag is
    not used then this flag will be ignored  Sets the offset for all four columns  The
    :type columnOffset4: [int, int, int, int]
    :param columnOffset5: (C) Used in conjunction with the -columnAttach5 flag  If that flag is
    not used then this flag will be ignored  Sets the offset for all five columns  The
    :type columnOffset5: [int, int, int, int, int]
    :param columnOffset6: (C) Used in conjunction with the -columnAttach6 flag  If that flag is
    not used then this flag will be ignored  Sets the offset for all six columns  The o
    :type columnOffset6: [int, int, int, int, int, int]
    :param columnWidth: (C E M) Width of a particular column  The first argument is a 1-based
    index specifying the column  The second argument is the width value
    :type columnWidth: [int, int]
    :param columnWidth1: (C) Width for the first column  Ignored if there isn't exactly one
    column
    :type columnWidth1: int
    :param columnWidth2: (C) Widths for both columns  Ignored if there isn't exactly two
    columns
    :type columnWidth2: [int, int]
    :param columnWidth3: (C) Widths for all three columns  Ignored if there isn't exactly three
    columns
    :type columnWidth3: [int, int, int]
    :param columnWidth4: (C) Widths for all four columns  Ignored if there isn't exactly four
    columns
    :type columnWidth4: [int, int, int, int]
    :param columnWidth5: (C) Widths for all five columns  Ignored if there isn't exactly five
    columns
    :type columnWidth5: [int, int, int, int, int]
    :param columnWidth6: (C) Widths for all six columns  Ignored if there isn't exactly six
    columns
    :type columnWidth6: [int, int, int, int, int, int]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfChildren: (Q) Returns in an int the number of immediate children of the
    layout
    :type numberOfChildren: boolean
    :param numberOfColumns: (C Q) Number of columns in the row  The specified number of columns
    must be a value greater than 0
    :type numberOfColumns: int
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rowAttach: (C E M) Vertically attach a particular column  The first argument is a
    1-based index specifying the column  The second argument is the attachment, valid valu
    :type rowAttach: [int, string, int]
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def ProfilerToolHideSelectedRepetition(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def aaf2fcp(*args, deleteFile=True, dstPath="", getFileName=0, progress=0, srcFile="",
            terminate=0, waitCompletion=0, **kwargs):
    """
    This command is used to convert an aff file to a Final Cut Pro (fcp) xml file The
    conversion process can take several seconds to complete and the command is meant to be run
    asynchronously
    
    :param deleteFile: (C) Delete temporary file  Can only be used with the terminate option
    :type deleteFile: boolean
    :param dstPath: (C) Specifiy a destination path
    :type dstPath: string
    :param getFileName: (C) Query output file name
    :type getFileName: int
    :param progress: (C) Request progress report
    :type progress: int
    :param srcFile: (C) Specifiy a source file
    :type srcFile: string
    :param terminate: (C) Complete the task
    :type terminate: int
    :param waitCompletion: (C) Wait for the conversion process to complete
    :type waitCompletion: int
    
    :returns: Command result
    :rtype: string
    """
    pass


def SetDrivenKey(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def spreadSheetEditor(*args, allAttr=True, attrRegExp="", control=True, defineTemplate="",
                      docTag="", execute="", exists=True, filter="", fixedAttrList=None,
                      forceMainConnection="", highlightConnection="", keyableOnly=True,
                      lockMainConnection=True, longNames=True, mainListConnection="",
                      niceNames=True, panel="", parent="", precision=0, selectedAttr=True,
                      selectionConnection="", showShapes=True, stateString=True, unParent=True,
                      unlockMainConnection=True, updateMainConnection=True, useTemplate="",
                      q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a new spread sheet editor in the current layout
    
    :param allAttr: (Q) Returns a list of all the attribute names currently being displayed 
    This flag is ignored when not being queried
    :type allAttr: boolean
    :param attrRegExp: (C Q E) Filter the current displayed attribute names  This expression
    matches the case-insensitive substring of attribute names
    :type attrRegExp: string
    :param control: (Q) Query only  Returns the top level control for this editor  Usually used
    for getting a parent to attach popup menus  Caution: It is possible for an ed
    :type control: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Attaches a tag to the editor
    :type docTag: string
    :param execute: (E) Immediately executes the command string once for every selected cell in
    the spreadSheet  Before the command is executed, "#A" is substituted with the
    :type execute: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param filter: (C Q E) Specifies the name of an itemFilter object to be used with this
    editor  This filters the information coming onto the main list of the editor
    :type filter: string
    :param fixedAttrList: (C Q E) Forces the editor to only display attributes with the
    specified names
    :type fixedAttrList: string[]
    :param forceMainConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type forceMainConnection: string
    :param highlightConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its highlight list  Not all editors have a highlight list 
    F
    :type highlightConnection: string
    :param keyableOnly: (C Q E) Limits the displayed attributes to be those that are keyable 
    True by default
    :type keyableOnly: boolean
    :param lockMainConnection: (C E) Locks the current list of objects within the
    mainConnection, so that only those objects are displayed within the editor  Further changes
    to the origi
    :type lockMainConnection: boolean
    :param longNames: (C Q E) Controls whether the attributes are displayed using their long
    names or their short names
    :type longNames: boolean
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type mainListConnection: string
    :param niceNames: (C Q E) Controls whether the attribute names will be displayed in a more
    user-friendly, readable way  When this is on, the longNames flag is ignored  When th
    :type niceNames: boolean
    :param panel: (C Q) Specifies the panel for this editor  By default if an editor is created
    in the create callback of a scripted panel it will belong to that panel  If a
    :type panel: string
    :param parent: (C Q E) Specifies the parent layout for this editor  This flag will only
    have an effect if the editor is currently un-parented
    :type parent: string
    :param precision: (C Q E) Specifies the maximum number of digits displayed to the right of
    the decimal place  Can be 0 to 20
    :type precision: int
    :param selectedAttr: (Q) Returns a list of all the attribute names that are selected  This
    flag is ignored when not being queried
    :type selectedAttr: boolean
    :param selectionConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its own selection list  As the user selects things in this
    e
    :type selectionConnection: string
    :param showShapes: (C Q E) If true, when transforms are selected their shapes will be
    displayed instead
    :type showShapes: boolean
    :param stateString: (Q) Query only flag  Returns the MEL command that will create an editor
    to match the current editor state  The returned command string uses the string va
    :type stateString: boolean
    :param unParent: (C E) Specifies that the editor should be removed from its layout  This
    cannot be used in query mode
    :type unParent: boolean
    :param unlockMainConnection: (C E) Unlocks the mainConnection, effectively restoring the
    original mainConnection (if it is still available), and dynamic updates
    :type unlockMainConnection: boolean
    :param updateMainConnection: (C E) Causes a locked mainConnection to be updated from the
    orginal mainConnection, but preserves the lock state
    :type updateMainConnection: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: The name of the editor
    :rtype: string
    """
    pass


def adskAssetLibrary(*args, **kwargs):
    """
    
    """
    pass


def dR_nexTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MarkingMenuPopDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AlembicExportAllOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowFluids(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def selectKey(*args, addTo=True, animation="keysOrObjects.", attribute="", clear=True,
              controlPoints=False, float=None, hierarchy="", inTangent=True,
              includeUpperBound=True, index=0, keyframe=True, outTangent=True, remove=True,
              replace=True, shape=True, time=None, toggle=True, unsnappedKeys=0.0, **kwargs):
    """
    This command operates on a keyset  A keyset is defined as a group of keys within a
    specified time range on one or more animation curves   The animation curves comprising a
    keyset depend on the value of the "-animation" flag:  keysOrObjects: Any active keys, when
    no target objects or -attribute flags appear on the command line, or All animation curv
    
    :param addTo: (C) Add to the current selection of keyframes/tangents
    :type addTo: boolean
    :param animation: (C) Where this command should get the animation to act on  Valid values
    are "objects," "keys," and "keysOrObjects" Default: "keysOrObjects." (See Descrip
    :type animation: string
    :param attribute: (C M) List of attributes to select In query mode, this flag needs a
    value
    :type attribute: string
    :param clear: (C) Remove all keyframes and tangents from the active list
    :type clear: boolean
    :param controlPoints: (C) This flag explicitly specifies whether or not to include the
    control points of a shape (see "-s" flag) in the list of attributes  Default: false  (No
    :type controlPoints: boolean
    :param float: (C M) value uniquely representing a non-time-based key (or key range) on a
    time-based animCurve  Valid floatRange include single values (-f 10) or a string
    :type float: floatrange
    :param hierarchy: (C) Hierarchy expansion options  Valid values are "above," "below," "both,
    " and "none." (Not valid for "pasteKey" cmd.) In query mode, this flag needs a
    :type hierarchy: string
    :param inTangent: (C) Select in-tangents of keyframes in the specified time range
    :type inTangent: boolean
    :param includeUpperBound: (C) When the -t/time or -f/float flags represent a range of keys,
    this flag determines whether the keys at the upper bound of the range are included in t
    :type includeUpperBound: boolean
    :param index: (C M) index of a key on an animCurve In query mode, this flag needs a value
    :type index: int
    :param keyframe: (C) select only keyframes (cannot be combined with -in/-out)
    :type keyframe: boolean
    :param outTangent: (C) Select out-tangents of keyframes in the specified time range
    :type outTangent: boolean
    :param remove: (C) Remove from the current selection of keyframes/tangents
    :type remove: boolean
    :param replace: (C) Replace the current selection of keyframes/tangents
    :type replace: boolean
    :param shape: (C) Consider attributes of shapes below transforms as well, except
    "controlPoints"  Default: true  (Not valid for "pasteKey" cmd.) In query mode, this fl
    :type shape: boolean
    :param time: (C M) time uniquely representing a key (or key range) on a time-based
    animCurve  See the code examples below on how to format for a single frame or frame r
    :type time: timerange
    :param toggle: (C) Toggle the picked state of the specified keyset
    :type toggle: boolean
    :param unsnappedKeys: (C) Select only keys that have times that are not a multiple of the
    specified numeric value
    :type unsnappedKeys: float
    
    :returns: The number of curves on which keys were
    selected (or deselcted).
    :rtype: int
    """
    pass


def displayPref(*args, activeObjectPivots=True, displayAffected=True, displayGradient=True,
                ghostFrames=None, materialLoadingMode="", maxHardwareTextureResolution=True,
                maxTextureResolution=0, purgeExistingTextures=True, regionOfEffect=True,
                shadeTemplates=True, textureDrawPixel=True, wireframeOnShadedActive="", q=True,
                query=True, **kwargs):
    """
    This command sets/queries the state of global display parameters
    
    :param activeObjectPivots: (C Q) Sets the display state for drawing pivots for active
    objects
    :type activeObjectPivots: boolean
    :param displayAffected: (C Q) Turns on/off the special coloring of objects that are
    affected by the objects that are currently in the selection list  If one of the curves in a
    lof
    :type displayAffected: boolean
    :param displayGradient: (C Q) Set whether to display the background using a colored
    gradient as opposed to a constant background color
    :type displayGradient: boolean
    :param ghostFrames: (C Q) Sets the ghosting frame preferences: steps before, steps after
    and step size
    :type ghostFrames: [int, int, int]
    :param materialLoadingMode: (C Q) Sets the material loading mode when loading the scene 
    Possible values for the string argument are "immediate", "deferred" and "parallel"
    :type materialLoadingMode: string
    :param maxHardwareTextureResolution: (Q) Query the maximum allowable hardware texture
    resolution available on the current video card  This maximum can vary between different
    video cards and
    :type maxHardwareTextureResolution: boolean
    :param maxTextureResolution: (C Q) Sets the maximum hardware texture resolution to be used
    when creating hardware textures for display  The maximum will be clamped to the maximum
    allow
    :type maxTextureResolution: int
    :param purgeExistingTextures: (C) Purge any existing hardware textures  This will force a
    re-evaluation of hardware textures used for display, and thus may take some time to
    evaluate
    :type purgeExistingTextures: boolean
    :param regionOfEffect: (C Q) Turns on/off the display of the region of curves/surfaces that
    is affected by changes to selected CVs and edit points
    :type regionOfEffect: boolean
    :param shadeTemplates: (C Q) Turns on/off the display of templated surfaces as shaded in
    shaded display mode  If its off, templated surfaces appear in wireframe
    :type shadeTemplates: boolean
    :param textureDrawPixel: (C Q) Sets the display mode for drawing image planes  True for use
    of gltexture calls for perspective views  This flag should not normally be needed  Image
    :type textureDrawPixel: boolean
    :param wireframeOnShadedActive: (C Q) Sets the display state for drawing the wireframe on
    active shaded objects  Possible values for the string argument are "full", "reduced" and
    "none"
    :type wireframeOnShadedActive: string
    
    :returns: 
    :rtype: None
    """
    pass


def fileDialog2(*args, buttonBoxOrientation=0, cancelCaption="", caption="", dialogStyle=0,
                fileFilter="", fileMode=0, fileTypeChanged=None, hideNameEdit=True,
                okCaption="", optionsUICancel=None, optionsUICommit=None, optionsUICommit2=None,
                optionsUICreate=None, optionsUIInit=None, returnFilter=True,
                selectFileFilter="", selectionChanged=None, setProjectBtnEnabled=True,
                startingDirectory="", **kwargs):
    """
    This command provides a dialog that allows users to select files or directories
    
    :param buttonBoxOrientation: (C) 1 Vertical button box layout  Cancel button is below the
    accept button  2 Horizontal button box layout  Cancel button is to the right of the accept
    b
    :type buttonBoxOrientation: int
    :param cancelCaption: (C) If the dialogStyle flag is set to 2 then this provides a caption
    for the Cancel button within the dialog
    :type cancelCaption: string
    :param caption: (C) Provide a title for the dialog
    :type caption: string
    :param dialogStyle: (C) 1 On Windows or Mac OS X will use a native style file dialog  2 Use
    a custom file dialog with a style that is consistent across platforms
    :type dialogStyle: int
    :param fileFilter: (C) Provide a list of file type filters to the dialog  Multiple filters
    should be separated by double semi-colons  See the examples section
    :type fileFilter: string
    :param fileMode: (C) Indicate what the dialog is to return  0 Any file, whether it exists
    or not  1 A single existing file  2 The name of a directory  Both directories an
    :type fileMode: int
    :param fileTypeChanged: (C) MEL only  The string is interpreted as a MEL callback, to be
    called when the user-selected file type changes  The callback is of the form: global pro
    :type fileTypeChanged: script
    :param hideNameEdit: (C) Hide name editing input field
    :type hideNameEdit: boolean
    :param okCaption: (C) If the dialogStyle flag is set to 2 then this provides a caption for
    the OK, or Accept, button within the dialog
    :type okCaption: string
    :param optionsUICancel: (C) MEL only  The string is interpreted as a MEL callback, to be
    called when the dialog is cancelled (with Cancel button or close button to close window)
    :type optionsUICancel: script
    :param optionsUICommit: (C) MEL only  The string is interpreted as a MEL callback, to be
    called when the dialog is successfully dismissed  It will not be called if the user canc
    :type optionsUICommit: script
    :param optionsUICommit2: (C) MEL only  As optionsUICommit, the given string is interpreted
    as a MEL callback, to be called when the dialog is successfully dismissed  The differen
    :type optionsUICommit2: script
    :param optionsUICreate: (C) MEL only  The string is interpreted as a MEL callback, to be
    called on creation of the file dialog  The callback is of the form: global proc MyCustom
    :type optionsUICreate: script
    :param optionsUIInit: (C) MEL only  The string is interpreted as a MEL callback, to be
    called just after file dialog creation, to initialize controls  The callback is of the f
    :type optionsUIInit: script
    :param returnFilter: (C) If true, the selected filter will be returned as the last item in
    the string array along with the selected files
    :type returnFilter: boolean
    :param selectFileFilter: (C) Specify the initial file filter to select  Specify just the
    begining text and not the full wildcard spec
    :type selectFileFilter: string
    :param selectionChanged: (C) MEL only  The string is interpreted as a MEL callback, to be
    called when the user changes the file selection in the file dialog  The callback is of t
    :type selectionChanged: script
    :param setProjectBtnEnabled: (C) Define whether the project button should be enabled
    :type setProjectBtnEnabled: boolean
    :param startingDirectory: (C) Provide the starting directory for the dialog
    :type startingDirectory: string
    
    :returns: array
    :rtype: string
    """
    pass


def SetToFaceNormalsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PaintRandomOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GraphPasteOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def license(*args, borrow=True, info=True, isBorrowed=True, isExported=True, isTrial=True,
            licenseMethod=True, productChoice=True, r=True, showBorrowInfo=True,
            showProductInfoDialog=True, status=True, usage=True, **kwargs):
    """
    This command displays version information about the application if it is executed without
    flags  If one of the above flags is specified then the specified version information is
    returned
    
    :param borrow: (C) This flag is obsolete and no longer supported
    :type borrow: boolean
    :param info: (C) This flag is obsolete and no longer supported
    :type info: boolean
    :param isBorrowed: (C) This flag is obsolete and no longer supported
    :type isBorrowed: boolean
    :param isExported: (C) This flag is obsolete and no longer supported
    :type isExported: boolean
    :param isTrial: (C) This flag is obsolete and no longer supported
    :type isTrial: boolean
    :param licenseMethod: (C) This flag is obsolete and no longer supported
    :type licenseMethod: boolean
    :param productChoice: (C) This flag is obsolete and no longer supported
    :type productChoice: boolean
    :param r: (C) This flag is obsolete and no longer supported
    :type r: boolean
    :param showBorrowInfo: (C) This flag is obsolete and no longer supported
    :type showBorrowInfo: boolean
    :param showProductInfoDialog: (C) Show the Product Information Dialog
    :type showProductInfoDialog: boolean
    :param status: (C) This flag is obsolete and no longer supported
    :type status: boolean
    :param usage: (C) This flag is obsolete and no longer supported
    :type usage: boolean
    
    :returns: The application's license information.
    :rtype: string
    """
    pass


def HypershadeDisplayAllShapes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddToCurrentSceneMudbox(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MirrorDeformerWeightsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddAnimationOffset(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolyExtrudeFacesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadePickWalkLeft(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TransferVertexOrder(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FreezeTransformations(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def skinCluster(*args, addInfluence="", addToSelection=True, after=True, afterReference=True,
                baseShape="", before=True, bindMethod=0, deformerTools=True, dropoffRate=0.0,
                exclusive="", forceNormalizeWeights=True, frontOfChain=True, geometry="",
                geometryIndices=True, heatmapFalloff=0.0, ignoreBindPose=True,
                ignoreHierarchy=True, ignoreSelected=True, includeHiddenSelections=False,
                influence="", lockWeights=True, maximumInfluences=0, moveJointsMode=True,
                name="", normalizeWeights=0, nurbsSamples=0, obeyMaxInfluences=True,
                parallel=True, polySmoothness=0.0, prune=True, recacheBindMatrices=True,
                remove=True, removeFromSelection=True, removeInfluence="",
                removeUnusedInfluence=True, selectInfluenceVerts="", skinMethod=1,
                smoothWeights=0.0, smoothWeightsMaxIterations=2, split=True,
                toSelectedBones=True, toSkeletonAndTransforms=True, unbind=True,
                unbindKeepHistory=True, useGeometry=True, volumeBind=0.0, volumeType=0,
                weight=0.0, weightDistribution=1, weightedInfluence=True, q=True, query=True,
                e=True, edit=True, **kwargs):
    """
    The skinCluster command is used for smooth skinning in maya  It binds the selected geometry
    to the selected joints or skeleton by means of a skinCluster node  Each point of the bound
    geometry can be affected by any number of joints  The extent to which each joint affects
    the motion of each point is regulated by a corresponding weight factor  Weight
    
    :param addInfluence: (E M) The specified transform or joint will be added to the list of
    transforms that influence the bound geometry  The maximum number of influences will be
    :type addInfluence: string
    :param addToSelection: (E) When used in conjunction with the selectInfluenceVerts flag,
    causes the vertices afftected by the influence to be added to the current selection, wit
    :type addToSelection: boolean
    :param after: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type after: boolean
    :param afterReference: (C E) The -afterReference flag is used to specify deformer ordering
    in a hybrid way that choses between -before and -after automatically  If the geometry b
    :type afterReference: boolean
    :param baseShape: (E M) This flag can be used in conjunction with the -addInfluence flag to
    specify the shape that will be used as the base shape when an influence object wi
    :type baseShape: string
    :param before: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type before: boolean
    :param bindMethod: (C Q) This flag sets the binding method  0 - Closest distance between a
    joint and a point of the geometry  1 - Closest distance between a joint, considerin
    :type bindMethod: int
    :param deformerTools: (Q) Returns the name of the deformer tool objects (if any) as string
    string ..
    :type deformerTools: boolean
    :param dropoffRate: (C Q E) Sets the rate at which the influence of a transform drops as
    the distance from that transform increases  The valid range is between 0.1 and 10.0  In
    :type dropoffRate: float
    :param exclusive: (C Q) Puts the deformation set in a deform partition
    :type exclusive: string
    :param forceNormalizeWeights: (E) If the normalization mode is none or post, it is possible
    (indeed likely) for the weights in the skin cluster to no longer add up to 1  This flag
    for
    :type forceNormalizeWeights: boolean
    :param frontOfChain: (C E) This command is used to specify that the new deformer node
    should be placed ahead (upstream) of existing deformer and skin nodes in the shape's histo
    :type frontOfChain: boolean
    :param geometry: (Q E M) The specified object will be added to the list of objects being
    deformed by this deformer object, unless the -rm flag is also specified  When queried
    :type geometry: string
    :param geometryIndices: (Q) Complements the -geometry flag in query mode  Returns the multi
    index of each geometry
    :type geometryIndices: boolean
    :param heatmapFalloff: (C) This flag sets the heatmap binding falloff  If set to 0.0
    (default) the deformation will be smoother due to many small weights spread over the mesh
    s
    :type heatmapFalloff: float
    :param ignoreBindPose: (C E) This flag is deprecated and no longer used  It will be ignored
    if used
    :type ignoreBindPose: boolean
    :param ignoreHierarchy: (C Q) Deprecated  Use bindMethod flag instead  Disregard the place
    of the joints in the skeleton hierarchy when computing the closest joints that influence
    :type ignoreHierarchy: boolean
    :param ignoreSelected: (C) Tells the command to not deform objects on the current selection
    list
    :type ignoreSelected: boolean
    :param includeHiddenSelections: (C) Apply the deformer to any visible and hidden objects in
    the selection list  Default is false
    :type includeHiddenSelections: boolean
    :param influence: (Q E) This flag specifies the influence object that will be used for the
    current edit operation  In query mode, returns a string array of the influence obj
    :type influence: string
    :param lockWeights: (Q E) Lock the weights of the specified influence object to their
    current value or to the value specified by the -weight flag
    :type lockWeights: boolean
    :param maximumInfluences: (C Q E) Sets the maximum number of transforms that can influence
    a point (have non-zero weight for the point) when the skinCluster is first created or a
    new
    :type maximumInfluences: int
    :param moveJointsMode: (E) If set to true, puts the skin into a mode where joints can be
    moved without modifying the skinning  If set to false, takes the skin out of move joint
    :type moveJointsMode: boolean
    :param name: (C) Used to specify the name of the node being created
    :type name: string
    :param normalizeWeights: (C Q E) This flag sets the normalization mode  0 - none, 1 -
    interactive, 2 - post (default) Interactive normalization makes sure the weights on the
    influenc
    :type normalizeWeights: int
    :param nurbsSamples: (C E) Sets the number of sample points that will be used along an
    influence curve or in each direction on an influence NURBS surface to influence the bound
    :type nurbsSamples: int
    :param obeyMaxInfluences: (C Q E) When true, the skinCluster will continue to enforce the
    maximum influences each time the user modifies the weight, so that any given point is only
    we
    :type obeyMaxInfluences: boolean
    :param parallel: (C E) Inserts the new deformer in a parallel chain to any existing
    deformers in the history of the object  A blendShape is inserted to blend the parallel r
    :type parallel: boolean
    :param polySmoothness: (C E) This flag controls how accurately the skin control points
    follow a given polygon influence object  The higher the value of polySmoothnmess the more
    r
    :type polySmoothness: float
    :param prune: (E) Removes any points not being deformed by the deformer in its current
    configuration from the deformer set
    :type prune: boolean
    :param recacheBindMatrices: (E) Forces the skinCluster node to recache its bind matrices
    :type recacheBindMatrices: boolean
    :param remove: (E M) Specifies that objects listed after the -g flag should be removed from
    this deformer
    :type remove: boolean
    :param removeFromSelection: (E) When used in conjunction with the selectInfluenceVerts flag,
    causes the vertices afftected by the influence to be removed from the current selection
    :type removeFromSelection: boolean
    :param removeInfluence: (E M) Remove the specified transform or joint from the list of
    transforms that influence the bound geometry The weights for the affected points are
    renorma
    :type removeInfluence: string
    :param removeUnusedInfluence: (C) If this flag is set to true then transform or joint whose
    weights are all zero (they have no effect) will not be bound to the geometry  Having this
    o
    :type removeUnusedInfluence: boolean
    :param selectInfluenceVerts: (E) Given the name of a transform, this will select the verts
    or control points being influenced by this transform, so users may visualize which
    vertices
    :type selectInfluenceVerts: string
    :param skinMethod: (C Q E) This flag set the skinning method  0 - classical linear skinning
    (default)  1 - dual quaternion (volume preserving), 2 - a weighted blend between the
    :type skinMethod: int
    :param smoothWeights: (E) This flag is used to detect sudden jumps in skin weight values,
    which often indicates bad weighting, and then smooth out those jaggies in skin weight
    :type smoothWeights: float
    :param smoothWeightsMaxIterations: (E) This flag is valid only with the smooth weights flag
     It is possible that not all the vertices detected as needing smoothing can be smoothed in
    1 ite
    :type smoothWeightsMaxIterations: int
    :param split: (C E) Branches off a new chain in the dependency graph instead of
    inserting/appending the deformer into/onto an existing chain  Works in create mode (and e
    :type split: boolean
    :param toSelectedBones: (C) geometry will be bound to the selected bones only
    :type toSelectedBones: boolean
    :param toSkeletonAndTransforms: (C) geometry will be bound to the skeleton and any
    transforms in the hierarchy  If any of the transforms are also bindable objects, assume
    that only the
    :type toSkeletonAndTransforms: boolean
    :param unbind: (E) Unbinds the geometry from the skinCluster and deletes the skinCluster
    node
    :type unbind: boolean
    :param unbindKeepHistory: (E) Unbinds the geometry from the skinCluster, but keeps the
    skinCluster node so that its weights can be used when the skin is rebound  To rebind, use
    th
    :type unbindKeepHistory: boolean
    :param useGeometry: (E) When adding an influence to a skinCluster, use the geometry
    parented under the influence transform to determine the weight dropoff of that influence
    :type useGeometry: boolean
    :param volumeBind: (C) Creates a volume bind node and attaches it to the new skin cluster
    node  This node holds hull geometry parameters for a volume based weighting system
    :type volumeBind: float
    :param volumeType: (C) Defines the initial shape of the binding volume (see volumeBind)  0
    - Default (currently set to a capsule) 1 - Capsule, 2 - Cylinder
    :type volumeType: int
    :param weight: (E) This flag is only valid in conjunction with the -addInfluence flag  It
    sets the weight for the influence object that is being added
    :type weight: float
    :param weightDistribution: (C Q E) This flag sets the weight distribution mode  0 -
    distance (default), 1 - neighbors When normalizeWeights is in effect, and a weight has been
    reduced
    :type weightDistribution: int
    :param weightedInfluence: (Q) This flag returns a string array of the influence objects
    (joints and transform) that have non-zero weighting
    :type weightedInfluence: boolean
    
    :returns: (the skinCluster node name)
    :rtype: string
    """
    pass


def NodeEditorGraphRemoveDownstream(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SeparatePolygon(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def walkCtx(*args, alternateContext=True, crouchCount=0.0, exists=True, history=True, image1="",
            image2="", image3="", name="", toolName="", walkHeight=0.0, walkSensitivity=0.0,
            walkSpeed=0.0, walkToolHud=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command can be used to create, edit, or query a walk context
    
    :param alternateContext: (C Q) Set the ALT+MMB and ALT+SHIFT+MMB to refer to this context
    :type alternateContext: boolean
    :param crouchCount: (C Q E) The camera crouch count
    :type crouchCount: float
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param toolName: (C Q) Name of the specific tool to which this command refers
    :type toolName: string
    :param walkHeight: (C Q E) The camera initial height
    :type walkHeight: float
    :param walkSensitivity: (C Q E) The camera rotate sensitivity
    :type walkSensitivity: float
    :param walkSpeed: (C Q E) The camera move speed
    :type walkSpeed: float
    :param walkToolHud: (C Q E) Control whether show walk tool HUD
    :type walkToolHud: boolean
    
    :returns: The name of the context
    :rtype: string
    """
    pass


def FBXExportGenerateLog(*args, **kwargs):
    """
    
    """
    pass


def showMetadata(*args, auto=True, dataType="", interpolation=True, isActivated=True,
                 listAllStreams=True, listMembers=True, listValidMethods=True,
                 listVisibleStreams=True, member="", method="", range=None, rayScale=0.0,
                 stream="", q=True, query=True, **kwargs):
    """
    This command is used to show metadata values which is in the specified channels "vertex",
    "edge", "face", and "vertexFace" in the viewport  You can view the data by three ways: 
    "color": draw color on the components  "ray": draw a ray on the components  "string": draw
    2d strings on the components   For example, if the metadata of "shape.vtx[1]" is 
    
    :param auto: (C Q) Similar to the flag "-range", but uses the min/max value from the
    metadata in the same stream and member instead of the specified input value  In que
    :type auto: boolean
    :param dataType: (C Q) In create mode, when used with the flags "stream" and "member",
    specify a member to show  If the flag "off" is used, specify the member to turn off
    :type dataType: string
    :param interpolation: (C Q) In create mode, enable/disable interpolation for "color" method
     When interpolation is on, the components will be displayed in the interpolated color
    :type interpolation: boolean
    :param isActivated: (C Q) Used to check if the given stream is activated  If some shapes
    are selected, query their states  If no shape is selected, query the states of all sha
    :type isActivated: boolean
    :param listAllStreams: (C Q) Used with object names to list all streams of the specified
    objects  no matter if they are visible in the viewport  Or you can use the flag individua
    :type listAllStreams: boolean
    :param listMembers: (C Q) Used with the flag 'stream' to get the member list in the
    specified stream
    :type listMembers: boolean
    :param listValidMethods: (C Q) List the valid visual methods that can be set for the
    current stream and member  Some data type cannot be displayed by some methods  For example,
    if
    :type listValidMethods: boolean
    :param listVisibleStreams: (C Q) Used with object names to list the name of the current
    visible streams of the specified object  Or you can use the flag with no object name to
    list a
    :type listVisibleStreams: boolean
    :param member: (C Q) In create mode, when used with the flags "stream" and "dataType",
    specify a member to show  If the flag "off" is on, specify the member to turn off
    :type member: string
    :param method: (C Q) Determine the method of visualization: "color" convert metadata to a
    color value and draw the components with the color "ray" convert metadata to a v
    :type method: string
    :param range: (C Q) Specify the range of data to use  The value which is out of the range
    will be clamped to the min/max value  If the method of visualization is "color"
    :type range: [float, float]
    :param rayScale: (C Q) Specify the scale of the ray to display it with a proper length
    :type rayScale: float
    :param stream: (C Q) In create mode, when used with the flags "member" and "dataType",
    specify a member to show  If the flag "off" is used, specify the member to turn off
    :type stream: string
    
    :returns: result of the operation or the queried status
    :rtype: string
    """
    pass


def hardware(*args, brdType=True, cpuType=True, graphicsType=True, megaHertz=True,
             numProcessors=True, **kwargs):
    """
    Return description of the hardware available in the machine
    
    :param brdType: (C) Returns IP number identifying the CPU motherboard
    :type brdType: boolean
    :param cpuType: (C) Returns type of CPU
    :type cpuType: boolean
    :param graphicsType: (C) Returns string identifying graphics hardware type
    :type graphicsType: boolean
    :param megaHertz: (C) Returns string identifying the speed of the CPU chip
    :type megaHertz: boolean
    :param numProcessors: (C) Returns string identifying the number of processors
    :type numProcessors: boolean
    
    :returns: Command result
    :rtype: string
    """
    pass


def SmoothSkinWeights(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def displayLevelOfDetail(*args, levelOfDetail=True, q=True, query=True, **kwargs):
    """
    This command is responsible for setting the display level-of-detail for edit refreshes  If
    enabled, objects will draw with lower detail based on their distance from the camera  When
    disabled objects will display at full resolution at all times  This is not an undoable
    command
    
    :param levelOfDetail: () Enable/disable level of detail
    :type levelOfDetail: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def IPROptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def LayoutUVAlong(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeReduceTraversalDepth(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeRenderTextureRange(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ArchiveScene(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def movieCompressor(*args, **kwargs):
    """
    
    """
    pass


def cMuscleWeight(*args, **kwargs):
    """
    
    """
    pass


def dR_modeVert(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PruneWire(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def cacheFileTrack(*args, insertTrack=0, lock=True, mute=True, removeEmptyTracks=True,
                   removeTrack=0, solo=True, track=0, q=True, query=True, e=True, edit=True,
                   **kwargs):
    """
    This command is used for inserting and removing tracks related to the caches displayed in
    the trax editor  It can also be used to modify the track state, for example, to lock or
    mute a track
    
    :param insertTrack: (C) This flag is used to insert a new empty track at the track index
    specified
    :type insertTrack: int
    :param lock: (C Q E) This flag specifies whether clips on a track are to be locked or not
    :type lock: boolean
    :param mute: (C Q E) This flag specifies whether clips on a track are to be muted or not
    :type mute: boolean
    :param removeEmptyTracks: (C) This flag is used to remove all tracks that have no clips
    :type removeEmptyTracks: boolean
    :param removeTrack: (C) This flag is used to remove the track with the specified index  The
    track must have no clips on it before it can be removed
    :type removeTrack: int
    :param solo: (C Q E) This flag specifies whether clips on a track are to be soloed or not
    :type solo: boolean
    :param track: (C Q E) Used to specify a new track index for a cache to be displayed 
    Track-indices are 1-based
    :type track: int
    
    :returns: 
    :rtype: None
    """
    pass


def xgmSmoothBrushContext(*args, **kwargs):
    """
    
    """
    pass


def dR_testCmd(*args, **kwargs):
    """
    
    """
    pass


def NEmitFromObjectOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmCutBrushContext(*args, **kwargs):
    """
    
    """
    pass


def MakeShadowLinks(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FloatSelectedPondObjectsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def insertKnotCurve(*args, addKnots=True, caching=True, insertBetween=False, nodeState=0,
                    numberOfKnots=1, parameter=0.0, constructionHistory=True,
                    curveOnSurface=True, name="", object=True, replaceOriginal=True, q=True,
                    query=True, e=True, edit=True, **kwargs):
    """
    The insertKnotCurve command inserts knots into a curve given a list of parameter values 
    The number of knots to add at each parameter value and whether the knots are added or
    complemented can be specified  The name of the curve is returned  If construction history
    is on, the name of the resulting dependency node is also returned   An edit point wil
    
    :param addKnots: (C Q E) Whether to add knots or complement  Complement means knots will be
    added to reach the specified number of knots  Default: true
    :type addKnots: boolean
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param insertBetween: (C Q E) If set to true, and there is more than one parameter value
    specified, the knots will get inserted at equally spaced intervals between the given param
    :type insertBetween: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param numberOfKnots: (C Q E M) How many knots to insert  At any point on the curve, there
    can be a maximum of "degree" knots  Default: 1
    :type numberOfKnots: int
    :param parameter: (C Q E M) Parameter value(s) where knots are added Default: 0.0
    :type parameter: float
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param curveOnSurface: (C) If possible, create 2D curve as a result
    :type curveOnSurface: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def PolygonSoftenEdge(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OutlinerCollapseAllSelectedItems(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideUnselectedCVs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def WireToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateGhostOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def listAttrPatterns(*args, patternType=True, verbose=True, **kwargs):
    """
    Attribute patterns are plain text descriptions of an entire Maya attribute forest 
    ("forest" because there could be an arbitrary number of root level attributes, it's not
    restricted to having a single common parent though in general that practice is a good
    idea.) This command lists the various pattern types available, usually created via plugin,
    as
    
    :param patternType: (C) If turned on then show the list of pattern types rather than actual
    instantiated patterns
    :type patternType: boolean
    :param verbose: (C) If turned on then show detailed information about the patterns or
    pattern types  The same list of instance or pattern names is returned as for the no
    :type verbose: boolean
    
    :returns: List of patterns or pattern instances available
    :rtype: string[]
    """
    pass


def cmdFileOutput(*args, close=0, closeAll=True, open="", status=0, q=True, query=True,
                  **kwargs):
    """
    This command will open a text file to receive all of the commands and results that normally
    get printed to the Script Editor window or console  The file will stay open until an
    explicit -close with the correct file descriptor or a -closeAll, so care should be taken
    not to leave a file open   To enable logging to commence as soon as Maya starts up, 
    
    :param close: (C) Closes the file corresponding to the given descriptor  If -3 is returned,
    the file did not exist  -1 is returned on error, 0 is returned on successfu
    :type close: int
    :param closeAll: (C) Closes all open files
    :type closeAll: boolean
    :param open: (C Q) Opens the given file for writing (will overwrite if it exists and is
    writable)  If successful, a value is returned to enable status queries and file
    :type open: string
    :param status: (C Q) Queries the status of the given descriptor  -3 is returned if no such
    file exists, -2 indicates the file is not open, -1 indicates an error condition
    :type status: int
    
    :returns: : On open, returns a value (descriptor) that can be used to query
    the status or
    close the file. Otherwise, a status code
    indicating status of file
    :rtype: int
    """
    pass


def GraphEditorNeverDisplayTangents(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UntrimSurfaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RemoveBlendShapeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_coordSpaceCustom(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreatePolygonCube(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UVUnstackShells(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nexMultiCutContext(*args, **kwargs):
    """
    
    """
    pass


def connectAttr(*args, force=True, lock=True, nextAvailable=True, referenceDest="", **kwargs):
    """
    Connect the attributes of two dependency nodes and return the names of the two connected
    attributes  The connected attributes must be be of compatible types  First argument is the
    source attribute, second one is the destination   Refer to dependency node documentation
    
    :param force: (C) Forces the connection  If the destination is already connected, the old
    connection is broken and the new one made
    :type force: boolean
    :param lock: (C) If the argument is true, the destination attribute is locked after making
    the connection  If the argument is false, the connection is unlocked before
    :type lock: boolean
    :param nextAvailable: (C) If the destination multi-attribute has set the indexMatters to be
    false with this flag specified, a connection is made to the next available index  N
    :type nextAvailable: boolean
    :param referenceDest: (C) This flag is used for file io only  The flag indicates that the
    connection replaces a connection made in a referenced file, and the flag argument ind
    :type referenceDest: string
    
    :returns: A phrase containing the names of the connected attributes.
    :rtype: string
    """
    pass


def treeLister(*args, addFavorite="", addItem=None, addVnnItem=None, annotation="",
               backgroundColor=None, clearContents=True, collapsePath="", defineTemplate="",
               docTag="", dragCallback=None, dropCallback=None, enable=True,
               enableBackground=True, enableKeyboardFocus=True, executeItem="", exists=True,
               expandPath="", expandToDepth=0, favoritesCallback=None, favoritesList=True,
               fullPathName=True, height=0, highlightColor=None, isObscured=True, itemScript="",
               manage=True, noBackground=True, numberOfPopupMenus=True, parent="",
               popupMenuArray=True, preventOverride=True, refreshCommand=None,
               removeFavorite="", removeItem="", resultsPathUnderCursor=True, selectPath="",
               statusBarMessage="", useTemplate="", visible=True, visibleChangeCommand=None,
               vnnString=True, width=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates/edits/queries the tree lister control  The optional argument is the
    name of the control
    
    :param addFavorite: (C E M) Add an item path to the favorites folder  The item path does
    not have to actually be in the tree
    :type addFavorite: string
    :param addItem: (C E M) Add an item to the control  The arguments are item-path,icon path,
    command where item-path is the path from the root of the tree to the item's name ic
    :type addItem: [string, string, script]
    :param addVnnItem: (C E M) Add a VNN (Virtual Node Network) item to the control  The
    arguments are: item-path, icon-path, vnn-string, vnn-action  Where item-path is the path
    fr
    :type addVnnItem: [string, string, string, string]
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param clearContents: (E) Clears the contents of the control
    :type clearContents: boolean
    :param collapsePath: (E M) Collapse a path in the tree
    :type collapsePath: string
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param executeItem: (E) Execute the command associated with an item
    :type executeItem: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param expandPath: (E M) Expand a path in the tree
    :type expandPath: string
    :param expandToDepth: (E) Expand the tree to the given depth
    :type expandToDepth: int
    :param favoritesCallback: (C E) This script is called whenever a favorite is added or
    removed  It is passed two arguments: The item's path and a boolean indicating if it is
    being ad
    :type favoritesCallback: script
    :param favoritesList: (Q) Returns the list of favorite items
    :type favoritesList: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param itemScript: (Q) Returns the language and script command of the passed item path as a
    two-element list, the first element is the string "MEL" or "Python" and the seco
    :type itemScript: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param refreshCommand: (C Q E) Command executed when the refresh button is pressed  Note:
    by default the refresh button is hidden and will be shown automatically when this command
    :type refreshCommand: script
    :param removeFavorite: (E M) Remove an item from favorites  Accepts the full favorite path
    or the tail of the full path
    :type removeFavorite: string
    :param removeItem: (E M) Remove an item path
    :type removeItem: string
    :param resultsPathUnderCursor: (Q) Returns the path to the result (right-pane) item under
    the mouse cursor  Returns an empty string if there is no such item
    :type resultsPathUnderCursor: boolean
    :param selectPath: (E M) Select a path in the tree
    :type selectPath: string
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param vnnString: (Q) Returns the VNN (Virtual Node Network) string of the passed item
    path
    :type vnnString: boolean
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the created control.
    :rtype: string
    """
    pass


def timer(*args, endTimer=True, lapTime=True, name="", startTimer=True, **kwargs):
    """
    Allow simple timing of scripts and commands  The resolution of this timer is at the level
    of your OS's gettimeofday() function   Note:This command does not handle stacked calls  For
    example, this code below will give an incorrect answer on the second timer -e call  timer
    -s; timer -s; timer -e; timer -e;  To do this use named timers: timer -s; time
    
    :param endTimer: (C) Stop the timer and return the time elapsed since the timer was started
    (in seconds)  Once a timer is turned off it no longer exists, though it can be
    :type endTimer: boolean
    :param lapTime: (C) Get the lap time of the timer (time elapsed since start in seconds) 
    Unlike the end flag this keeps the timer running
    :type lapTime: boolean
    :param name: (C) Use a named timer for the operation  If this is omitted then the default
    timer is assumed
    :type name: string
    :param startTimer: (C) Start the timer
    :type startTimer: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def SplitEdgeRingToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_loadRecentFile2(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def getInputDeviceRange(*args, maxValue=True, minValue=True, **kwargs):
    """
    This command lists the minimum and maximum values the device axis can return  This value is
    the raw device values before any mapping is applied  If you don't specify an axis the
    values for all axes of the device are returned
    
    :param maxValue: (C) list only the maximum value of the axis
    :type maxValue: boolean
    :param minValue: (C) list only the minimum value of the axis
    :type minValue: boolean
    
    :returns: Command result
    :rtype: float[]
    """
    pass


def createNurbsCubeCtx(*args, **kwargs):
    """
    
    """
    pass


def glRender(*args, accumBufferPasses=0, alphaSource="", antiAliasMethod="", cameraIcons=True,
             clearClr=None, collisionIcons=True, crossingEffect=True, currentFrame=True,
             drawStyle="", edgeSmoothness=0.0, emitterIcons=True, fieldIcons=True,
             flipbookCallback="", frameEnd=0, frameIncrement=0, frameStart=0,
             fullResolution=True, grid=True, imageDirectory="", imageName="", imageSize=None,
             lightIcons=True, lightingMode="", lineSmoothing=True, offScreen=True,
             renderFrame="", renderSequence="", sharpness=0.0, shutterAngle=0.0,
             textureDisplay=True, transformIcons=True, useAccumBuffer=True, viewport=None,
             writeDepthMap=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command provides access to the Hardware Render Manager (HRM)  There is
    one-and-only-one HRM in maya  The HRM controls the rendering performed in the hardware
    render buffer window  This command allows shell scripts, to modify the render state, and to
    initiate a render request
    
    :param accumBufferPasses: (Q E) Set the number of accum buffer render passes
    :type accumBufferPasses: int
    :param alphaSource: (Q E) Control the alpha source when writing image files  Valid values
    include: off, alpha, red, green, blue, luminance, clamp, invClamp
    :type alphaSource: string
    :param antiAliasMethod: (Q E) Set the method used for anti-aliasing polygons: off, uniform,
    gaussian
    :type antiAliasMethod: string
    :param cameraIcons: (Q E) Set display status of camera icons
    :type cameraIcons: boolean
    :param clearClr: (Q E) Set the viewport clear color (0 - 1)
    :type clearClr: [float, float, float]
    :param collisionIcons: (Q E) Set display status of collison model icons
    :type collisionIcons: boolean
    :param crossingEffect: (Q E) Enable/disable image filtering with a convolution filter
    :type crossingEffect: boolean
    :param currentFrame: (Q) Returns the current frame being rendered
    :type currentFrame: boolean
    :param drawStyle: (Q E) Set the object drawing style: boundingBox, points, wireframe,
    flatShaded, smoothShaded
    :type drawStyle: string
    :param edgeSmoothness: (Q E) Controls the amount of edge smoothing  A value of 0.0 gives no
    smoothing, 1.0 gives default smoothing, and any other value scales the amount of defau
    :type edgeSmoothness: float
    :param emitterIcons: (Q E) Set display status of emitter icons
    :type emitterIcons: boolean
    :param fieldIcons: (Q E) Set display status of field icons
    :type fieldIcons: boolean
    :param flipbookCallback: (Q E) Register a procedure to be called after the render sequence
    has completed  Used to build the flipbook pulldown menu  See the example section for more
    :type flipbookCallback: string
    :param frameEnd: (Q E) Set the last frame to be rendered
    :type frameEnd: int
    :param frameIncrement: (Q E) Set the frame increment during rendering
    :type frameIncrement: int
    :param frameStart: (Q E) Set the first frame to be rendered
    :type frameStart: int
    :param fullResolution: (Q E) Enable/disable rendering to full image output resolution  Must
    set a valid image output resolution (-is)
    :type fullResolution: boolean
    :param grid: (Q E) Set display status of the grid
    :type grid: boolean
    :param imageDirectory: (Q E) Set the directory for the image files
    :type imageDirectory: string
    :param imageName: (Q E) Set the base name of the image files
    :type imageName: string
    :param imageSize: (Q E) Set the image output size  Takes width, height and aspect ratio 
    Pass 0,0,0 to use current port size  The image size must be equal to or greater then
    :type imageSize: [int, int, float]
    :param lightIcons: (Q E) Set display status of light icons
    :type lightIcons: boolean
    :param lightingMode: (Q E) Set the lighting mode used for rendering: all, selected,
    default
    :type lightingMode: string
    :param lineSmoothing: (Q E) Enable/disable anti-aliased lines
    :type lineSmoothing: boolean
    :param offScreen: (Q E) When set, this toggle allow HRM to use an offscreen buffer to
    render the view  This allows HRM to work when the application is iconified, or obscured
    :type offScreen: boolean
    :param renderFrame: (Q E) Render the current frame  Requires the name of the view in which
    to render
    :type renderFrame: string
    :param renderSequence: (Q E) Render the current frame sequence  Requires the name of the
    view in which to render
    :type renderSequence: string
    :param sharpness: (Q E) Control the sharpness level of the convolution filter
    :type sharpness: float
    :param shutterAngle: (Q E) Set the shutter angle used for motion blur (0 - 1)  A value of
    0.0 gives no blurring, 0.5 gives correct blurring, and 1.0 gives continuous blurring
    :type shutterAngle: float
    :param textureDisplay: (Q E) Enable/disable texture map display
    :type textureDisplay: boolean
    :param transformIcons: (Q E) Set display status of transform icons
    :type transformIcons: boolean
    :param useAccumBuffer: (Q E) Enable/disable the accumulation buffer
    :type useAccumBuffer: boolean
    :param viewport: (Q E) Set the viewport size  Pass in the width, height and aspect ratio 
    This size will be used for all test rendering and image output size unless full re
    :type viewport: [int, int, float]
    :param writeDepthMap: (Q E) Enable/disable writing of zdepth to image files
    :type writeDepthMap: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def bakeSimulation(*args, animation="keysOrObjects.", attribute="", bakeOnOverrideLayer=True,
                   controlPoints=False, destinationLayer="", disableImplicitControl=True,
                   float=None, hierarchy="", includeUpperBound=True, index=0,
                   minimizeRotation=True, preserveOutsideKeys=False,
                   removeBakedAnimFromLayer=True, removeBakedAttributeFromLayer=True,
                   resolveWithoutLayer="", sampleBy=None, shape=True, simulation=True,
                   smart=None, sparseAnimCurveBake=False, time=None, q=True, query=True, e=True,
                   edit=True, **kwargs):
    """
    This command operates on a keyset  A keyset is defined as a group of keys within a
    specified time range on one or more animation curves   The animation curves comprising a
    keyset depend on the value of the "-animation" flag:  keysOrObjects: Any active keys, when
    no target objects or -attribute flags appear on the command line, or All animation curv
    
    :param animation: (C) Where this command should get the animation to act on  Valid values
    are "objects," "keys," and "keysOrObjects" Default: "keysOrObjects." (See Descrip
    :type animation: string
    :param attribute: (C M) List of attributes to select In query mode, this flag needs a
    value
    :type attribute: string
    :param bakeOnOverrideLayer: (C) If true, all layered and baked attributes will be added as
    a top override layer
    :type bakeOnOverrideLayer: boolean
    :param controlPoints: (C) This flag explicitly specifies whether or not to include the
    control points of a shape (see "-s" flag) in the list of attributes  Default: false  (No
    :type controlPoints: boolean
    :param destinationLayer: (C) This flag can be used to specify an existing layer where the
    baked results should be stored
    :type destinationLayer: string
    :param disableImplicitControl: (C) Whether to disable implicit control after the anim
    curves are obtained as the result of this command  An implicit control to an attribute is
    some fun
    :type disableImplicitControl: boolean
    :param float: (C M) value uniquely representing a non-time-based key (or key range) on a
    time-based animCurve  Valid floatRange include single values (-f 10) or a string
    :type float: floatrange
    :param hierarchy: (C) Hierarchy expansion options  Valid values are "above," "below," "both,
    " and "none." (Not valid for "pasteKey" cmd.) In query mode, this flag needs a
    :type hierarchy: string
    :param includeUpperBound: (C) When the -t/time or -f/float flags represent a range of keys,
    this flag determines whether the keys at the upper bound of the range are included in t
    :type includeUpperBound: boolean
    :param index: (C M) index of a key on an animCurve In query mode, this flag needs a value
    :type index: int
    :param minimizeRotation: (C) Specify whether to minimize the local euler component from key
    to key during baking of rotation channels
    :type minimizeRotation: boolean
    :param preserveOutsideKeys: (C) Whether to preserve keys that are outside the bake range
    when there are directly connected animation curves  The default (false) is to remove
    frames
    :type preserveOutsideKeys: boolean
    :param removeBakedAnimFromLayer: (C) If true, all baked animation will be removed from the
    layer
    :type removeBakedAnimFromLayer: boolean
    :param removeBakedAttributeFromLayer: (C) If true, all baked attributes will be removed
    from the layer
    :type removeBakedAttributeFromLayer: boolean
    :param resolveWithoutLayer: (C M) This flag can be used to specify a list of layers to be
    merged together during the bake process  This is a multi-use flag  Its name refers to the
    fac
    :type resolveWithoutLayer: string
    :param sampleBy: (C) Amount to sample by  Default is 1.0 in current timeUnit
    :type sampleBy: time
    :param shape: (C) Consider attributes of shapes below transforms as well, except
    "controlPoints"  Default: true  (Not valid for "pasteKey" cmd.) In query mode, this fl
    :type shape: boolean
    :param simulation: (C) Using this flag instructs the command to preform a simulation
    instead of just evaluating each attribute separately over the range of time  The simula
    :type simulation: boolean
    :param smart: (C) Specify whether to enable smart bake and the optional smart bake
    tolerance
    :type smart: [[, boolean, float, ]]
    :param sparseAnimCurveBake: (C) When baking anim curves, do not insert any keys into areas
    of the curve where animation is defined  And, use as few keys as possible to bake the pre
    :type sparseAnimCurveBake: boolean
    :param time: (C M) time uniquely representing a key (or key range) on a time-based
    animCurve  See the code examples below on how to format for a single frame or frame r
    :type time: timerange
    
    :returns: 
    :rtype: None
    """
    pass


def dR_selectInvert(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def prependListItem(*args, **kwargs):
    """
    
    """
    pass


def cameraSet(*args, active=True, appendTo=True, camera="", clearDepth=True, deleteAll=True,
              deleteLayer=True, insertAt=True, layer=0, name="", numLayers=True, objectSet="",
              order=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command manages camera set nodes  Camera sets allow the users to break a single camera
    shot into layers  Instead of drawing all objects with a single camera, you can isolate the
    camera to only focus on certain objects and layer another camera into the viewport that
    draws the other objects  The situation to use camera sets primarily occurs when
    
    :param active: (C Q E) Gets / sets the active camera layer
    :type active: boolean
    :param appendTo: (C E) Append a new camera and/or object set to then end of the cameraSet
    layer list  This flag cannot be used in conjunction with insert flag  Additionally
    :type appendTo: boolean
    :param camera: (C Q E) Set/get the camera for a particular layer  When in query mode, You
    must specify the layer with the layer flag
    :type camera: string
    :param clearDepth: (C Q E) Specifies if the drawing buffer should be cleared before
    beginning the draw for that layer
    :type clearDepth: boolean
    :param deleteAll: (C E) Delete all camera layers
    :type deleteAll: boolean
    :param deleteLayer: (C E) Delete a layer from the camera set  You must specify the layer
    using the layer flag
    :type deleteLayer: boolean
    :param insertAt: (C E) Inserts the specified camera and/or object set at the specified
    layer  This flag cannot be used in conjunction with the append flag  Additionally, th
    :type insertAt: boolean
    :param layer: (C Q E) Specifies the layer index to be used when accessing layer
    information
    :type layer: int
    :param name: (C Q) Gets or sets the name for the created camera set
    :type name: string
    :param numLayers: (C Q) Returns the number of layers defined in the specified cameraSet
    :type numLayers: boolean
    :param objectSet: (C Q E) Set/get the objectSet for a particular layer  When in query mode,
    you must specify the layer with the layer flag
    :type objectSet: string
    :param order: (C Q E) Set the order in which a particular layer is processed  This flag
    must be used in conjunction with the layer flag
    :type order: int
    
    :returns: The new cameraSet node (when in create mode)
    :rtype: string
    """
    pass


def EditOversamplingForCacheSettings(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def unapplyOverride(*args, **kwargs):
    """
    
    """
    pass


def EnableRigidBodies(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def pickWalk(*args, direction="", recurse=True, type="", **kwargs):
    """
    The pickWalk command allows you to quickly change the selection list relative to the nodes
    that are currently selected  It is called pickWalk, because it walks from one selection
    list to another by unselecting what's currently selected, and selecting nodes that are in
    the specified direction from the currently selected list  If you specify objects 
    
    :param direction: (C) The direction to walk from the node  The choices are up | down | left
    | right | in | out  up walks to the parent node, down to the child node, and le
    :type direction: string
    :param recurse: (C) If specified then recurse down when walking
    :type recurse: boolean
    :param type: (C) The choices are nodes | instances | edgeloop | edgering | faceloop | keys
    | latticepoints | motiontrailpoints  If type is nodes, then the left and ri
    :type type: string
    
    :returns: A list of the newly selected items
    :rtype: string[]
    """
    pass


def HypershadeMoveTabRight(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BakeAllNonDefHistory(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polySuperCtx(*args, **kwargs):
    """
    
    """
    pass


def SetBreakdownKey(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_softSelDistanceTypeObject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportFinestSubdivLevel(*args, **kwargs):
    """
    
    """
    pass


def ShowDeformingGeometry(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ScaleToolMarkingMenuPopDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportBakeComplexStart(*args, **kwargs):
    """
    
    """
    pass


def PrevSkinPaintMode(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def deformer(*args, after=True, afterReference=True, before=True, deformerTools=True,
             exclusive="", frontOfChain=True, geometry="", geometryIndices=True,
             ignoreSelected=True, includeHiddenSelections=False, name="", parallel=True,
             prune=True, remove=True, split=True, type="", q=True, query=True, e=True,
             edit=True, **kwargs):
    """
    This command creates a deformer of the specified type  The deformer will deform the
    selected objects
    
    :param after: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type after: boolean
    :param afterReference: (C E) The -afterReference flag is used to specify deformer ordering
    in a hybrid way that choses between -before and -after automatically  If the geometry b
    :type afterReference: boolean
    :param before: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type before: boolean
    :param deformerTools: (Q) Returns the name of the deformer tool objects (if any) as string
    string ..
    :type deformerTools: boolean
    :param exclusive: (C Q) Puts the deformation set in a deform partition
    :type exclusive: string
    :param frontOfChain: (C E) This command is used to specify that the new deformer node
    should be placed ahead (upstream) of existing deformer and skin nodes in the shape's histo
    :type frontOfChain: boolean
    :param geometry: (Q E M) The specified object will be added to the list of objects being
    deformed by this deformer object, unless the -rm flag is also specified  When queried
    :type geometry: string
    :param geometryIndices: (Q) Complements the -geometry flag in query mode  Returns the multi
    index of each geometry
    :type geometryIndices: boolean
    :param ignoreSelected: (C) Tells the command to not deform objects on the current selection
    list
    :type ignoreSelected: boolean
    :param includeHiddenSelections: (C) Apply the deformer to any visible and hidden objects in
    the selection list  Default is false
    :type includeHiddenSelections: boolean
    :param name: (C) Used to specify the name of the node being created
    :type name: string
    :param parallel: (C E) Inserts the new deformer in a parallel chain to any existing
    deformers in the history of the object  A blendShape is inserted to blend the parallel r
    :type parallel: boolean
    :param prune: (E) Removes any points not being deformed by the deformer in its current
    configuration from the deformer set
    :type prune: boolean
    :param remove: (E M) Specifies that objects listed after the -g flag should be removed from
    this deformer
    :type remove: boolean
    :param split: (C E) Branches off a new chain in the dependency graph instead of
    inserting/appending the deformer into/onto an existing chain  Works in create mode (and e
    :type split: boolean
    :param type: (C) Specify the type of deformer to create  This flag is required in create
    mode  Typically the type should specify a loaded plugin deformer  This comman
    :type type: string
    
    :returns: Name of the algorithm node created/edited.
    :rtype: string[]
    """
    pass


def polyExtrudeVertex(*args, caching=True, constructionHistory=True, divisions=1, length=0,
                      name="", nodeState=0, width=0, worldSpace=True, q=True, query=True,
                      e=True, edit=True, **kwargs):
    """
    Command that extrudes selected vertices outwards
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param divisions: (C Q E) This flag specifies the number of subdivisions  C: Default is 1
    Q: When queried, this flag returns an int
    :type divisions: int
    :param length: (C Q E) This flag specifies the length of the vertex extrusion  C: Default
    is 0 Q: When queried, this flag returns a float
    :type length: float
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param width: (C Q E) This flag specifies the width of the vertex extrusion  C: Default is
    0 Q: When queried, this flag returns a float
    :type width: float
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def ToggleUVs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PerspGraphHypergraphLayout(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def scrollField(*args, annotation="", backgroundColor=None, changeCommand=None, clear=True,
                command="", defineTemplate="", docTag="", dragCallback=None, dropCallback=None,
                editable=True, enable=True, enableBackground=True, enableKeyboardFocus=True,
                enterCommand=None, exists=True, font="", fontPointSize=0, fullPathName=True,
                height=0, highlightColor=None, insertText="", insertionPosition=0,
                isObscured=True, keyPressCommand=None, manage=True, noBackground=True,
                numberOfLines=0, numberOfPopupMenus=True, parent="", popupMenuArray=True,
                preventOverride=True, qtFont="", selection=True, statusBarMessage="", text="",
                useTemplate="", visible=True, visibleChangeCommand=None, width=0, wordWrap=True,
                q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a scrolling field that handles multiple lines of text
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Command executed when the value changes  This command is
    executed whenever the field loses focus
    :type changeCommand: script
    :param clear: (C E) Removes all text in the field
    :type clear: boolean
    :param command: (C E) Obsolete - use "enterCommand" instead
    :type command: string
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param editable: (C Q E) The edit state of the field  By default, this flag is set to true
    and the field value may be changed by typing into it  If false then the field is 'r
    :type editable: boolean
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param enterCommand: (C E) Command executed when the enter key is pressed  This applies to
    the enter key on the numeric keypad only
    :type enterCommand: script
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param font: (C Q E) The font for the text  Valid values are "boldLabelFont",
    "smallBoldLabelFont", "tinyBoldLabelFont", "plainLabelFont", "smallPlainLabelFont",
    "oblique
    :type font: string
    :param fontPointSize: (C Q E) The font point size for the text
    :type fontPointSize: int
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param insertText: (C E) Insert text into the field at the current insertion position
    (specified by the -ip/insertionPosition flag)
    :type insertText: string
    :param insertionPosition: (C Q E) The insertion position for inserted text  This is a 1
    based value where position 1 specifies the beginning of the field  Position 0 may be used
    to sp
    :type insertionPosition: int
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param keyPressCommand: (C E) Command executed when any key is pressed
    :type keyPressCommand: script
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfLines: (Q) Number of lines in the scroll field
    :type numberOfLines: int
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param qtFont: (C Q E) The Qt font family for the text
    :type qtFont: string
    :param selection: (Q) The selected text in the field  An empty string is returned if there
    is no selected text
    :type selection: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param text: (C Q E) The field text
    :type text: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    :param wordWrap: (C) Specify true to break lines at spaces, tabs, or newlines  Text will
    continue on the following line  A value of false will not break text between word
    :type wordWrap: boolean
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def shapeEditor(*args, clearSelection=True, control=True, defineTemplate="", docTag="",
                exists=True, filter="", forceMainConnection="", highlightConnection="",
                lockMainConnection=True, lowestSelection=True, mainListConnection="", panel="",
                parent="", selectionConnection="", stateString=True, targetControlList=True,
                targetList=True, unParent=True, unlockMainConnection=True,
                updateMainConnection=True, useTemplate="", verticalSliders=True, q=True,
                query=True, e=True, edit=True, **kwargs):
    """
    This command creates an editor that derives from the base editor class that has controls
    for deformer, control nodes
    
    :param clearSelection: (E) Clear the shape editor selection
    :type clearSelection: boolean
    :param control: (Q) Query only  Returns the top level control for this editor  Usually used
    for getting a parent to attach popup menus  Caution: It is possible for an ed
    :type control: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Attaches a tag to the editor
    :type docTag: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param filter: (C Q E) Specifies the name of an itemFilter object to be used with this
    editor  This filters the information coming onto the main list of the editor
    :type filter: string
    :param forceMainConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type forceMainConnection: string
    :param highlightConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its highlight list  Not all editors have a highlight list 
    F
    :type highlightConnection: string
    :param lockMainConnection: (C E) Locks the current list of objects within the
    mainConnection, so that only those objects are displayed within the editor  Further changes
    to the origi
    :type lockMainConnection: boolean
    :param lowestSelection: (Q) Query the lowest selection item
    :type lowestSelection: boolean
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type mainListConnection: string
    :param panel: (C Q) Specifies the panel for this editor  By default if an editor is created
    in the create callback of a scripted panel it will belong to that panel  If a
    :type panel: string
    :param parent: (C Q E) Specifies the parent layout for this editor  This flag will only
    have an effect if the editor is currently un-parented
    :type parent: string
    :param selectionConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its own selection list  As the user selects things in this
    e
    :type selectionConnection: string
    :param stateString: (Q) Query only flag  Returns the MEL command that will create an editor
    to match the current editor state  The returned command string uses the string va
    :type stateString: boolean
    :param targetControlList: (Q) Query the target control list
    :type targetControlList: boolean
    :param targetList: (Q) Query the target list
    :type targetList: boolean
    :param unParent: (C E) Specifies that the editor should be removed from its layout  This
    cannot be used in query mode
    :type unParent: boolean
    :param unlockMainConnection: (C E) Unlocks the mainConnection, effectively restoring the
    original mainConnection (if it is still available), and dynamic updates
    :type unlockMainConnection: boolean
    :param updateMainConnection: (C E) Causes a locked mainConnection to be updated from the
    orginal mainConnection, but preserves the lock state
    :type updateMainConnection: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param verticalSliders: (C Q E) Should the sliders be vertical?
    :type verticalSliders: boolean
    
    :returns: The name of the editor
    :rtype: string
    """
    pass


def SplitEdgeRingTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def gameExporter(*args, **kwargs):
    """
    
    """
    pass


def ogs(*args, deviceInformation=True, disposeReleasableTextures=True, dumpTexture="",
        enableHardwareInstancing=True, fragmentEditor="", fragmentXML="", gpuMemoryTotal=0,
        gpuMemoryUsed=True, isLegacyViewportEnabled=True, isWinRemoteSession=True, pause=True,
        rebakeTextures=True, regenerateUVTilePreview="", reloadTextures=True, reset=True,
        shaderSource="", toggleTexturePaging=True, traceRenderPipeline=True, q=True, query=True,
        **kwargs):
    """
    OGS is one of the viewport renderers  As there is a lot of effort involved in migrating
    functionality it will evolve over several releases  As it evolves it is prudent to provide
    safeguards to get the database back to a known state  That is the function of this command,
    similar to how 'dgdirty' is used to restore state to the dependency graph
    
    :param deviceInformation: (C) If used then output the current device information
    :type deviceInformation: boolean
    :param disposeReleasableTextures: (C) Clear up all the releasable file textures in GPU
    memory that are not required for rendering
    :type disposeReleasableTextures: boolean
    :param dumpTexture: (C) If used then dump GPU texture memory usage info (in MB), must be
    used with FLAG gpuMemoryUsed  The final info detail is specified by the string param
    :type dumpTexture: string
    :param enableHardwareInstancing: (C) Enables/disables new gpu instancing of instanceable
    render items in OGS
    :type enableHardwareInstancing: boolean
    :param fragmentEditor: (C) If used then launch the fragment editor UI
    :type fragmentEditor: string
    :param fragmentXML: (C) Get the fragment XML associated with a shading node
    :type fragmentXML: string
    :param gpuMemoryTotal: (C Q) Get or set the total amount of GPU memory which Maya is
    allowed to use (in MB)
    :type gpuMemoryTotal: int
    :param gpuMemoryUsed: (C) If used then output the estimated amount of GPU memory in use (in
    MB)
    :type gpuMemoryUsed: boolean
    :param isLegacyViewportEnabled: (Q) To query if the legacy viewport is enabled
    :type isLegacyViewportEnabled: boolean
    :param isWinRemoteSession: (Q) Query if this is a remote session
    :type isWinRemoteSession: boolean
    :param pause: (C Q) Toggle pausing VP2 display update
    :type pause: boolean
    :param rebakeTextures: (C) If used then re-bake all baked textures for OGS
    :type rebakeTextures: boolean
    :param regenerateUVTilePreview: (C) If used then regenerate all UV tiles preview textures
    for OGS
    :type regenerateUVTilePreview: string
    :param reloadTextures: (C) If used then reload all textures for OGS
    :type reloadTextures: boolean
    :param reset: (C Q) If used then reset the entire OGS database for all viewports using it 
    In query mode the number of viewports that would be affected is returned but t
    :type reset: boolean
    :param shaderSource: (Q) Get the shader source for the specified material
    :type shaderSource: string
    :param toggleTexturePaging: (C) If used then toggle the default OGS Texture paging
    mechanism
    :type toggleTexturePaging: boolean
    :param traceRenderPipeline: (C) Enable debug tracing of the renderer pipeline
    :type traceRenderPipeline: boolean
    
    :returns: Result of the operation
    :rtype: string
    """
    pass


def Fireworks(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GetHIKParentId(*args, **kwargs):
    """
    
    """
    pass


def ClearCurrentContainer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AssignOfflineFileFromRefEdOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def colorEditor(*args, alpha=0.0, hsvValue=None, mini=True, parent="", position=None,
                result=True, rgbValue=None, q=True, query=True, **kwargs):
    """
    The colorEditor command displays a modal dialog that may be used to specify colors in RGB
    or HSV  The default behaviour when no arguments are specified is to provide an initial
    color of black (rgb 0.0 0.0 0.0)   The command will return the user's color component
    values along with a boolean to indicate whether the dialog was dismissed by pressing th
    
    :param alpha: (C Q) Float values corresponding to the alpha transparency component, , which
    ranges from 0.0 to 1.0  Use this flag to specify the initial alpha value of t
    :type alpha: float
    :param hsvValue: (C Q) Three float values corresponding to the hue, saturation, and value
    color components, where the hue value ranges from 0.0 to 360.0 and the saturation
    :type hsvValue: [float, float, float]
    :param mini: (C) Enable the mini color editor mode
    :type mini: boolean
    :param parent: (C) Specify the parent window for the dialog  The dialog will be centered on
    this window and raise and lower with it's parent  By default, the dialog is
    :type parent: string
    :param position: (C) Specify the window position for the dialog
    :type position: [int, int]
    :param result: (Q) This query only flag returns true if the dialog's "OK" button was
    pressed, false otherwise  If you query this flag immediately after showing the Colo
    :type result: boolean
    :param rgbValue: (C Q) Three float values corresponding to the red, green, and blue color
    components, all of which range from 0.0 to 1.0  Use this flag to specify the initi
    :type rgbValue: [float, float, float]
    
    :returns: The string format is "float float float boolean". The first three
    float values
    correspond to the color components.
    
    The final argument is 1 if the dialog's "OK" button
    was pressed,
    and 0 if the "Cancel" button was pressed.
    :rtype: string
    """
    pass


def Snap3PointsTo3Points(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def repeatLast(*args, **kwargs):
    """
    
    """
    pass


def SelectObjectsIlluminatedByLight(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def containerPublish(*args, bindNode=None, bindTemplateStandins=True, inConnections=True,
                     mergeShared=True, outConnections=True, publishNode=None, unbindNode="",
                     unpublishNode="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    This is an accessory command to the container command which is used for some advanced
    publishing operations on the container  For example, the "publishConnections" flag on the
    container will publish all the connections, but this command can be used to publish just
    the inputs, outputs, or to collapse the shared inputs into a single attribute before
    
    
    :param bindNode: (C Q E) Bind the specified node to the published node name
    :type bindNode: [string, string]
    :param bindTemplateStandins: (C Q E) This flag will create a temporary stand-in attribute
    for any attributes that exist in the template but are not already bound  This enables you
    to set
    :type bindTemplateStandins: boolean
    :param inConnections: (C) Specifies that the unpublished connections to nodes in the
    container from external nodes should be published
    :type inConnections: boolean
    :param mergeShared: (C) For use with the inConnections flag  Indicates that when an
    external attribute connects to multiple internal attributes within the container, a singl
    :type mergeShared: boolean
    :param outConnections: (C) Specifies that the unpublished connections from nodes in the
    container to external nodes should be published
    :type outConnections: boolean
    :param publishNode: (C Q E) Publish a name and type  When first published, nothing will be
    bound  To bind a node to the published name, use the bindNode flag
    :type publishNode: [string, string]
    :param unbindNode: (C Q E) Unbind the node that is published with the name specified by the
    flag
    :type unbindNode: string
    :param unpublishNode: (C Q E) Unpublish the specified published node name
    :type unpublishNode: string
    
    :returns: 
    :rtype: None
    """
    pass


def NodeEditorCreateTab(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolygonClearClipboard(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmDensityBrushToolCmd(*args, **kwargs):
    """
    
    """
    pass


def geometryDeleteCacheOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def agFormatIn(*args, **kwargs):
    """
    
    """
    pass


def ShotPlaylistEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetFullBodyIKKeysAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def geometryAppendCacheOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def renderLayerMembers(*args, **kwargs):
    """
    
    """
    pass


def SendToUnitySelection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectNextIntermediatObject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TwistOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def STRSTweakModeOff(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def rigidSolver(*args, autoTolerances=True, bounciness=True, cacheData=True, collide=True,
                collisionTolerance=0.02, contactData=True, create=True, current=True,
                deleteCache=True, displayCenterOfMass=True, displayConstraint=True,
                displayVelocity=True, dynamics=True, friction=True, interpenetrate=True,
                interpenetrationCheck=True, name="", rigidBodies=True, rigidBodyCount=True,
                showCollision=True, showInterpenetration=True, solverMethod=2, startTime=0.0,
                state=True, statistics=True, stepSize=0.0333, velocityVectorScale=0.0, q=True,
                query=True, e=True, edit=True, **kwargs):
    """
    This command sets the attributes for the rigid solver
    
    :param autoTolerances: (Q E) Turns the auto tolerance calculation on and off  The auto
    tolerances calculation will override the default or user defined values of the step size
    an
    :type autoTolerances: boolean
    :param bounciness: (Q E) Turns bounciness on and off for the an the objects in the
    simulation  Default value: on
    :type bounciness: boolean
    :param cacheData: (Q E) Turns the cache on fall all rigid bodies in the system  Default
    value: off
    :type cacheData: boolean
    :param collide: (Q E) Disallows the interpenetration of the two rigid bodies listed 
    Default: Collide is on for all bodies
    :type collide: boolean
    :param collisionTolerance: (Q E) Sets the collision tolerance  This is the error at which
    two objects are considered to have collided  Range: 0.0005 - 1.000 Default: 0.02
    :type collisionTolerance: float
    :param contactData: (Q E) Turns the contact data information on/off for all rigid bodies 
    Default value: off
    :type contactData: boolean
    :param create: (C) Creates a new rigid solver
    :type create: boolean
    :param current: (C) Sets rigid solver as the current solver
    :type current: boolean
    :param deleteCache: (Q E) Deletes the cache for all rigid bodies in the system
    :type deleteCache: boolean
    :param displayCenterOfMass: (Q E) Displays the center of mass icon  Default value: on
    :type displayCenterOfMass: boolean
    :param displayConstraint: (Q E) Displays the constraint vectors  Default value: on
    :type displayConstraint: boolean
    :param displayVelocity: (Q E) Displays the velocity vectors  Default value: off
    :type displayVelocity: boolean
    :param dynamics: (Q E) Turns dynamics on and off for the an the objects in the simulation 
    Default value: on
    :type dynamics: boolean
    :param friction: (Q E) Turns friction on and off for the an the objects in the simulation 
    Default value: on
    :type friction: boolean
    :param interpenetrate: (Q E) Allows the two rigid bodies listed to interpenetrate  Default:
    interpenetration is off for all bodies
    :type interpenetrate: boolean
    :param interpenetrationCheck: (E) Checks for interpenetrating rigid bodies in the scene
    :type interpenetrationCheck: boolean
    :param name: (C Q E) Name of the new object
    :type name: string
    :param rigidBodies: (Q) Returns a list of rigid bodies in the solver
    :type rigidBodies: boolean
    :param rigidBodyCount: (Q) Returns the number of rigid bodies in the solver
    :type rigidBodyCount: boolean
    :param showCollision: (Q E) Displays the colliding objects in a different color
    :type showCollision: boolean
    :param showInterpenetration: (Q E) Displays the interpenetrating objects in a different
    color
    :type showInterpenetration: boolean
    :param solverMethod: (Q E) Sets the solver method  The choices are 0 | 1 | 2  0 = Euler
    (fastest/least acurate), 1 = Runge-Kutta ( slower/more acurate), 2 = adaptive Runge-Kutt
    :type solverMethod: int
    :param startTime: (C Q E) Sets the start time for the solver
    :type startTime: float
    :param state: (Q E) Turns the rigid solver on or off
    :type state: boolean
    :param statistics: (Q E) Turns the statistic information on/off for all rigid bodies 
    Default value: off
    :type statistics: boolean
    :param stepSize: (Q E) Sets the solvers step size  This is the maximum size of a single
    step the solver will take at one time  Range: 0.0004 - 0.100 Default: 0.0333
    :type stepSize: float
    :param velocityVectorScale: (Q E) scales the velocity vector display  Default value: 1.0
    :type velocityVectorScale: float
    
    :returns: 
    :rtype: None
    """
    pass


def ToggleVisibilityAndKeepSelection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PokePolygon(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def closeSurface(*args, blendBias=0.5, blendKnotInsertion=False, caching=True, direction=0,
                 nodeState=0, parameter=0.1, preserveShape=1, constructionHistory=True, name="",
                 object=True, replaceOriginal=True, q=True, query=True, e=True, edit=True,
                 **kwargs):
    """
    The closeSurface command closes a surface in the U, V, or both directions, making it
    periodic  The close direction is controlled by the direction flag  If a surface is not
    specified in the command, then the first selected surface will be used   The pathname to
    the newly closed surface and the name of the resulting dependency node are returned   Thi
    
    :param blendBias: (C Q E) Skew the result toward the first or the second surface depending
    on the blend value being smaller or larger than 0.5  Default: 0.5
    :type blendBias: float
    :param blendKnotInsertion: (C Q E) If set to true, insert a knot in one of the original
    surfaces (relative position given by the parameter attribute below) in order to produce a
    slight
    :type blendKnotInsertion: boolean
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param direction: (C Q E) The direction in which to close: 0 - U, 1 - V, 2 - Both U and V
    Default: 0
    :type direction: int
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param parameter: (C Q E) The parameter value for the positioning of the newly inserted
    knot  Default: 0.1
    :type parameter: float
    :param preserveShape: (C Q E) 0 - without preserving the shape 1 - preserve shape 2 - blend
    Default: 1
    :type preserveShape: int
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def ImportDeformerWeightsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_softSelToolTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Create3DContainerEmitter(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def pushPinning(*args, **kwargs):
    """
    
    """
    pass


def CreatePassiveRigidBody(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TangentsLinear(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GoToNextDrivenKey(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def manipScaleLimitsCtx(*args, exists=True, history=True, image1="", image2="", image3="",
                        name="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    Create a context for the scale limits manipulator
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: Name of newly created context.
    :rtype: string
    """
    pass


def polyMoveUV(*args, axisLen=None, axisLenX=0.0, axisLenY=0.0, caching=True,
               constructionHistory=True, name="", nodeState=0, pivot=None, pivotU=0.0,
               pivotV=0.0, random=0.0, rotationAngle=0.0, scale=None, scaleU=0.0, scaleV=0.0,
               translate=None, translateU=0.0, translateV=0.0, q=True, query=True, e=True,
               edit=True, **kwargs):
    """
    Moves selected UV coordinates in 2D space  As the selected UVs are adjusted, the way the
    image is mapped onto the object changes accordingly  This command manipulates the UV values
    without changing the 3D geometry of the object
    
    :param axisLen: (C Q E) AxisLen vector, used to draw the manip handles  Default: 1.0, 1.0
    :type axisLen: [float, float]
    :param axisLenX: (C Q E) AxisLen X coord
    :type axisLenX: float
    :param axisLenY: (C Q E) AxisLen Y coord
    :type axisLenY: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param pivot: (C Q E) The pivot for scaling and rotation  Default: 0.5, 0.5
    :type pivot: [float, float]
    :param pivotU: (C Q E) Pivot U coord
    :type pivotU: float
    :param pivotV: (C Q E) Pivot V coord
    :type pivotV: float
    :param random: (C Q E) Random value, added to all parameters  Default: 0.0
    :type random: float
    :param rotationAngle: (C Q E) Angle of rotation  Default: 0.0
    :type rotationAngle: float
    :param scale: (C Q E) Scaling vector  Default: 1.0, 1.0
    :type scale: [float, float]
    :param scaleU: (C Q E) Scaling U coord
    :type scaleU: float
    :param scaleV: (C Q E) Scaling V coord
    :type scaleV: float
    :param translate: (C Q E) Translation vector  Default: 0.0, 0.0
    :type translate: [float, float]
    :param translateU: (C Q E) Translation U coord
    :type translateU: float
    :param translateV: (C Q E) Translation V coord
    :type translateV: float
    
    :returns: The node name.
    :rtype: string
    """
    pass


def GpuCacheExportSelectionOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolyDisplayReset(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ResetTemplateBrush(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SmokeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dynGlobals(*args, active=True, listAll=True, overSampling=0, q=True, query=True, e=True,
               edit=True, **kwargs):
    """
    This node edits and queries the attributes of the active dynGlobals node in the scene 
    There can be only one active node of this type  The active dynGlobals node is the first one
    that was created, either with a "createNode" command or by accessing/editing any of the
    attributes on the node through this command
    
    :param active: (Q) This flag returns the name of the active dynGlobals node in the the
    scene  Only one dynGlobals node is active  It is the first on created  Any additi
    :type active: boolean
    :param listAll: (Q) This flag will list all of the dynGlobals nodes in the scene
    :type listAll: boolean
    :param overSampling: (Q E) This flag will set the current overSampling value for all of the
    particle in the scene
    :type overSampling: int
    
    :returns: For edit commands
    :rtype: string
    """
    pass


def threadCount(*args, numberOfThreads=0, q=True, query=True, **kwargs):
    """
    This command sets the number of threads to be used by Maya in regions of code that are
    multithreaded  By default the number of threads is equal to the number of logical CPUs, not
    the number of physical CPUs  Logical CPUs are different from physical CPUs in the following
    ways:  A physical CPU with hyperthreading counts as two logical CPUs A dual-cor
    
    :param numberOfThreads: (C Q) Sets the number of threads to use
    :type numberOfThreads: int
    
    :returns: 
    :rtype: None
    """
    pass


def CurveSmoothnessFine(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBIKReachKeyingOptionFK(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowMeshSprayToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportFileVersion(*args, **kwargs):
    """
    
    """
    pass


def PreviousViewArrangement(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteKeysOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectSharedUVInstances(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def snapMode(*args, curve=True, distanceIncrement=0.0, edgeMagnet=0, edgeMagnetTolerance=0.0,
             grid=True, liveFaceCenter=True, livePoint=True, meshCenter=True, pixelCenter=True,
             pixelSnap=True, point=True, tolerance=0, useTolerance=True, uvTolerance=0,
             viewPlane=True, q=True, query=True, **kwargs):
    """
    The snapMode command is used to control snapping  It toggles the snapping modes in effect
    and sets information used for snapping
    
    :param curve: (C Q) Set curve snap mode
    :type curve: boolean
    :param distanceIncrement: (C Q) Set the distance for the snapping to objects such as a
    lines or planes
    :type distanceIncrement: float
    :param edgeMagnet: (C Q) Number of extra magnets to snap onto, regularly spaced along the
    edge
    :type edgeMagnet: int
    :param edgeMagnetTolerance: (C Q) Precision for edge magnet snapping
    :type edgeMagnetTolerance: float
    :param grid: (C Q) Set grid snap mode
    :type grid: boolean
    :param liveFaceCenter: (C Q) While moving on live polygon objects, snap to its face
    centers
    :type liveFaceCenter: boolean
    :param livePoint: (C Q) While moving on live polygon objects, snap to its vertices
    :type livePoint: boolean
    :param meshCenter: (C Q) While moving, snap on the center of the mesh that intersect the
    line from the camera to the cursor
    :type meshCenter: boolean
    :param pixelCenter: (C Q) Snap UV to the center of the pixel instead of the corner
    :type pixelCenter: boolean
    :param pixelSnap: (C Q) Snap UVs to the nearest pixel center or corner
    :type pixelSnap: boolean
    :param point: (C Q) Set point snap mode
    :type point: boolean
    :param tolerance: (C Q) Tolerance defines the size of the square region in which points
    must lie in order to be snapped to  The tolerance value is the distance from the curs
    :type tolerance: int
    :param useTolerance: (C Q) If useTolerance is set, then point snapping is limited to points
    that are within a square region surrounding the cursor position  The size of the squ
    :type useTolerance: boolean
    :param uvTolerance: (C Q) uvTolerance defines the size of the square region in which points
    must lie in order to be snapped to, in the UV Editor  The tolerance value is the di
    :type uvTolerance: int
    :param viewPlane: (C Q) Set view-plane snap mode
    :type viewPlane: boolean
    
    :returns: if command is a query
    :rtype: boolean
    """
    pass


def SelectEdgeLoopSp(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ObjectCentricLightLinkingEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def textFieldGrp(*args, adjustableColumn=0, adjustableColumn2=0, adjustableColumn3=0,
                 adjustableColumn4=0, adjustableColumn5=0, adjustableColumn6=0, annotation="",
                 backgroundColor=None, changeCommand=None, columnAlign=None, columnAlign2=None,
                 columnAlign3=None, columnAlign4=None, columnAlign5=None, columnAlign6=None,
                 columnAttach=None, columnAttach2=None, columnAttach3=None, columnAttach4=None,
                 columnAttach5=None, columnAttach6=None, columnOffset2=None, columnOffset3=None,
                 columnOffset4=None, columnOffset5=None, columnOffset6=None, columnWidth=None,
                 columnWidth1=0, columnWidth2=None, columnWidth3=None, columnWidth4=None,
                 columnWidth5=None, columnWidth6=None, defineTemplate="", docTag="",
                 dragCallback=None, dropCallback=None, editable=True, enable=True,
                 enableBackground=True, enableKeyboardFocus=True, exists=True, fileName="",
                 forceChangeCommand=True, fullPathName=True, height=0, highlightColor=None,
                 insertText="", insertionPosition=0, isObscured=True, label="", manage=True,
                 noBackground=True, numberOfPopupMenus=True, parent="", placeholderText="",
                 popupMenuArray=True, preventOverride=True, rowAttach=None, statusBarMessage="",
                 text="", textChangedCommand=None, useTemplate="", visible=True,
                 visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
                 **kwargs):
    """
    All of the group commands position their individual controls in columns starting at column
    1  The layout of each control (ie  column) can be customized using the -cw/columnWidth,
    -co/columnOffset, -cat/columnAttach, -cal/columnAlign, and -adj/adjustableColumn flags  By
    default, columns are left aligned with no offset and are 100 pixels wide  Only o
    
    :param adjustableColumn: (C E) Specifies which column has an adjustable size that changes
    with the sizing of the layout  The column value is a 1-based index  Passing 0 as argument
    :type adjustableColumn: int
    :param adjustableColumn2: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly two columns
    :type adjustableColumn2: int
    :param adjustableColumn3: (C E) Specifies that the column has an adjustable size that
    changes with the size of the parent layout  Ignored if there are not exactly three columns
    :type adjustableColumn3: int
    :param adjustableColumn4: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly four columns
    :type adjustableColumn4: int
    :param adjustableColumn5: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly five columns
    :type adjustableColumn5: int
    :param adjustableColumn6: (C E) Specifies which column has an adjustable size that changes
    with the size of the parent layout  Ignored if there are not exactly six columns
    :type adjustableColumn6: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Command executed when the field text changes and user presses
    Enter or Return
    :type changeCommand: script
    :param columnAlign: (C E M) Arguments are : column number, alignment type  Possible
    alignments are: left | right | center  Specifies alignment type for the specified column
    :type columnAlign: [int, string]
    :param columnAlign2: (C E) Sets the text alignment of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "center"
    :type columnAlign2: [string, string]
    :param columnAlign3: (C E) Sets the text alignment for all three columns  Ignored if there
    are not exactly three columns  Valid values are "left", "right", and "center"
    :type columnAlign3: [string, string, string]
    :param columnAlign4: (C E) Sets the text alignment for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "center"
    :type columnAlign4: [string, string, string, string]
    :param columnAlign5: (C E) Sets the text alignment for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "center"
    :type columnAlign5: [string, string, string, string, string]
    :param columnAlign6: (C E) Sets the text alignment for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "center"
    :type columnAlign6: [string, string, string, string, string, string]
    :param columnAttach: (C E M) Arguments are : column number, attachment type, and offset 
    Possible attachments are: left | right | both  Specifies column attachment types and offe
    :type columnAttach: [int, string, int]
    :param columnAttach2: (C E) Sets the attachment type of both columns  Ignored if there are
    not exactly two columns  Valid values are "left", "right", and "both"
    :type columnAttach2: [string, string]
    :param columnAttach3: (C E) Sets the attachment type for all three columns  Ignored if
    there are not exactly three columns  Valid values are "left", "right", and "both"
    :type columnAttach3: [string, string, string]
    :param columnAttach4: (C E) Sets the attachment type for all four columns  Ignored if there
    are not exactly four columns  Valid values are "left", "right", and "both"
    :type columnAttach4: [string, string, string, string]
    :param columnAttach5: (C E) Sets the attachment type for all five columns  Ignored if there
    are not exactly five columns  Valid values are "left", "right", and "both"
    :type columnAttach5: [string, string, string, string, string]
    :param columnAttach6: (C E) Sets the attachment type for all six columns  Ignored if there
    are not exactly six columns  Valid values are "left", "right", and "both"
    :type columnAttach6: [string, string, string, string, string, string]
    :param columnOffset2: (C E) This flag is used in conjunction with the -columnAttach2 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the tw
    :type columnOffset2: [int, int]
    :param columnOffset3: (C E) This flag is used in conjunction with the -columnAttach3 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the th
    :type columnOffset3: [int, int, int]
    :param columnOffset4: (C E) This flag is used in conjunction with the -columnAttach4 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fo
    :type columnOffset4: [int, int, int, int]
    :param columnOffset5: (C E) This flag is used in conjunction with the -columnAttach5 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the fi
    :type columnOffset5: [int, int, int, int, int]
    :param columnOffset6: (C E) This flag is used in conjunction with the -columnAttach6 flag 
    If that flag is not used then this flag will be ignored  It sets the offset for the si
    :type columnOffset6: [int, int, int, int, int, int]
    :param columnWidth: (C E M) Arguments are : column number, column width  Sets the width of
    the specified column where the first parameter specifies the column (1 based index) an
    :type columnWidth: [int, int]
    :param columnWidth1: (C E) Sets the width of the first column  Ignored if there is not
    exactly one column
    :type columnWidth1: int
    :param columnWidth2: (C E) Sets the column widths of both columns  Ignored if there are not
    exactly two columns
    :type columnWidth2: [int, int]
    :param columnWidth3: (C E) Sets the column widths for all 3 columns  Ignored if there are
    not exactly 3 columns
    :type columnWidth3: [int, int, int]
    :param columnWidth4: (C E) Sets the column widths for all 4 columns  Ignored if there are
    not exactly 4 columns
    :type columnWidth4: [int, int, int, int]
    :param columnWidth5: (C E) Sets the column widths for all 5 columns  Ignored if there are
    not exactly 5 columns
    :type columnWidth5: [int, int, int, int, int]
    :param columnWidth6: (C E) Sets the column widths for all 6 columns  Ignored if there are
    not exactly 6 columns
    :type columnWidth6: [int, int, int, int, int, int]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param editable: (C Q E) The edit state of the field  By default, this flag is set to true
    and the field value may be changed by typing into it  If false then the field is 'r
    :type editable: boolean
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fileName: (C Q E) Text in the field as a filename  This does conversions between
    internal and external (UI) file representation
    :type fileName: string
    :param forceChangeCommand: (C E) If used together with -text or -inserText flag, change
    command will be executed after text modification
    :type forceChangeCommand: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param insertText: (C E) Insert text into the field at the current insertion position
    (specified by the -ip/insertionPosition flag)
    :type insertText: string
    :param insertionPosition: (C Q E) The insertion position for inserted text  This is a 1
    based value where position 1 specifies the beginning of the field  Position 0 may be used
    to sp
    :type insertionPosition: int
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) Label text for the group
    :type label: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param placeholderText: (C Q E) Setting this property makes the line edit display a
    grayed-out placeholder text as long as the text field is empty and the widget doesn't have
    focus
    :type placeholderText: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rowAttach: (C E M) Arguments are : column, attachment type, offset  Possible
    attachments are: top | bottom | both  Specifies attachment types and offsets for the
    entire
    :type rowAttach: [int, string, int]
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param text: (C Q E) Text in the field
    :type text: string
    :param textChangedCommand: (C E) Command executed immediately when the field text changes
    :type textChangedCommand: script
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def SculptReferenceVectorMarkingMenuPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def clip(*args, absolute=True, absoluteRotations=True, active="", addTrack=True,
         allAbsolute=True, allClips=True, allRelative=True, allSourceClips=True,
         animCurveRange=True, character=True, constraint=True, copy=True, defaultAbsolute=True,
         duplicate=True, endTime=None, expression=True, ignoreSubcharacters=True, isolate=True,
         leaveOriginal=True, mapMethod="", name="", newName="", paste=True, pasteInstance=True,
         remove=True, removeTrack=True, rotationOffset=None, rotationsAbsolute=True,
         scheduleClip=True, sourceClipName=True, split=None, startTime=None,
         translationOffset=None, useChannel="", q=True, query=True, e=True, edit=True,
         **kwargs):
    """
    This command is used to create, edit and query character clips
    
    :param absolute: (C) This flag is now deprecated  Use aa/allAbsolute, ar/allRelative,
    ra/rotationsAbsolute, or da/defaultAbsolute instead  This flag controls whether the
    :type absolute: boolean
    :param absoluteRotations: (C) This flag is now deprecated  Use aa/allAbsolute,
    ar/allRelative, ra/rotationsAbsolute, or da/defaultAbsolute instead  If true, this
    overrides the -ab
    :type absoluteRotations: boolean
    :param active: (Q E) Query or edit the active clip  This flag is not valid in create mode 
    Making a clip active causes its animCurves to be hooked directly to the charact
    :type active: string
    :param addTrack: () This flag is now obsolete  Use the insertTrack flag on the clipSchedule
    command instead
    :type addTrack: boolean
    :param allAbsolute: (C) Set all channels to be calculated with absolute offsets  This flag
    cannot be used in conjunction with the ar/allRelative, ra/rotationsAbsolute or da/
    :type allAbsolute: boolean
    :param allClips: (Q) This flag is used to query all the clips in the scene  Nodes of type
    "animClip" that are storing poses, are not returned by this command
    :type allClips: boolean
    :param allRelative: (C) Set all channels to be calculated with relative offsets  This flag
    cannot be used in conjunction with the aa/allAbsolute, ra/rotationsAbsolute or da/
    :type allRelative: boolean
    :param allSourceClips: (Q) This flag is used to query all the source clips in the scene 
    Nodes of type "animClip" that are storing poses or clip instances, are not returned by
    :type allSourceClips: boolean
    :param animCurveRange: (C) This flag can be used at the time you create the clip instead of
    the startTime and endTime flags  It specifies that you want the range of the clip to
    :type animCurveRange: boolean
    :param character: (Q) This is a query only flag which operates on the specified clip  It
    returns the names of any characters that a clip is associated with
    :type character: boolean
    :param constraint: (C) This creates a clip out of any constraints on the character  The
    constraint will be moved off of the character and into the clip, so that it is only
    :type constraint: boolean
    :param copy: (C Q) This flag is used to copy a clip or clips to the clipboard  It should be
    used in conjunction with the name flag to copy the named clips on the specif
    :type copy: boolean
    :param defaultAbsolute: (C) Sets all top-level channels except rotations in the clip to
    relative, and the remaining channels to absolute  This is the default during clip creatio
    :type defaultAbsolute: boolean
    :param duplicate: (Q) Duplicate the clip specified by the name flag  The start time of the
    new clip should be specified with the startTime flag
    :type duplicate: boolean
    :param endTime: (C Q E) Specify the clip end
    :type endTime: time
    :param expression: (C) This creates a clip out of any expressions on the character  The
    expression will be moved off of the character and into the clip, so that it is only
    :type expression: boolean
    :param ignoreSubcharacters: (C) During clip creation, duplication and isolation,
    subcharacters are included by default  If you want to create a clip on the top level
    character only,
    :type ignoreSubcharacters: boolean
    :param isolate: (C) This flag should be used in conjunction with the name flag to specify
    that a clip or clips should be copied to a new clip library  The most common us
    :type isolate: boolean
    :param leaveOriginal: (C) This flag is used when creating a clip to specify that the
    animation curves should be copied to the clip library, and left on the character
    :type leaveOriginal: boolean
    :param mapMethod: (C) This is is valid with the paste and pasteInstance flags only  It
    specifies how the mapping should be done  Valid options are: "byNodeName", "byAttrNa
    :type mapMethod: string
    :param name: (C Q M) In create mode, specify the clip name  In query mode, return a list of
    all the clips  In duplicate mode, specify the clip to be duplicated  In copy m
    :type name: string
    :param newName: (C) Rename a clip  Must be used in conjunction with the clip name flag,
    which is used to specify the clip to be renamed
    :type newName: string
    :param paste: (C) This flag is used to paste a clip or clips from the clipboard to a
    character  Clips are added to the clipboard using the c/copy flag
    :type paste: boolean
    :param pasteInstance: (C) This flag is used to paste an instance of a clip or clips from
    the clipboard to a character  Unlike the p/paste flag, which duplicates the animCurves
    :type pasteInstance: boolean
    :param remove: (Q) Remove the clip specified by the name flag  The clip will be permanently
    removed from the library and deleted from any times where it has been schedu
    :type remove: boolean
    :param removeTrack: (C) This flag is now obsolete  Use removeTrack flag on the clipSchedule
    command instead
    :type removeTrack: boolean
    :param rotationOffset: (C Q) Return the channel offsets used to modify the clip's rotation
    :type rotationOffset: [float, float, float]
    :param rotationsAbsolute: (C) Set all channels except rotations to be calculated with
    relative offsets  Rotation channels will be calculated with absolute offsets  This flag
    canno
    :type rotationsAbsolute: boolean
    :param scheduleClip: (C) This flag is used when creating a clip to specify whether or not
    the clip should immediately be scheduled at the current time  If the clip is not sch
    :type scheduleClip: boolean
    :param sourceClipName: (Q) This flag is for query only  It returns the name of the source
    clip that controls an instanced clip
    :type sourceClipName: boolean
    :param split: (C E) Split an existing clip into two clips  The split occurs around the
    specified time
    :type split: time
    :param startTime: (C Q E) Specify the clip start
    :type startTime: time
    :param translationOffset: (C Q) Return the channel offsets used to modify the clip's
    translation
    :type translationOffset: [float, float, float]
    :param useChannel: (C M) Specify which channels should be acted on  This flag is valid only
    in conjunction with clip creation, and the isolate flag  The specified channels mu
    :type useChannel: string
    
    :returns: clip names
    :rtype: string[]
    """
    pass


def DecreaseExposureFine(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def curveSketchCtx(*args, degree=0, exists=True, history=True, image1="", image2="", image3="",
                   name="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    The curveSketchCtx command creates a new curve sketch context, also known as the "pencil
    context"
    
    :param degree: (C Q E) Valid values are 1 or 3
    :type degree: int
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: (name of the new curve sketch context)
    :rtype: string
    """
    pass


def MakeLightLinks(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXImportFillTimeline(*args, **kwargs):
    """
    
    """
    pass


def EnableNParticles(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PaintGeomCacheTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def userCtx(*args, **kwargs):
    """
    
    """
    pass


def saveMenu(*args, **kwargs):
    """
    This command is used for saving the contents of a menu, so that another instance of the
    menu may be recreated later  The command writes out a file which, when run as a script,
    will rebuild the menuItems contained in the original menu  Note that the fileName is
    relative to the user's marking menu preference directory   Note that this command is used
    
    
    :returns: The name of the saved file.
    :rtype: string
    """
    pass


def listDeviceAttachments(*args, attribute="", axis="", clutch="", device="", file="",
                          selection=True, write=True, **kwargs):
    """
    This command lists the current set of device attachments  The listing is in the form of the
    commands required to recreate them  This includes both attachments and device mappings
    
    :param attribute: (C) specify the attribute attachments to list
    :type attribute: string
    :param axis: (C) specify the axis attachments to list
    :type axis: string
    :param clutch: (C) List only attachment clutched with this button
    :type clutch: string
    :param device: (C) specify which device attachments to list
    :type device: string
    :param file: (C) Specify the name of the file to write out device attachments
    :type file: string
    :param selection: (C) This flag list only attachments on selection
    :type selection: boolean
    :param write: (C) Write out device attachments to a file specified by the -f flag, is set 
    If -f is not set, it'll write out to a file named for the device
    :type write: boolean
    
    :returns: Command result
    :rtype: string
    """
    pass


def panZoom(*args, absolute=True, downDistance=0.0, leftDistance=0.0, relative=True,
            rightDistance=0.0, upDistance=0.0, zoomRatio=0.0, **kwargs):
    """
    The panZoom command pans/zooms the 2D film   The panZoom command can be applied to either a
    perspective or an orthographic camera   When no camera name is supplied, this command is
    applied to the camera in the active view
    
    :param absolute: (C) This flag modifies the behavior of the distance and zoomRatio flags 
    If specified, the distance and zoomRatio value will be applied directly
    :type absolute: boolean
    :param downDistance: (C) Set the amount of down pan distance in inches
    :type downDistance: float
    :param leftDistance: (C) Set the amount of left pan distance in inches
    :type leftDistance: float
    :param relative: (C) This flag modifies the behavior of the distance and zoomRatio flags 
    If specified, the distance or zoomRatio value is used multiply the camera's exis
    :type relative: boolean
    :param rightDistance: (C) Set the amount of right pan distance in inches
    :type rightDistance: float
    :param upDistance: (C) Set the amount of up pan distance in inches
    :type upDistance: float
    :param zoomRatio: (C) Set the amount of zoom ratio
    :type zoomRatio: float
    
    :returns: 
    :rtype: None
    """
    pass


def webView(*args, urlAddress="", windowHeight=0, windowWidth=0, **kwargs):
    """
    This command allows the user to bring up a web page view
    
    :param urlAddress: (C) Bring up webView on given URL
    :type urlAddress: string
    :param windowHeight: (C) Set the window height
    :type windowHeight: int
    :param windowWidth: (C) Set the window width
    :type windowWidth: int
    
    :returns: 
    :rtype: None
    """
    pass


def DeleteAllNCloths(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GoToDefaultView(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmNoiseBrushContext(*args, **kwargs):
    """
    
    """
    pass


def ScaleToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ctxData(*args, **kwargs):
    """
    
    """
    pass


def HIKUiControl(*args, **kwargs):
    """
    
    """
    pass


def jointCtx(*args, autoJointOrient="xyz", autoPriorityH=True, createIKHandle=True,
             degreeOfFreedomJ="xyz", exists=True, forceSolverH=True, image1="", image2="",
             image3="", jointAutoLimits=True, jointOrientationJ=None, largeBoneLength=0.0,
             largeBoneRadius=0.0, poWeightH=1, priorityH=0, scaleCompensateJ=True, scaleJ=None,
             scaleOrientationJ=None, secondaryAxisOrient="", smallBoneLength=0.0,
             smallBoneRadius=0.0, snapHandleH=True, solverTypeH="", stickyH="off",
             symmetry=True, symmetryAxis="", variableBoneSize=True, weightH=1, q=True,
             query=True, e=True, edit=True, **kwargs):
    """
    The joint context command (jointCtx) updates the parameters of the joint tool  The options
    for the tool will be set by the flags the user specifies
    
    :param autoJointOrient: (C Q E) Specifies the joint orientation  Valid string choices are
    permutations of the axes; "none", "xyz", "yzx", "zxy", "xzy", "yxz", "zyx"  The first
    lette
    :type autoJointOrient: string
    :param autoPriorityH: (C Q E) Specifies if the ikHandle's priority is assigned
    automatically  C: The default is off  Q: When queried, this flag returns an int
    :type autoPriorityH: boolean
    :param createIKHandle: (C Q E) Enables the joint tool to create an ikHandle when the tool
    is completed  C: The default is off  Q: When queried, this flag returns an int
    :type createIKHandle: boolean
    :param degreeOfFreedomJ: (C Q E) Specifies the degrees of freedom for all of the joints
    created by the tool  Valid string choices are the free axes; "x", "y", "z", "xy", "xz",
    "yz",
    :type degreeOfFreedomJ: string
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param forceSolverH: (C Q E) Specifies if the ikSolver for the ikHandle is enabled  C: The
    default is on  Q: When queried, this flag returns an int
    :type forceSolverH: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param jointAutoLimits: (C Q E) Automatically computes the joint limits based on the kind
    of joint created  C: The default is off  Q: When queried, this flag returns an int
    :type jointAutoLimits: boolean
    :param jointOrientationJ: (C Q E) Sets the orientation of the joints created by the tool 
    If autoJointOrient in on, these values will be ignored  C: The default is 0 0 0  Q: When
    quer
    :type jointOrientationJ: [float, float, float]
    :param largeBoneLength: (C Q E) Specifies the length above which bones should be assigned
    the largeBoneRadius
    :type largeBoneLength: float
    :param largeBoneRadius: (C Q E) Specifies the radius for bones whose length is above the
    largeBoneLength
    :type largeBoneRadius: float
    :param poWeightH: (C Q E) Specifies the position/orientation weight of the ikHandle  C: The
    default is 1  Q: When queried, this flag returns a float
    :type poWeightH: float
    :param priorityH: (C Q E) Specifies the priority of the ikHandle  C: The default is on  Q:
    When queried, this flag returns an int
    :type priorityH: int
    :param scaleCompensateJ: (C Q E) Specifies if scale compensate is enabled  C: The default
    is on  Q: When queried, this flag returns an int
    :type scaleCompensateJ: boolean
    :param scaleJ: (C Q E) Sets the scale for the joints created by the tool  C: The default is
    1 1 1  Q: When queried, this flag returns an array of three floats
    :type scaleJ: [float, float, float]
    :param scaleOrientationJ: (C Q E) Sets the current value for the scale orientation  If
    autoJointOrient in on, these values will be ignored  C: The default is 0 0 0  Q: When
    queried, t
    :type scaleOrientationJ: [float, float, float]
    :param secondaryAxisOrient: (C Q E) Specifies the orientation of the secondary rotate axis 
    Valid string choices are: "xup", "xdown", "yup", "ydown", "zup", "zdown", "none"
    :type secondaryAxisOrient: string
    :param smallBoneLength: (C Q E) Specifies the length below which bones should be assigned
    the smallBoneRadius
    :type smallBoneLength: float
    :param smallBoneRadius: (C Q E) Specifies the radius for bones whose length is below the
    smallBoneLength
    :type smallBoneRadius: float
    :param snapHandleH: (C Q E) Sepcifies if snapping is enabled for the ikHandle  C: The
    default is on  Q: When queried, this flag returns an int
    :type snapHandleH: boolean
    :param solverTypeH: (C Q E) Sets the name of the solver to use with the ikHandle  C: The
    default is the solver set to the default in the user preferences  Q: When queried, this
    :type solverTypeH: string
    :param stickyH: (C Q E) Specifies if the ikHandle is sticky or not  If "sticky" is passed
    then the ikHandle will be sticky  If "off" is used then ikHandle stickiness will be
    :type stickyH: string
    :param symmetry: (C Q E) Automaticaly create a symmetry joint based if symmetry is on  C:
    The default is off  Q: When queried, this flag returns an int
    :type symmetry: boolean
    :param symmetryAxis: (C Q E) Automaticaly create a symmetry joint use x, y , z axis or
    combination to do the symmetry  C: The default is x  Q: When queried, this flag returns a
    s
    :type symmetryAxis: string
    :param variableBoneSize: (C Q E) Specifies whether or not variable bone length and radius
    settings should be used
    :type variableBoneSize: boolean
    :param weightH: (C Q E) Specifies the weight of the ikHandle  The weight is relative to the
    other ikHandles in the scene  C: The default is 1  Q: When queried, this flag ret
    :type weightH: float
    
    :returns: The name of the context.
    :rtype: string
    """
    pass


def HypershadeExportSelectedNetwork(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreatePolygonType(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def instance(*args, leaf=True, name="", smartTransform=True, **kwargs):
    """
    Instancing is a way of making the same object appear twice in the scene  This is
    accomplished by creation of a new transform node that points to an exisiting object 
    Changes to the transform are independent but changes to the "instanced" object affect all
    instances since the node is shared   If no objects are given, then the selected list is
    instan
    
    :param leaf: (C) Instances leaf-level objects  Acts like duplicate except leaf-level
    objects are instanced
    :type leaf: boolean
    :param name: (C) Name to give new instance
    :type name: string
    :param smartTransform: (C) Transforms instances item based on movements between transforms
    :type smartTransform: boolean
    
    :returns: - the name of the new transform node is returned.
    :rtype: string
    """
    pass


def dR_scaleRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def editImportedStatus(*args, **kwargs):
    """
    
    """
    pass


def nurbsPlane(*args, axis=None, caching=True, degree=3, lengthRatio=1.0, nodeState=0,
               patchesU=1, patchesV=1, pivot=None, width=1.0, constructionHistory=True, name="",
               object=True, polygon=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The nurbsPlane command creates a new NURBS Plane and return the name of the new surface  It
    creates an unit plane with center at origin by default
    
    :param axis: (C Q E) The primitive's axis
    :type axis: [float, float, float]
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param degree: (C Q E) The degree of the resulting surface 1 - linear, 2 - quadratic, 3 -
    cubic, 5 - quintic, 7 - heptic Default: 3
    :type degree: int
    :param lengthRatio: (C Q E) The ratio of "length" to "width" of the plane  Default: 1.0
    :type lengthRatio: float
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param patchesU: (C Q E) The number of spans in the U direction  Default: 1
    :type patchesU: int
    :param patchesV: (C Q E) The number of spans in the V direction  Default: 1
    :type patchesV: int
    :param pivot: (C Q E) The primitive's pivot point
    :type pivot: [float, float, float]
    :param width: (C Q E) The width of the plane Default: 1.0
    :type width: float
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param polygon: (C) The value of this argument controls the type of the object created by
    this operation 0: nurbs surface 1: polygon (use nurbsToPolygonsPref to set the
    :type polygon: int
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def dR_softSelDistanceTypeSurface(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmNullRender(*args, **kwargs):
    """
    
    """
    pass


def igBrush(*args, **kwargs):
    """
    
    """
    pass


def retimeHelper(*args, **kwargs):
    """
    
    """
    pass


def xgmRebuildCurve(*args, **kwargs):
    """
    
    """
    pass


def FluidEmitter(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OutlinerToggleSetMembers(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetMeshFlattenTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def unloadPlugin(*args, addCallback=None, force=True, removeCallback=None, **kwargs):
    """
    Unload plug-ins from Maya  After the successful execution of this command, plug-in services
    will no longer be available
    
    :param addCallback: (C) Add a procedure to be called just before a plugin is unloaded  The
    procedure should have one string argument, which will be the plugin's name
    :type addCallback: script
    :param force: (C) Unload the plugin even if it is providing services  This is not
    recommended  If you unload a plug-in that implements a node or data type in the scene
    :type force: boolean
    :param removeCallback: (C) Remove a procedure which was previously added with -addCallback
    :type removeCallback: script
    
    :returns: the internal names of the successfully unloaded plug-ins
    :rtype: string[]
    """
    pass


def snapKey(*args, animation="keysOrObjects.", attribute="", controlPoints=False, float=None,
            hierarchy="", includeUpperBound=True, index=0, shape=True, time=None,
            timeMultiple=0.0, valueMultiple=0.0, **kwargs):
    """
    This command operates on a keyset  A keyset is defined as a group of keys within a
    specified time range on one or more animation curves   The animation curves comprising a
    keyset depend on the value of the "-animation" flag:  keysOrObjects: Any active keys, when
    no target objects or -attribute flags appear on the command line, or All animation curv
    
    :param animation: (C) Where this command should get the animation to act on  Valid values
    are "objects," "keys," and "keysOrObjects" Default: "keysOrObjects." (See Descrip
    :type animation: string
    :param attribute: (C M) List of attributes to select In query mode, this flag needs a
    value
    :type attribute: string
    :param controlPoints: (C) This flag explicitly specifies whether or not to include the
    control points of a shape (see "-s" flag) in the list of attributes  Default: false  (No
    :type controlPoints: boolean
    :param float: (C M) value uniquely representing a non-time-based key (or key range) on a
    time-based animCurve  Valid floatRange include single values (-f 10) or a string
    :type float: floatrange
    :param hierarchy: (C) Hierarchy expansion options  Valid values are "above," "below," "both,
    " and "none." (Not valid for "pasteKey" cmd.) In query mode, this flag needs a
    :type hierarchy: string
    :param includeUpperBound: (C) When the -t/time or -f/float flags represent a range of keys,
    this flag determines whether the keys at the upper bound of the range are included in t
    :type includeUpperBound: boolean
    :param index: (C M) index of a key on an animCurve In query mode, this flag needs a value
    :type index: int
    :param shape: (C) Consider attributes of shapes below transforms as well, except
    "controlPoints"  Default: true  (Not valid for "pasteKey" cmd.) In query mode, this fl
    :type shape: boolean
    :param time: (C M) time uniquely representing a key (or key range) on a time-based
    animCurve  See the code examples below on how to format for a single frame or frame r
    :type time: timerange
    :param timeMultiple: (C) If this flag is present, key times will be snapped to a multiple
    of the specified float value
    :type timeMultiple: float
    :param valueMultiple: (C) If this flag is present, key values will be snapped to a multiple
    of the specified float value
    :type valueMultiple: float
    
    :returns: Number of animation curves
    with keys that were not snapped because of
    time-snapping
    conflicts.
    :rtype: int
    """
    pass


def SculptSurfacesTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def controller(*args, allControllers=True, children=True, group=True, index=0, isController="",
               parent=True, pickWalkDown=True, pickWalkLeft=True, pickWalkRight=True,
               pickWalkUp=True, unparent=True, q=True, query=True, e=True, edit=True,
               **kwargs):
    """
    Commands for managing animation sources
    
    :param allControllers: (C Q E) When this flag is queried, returns all dependNode attached
    to a controller in the scene
    :type allControllers: boolean
    :param children: (Q E) Return true if the specified dependNode is a controller
    :type children: boolean
    :param group: (C Q E) Create a controller that is not associated with any object  This new
    controller will be the parent of all the selected objects
    :type group: boolean
    :param index: (Q E) In query mode, returns the index of the controller in the parent
    controller's list of children  In edit mode, reorder the parent controller's childre
    :type index: int
    :param isController: (C Q E) Returns true if the specified dependNode is a controller
    :type isController: string
    :param parent: (C Q E) Set or query the parent controller of the selected controller node
    :type parent: boolean
    :param pickWalkDown: (Q E) Return the first child
    :type pickWalkDown: boolean
    :param pickWalkLeft: (Q E) Return the previous sibling
    :type pickWalkLeft: boolean
    :param pickWalkRight: (Q E) Return the next sibling
    :type pickWalkRight: boolean
    :param pickWalkUp: (Q E) Return the parent
    :type pickWalkUp: boolean
    :param unparent: (Q E) Unparent all selected controller objects from their respective
    parent
    :type unparent: boolean
    
    :returns: Command result
    :rtype: string
    """
    pass


def ThreePointArcTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UniversalManipOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dagObjectCompare(*args, attribute=True, bail="", connection=True, namespace="",
                     relative=True, short=True, type=True, **kwargs):
    """
    dagObjectCompare can be used to compare to compare objects based on:  type - Currently
    supports transform nodes and shape nodes relatives - Compares DAG objects' children and
    parents connections - Checks to make sure the two dags are connected to the same sources
    and destinations attributes - Checks to make sure that the properties of active attrib
    
    :param attribute: (C) Compare dag object attributes
    :type attribute: boolean
    :param bail: (C) Bail on first error or bail on category  Legal values are "never", "first",
    and "category"
    :type bail: string
    :param connection: (C) Compare dag connections
    :type connection: boolean
    :param namespace: (C) The baseline namespace
    :type namespace: string
    :param relative: (C) dag relatives
    :type relative: boolean
    :param short: (C) Compress output to short form (not as verbose)
    :type short: boolean
    :param type: (C) Compare based on dag object type
    :type type: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def pluginInfo(*args, activeFile=True, animCurveInterp="", apiVersion=True, autoload=True,
               cacheFormat=True, changedCommand=None, command="", constraintCommand=True,
               controlCommand=True, data=None, dependNode=True, dependNodeByType="",
               dependNodeId="", device=True, dragAndDropBehavior=True, iksolver=True,
               listPlugins=True, listPluginsPath=True, loadPluginPrefs=True, loaded=True,
               modelEditorCommand=True, name="", path="", pluginsInUse=True,
               referenceTranslators=True, registered=True, remove=True, renderer=True,
               savePluginPrefs=True, serviceDescriptions=True, settings=True, tool="",
               translator=True, unloadOk=True, userNamed=True, vendor="", version=True,
               writeRequires=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command provides access to the plug-in registry of the application  It is used mainly
    to query the characteristics of registered plug-ins  Plugins automatically become
    registered the first time that they are loaded   The argument is either the internal name
    of the plug-in or the path to access it
    
    :param activeFile: (Q) Restricts the command to the active file only, not the entire scene 
    This only affects the dependNode/dn and pluginsInUse/pu flags  For use during ex
    :type activeFile: boolean
    :param animCurveInterp: (Q) Returns a string array containing the names of all of the
    animation curve interpolators registered by this plug-in
    :type animCurveInterp: string
    :param apiVersion: (Q) Returns a string containing the version of the API that this plug-in
    was compiled with  See the comments in MTypes.h for the details on how to interp
    :type apiVersion: boolean
    :param autoload: (C Q E) Sets whether or not this plug-in should be loaded every time the
    application starts up  Returns a boolean in query mode
    :type autoload: boolean
    :param cacheFormat: (Q) Returns a string array containing the names of all of the
    registered geometry cache formats
    :type cacheFormat: boolean
    :param changedCommand: (C) Adds a callback that will get executed every time the plug-in
    registry changes  Any other previously registered callbacks will also get called
    :type changedCommand: script
    :param command: (Q M) Returns a string array containing the names of all of the normal
    commands registered by this plug-in  Constraint, control, context and model editor c
    :type command: string
    :param constraintCommand: (Q) Returns a string array containing the names of all of the
    constraint commands registered by this plug-in
    :type constraintCommand: boolean
    :param controlCommand: (Q) Returns a string array containing the names of all of the
    control commands registered by this plug-in
    :type controlCommand: boolean
    :param data: (Q M) Returns a string array containing the names of all of the data types
    registered by this plug-in
    :type data: [string, string]
    :param dependNode: (Q M) Returns a string array containing the names of all of the custom
    nodes types registered by this plug-in
    :type dependNode: boolean
    :param dependNodeByType: (Q) Returns a string array of all registered node types within a
    specified class of nodes  Each custom node type registered by a plug-in belongs to a mor
    :type dependNodeByType: string
    :param dependNodeId: (Q) Returns an integer array containing the ids of all of the custom
    node types registered by this plug-in
    :type dependNodeId: string
    :param device: (Q) Returns a string array containing the names of all of the devices
    registered by this plug-in
    :type device: boolean
    :param dragAndDropBehavior: (Q) Returns a string array containing the names of all of the
    drag and drop behaviors registered by this plug-in
    :type dragAndDropBehavior: boolean
    :param iksolver: (Q) Returns a string array containing the names of all of the ik solvers
    registered by this plug-in
    :type iksolver: boolean
    :param listPlugins: (Q) Returns a string array containing all the plug-ins that are
    currently loaded
    :type listPlugins: boolean
    :param listPluginsPath: (Q) Returns a string array containing the full paths of all the
    plug-ins that are currently loaded
    :type listPluginsPath: boolean
    :param loadPluginPrefs: (C) Loads the plug-in preferences (ie  autoload) from
    pluginPrefs.mel into Maya
    :type loadPluginPrefs: boolean
    :param loaded: (Q) Returns a boolean specifying whether or not the plug-in is loaded
    :type loaded: boolean
    :param modelEditorCommand: (Q) Returns a string array containing the names of all of the
    model editor commands registered by this plug-in
    :type modelEditorCommand: boolean
    :param name: (Q) Returns a string containing the internal name by which the plug-in is
    registered
    :type name: string
    :param path: (Q) Returns a string containing the absolute path name to the plug-in
    :type path: string
    :param pluginsInUse: (Q) Returns a string array containing all the plug-ins that are
    currently being used in the scene
    :type pluginsInUse: boolean
    :param referenceTranslators: (Q) If this flag is used in conjunction with the
    pluginsInUse/pu flag then it will modify the output  When true it will only show plug-ins
    currently in u
    :type referenceTranslators: boolean
    :param registered: (Q) Returns a boolean specifying whether or not plug-in is currently
    registered with the system
    :type registered: boolean
    :param remove: (E) Removes the given plug-in's record from the registry  There is no return
    value
    :type remove: boolean
    :param renderer: (Q) Returns a string array containing the names of all of the renderers
    registered by this plug-in
    :type renderer: boolean
    :param savePluginPrefs: (C) Saves the plug-in preferences (ie  autoload) out to
    pluginPrefs.mel
    :type savePluginPrefs: boolean
    :param serviceDescriptions: (Q) If there are services in use, then this flag will return a
    string array containing short descriptions saying what those services are
    :type serviceDescriptions: boolean
    :param settings: (Q) Returns an array of values with the loaded, autoload, registered
    flags
    :type settings: boolean
    :param tool: (Q M) Returns a string array containing the names of all of the tool contexts
    registered by this plug-in
    :type tool: string
    :param translator: (Q) Returns a string array containing the names of all of the file
    translators registered by this plug-in
    :type translator: boolean
    :param unloadOk: (Q) Returns a boolean that specifies whether or not the plug-in can be
    safely unloaded  It will return false if the plug-in is currently in use  For exam
    :type unloadOk: boolean
    :param userNamed: (Q) Returns a boolean specifying whether or not the plug-in has been
    assigned a name by the user
    :type userNamed: boolean
    :param vendor: (Q) Returns a string containing the vendor of the plug-in
    :type vendor: string
    :param version: (Q) Returns a string containing the version the plug-in
    :type version: boolean
    :param writeRequires: (C Q E) Sets whether or not this plug-in should write "requires"
    command into the saved file  "requires" command could autoload the plug-in when you open
    or
    :type writeRequires: boolean
    
    :returns: Dependent upon the action requested.
    :rtype: Any
    """
    pass


def xgmGrabBrushContext(*args, **kwargs):
    """
    
    """
    pass


def Radial(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateSubdivSurface(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def subdMirror(*args, caching=True, nodeState=0, xMirror=False, yMirror=False, zMirror=False,
               constructionHistory=True, name="", object=True, q=True, query=True, e=True,
               edit=True, **kwargs):
    """
    This command takes a subdivision surface, passed as the argument, and produces a
    subdivision surface that is a mirror  Returns the name of the subdivision surface created
    and optionally the DG node that does the mirroring
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param xMirror: (C Q E) Mirror the vertices in X Default: false
    :type xMirror: boolean
    :param yMirror: (C Q E) Mirror the vertices in Y Default: false
    :type yMirror: boolean
    :param zMirror: (C Q E) Mirror the vertices in Z Default: false
    :type zMirror: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    
    :returns: The subdivision surface and optionally the dependency node name
    :rtype: string[]
    """
    pass


def HypershadeDisplayNoShapes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def u3dOptimize(*args, **kwargs):
    """
    
    """
    pass


def dR_wireframeSmoothTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def modelEditor(*args, activeComponentsXray=True, activeCustomEnvironment="",
                activeCustomGeometry="", activeCustomLighSet="",
                activeCustomOverrideGeometry="", activeCustomRenderer="", activeOnly=True,
                activeShadingGraph="", activeView=True, addObjects="", addSelected=True,
                addSelectedObjects=True, allObjects=True, backfaceCulling=True, bufferMode="",
                bumpResolution=None, camera="", cameraName="", cameraSet="", cameraSetup=True,
                cameras=True, capture="", captureSequenceNumber=0, clipGhosts=True,
                cmEnabled=True, colorMap=True, colorResolution=None, control=True,
                controlVertices=True, cullingOverride="", default=True, defineTemplate="",
                deformers=True, dimensions=True, displayAppearance="", displayLights="",
                displayTextures=True, docTag="", dynamicConstraints=True, dynamics=True,
                editorChanged=None, exists=True, exposure=0.0, filter="",
                filteredObjectList=True, fluids=True, fogColor=None, fogDensity=0.0, fogEnd=0.0,
                fogMode="", fogSource="", fogStart=0.0, fogging=True, follicles=True,
                forceMainConnection="", gamma=0.0, greasePencils=True, grid=True,
                hairSystems=True, handles=True, headsUpDisplay=True, height=True,
                highlightConnection="", hulls=True, ignorePanZoom=True, ikHandles=True,
                imagePlane=True, interactive=True, interactiveBackFaceCull=True,
                interactiveDisableShadows=True, isFiltered=True, jointXray=True, joints=True,
                lights=True, lineWidth=0.0, locators=True, lockMainConnection=True,
                lowQualityLighting=True, mainListConnection="", manipulators=True,
                maxConstantTransparency=0.0, maximumNumHardwareLights=True, modelPanel="",
                motionTrails=True, nCloths=True, nParticles=True, nRigids=True, noUndo=True,
                nurbsCurves=True, nurbsSurfaces=True, objectFilter=None, objectFilterList=None,
                objectFilterListUI=None, objectFilterShowInHUD=True, objectFilterUI=None,
                occlusionCulling=True, panel="", parent="", particleInstancers=True,
                pivots=True, planes=True, pluginObjects=None, pluginShapes=True,
                polymeshes=True, queryPluginObjects="", removeSelected=True,
                rendererDeviceName=True, rendererList=True, rendererListUI=True,
                rendererName="", rendererOverrideList=True, rendererOverrideListUI=True,
                rendererOverrideName="", resetCustomCamera=True, sceneRenderFilter="",
                selectionConnection="", selectionHiliteDisplay=True, setSelected=True,
                shadingModel=0, shadows=True, smallObjectCulling=True, smallObjectThreshold=0.0,
                smoothWireframe=True, sortTransparent=True, stateString=True,
                stereoDrawMode=True, strokes=True, subdivSurfaces=True, textureAnisotropic=True,
                textureCompression=True, textureDisplay="", textureEnvironmentMap=True,
                textureHilight=True, textureMaxSize=0, textureMemoryUsed=True,
                textureSampling=0, textures=True, toggleExposure=True, toggleGamma=True,
                transpInShadows=True, transparencyAlgorithm="", twoSidedLighting=True,
                unParent=True, unlockMainConnection=True, updateColorMode=True,
                updateMainConnection=True, useBaseRenderer=True, useColorIndex=True,
                useDefaultMaterial=True, useInteractiveMode=True, useRGBImagePlane=True,
                useReducedRenderer=True, useTemplate="", userNode="", viewObjects=True,
                viewSelected=True, viewTransformName="", viewType=True, width=True,
                wireframeBackingStore=True, wireframeOnShaded=True, xray=True, q=True,
                query=True, e=True, edit=True, **kwargs):
    """
    Create, edit or query a model editor   Note that some of the flags of this command may have
    different settings for normal mode and for interactive/playback mode  For example, a
    modelEditor can be set to use shaded mode normally, but to use wireframe during playback
    for greater speed  Some flags also support having defaults set so that new model edi
    
    :param activeComponentsXray: (Q E) Turns on or off Xray mode for active components
    :type activeComponentsXray: boolean
    :param activeCustomEnvironment: (E) Specifies a path to an image file to be used as
    environment map  It is only enabled when a valid scene render filter is specified
    :type activeCustomEnvironment: string
    :param activeCustomGeometry: (Q E) Specifies an identifier for custom geometry to override
    the geometry to display  It is only enabled when a valid scene render filter is specified
    :type activeCustomGeometry: string
    :param activeCustomLighSet: (Q E) Specifies an identifier for the light set to use with a
    scene render filter  It is only enabled when a valid scene render filter is specified
    :type activeCustomLighSet: string
    :param activeCustomOverrideGeometry: (Q E) Specifies an identifier for an override on the
    custom geometry for a scene render filter
    :type activeCustomOverrideGeometry: string
    :param activeCustomRenderer: (Q E) Specifies an identifier for custom renderer to use when
    a valid scene render filter is also specified
    :type activeCustomRenderer: string
    :param activeOnly: (Q E) Sets whether only active objects should appear shaded in shaded
    display
    :type activeOnly: boolean
    :param activeShadingGraph: (Q E) Specifies the shading graph to use to override material
    display  Only enabled when a valid scene render filter is specified
    :type activeShadingGraph: string
    :param activeView: (Q E) Sets this model editor to be the active view  Returns true if
    successful  On query this flag will return whether the view is the active view
    :type activeView: boolean
    :param addObjects: (E) This flag causes the objects contained within the selection
    connection to be added to the list of objects visible in the view (if viewSelected is tru
    :type addObjects: string
    :param addSelected: (E) This flag causes the currently active objects to be added to the
    list of objects visible in the view (if viewSelected is true)
    :type addSelected: boolean
    :param addSelectedObjects: (C) If set then add the selected objects to the editor
    :type addSelectedObjects: boolean
    :param allObjects: (Q E) Turn on/off the display of all objects for the view of the model
    editor  This excludes NURBS, CVs, hulls, grids and manipulators
    :type allObjects: boolean
    :param backfaceCulling: (Q E) Turns on or off backface culling for the whole view  This
    setting overrides the culling settings of individual objects  All objects draw in the view
    :type backfaceCulling: boolean
    :param bufferMode: (Q E) Deprecated: this is not supported in Viewport 2.0  Sets the
    graphic buffer mode  Possible values are "single" or "double"
    :type bufferMode: string
    :param bumpResolution: (Q E) Set the resolution for "baked" bump map textures when using
    the hardware renderer  The default value is 512, 512 respectively
    :type bumpResolution: [int, int]
    :param camera: (Q E) Change or query the name of the camera in model editor
    :type camera: string
    :param cameraName: (C E) Set the name of the panel's camera transform and shape  The shape
    name is computed by appending the string "Shape" to the transform name  This flag m
    :type cameraName: string
    :param cameraSet: (C Q E) Name of the camera set
    :type cameraSet: string
    :param cameraSetup: (Q) Based on the model editor name passed in will returns a string list
    containing camera setups  A camera setup can contain one or more cameras which ar
    :type cameraSetup: boolean
    :param cameras: (Q E) Turn on/off the display of cameras for the view of the model editor
    :type cameras: boolean
    :param capture: (Q E) Perform an one-time capture of the viewport to the named image file
    on disk
    :type capture: string
    :param captureSequenceNumber: (Q E) When a number greater or equal to 0 is specified each
    subsequent refresh will save an image file to disk if the capture flag has been enabled 
    The na
    :type captureSequenceNumber: int
    :param clipGhosts: (C Q E) Define whether the clip ghosts should be added or not
    :type clipGhosts: boolean
    :param cmEnabled: (Q E) Turn on or off applying color management in the editor  If set, the
    color management configuration set in the current editor is used
    :type cmEnabled: boolean
    :param colorMap: (Q) Queries the color map style for the model panel  Possible values are
    "colorIndex" and "rgb"
    :type colorMap: boolean
    :param colorResolution: (Q E) Set the resolution for "baked" color textures when using the
    hardware renderer  The default value is 256, 256 respectively
    :type colorResolution: [int, int]
    :param control: (Q) Query only  Returns the top level control for this editor  Usually used
    for getting a parent to attach popup menus  Caution: It is possible for an ed
    :type control: boolean
    :param controlVertices: (Q E) Turn on/off the display of NURBS CVs for the view of the
    model editor
    :type controlVertices: boolean
    :param cullingOverride: (Q E) Set whether to override the culling attributes on objects
    when using the hardware renderer  The options are: "none" : Use the culling object
    attribut
    :type cullingOverride: string
    :param default: (Q E) Causes this command to modify the default value of this setting 
    Newly created model editors will inherit the values  This flag may be used with the
    :type default: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param deformers: (Q E) Turn on/off the display of deformer objects for the view of the
    model editor
    :type deformers: boolean
    :param dimensions: (Q E) Turn on/off the display of dimension objects for the view of the
    model editor
    :type dimensions: boolean
    :param displayAppearance: (Q E) Sets the display appearance of the model panel  Possible
    values are "wireframe", "points", "boundingBox", "smoothShaded", "flatShaded"  This flag
    may
    :type displayAppearance: string
    :param displayLights: (Q E) Sets the lighting for shaded mode  Possible values are
    "selected", "active", "all", "default", "none"
    :type displayLights: string
    :param displayTextures: (Q E) Turns on or off display of textures in shaded mode
    :type displayTextures: boolean
    :param docTag: (C Q E) Attaches a tag to the editor
    :type docTag: string
    :param dynamicConstraints: (Q E) Turn on/off the display of dynamicConstraints for the view
    of the model editor
    :type dynamicConstraints: boolean
    :param dynamics: (Q E) Turn on/off the display of dynamics objects for the view of the
    model editor
    :type dynamics: boolean
    :param editorChanged: (C Q E) An optional script callback which is called when the editors
    options have changed  This is useful in a situation where a scripted panel contains a mo
    :type editorChanged: script
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param exposure: (Q E) The exposure value used by the color management of the current
    editor
    :type exposure: float
    :param filter: (C Q E) Specifies the name of an itemFilter object to be used with this
    editor  This filters the information coming onto the main list of the editor
    :type filter: string
    :param filteredObjectList: (Q) For model editors with filtering on (either using an object
    filter, or isolate select), this flag returns a string list of the objects which are disp
    :type filteredObjectList: boolean
    :param fluids: (Q E) Turn on/off the display of fluids for the view of the model editor
    :type fluids: boolean
    :param fogColor: (Q E) The color used for hardware fogging
    :type fogColor: [float, float, float, float]
    :param fogDensity: (Q E) Determines the density of hardware fogging
    :type fogDensity: float
    :param fogEnd: (Q E) The end location of hardware fogging
    :type fogEnd: float
    :param fogMode: (Q E) This determines the drop-off mode for fog  The possibilities are:
    "linear" : linear drop-off "exponent" : exponential drop-off "exponent2" : squared
    :type fogMode: string
    :param fogSource: (Q E) Set the type of fog algorithm to use  If the argument is "fragment"
    (default) then fog is computed per pixel  If the argument is "coordinate" then if
    :type fogSource: string
    :param fogStart: (Q E) The start location of hardware fogging
    :type fogStart: float
    :param fogging: (Q E) Set whether hardware fogging is enabled or not
    :type fogging: boolean
    :param follicles: (Q E) Turn on/off the display of follicles for the view of the model
    editor
    :type follicles: boolean
    :param forceMainConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type forceMainConnection: string
    :param gamma: (Q E) The gamma value used by the color management of the current editor
    :type gamma: float
    :param greasePencils: (C Q E) Define whether the grease pencil marks should be added or
    not
    :type greasePencils: boolean
    :param grid: (Q E) Turn on/off the display of the grid for the view of the model editor
    :type grid: boolean
    :param hairSystems: (Q E) Turn on/off the display of hairSystems for the view of the model
    editor
    :type hairSystems: boolean
    :param handles: (Q E) Turn on/off the display of select handles for the view of the model
    editor
    :type handles: boolean
    :param headsUpDisplay: (Q E) Sets whether the model panel will draw any enabled heads up
    display elements in this window (if true)  Currently this requires the HUD elements to be
    :type headsUpDisplay: boolean
    :param height: (Q) Return the height of the associated viewport in pixels
    :type height: boolean
    :param highlightConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its highlight list  Not all editors have a highlight list 
    F
    :type highlightConnection: string
    :param hulls: (Q E) Turn on/off the display of NURBS hulls for the view of the model
    editor
    :type hulls: boolean
    :param ignorePanZoom: (Q E) Sets whether the model panel will ignore the 2D pan/zoom value
    to give an overview of the scene
    :type ignorePanZoom: boolean
    :param ikHandles: (Q E) Turn on/off the display of ik handles and end effectors for the
    view of the model editor
    :type ikHandles: boolean
    :param imagePlane: (Q E) Turn on/off the display of image plane for the view
    :type imagePlane: boolean
    :param interactive: (Q E) Causes this command to modify the interactive refresh settings of
    the view  In this way it is possible to change the behavior of the model editor dur
    :type interactive: boolean
    :param interactiveBackFaceCull: (C Q E) Define whether interactive backface culling should
    be on or not
    :type interactiveBackFaceCull: boolean
    :param interactiveDisableShadows: (C Q E) Define whether interactive shadows should be
    disabled or not
    :type interactiveDisableShadows: boolean
    :param isFiltered: (Q) Returns true for model editors with filtering applied to their view
    of the scene  This could either be an explicit object filter, or a display option
    :type isFiltered: boolean
    :param jointXray: (Q E) Turns on or off Xray mode for joints
    :type jointXray: boolean
    :param joints: (Q E) Turn on/off the display of joints for the view of the model editor
    :type joints: boolean
    :param lights: (Q E) Turn on/off the display of lights for the view of the model editor
    :type lights: boolean
    :param lineWidth: (Q E) Set width of lines for display
    :type lineWidth: float
    :param locators: (Q E) Turn on/off the display of locator objects for the view of the model
    editor
    :type locators: boolean
    :param lockMainConnection: (C E) Locks the current list of objects within the
    mainConnection, so that only those objects are displayed within the editor  Further changes
    to the origi
    :type lockMainConnection: boolean
    :param lowQualityLighting: (Q E) Set whether to use "low quality lighting" when using the
    hardware renderer  The default value is false
    :type lowQualityLighting: boolean
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type mainListConnection: string
    :param manipulators: (Q E) Turn on/off the display of manipulator objects for the view of
    the model editor
    :type manipulators: boolean
    :param maxConstantTransparency: (Q E) Sets the maximum constant transparency  Setting this
    value remaps constant transparency values from the range [0.0, 1.0] to the range [0.0,
    maxConsta
    :type maxConstantTransparency: float
    :param maximumNumHardwareLights: (C Q E) Define whether the hardware light maximum should
    be respected or not
    :type maximumNumHardwareLights: boolean
    :param modelPanel: (C) Allows the created model editor to be embedded in the named model
    panel  Intended for use with custom model editors created via the API (i.e  the fla
    :type modelPanel: string
    :param motionTrails: (Q E) Turn on/off the Motion Trail display in the Viewport
    :type motionTrails: boolean
    :param nCloths: (Q E) Turn on/off the display of nCloths for the view of the model editor
    :type nCloths: boolean
    :param nParticles: (Q E) Turn on/off the display of nParticles for the view of the model
    editor
    :type nParticles: boolean
    :param nRigids: (Q E) Turn on/off the display of nRigids for the view of the model editor
    :type nRigids: boolean
    :param noUndo: (E) This flag prevents some viewport operations (such as isolate select)
    from being added to the undo queue
    :type noUndo: boolean
    :param nurbsCurves: (Q E) Turn on/off the display of nurbs curves for the view of the model
    editor
    :type nurbsCurves: boolean
    :param nurbsSurfaces: (Q E) Turn on/off the display of nurbs surfaces for the view of the
    model editor
    :type nurbsSurfaces: boolean
    :param objectFilter: (Q E) Set or query the current object filter name  An object filter is
    required to have already been registered
    :type objectFilter: script
    :param objectFilterList: (Q) Return a list of names of registered filters
    :type objectFilterList: script
    :param objectFilterListUI: (Q) Return a list of UI names of registered filters
    :type objectFilterListUI: script
    :param objectFilterShowInHUD: (Q E) Sets whether or not to display the object filter UI
    name in the heads up display when an object filter is active  This string is concatenated
    with th
    :type objectFilterShowInHUD: boolean
    :param objectFilterUI: (Q) Query the current object filter UI name  The object filter is
    required to have already been registered
    :type objectFilterUI: script
    :param occlusionCulling: (Q E) Set whether to enable occlusion culling testing when using
    the hardware renderer  The default value is false
    :type occlusionCulling: boolean
    :param panel: (C Q) Specifies the panel for this editor  By default if an editor is created
    in the create callback of a scripted panel it will belong to that panel  If a
    :type panel: string
    :param parent: (C Q E) Specifies the parent layout for this editor  This flag will only
    have an effect if the editor is currently un-parented
    :type parent: string
    :param particleInstancers: (C Q E) Define whether the particle instances should be shown or
    not
    :type particleInstancers: boolean
    :param pivots: (Q E) Turn on/off the display of transform pivots for the view of the model
    editor
    :type pivots: boolean
    :param planes: (Q E) Turn on/off the display of sketch planes for the view of the model
    editor
    :type planes: boolean
    :param pluginObjects: (E M) Turn on/off the display of plug-in objects for the view  It
    depends on the plug-in implementation whether to respect this flag
    :type pluginObjects: [string, boolean]
    :param pluginShapes: (E) Turn on/off the display of plug-in shapes for the view  It depends
    on the plug-in implementation whether to respect this flag
    :type pluginShapes: boolean
    :param polymeshes: (Q E) Turn on/off the display of polygon meshes for the view of the
    model editor
    :type polymeshes: boolean
    :param queryPluginObjects: (Q) Query the on/off state of plug-in objects display for the
    view  To set the on/off state, use -pluginObjects instead
    :type queryPluginObjects: string
    :param removeSelected: (E) This flag causes the currently active objects to be removed from
    the list of objects visible in the view (if viewSelected is true)
    :type removeSelected: boolean
    :param rendererDeviceName: (Q) Query for the name of the draw API used by the Viewport 2.0
    renderer for a 3d modeling viewport  The possible return values are "VirtualDeviceGL" if
    :type rendererDeviceName: boolean
    :param rendererList: (Q) Query for a list of the internal names for renderers available for
    use with the 3d modeling viewport  The default list contains at least "vp2Renderer
    :type rendererList: boolean
    :param rendererListUI: (Q) Query for a list of the UI names for renderers available for use
    with the 3d modeling viewport  The default list consists of the UI name for "vp2Rend
    :type rendererListUI: boolean
    :param rendererName: (Q E) Set or get the renderer used for a 3d modeling viewport  The
    name provided should be an internal name of a renderer  The 'rendererList' flag can be u
    :type rendererName: string
    :param rendererOverrideList: (Q) Query for a list of the internal names for renderer
    overrides for a 3d viewport renderer  Currently only the "Viewport 2" renderer supports
    renderer
    :type rendererOverrideList: boolean
    :param rendererOverrideListUI: (Q) Query for a list of the UI names for renderer overrides
    for a 3d viewport renderer  Currently only the "Viewport 2" renderer supports renderer
    overri
    :type rendererOverrideListUI: boolean
    :param rendererOverrideName: (Q E) Set or get the override used for a 3d viewport renderer 
    The name provided should be the internal name for an override  The 'rendererOverrideList'
    fl
    :type rendererOverrideName: string
    :param resetCustomCamera: (E) When specified will reset the camera transform for the active
    custom camera used for a scene render filter  It is only enabled when a valid scene ren
    :type resetCustomCamera: boolean
    :param sceneRenderFilter: (Q E) Specifies the name of a scene render filter
    :type sceneRenderFilter: string
    :param selectionConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its own selection list  As the user selects things in this
    e
    :type selectionConnection: string
    :param selectionHiliteDisplay: (Q E) Sets whether the model panel will draw any selection
    hiliting on the objects in this window
    :type selectionHiliteDisplay: boolean
    :param setSelected: (E) This flag causes the currently active objects to be the only
    objects visible in the view (if viewSelected is true)
    :type setSelected: boolean
    :param shadingModel: (C Q E) Shading model to use
    :type shadingModel: int
    :param shadows: (Q E) Turn on/off the display of hardware shadows in shaded mode
    :type shadows: boolean
    :param smallObjectCulling: (C Q E) Define whether small object culling should be enabled or
    not
    :type smallObjectCulling: boolean
    :param smallObjectThreshold: (C Q E) Threshold used for small object culling
    :type smallObjectThreshold: float
    :param smoothWireframe: (Q E) Turns on or off smoothing of wireframe lines and points
    :type smoothWireframe: boolean
    :param sortTransparent: (Q E) This flag turns on/off sorting of transparent objects during
    shaded mode refresh  Normally, objects are sorted according to their origin in camera sp
    :type sortTransparent: boolean
    :param stateString: (Q) Query only flag  Returns the MEL command that will create an editor
    to match the current editor state  The returned command string uses the string va
    :type stateString: boolean
    :param stereoDrawMode: (C Q E) If this flag is used then set stereo draw mode
    :type stereoDrawMode: boolean
    :param strokes: (Q E) Turn on/off the display of Paint Effects strokes for the view
    :type strokes: boolean
    :param subdivSurfaces: (Q E) Turn on/off the display of subdivision surfaces for the view
    of the model editor
    :type subdivSurfaces: boolean
    :param textureAnisotropic: (Q E) Set whether to perform anisotropic texture filtering  Will
    work only if the anisotropic texture filtering extension is supported in OpenGL on the gra
    :type textureAnisotropic: boolean
    :param textureCompression: (C Q E) Defines whether texture compression should be used or
    not
    :type textureCompression: boolean
    :param textureDisplay: (Q E) Set the type of blending to use for textures  The blend is
    performed between the destination fragment and the texture fragment  The source is usually
    :type textureDisplay: string
    :param textureEnvironmentMap: (C Q E) If true then use a texture environment map
    :type textureEnvironmentMap: boolean
    :param textureHilight: (Q E) Set whether to show specular hilighting when the display is in
    shaded textured mode
    :type textureHilight: boolean
    :param textureMaxSize: (Q E) Set maximum texture size for hardware texturing  The integer
    value must be a power of 2  Recommended values are 128 or 256  If the value specified is
    :type textureMaxSize: int
    :param textureMemoryUsed: (Q) Returns the total number of bytes used by all texture maps 
    This is typicly width*height*channels for all texture objects in the scene If the texture
    :type textureMemoryUsed: boolean
    :param textureSampling: (Q E) Set the type of sampling to be used for texture display  The
    argument can be either: 1 : means to perform point sample 2 : means to perform bilinear
    :type textureSampling: int
    :param textures: (Q E) Turn on/off the display of texture objects for the view
    :type textures: boolean
    :param toggleExposure: (E) Toggles between the current and the default exposure value of
    the editor
    :type toggleExposure: boolean
    :param toggleGamma: (E) Toggles between the current and the default gamma value of the
    editor
    :type toggleGamma: boolean
    :param transpInShadows: (Q E) Set whether to enable display of transparency in shadows when
    using the hardware renderer  The default value is false
    :type transpInShadows: boolean
    :param transparencyAlgorithm: (Q E) Set the transparency algorithm  The options are: 1)
    "frontAndBackCull" : Two pass front and back culling technique  2) "perPolygonSort" : Draw
    transp
    :type transparencyAlgorithm: string
    :param twoSidedLighting: (Q E) Turns on or off two sided lighting  This may be used with
    the -default flag
    :type twoSidedLighting: boolean
    :param unParent: (C E) Specifies that the editor should be removed from its layout  This
    cannot be used in query mode
    :type unParent: boolean
    :param unlockMainConnection: (C E) Unlocks the mainConnection, effectively restoring the
    original mainConnection (if it is still available), and dynamic updates
    :type unlockMainConnection: boolean
    :param updateColorMode: (E) Using this flag tells the model panel to check which color mode
    it should be in, and to switch accordingly  This flag may be used to update a model p
    :type updateColorMode: boolean
    :param updateMainConnection: (C E) Causes a locked mainConnection to be updated from the
    orginal mainConnection, but preserves the lock state
    :type updateMainConnection: boolean
    :param useBaseRenderer: (Q E) Set whether to use the "base" renderer when using the
    hardware renderer and in "interactive display mode" (-useInteractiveMode) The default value
    is
    :type useBaseRenderer: boolean
    :param useColorIndex: (Q E) Sets whether the model panel will attempt to use color index
    mode when possible  Color index mode can provide a performance increase for point, bound
    :type useColorIndex: boolean
    :param useDefaultMaterial: (Q E) Sets whether the model panel will draw all the shaded
    surfaces using the default material as opposed to using the material(s) currently assigned
    to t
    :type useDefaultMaterial: boolean
    :param useInteractiveMode: (Q E) Turns on or off the use of the special interaction
    settings during playback  This flag may be used with the -default flag
    :type useInteractiveMode: boolean
    :param useRGBImagePlane: (Q E) Sets whether the model panel will be forced into RGB mode
    when there is an image plane attached to the panel's camera
    :type useRGBImagePlane: boolean
    :param useReducedRenderer: (C Q E) Set true if using the reduced renderer
    :type useReducedRenderer: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param userNode: (Q E) Allows the user to associate a node name with the modelEditor  The
    value is automatically updated in the event the node is deleted or renamed
    :type userNode: string
    :param viewObjects: (Q) Returns the name (if any) of the objectSet which contains the list
    of objects visible in the view if viewSelected is true and the list of objects bei
    :type viewObjects: boolean
    :param viewSelected: (Q E) This flag turns on/off viewing of selected objects  When the
    flag is set to true, the currently active objects are captured and used as the list of o
    :type viewSelected: boolean
    :param viewTransformName: (Q E) Sets the view pipeline to be applied if color management is
    enabled in the current editor
    :type viewTransformName: string
    :param viewType: (Q) Returns a string indicating the type of the model editor  For the
    default model editor, returns the empty string  For custom model editor types creat
    :type viewType: boolean
    :param width: (Q) Return the width of the associated viewport in pixels
    :type width: boolean
    :param wireframeBackingStore: (Q E) Sets whether a backing store is used to optimization
    the drawing of active objects  This mode can provide a performance increase in wireframe
    mode fo
    :type wireframeBackingStore: boolean
    :param wireframeOnShaded: (Q E) Sets whether the model panel will draw the wireframe on all
    shaded objects (if true) or only for active objects (if false)
    :type wireframeOnShaded: boolean
    :param xray: (Q E) Turns on or off Xray mode  This may be used with the -default flag
    :type xray: boolean
    
    :returns: the name of the editor.
    :rtype: string
    """
    pass


def SculptPolygonsToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ModifyUpperRadiusRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def roll(*args, absolute=True, degree=0.0, relative=True, **kwargs):
    """
    The roll command rotates a camera about its viewing direction, a positive angle produces
    clockwise camera rotation, while a negative angle produces counter-clockwise camera
    rotation   The default mode is relative and the rotation is applied with respect to the
    current orientation of the camera  When mode is set to absolute, the rotation is applied
    
    
    :param absolute: (C) Set to absolute mode
    :type absolute: boolean
    :param degree: (C) Set the amount of the rotation angle
    :type degree: float
    :param relative: (C) Set to relative mode
    :type relative: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def ConvertSelectionToContainedFaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SlideEdgeTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorFramePlaybackRange(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Export(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Bend(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorKeepTransitionsTogglePress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetMeshSmearTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectBrushNames(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def constrain(*args, barrier=True, damping=0.0, directionalHinge=True, hinge=True,
              interpenetrate=True, nail=True, name="", orientation=None, pinConstraint=True,
              position=None, restLength=0.0, spring=True, stiffness=0.0, q=True, query=True,
              e=True, edit=True, **kwargs):
    """
    This command constrains rigid bodies to the world or other rigid bodies
    
    :param barrier: (C Q) Creates a barrier constraint  This command requires one rigid bodies
    :type barrier: boolean
    :param damping: (C Q E) Sets the damping constant  Default value: 0.1 Range: -1000.0 to
    1000.0
    :type damping: float
    :param directionalHinge: (C Q) Creates a directional hinge constraint  This command
    requires two rigid bodies  The directional hinge always maintains the initial direction of
    its a
    :type directionalHinge: boolean
    :param hinge: (C Q) Creates a hinge constraint  This command requires one or two rigid
    bodies
    :type hinge: boolean
    :param interpenetrate: (C Q E) Allows (or disallows) the rigid bodies defined in the
    constrain to ipenetrate
    :type interpenetrate: boolean
    :param nail: (C Q) Creates a nail constraint  This command requires one rigid body
    :type nail: boolean
    :param name: (C Q E) Names the rigid constraint
    :type name: string
    :param orientation: (C Q E) Set initial orientation of the constraint in world space  This
    command is only valid with hinge and barrier constraints Default value: 0.0 0.0 0.0
    :type orientation: [float, float, float]
    :param pinConstraint: (C Q) Creates a pin constraint  This command requires two rigid
    bodies
    :type pinConstraint: boolean
    :param position: (C Q E) Set initial position of the constraint in world space  Default
    value: 0.0 0.0 0.0 for uni-constraints, midpoint of bodies for deul constraint
    :type position: [float, float, float]
    :param restLength: (C Q E) Sets the rest length  Default value: 1.0
    :type restLength: float
    :param spring: (C Q) Creates a spring constraint  This command requires one or two
    rigidies
    :type spring: boolean
    :param stiffness: (C Q E) Sets the springs stiffness constant  Default value: 5.0
    :type stiffness: float
    
    :returns: 
    :rtype: None
    """
    pass


def nexConnectContext(*args, **kwargs):
    """
    
    """
    pass


def cmdScrollFieldReporter(*args, annotation="", backgroundColor=None, clear=True,
                           copySelection=True, cutSelection=True, defineTemplate="", docTag="",
                           dragCallback=None, dropCallback=None, echoAllCommands=True,
                           enable=True, enableBackground=True, enableKeyboardFocus=True,
                           exists=True, filterSourceType="", fullPathName=True, hasFocus=True,
                           height=0, highlightColor=None, isObscured=True, lineNumbers=True,
                           manage=True, noBackground=True, numberOfPopupMenus=True, parent="",
                           pasteSelection=True, popupMenuArray=True, preventOverride=True,
                           receiveFocusCommand=None, saveSelection="",
                           saveSelectionToShelf=True, select=None, selectAll=True,
                           stackTrace=True, statusBarMessage="", suppressErrors=True,
                           suppressInfo=True, suppressResults=True, suppressStackTrace=True,
                           suppressWarnings=True, text="", textLength=True, useTemplate="",
                           visible=True, visibleChangeCommand=None, width=0, q=True, query=True,
                           e=True, edit=True, **kwargs):
    """
    A script editor reporter control used to receive and display the history of processed
    commmands
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param clear: (C E) Clears the field
    :type clear: boolean
    :param copySelection: (C E) Copies the current selection from this field
    :type copySelection: boolean
    :param cutSelection: (C E) Cuts the current selection from this field
    :type cutSelection: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param echoAllCommands: (C Q E) Echo all commands  (Global parameter, affects all command
    reporters)
    :type echoAllCommands: boolean
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param filterSourceType: (C Q E) Filters the specified source type from showing in this
    command reporter  Currently supports either "mel", "python", or "" (default)  Setting the
    filt
    :type filterSourceType: string
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param hasFocus: (Q) Whether this control is currently in focus
    :type hasFocus: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param lineNumbers: (C Q E) Show line numbers (in Error/Warning messages)  (Global
    parameter, affects all command reporters)
    :type lineNumbers: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param pasteSelection: (C E) Pastes text into this field at the current caret position
    :type pasteSelection: boolean
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param receiveFocusCommand: (C E) Command executed when the field receives focus
    :type receiveFocusCommand: script
    :param saveSelection: (C E) Prompts to save the current selection to a file  The default
    filename prompt will be prepended with the given string
    :type saveSelection: string
    :param saveSelectionToShelf: (C E) Prompts to save the current selection to an item in the
    shelf
    :type saveSelectionToShelf: boolean
    :param select: (C E) Selects text within a specified range
    :type select: [int, int]
    :param selectAll: (C E) Selects all text
    :type selectAll: boolean
    :param stackTrace: (C Q E) Show stack trace  (Global parameter, affects all command
    reporters)
    :type stackTrace: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param suppressErrors: (C Q E) Suppress errors
    :type suppressErrors: boolean
    :param suppressInfo: (C Q E) Suppress info
    :type suppressInfo: boolean
    :param suppressResults: (C Q E) Suppress results
    :type suppressResults: boolean
    :param suppressStackTrace: (C Q E) Suppress stack trace
    :type suppressStackTrace: boolean
    :param suppressWarnings: (C Q E) Suppress warnings
    :type suppressWarnings: boolean
    :param text: (C Q E) Replaces the field text with the given string
    :type text: string
    :param textLength: (Q) The number of characters in this text field
    :type textLength: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the reporter control
    :rtype: string
    """
    pass


def cameraView(*args, addBookmark=True, animate=True, bookmarkType=0, camera=None, name="",
               removeBookmark=True, setCamera=True, setView=True, e=True, edit=True, **kwargs):
    """
    This command creates a preset view for a camera which is then independent of the camera 
    The view stores a camera's eye point, center of interest point, up vector, tumble pivot,
    horizontal aperture, vertical aperature, focal length, orthographic width, and whether the
    camera is orthographic or perspective by default  Or you can only store 2D pan/zo
    
    :param addBookmark: (C E) Associate this view with the camera specified or the camera in
    the active model panel  This flag can be used for creation or edit
    :type addBookmark: boolean
    :param animate: (C E) Set the animation capability for view switches
    :type animate: boolean
    :param bookmarkType: (C) Specify the bookmark type, which can be: 0  3D bookmark; 1  2D
    Pan/Zoom bookmark
    :type bookmarkType: int
    :param camera: (E) Specify the camera to use  This flag should be used in conjunction with
    the add bookmark, remove bookmark, set camera, or set view flags  If this fla
    :type camera: name
    :param name: (C) Set the name of the view  This flag can only be used for creation
    :type name: string
    :param removeBookmark: (E) Remove the association of this view with the camera specified or
    the camera in the active model panel  This can only be used with edit
    :type removeBookmark: boolean
    :param setCamera: (E) Set this view into a camera specified by the camera flag or the
    camera in the active model panel  This flag can only be used with edit
    :type setCamera: boolean
    :param setView: (E) Set the camera view to match a camera specified or the active model
    panel  This flag can only be used with edit
    :type setView: boolean
    
    :returns: (name of the camera view)
    :rtype: string
    """
    pass


def TimeEditorPasteClips(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def orbitCtx(*args, alternateContext=True, exists=True, history=True, image1="", image2="",
             image3="", localOrbit=True, name="", orbitScale=0.0, toolName="", q=True,
             query=True, e=True, edit=True, **kwargs):
    """
    Create, edit, or query an orbit context
    
    :param alternateContext: (C Q) Set the ALT+MMB and ALT+SHIFT+MMB to refer to this context
    :type alternateContext: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param localOrbit: (C Q E) Orbit around the camera's center of interest
    :type localOrbit: boolean
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param orbitScale: (C Q E) In degrees of rotation per 100 pixels of cursor drag
    :type orbitScale: float
    :param toolName: (C Q) Name of the specific tool to which this command refers
    :type toolName: string
    
    :returns: The name of the context
    :rtype: string
    """
    pass


def DeleteMemoryCaching(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def profilerTool(*args, categoryView=True, collapseSelectedEvents=True,
                 collapseSelectedEventsRepetition=True, cpuView=True, destroy=True,
                 eventTypes=True, exists=True, expandSelectedEvents=True,
                 expandSelectedEventsRepetition=True, findNext=True, findPrevious=True,
                 frameAll=True, frameSelected=True, isolateSegment=0, make=True,
                 matchWholeWord=True, searchEvent="", segmentCount=True, showAllEvent=True,
                 showCriticalPath=True, showSelectedEvents=True,
                 showSelectedEventsRepetition=True, threadView=True, unisolateSegment=True,
                 q=True, query=True, e=True, edit=True, **kwargs):
    """
    This script is intended to be used by the profilerPanel to interact with the profiler
    tool's view (draw region)  It can be used to control some behaviors about the profiler Tool
    
    :param categoryView: (E) Change view mode to category view
    :type categoryView: boolean
    :param collapseSelectedEvents: (E) Hide all sub-events of selected events so that only
    top-level events show
    :type collapseSelectedEvents: boolean
    :param collapseSelectedEventsRepetition: (E) Hide all sub-events repetition of selected
    events based on their comment
    :type collapseSelectedEventsRepetition: boolean
    :param cpuView: (E) Change view mode to cpu view
    :type cpuView: boolean
    :param destroy: (C) Destroy the profiler tool Internal flag  Should not be used by user
    :type destroy: boolean
    :param eventTypes: (Q) Return JSON data containing the list of event types on currently
    existing events  If the value of the flag is true then show only event types for sel
    :type eventTypes: boolean
    :param exists: (Q) Query if the profiler tool view exists  Profiler tool can only exist
    after "profilerTool -make" is called
    :type exists: boolean
    :param expandSelectedEvents: (E) Show all sub-events of selected events
    :type expandSelectedEvents: boolean
    :param expandSelectedEventsRepetition: (E) Show all sub-events repetition of selected
    events based on their comment
    :type expandSelectedEventsRepetition: boolean
    :param findNext: (Q) This flag is used along with flag -searchEvent
    :type findNext: boolean
    :param findPrevious: (Q) This flag is used along with flag -searchEvent
    :type findPrevious: boolean
    :param frameAll: (E) Frame on all events in the profilerToolView
    :type frameAll: boolean
    :param frameSelected: (E) Frame on all selected events in the profilerToolView
    :type frameSelected: boolean
    :param isolateSegment: (E) Isolate a specified segment  A segment is a set of events that
    happened in one animation frame  You can use flag -segmentCount to query the number of
    :type isolateSegment: int
    :param make: (C) Make the profiler tool and parent it to the most recent layout created
    Internal flag  Should not be used by user
    :type make: boolean
    :param matchWholeWord: (E) Tells profiler tool if it should match whole word when searching
    event(s)  The default value is false
    :type matchWholeWord: boolean
    :param searchEvent: (Q) Search event(s)  You can set -matchWholeWord before you use
    -searchEvent  If -matchWholeWord has been set to true, the profiler tool will search even
    :type searchEvent: string
    :param segmentCount: (Q) Returns the number of segments in the event buffer
    :type segmentCount: boolean
    :param showAllEvent: (E) Show all events (if events were hidden by filtering) (true) or
    Hide all events (false)
    :type showAllEvent: boolean
    :param showCriticalPath: (E) Show critical path of selected frame
    :type showCriticalPath: boolean
    :param showSelectedEvents: (E) Show only the selected events (true) or hide all selected
    events (false)
    :type showSelectedEvents: boolean
    :param showSelectedEventsRepetition: (E) Show only the selected events repetition based on
    their comment (true) or Hide all selected events repetition based on their comment (false)
    :type showSelectedEventsRepetition: boolean
    :param threadView: (E) Change view mode to thread view
    :type threadView: boolean
    :param unisolateSegment: (E) Unisolate current isolated segment  If no segment is currently
    isolated, nothing will happen
    :type unisolateSegment: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def EmitFromObject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectUVOverlappingComponents(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Goal(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def substituteGeometry(*args, disableNonSkinDeformers=True, newGeometryToLayer=True,
                       oldGeometryToLayer=True, reWeightDistTolerance=0.0,
                       retainOldGeometry=True, **kwargs):
    """
    This command can be used to replace the geometry which is already connected to deformers
    with a new geometry  The weights on the old geometry will be retargeted to the new geometry
    
    :param disableNonSkinDeformers: (C) This flag controls the state of deformers other than
    skin deformers after the substitution has taken place  If the flag is true then non-skin
    deforme
    :type disableNonSkinDeformers: boolean
    :param newGeometryToLayer: (C) Create a new layer for the new geometry
    :type newGeometryToLayer: boolean
    :param oldGeometryToLayer: (C) Create a new layer and move the old geometry to this layer
    :type oldGeometryToLayer: boolean
    :param reWeightDistTolerance: (C) Specify the distance tolerance value to be used for
    retargeting weights  While transferring weights the command tries to find the corresponding
    verti
    :type reWeightDistTolerance: float
    :param retainOldGeometry: (C) A copy of the old geometry should be retained
    :type retainOldGeometry: boolean
    
    :returns: Name of shapes that were replaced
    :rtype: string
    """
    pass


def WarpImage(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GrowLoopPolygonSelectionRegion(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportAxisConversionMethod(*args, **kwargs):
    """
    
    """
    pass


def xgmGuideSculptToolCmd(*args, **kwargs):
    """
    
    """
    pass


def ToggleUVDistortion(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UVEditorFrameAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddTargetShape(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def listNodeTypes(*args, exclude="", **kwargs):
    """
    Lists dependency node types satisfying a specified classification string   See the
    'getClassification' command for a list of the standard classification strings
    
    :param exclude: (C) Nodes that satisfies this exclude classification will be filtered out
    :type exclude: string
    
    :returns: The type names of all node types in the system that satisfy the
    given
    classification string.
    :rtype: string[]
    """
    pass


def NodeEditorGraphRemoveSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MergeMultipleEdges(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def manipRotateContext(*args, activeHandle=0, alignAlong=None, centerTrackball=True,
                       constrainAlongNormal=True, currentActiveHandle=0, editPivotMode=True,
                       editPivotPosition=True, exists=True, image1="", image2="", image3="",
                       lastMode=0, manipVisible=True, mode=1, modifyTranslation=False,
                       orientAxes=None, orientObject="", orientTowards=None, pinPivot=True,
                       pivotOriHandle=True, position=True, postCommand=None,
                       postDragCommand=None, preCommand=None, preDragCommand=None,
                       preserveChildPosition=False, preserveUV=True, reflection=True,
                       reflectionAbout=0, reflectionAxis=0, reflectionTolerance=0.0,
                       rotate=None, snap=True, snapPivotOri=True, snapPivotPos=True,
                       snapRelative=True, snapValue=0.0, tweakMode=True, useCenterPivot=True,
                       useManipPivot=True, useObjectPivot=True, xformConstraint="", q=True,
                       query=True, e=True, edit=True, **kwargs):
    """
    This command can be used to create, edit, or query a rotate manip context
    
    :param activeHandle: (Q E) Sets the default active handle for the manip  That is, the
    handle which should be initially active when the tool is activated  Values can be: 0 - X a
    :type activeHandle: int
    :param alignAlong: (C E) Aligns active handle along vector
    :type alignAlong: [float, float, float]
    :param centerTrackball: (C Q E) Specify if the center is to be handled like a trackball
    :type centerTrackball: boolean
    :param constrainAlongNormal: (Q E) When true, transform constraints are applied along the
    vertex normal first and only use the closest point when no intersection is found along the
    nor
    :type constrainAlongNormal: boolean
    :param currentActiveHandle: (Q E) Sets the active handle for the manip  Values can be: 0 -
    X axis handle is active 1 - Y axis handle is active 2 - Z axis handle is active 3 - View
    rot
    :type currentActiveHandle: int
    :param editPivotMode: (Q) Returns true manipulator is in edit pivot mode
    :type editPivotMode: boolean
    :param editPivotPosition: (Q) Returns the current position of the edit pivot manipulator
    :type editPivotPosition: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param lastMode: (Q) Returns the previous rotation mode
    :type lastMode: int
    :param manipVisible: (Q) Returns true if the rotate manipulator is visible
    :type manipVisible: boolean
    :param mode: (Q E) Rotate mode: 0 - Object Space (default) 1 - World Space 2 - Gimbal Mode
    3 - Custom Axis Orientation 10 - Component Space
    :type mode: int
    :param modifyTranslation: (Q E) When false, and an object is rotated about a point other
    than its rotate pivot, its rotateTranslate attribute is modified to put the object at the
    co
    :type modifyTranslation: boolean
    :param orientAxes: (Q E) Orients manipulator rotating around axes by specified angles
    :type orientAxes: [float, float, float]
    :param orientObject: (C E) Orients manipulator to the passed in object/component
    :type orientObject: string
    :param orientTowards: (C E) Orients active handle towards world point
    :type orientTowards: [float, float, float]
    :param pinPivot: (Q E) Pin component pivot  When the component pivot is set and pinned
    selection changes will not reset the pivot position and orientation
    :type pinPivot: boolean
    :param pivotOriHandle: (Q E) When true, the pivot manipulator will show the orientation
    handle during editing  Default is true
    :type pivotOriHandle: boolean
    :param position: (Q) Returns the current position of the manipulator
    :type position: boolean
    :param postCommand: (C E) Specifies a command to be executed when the tool is exited
    :type postCommand: script
    :param postDragCommand: (C E) Specifies a command and a node type  The command will be
    executed at the end of a drag when a node of the specified type is in the selection
    :type postDragCommand: [script, string]
    :param preCommand: (C E) Specifies a command to be executed when the tool is entered
    :type preCommand: script
    :param preDragCommand: (C E) Specifies a command and a node type  The command will be
    executed at the start of a drag when a node of the specified type is in the selection
    :type preDragCommand: [script, string]
    :param preserveChildPosition: (Q E) When false, the children objects move when their parent
    is rotated  When true, the worldspace position of the children will be maintained as the
    pare
    :type preserveChildPosition: boolean
    :param preserveUV: (Q E) When false, the uvs are not changes to match the vertex edit  When
    true, the uvs are edited to project to new values to stop texture swimming as vert
    :type preserveUV: boolean
    :param reflection: () This flag is obsolete  Reflection is now managed as part of selection
    itself using the symmetricModeling command
    :type reflection: boolean
    :param reflectionAbout: () This flag is obsolete  Reflection is now managed as part of
    selection itself using the symmetricModeling command
    :type reflectionAbout: int
    :param reflectionAxis: () This flag is obsolete  Reflection is now managed as part of
    selection itself using the symmetricModeling command
    :type reflectionAxis: int
    :param reflectionTolerance: () This flag is obsolete  Reflection is now managed as part of
    selection itself using the symmetricModeling command
    :type reflectionTolerance: float
    :param rotate: (Q E) Returns the rotation of the manipulator for its current
    orientation/mode
    :type rotate: [float, float, float]
    :param snap: (C Q E) Specify that the manipulation is to use absolute snap
    :type snap: boolean
    :param snapPivotOri: (Q E) Snap pivot orientation  Modify pivot orientation when snapping
    the pivot to a component
    :type snapPivotOri: boolean
    :param snapPivotPos: (Q E) Snap pivot position  Modify pivot position when snapping the
    pivot to a component
    :type snapPivotPos: boolean
    :param snapRelative: (C Q E) Specify that the manipulation is to use relative snap
    :type snapRelative: boolean
    :param snapValue: (C Q E) Specify the snapping value
    :type snapValue: float
    :param tweakMode: (Q E) When true, the manipulator is hidden and highlighted components can
    be selected and rotated in one step using a click-drag interaction
    :type tweakMode: boolean
    :param useCenterPivot: (Q E) When true, use the center of the selection's bounding box as
    the center of the rotation (for all objects)
    :type useCenterPivot: boolean
    :param useManipPivot: (Q E) When true, use the manipulator's center as the center of the
    rotation (for all objects)
    :type useManipPivot: boolean
    :param useObjectPivot: (Q E) When true, use each object's pivot as the center of its
    rotation
    :type useObjectPivot: boolean
    :param xformConstraint: (Q E) none - no transform constraint edge - edge transform
    constraint surface - surface transform constraint
    :type xformConstraint: string
    
    :returns: (name of the new context)
    :rtype: string
    """
    pass


def FineLevelComponentDisplay(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MakeCollide(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def adskRepresentation(*args, **kwargs):
    """
    
    """
    pass


def polyColorMod(*args, alphaScale_FloatValue=0.0, alphaScale_Interp=0, alphaScale_Position=0.0,
                 baseColorName="", blueScale_FloatValue=0.0, blueScale_Interp=0,
                 blueScale_Position=0.0, caching=True, constructionHistory=True,
                 greenScale_FloatValue=0.0, greenScale_Interp=0, greenScale_Position=0.0,
                 huev=0.0, intensityScale_FloatValue=0.0, intensityScale_Interp=0,
                 intensityScale_Position=0.0, name="", nodeState=0, redScale_FloatValue=0.0,
                 redScale_Interp=0, redScale_Position=0.0, satv=1.0, value=1.0, q=True,
                 query=True, e=True, edit=True, **kwargs):
    """
    Modifies the attributes of a poly color set
    
    :param alphaScale_FloatValue: (C Q E) ?????
    :type alphaScale_FloatValue: float
    :param alphaScale_Interp: (C Q E) ????? Default: 0
    :type alphaScale_Interp: int
    :param alphaScale_Position: (C Q E) ?????
    :type alphaScale_Position: float
    :param baseColorName: (C) The name of the color set to be modified
    :type baseColorName: string
    :param blueScale_FloatValue: (C Q E) ?????
    :type blueScale_FloatValue: float
    :param blueScale_Interp: (C Q E) ????? Default: 0
    :type blueScale_Interp: int
    :param blueScale_Position: (C Q E) ?????
    :type blueScale_Position: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param greenScale_FloatValue: (C Q E) ?????
    :type greenScale_FloatValue: float
    :param greenScale_Interp: (C Q E) ????? Default: 0
    :type greenScale_Interp: int
    :param greenScale_Position: (C Q E) ?????
    :type greenScale_Position: float
    :param huev: (C Q E) Hue rotates hue value of the final color  Default: 0.0
    :type huev: float
    :param intensityScale_FloatValue: (C Q E) ?????
    :type intensityScale_FloatValue: float
    :param intensityScale_Interp: (C Q E) ????? Default: 0
    :type intensityScale_Interp: int
    :param intensityScale_Position: (C Q E) ?????
    :type intensityScale_Position: float
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param redScale_FloatValue: (C Q E) ?????
    :type redScale_FloatValue: float
    :param redScale_Interp: (C Q E) ????? Default: 0
    :type redScale_Interp: int
    :param redScale_Position: (C Q E) ?????
    :type redScale_Position: float
    :param satv: (C Q E) Sat scales the staturation of the final color  Default: 1.0
    :type satv: float
    :param value: (C Q E) Value scales the final color value  Default: 1.0
    :type value: float
    
    :returns: The node name.
    :rtype: string
    """
    pass


def subdPlanarProjection(*args, caching=True, nodeState=0, constructionHistory=True,
                         createNewMap=True, imageCenter=None, imageCenterX=0.5,
                         imageCenterY=0.5, imageScale=None, imageScaleU=1.0, imageScaleV=1.0,
                         insertBeforeDeformers=True, keepImageRatio=True, mapDirection="",
                         name="", projectionCenter=None, projectionCenterX=0.0,
                         projectionCenterY=0.0, projectionCenterZ=0.0, projectionHeight=1.0,
                         projectionScale=None, projectionWidth=1.0, rotate=None, rotateX=0.0,
                         rotateY=0.0, rotateZ=0.0, rotationAngle=10.0, smartFit=True,
                         worldSpace=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    TsubProjCmdBase is a base class for the command to create a mapping on the selected
    subdivision faces  Projects a map onto an object, using an orthogonal projection  The piece
    of the map defined from isu, isv, icx, icy area, is placed at pcx, pcy, pcz location
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param createNewMap: (C Q E) This flag when set true will create a new map with a the name
    passed in, if the map does not already exist
    :type createNewMap: boolean
    :param imageCenter: (C Q E) This flag specifies the center point of the 2D model layout  C:
    Default is 0.5 0.5  Q: When queried, this flag returns a float[2]
    :type imageCenter: [float, float]
    :param imageCenterX: (C Q E) This flag specifies X for the center point of the 2D model
    layout  C: Default is 0.5  Q: When queried, this flag returns a float
    :type imageCenterX: float
    :param imageCenterY: (C Q E) This flag specifies Y for the center point of the 2D model
    layout  C: Default is 0.5  Q: When queried, this flag returns a float
    :type imageCenterY: float
    :param imageScale: (C Q E) This flag specifies the UV scale : Enlarges or reduces the 2D
    version of the model in U or V space relative to the 2D centerpoint  C: Default is 1.0
    :type imageScale: [float, float]
    :param imageScaleU: (C Q E) This flag specifies the U scale : Enlarges or reduces the 2D
    version of the model in U space relative to the 2D centerpoint  C: Default is 1.0  Q: Wh
    :type imageScaleU: float
    :param imageScaleV: (C Q E) This flag specifies the V scale : Enlarges or reduces the 2D
    version of the model in V space relative to the 2D centerpoint  C: Default is 1.0  Q: Wh
    :type imageScaleV: float
    :param insertBeforeDeformers: (C) This flag specifies if the projection node should be
    inserted before or after deformer nodes already applied to the shape  Inserting the
    projection a
    :type insertBeforeDeformers: boolean
    :param keepImageRatio: (C) True means keep any image ratio
    :type keepImageRatio: boolean
    :param mapDirection: (C) This flag specifies the mapping direction  'x', 'y' and 'z'
    projects the map along the corresponding axis  'c' projects along the current camera view
    :type mapDirection: string
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param projectionCenter: (C Q E) This flag specifies the origin point from which the map is
    projected  C: Default is 0.0 0.0 0.0  Q: When queried, this flag returns a float[3]
    :type projectionCenter: [float, float, float]
    :param projectionCenterX: (C Q E) This flag specifies X for the origin point from which the
    map is projected  C: Default is 0.0  Q: When queried, this flag returns a float
    :type projectionCenterX: float
    :param projectionCenterY: (C Q E) This flag specifies Y for the origin point from which the
    map is projected  C: Default is 0.0  Q: When queried, this flag returns a float
    :type projectionCenterY: float
    :param projectionCenterZ: (C Q E) This flag specifies Z for the origin point from which the
    map is projected  C: Default is 0.0  Q: When queried, this flag returns a float
    :type projectionCenterZ: float
    :param projectionHeight: (C Q E) This flag specifies the height of the map relative to the
    3D projection axis  C: Default is 1.0 Q: When queried, this flag returns a float
    :type projectionHeight: float
    :param projectionScale: (C Q E) This flag specifies the width and the height of the map
    relative to the 3D projection axis  C: Default is 1.0 1.0  Q: When queried, this flag
    returns
    :type projectionScale: [float, float]
    :param projectionWidth: (C Q E) This flag specifies the width of the map relative to the 3D
    projection axis  C: Default is 1.0 Q: When queried, this flag returns a float
    :type projectionWidth: float
    :param rotate: (C Q E) This flag specifies the mapping rotate angles  C: Default is 0.0 0.0
    0.0  Q: When queried, this flag returns a float[3]
    :type rotate: [float, float, float]
    :param rotateX: (C Q E) This flag specifies X mapping rotate angle  C: Default is 0.0  Q:
    When queried, this flag returns a float[3]
    :type rotateX: float
    :param rotateY: (C Q E) This flag specifies Y mapping rotate angle  C: Default is 0.0  Q:
    When queried, this flag returns a float
    :type rotateY: float
    :param rotateZ: (C Q E) This flag specifies Z mapping rotate angle  C: Default is 0.0  Q:
    When queried, this flag returns a float
    :type rotateZ: float
    :param rotationAngle: (C Q E) This flag specifies the rotation angle in the mapping space 
    When the angle is positive, then the map rotates counterclockwise on the mapped model, w
    :type rotationAngle: float
    :param smartFit: (C) True means use the smart fit algorithm
    :type smartFit: boolean
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def MarkingMenuPreferencesWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PaintSetMembershipToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UnpublishNode(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DisplayShadingMarkingMenu(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ConvertSelectionToUVEdgeLoop(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectLightsIlluminatingObject(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowDynamicConstraints(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def greasePencilCtx(*args, autoCreateFrames=True, canDraw=True, createOrEditFrame=0,
                    exists=True, exportArchive=None, fileTextureSize=0, greasePencilType=0,
                    image1="", image2="", image3="", importArchive="", makeStroke=0,
                    removeFrame=0, resetBrushes=True, rgbcolor=None, sequenceNodeName="",
                    q=True, query=True, e=True, edit=True, **kwargs):
    """
    This is a tool context command for the grease pencil tool
    
    :param autoCreateFrames: (C Q E) Should frames be automatically created when drawing?
    :type autoCreateFrames: boolean
    :param canDraw: (Q) Check to see if drawing is allowed
    :type canDraw: boolean
    :param createOrEditFrame: (Q) Frame number for create or edit
    :type createOrEditFrame: int
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param exportArchive: (E) Modify names of export archive
    :type exportArchive: [string, string]
    :param fileTextureSize: (C Q E) Both width and height dimensions of the file texture (they
    are square)
    :type fileTextureSize: int
    :param greasePencilType: (C Q E) Grease pencil type  1 = Pencil, 2 = Marker, 3 = Soft
    Pencil, 4 = Eraser
    :type greasePencilType: int
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param importArchive: (E) Modify name of import archive
    :type importArchive: string
    :param makeStroke: (C Q E M) Stroke point values
    :type makeStroke: int
    :param removeFrame: (E) Remove the given frame
    :type removeFrame: int
    :param resetBrushes: (Q E) Should the brushes reset?
    :type resetBrushes: boolean
    :param rgbcolor: (C Q E) Color of the grease pencil
    :type rgbcolor: [float, float, float]
    :param sequenceNodeName: (Q) Query the name of the sequence node
    :type sequenceNodeName: string
    
    :returns: 
    :rtype: None
    """
    pass


def BendOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sculptMeshCacheChangeCloneSource(*args, blendShape="", target="", q=True, query=True,
                                     e=True, edit=True, **kwargs):
    """
    This command changes the source blend shape and target for the clone target tool  Used
    internally for undo/redo, and should not be called directly
    
    :param blendShape: (C Q E) Set which blend shape should be used as the source when using
    the clone tool  When queried, returns the current blend shape name as a string
    :type blendShape: string
    :param target: (C Q E) Set which blend shape should be used as the target when using the
    clone tool  When queried, returns the current blend shape target name as a string
    :type target: string
    
    :returns: 
    :rtype: None
    """
    pass


def NodeEditorToggleNodeSelectedPins(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NURBSSmoothnessRoughOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def hotBox(*args, PaneOnlyMenus=True, PaneToggleMenus=True, animationOnlyMenus=True,
           animationToggleMenus=True, clothOnlyMenus=True, clothToggleMenus=True,
           commonOnlyMenus=True, commonToggleMenus=True, customMenuSetsToggleMenus=True,
           displayCenterOnly=True, displayHotbox=True, displayStyle=True, displayZonesOnly=True,
           dynamicsOnlyMenus=True, dynamicsToggleMenus=True, liveOnlyMenus=True,
           liveToggleMenus=True, menuSetOnly="", menuSetToggle=None, modelingOnlyMenus=True,
           modelingToggleMenus=True, noClickCommand=None, noClickDelay=0.0,
           noClickPosition=True, noKeyPress=True, polygonsOnlyMenus=True,
           polygonsToggleMenus=True, position=None, release=True, renderingOnlyMenus=True,
           renderingToggleMenus=True, riggingOnlyMenus=True, riggingToggleMenus=True,
           rmbPopups=True, showAllToggleMenus=True, surfacesOnlyMenus=True,
           surfacesToggleMenus=True, transparenyLevel=0, updateMenus=True, q=True, query=True,
           **kwargs):
    """
    This command controls parameters related to the hotBox menubar palette  When the command is
    invoked with no flags, the hotBox is popped up
    
    :param PaneOnlyMenus: (C) Sets a row of menus to be the only visible row
    :type PaneOnlyMenus: boolean
    :param PaneToggleMenus: (C Q) Sets the visibilty of a row of menus to on or off
    :type PaneToggleMenus: boolean
    :param animationOnlyMenus: (C Q) 
    :type animationOnlyMenus: boolean
    :param animationToggleMenus: (C Q) 
    :type animationToggleMenus: boolean
    :param clothOnlyMenus: (C Q) 
    :type clothOnlyMenus: boolean
    :param clothToggleMenus: (C Q) 
    :type clothToggleMenus: boolean
    :param commonOnlyMenus: (C Q) 
    :type commonOnlyMenus: boolean
    :param commonToggleMenus: (C Q) 
    :type commonToggleMenus: boolean
    :param customMenuSetsToggleMenus: (C Q) 
    :type customMenuSetsToggleMenus: boolean
    :param displayCenterOnly: (C) Three different display styles are defined for the hotBox  It
    can be fully displayed (dh), display only the marking menu zones (dzo) or no display (d
    :type displayCenterOnly: boolean
    :param displayHotbox: (C Q) 
    :type displayHotbox: boolean
    :param displayStyle: (Q) Returns a string that identifies the flag used to set the current
    display style  The results can be dh, dzo, or dco, depending on which style the hot
    :type displayStyle: boolean
    :param displayZonesOnly: (C Q) 
    :type displayZonesOnly: boolean
    :param dynamicsOnlyMenus: (C Q) 
    :type dynamicsOnlyMenus: boolean
    :param dynamicsToggleMenus: (C Q) 
    :type dynamicsToggleMenus: boolean
    :param liveOnlyMenus: (C Q) 
    :type liveOnlyMenus: boolean
    :param liveToggleMenus: (C Q) 
    :type liveToggleMenus: boolean
    :param menuSetOnly: (C) Show only the named menu set
    :type menuSetOnly: string
    :param menuSetToggle: (C) Update the given menu sets with the paired toggle value
    :type menuSetToggle: [string, boolean]
    :param modelingOnlyMenus: (C Q) 
    :type modelingOnlyMenus: boolean
    :param modelingToggleMenus: (C Q) 
    :type modelingToggleMenus: boolean
    :param noClickCommand: (C) The command to be executed if the hotBox is engaged and then
    disengaged within noClickDelay time units
    :type noClickCommand: script
    :param noClickDelay: (C) If the hotBox is engaged and then disengaged within this time
    interval, then the noClickCommand is executed  The time interval is in seconds  The def
    :type noClickDelay: float
    :param noClickPosition: (C) If a -noClickCommand has been specified then this flag will
    cause the X and Y screen coordinates of the mouse pointer to be appended as arguments to
    :type noClickPosition: boolean
    :param noKeyPress: (C Q) Normally the hotbox is popped by a pressing a keyboard key  Use
    the nkp flag to pop the hotbox from a device other than the keyboard (still use the r
    :type noKeyPress: boolean
    :param polygonsOnlyMenus: (C Q) 
    :type polygonsOnlyMenus: boolean
    :param polygonsToggleMenus: (C Q) 
    :type polygonsToggleMenus: boolean
    :param position: (C) Specify the screen position the hotbox should be centered at next time
    it is displayed  The default is the cursor position
    :type position: [int, int]
    :param release: (C Q) Action to be called on the release of the key which invoked the
    hotbox
    :type release: boolean
    :param renderingOnlyMenus: (C Q) 
    :type renderingOnlyMenus: boolean
    :param renderingToggleMenus: (C Q) 
    :type renderingToggleMenus: boolean
    :param riggingOnlyMenus: (C Q) 
    :type riggingOnlyMenus: boolean
    :param riggingToggleMenus: (C Q) 
    :type riggingToggleMenus: boolean
    :param rmbPopups: (C Q) Enables/Disables a popup menu of the current function set  This
    popup menu appear when the right mouse button is pressed in the center zone of the ho
    :type rmbPopups: boolean
    :param showAllToggleMenus: (C Q) Sets the visibility of all menus to on or off  When
    queried, will only return true if all menu rows are visible
    :type showAllToggleMenus: boolean
    :param surfacesOnlyMenus: (C Q) 
    :type surfacesOnlyMenus: boolean
    :param surfacesToggleMenus: (C Q) 
    :type surfacesToggleMenus: boolean
    :param transparenyLevel: (C Q) The percentage of transparency, from 0 to 100  Currently,
    only the values 0, 25, 50, 75 and 100 are supported  Any other values will be rounded off
    t
    :type transparenyLevel: int
    :param updateMenus: (C) Reloads the hotBox menus from the main menubar  This flag is used
    when the menus in the main menubar are modified, and the hotBox menus need to be re
    :type updateMenus: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def FBXImportResamplingRateSource(*args, **kwargs):
    """
    
    """
    pass


def melInfo(*args, **kwargs):
    """
    This command returns the names of all global MEL procedures that are currently defined as a
    string array  The user can query the definition of each MEL procedure using the "whatIs"
    command
    
    
    :returns: procedure names
    :rtype: string[]
    """
    pass


def Undo(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolyRemoveAllCrease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteVertex(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyInstallAction(*args, commandName=True, convertSelection=True, installConstraint=True,
                      installDisplay=True, keepInstances=True, uninstallConstraint=True,
                      uninstallDisplay=True, q=True, query=True, **kwargs):
    """
    Installs/uninstalls several things to help the user to perform the specified action : 
    Pickmask Internal selection constraints Display attributes
    
    :param commandName: (Q) return as a string the name of the command previously installed
    :type commandName: boolean
    :param convertSelection: (C) convert all polys selected in object mode into their full
    matching component selection  For example : if a polyMesh is selected, polyInstallAction
    -c
    :type convertSelection: boolean
    :param installConstraint: (C Q) C: install selection pickmask and internal constraints for
    actionname Q: returns 1 if any internal constraint is set for current action
    :type installConstraint: boolean
    :param installDisplay: (C Q) C: install display attributes for actionname Q: returns 1 if
    any display is set for current action
    :type installDisplay: boolean
    :param keepInstances: (C) Convert components for all selected instances rather than only
    the first selected instance
    :type keepInstances: boolean
    :param uninstallConstraint: (C) uninstall internal constraints previously installed
    :type uninstallConstraint: boolean
    :param uninstallDisplay: (C) uninstall display attributes previously installed
    :type uninstallDisplay: boolean
    
    :returns: When installing constraint, returns as an array of strings the
    items on which the
    installed command will act on. otherwise, returns nothing
    :rtype: string[]
    """
    pass


def StitchEdgesTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShelfPreferencesWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CutPolygonOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXImportConvertDeformingNullsToJoint(*args, **kwargs):
    """
    
    """
    pass


def createNode(*args, name="", parent="", shared=True, skipSelect=True, **kwargs):
    """
    This command creates a new node in the dependency graph of the specified type
    
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param parent: (C) Specifies the parent in the DAG under which the new node belongs
    :type parent: string
    :param shared: (C) This node is shared across multiple files, so only create it if it does
    not already exist
    :type shared: boolean
    :param skipSelect: (C) This node is not to be selected after creation, the original
    selection will be preserved
    :type skipSelect: boolean
    
    :returns: The name of the new node.
    :rtype: string
    """
    pass


def evalEcho(*args, **kwargs):
    """
    
    """
    pass


def dynExport(*args, allObjects=True, attribute="", format="", maxFrame=None, minFrame=None,
              onlyUpdateParticles=True, overSampling=0, path="", **kwargs):
    """
    Export particle data to disk files   For cache export (-format cache), dynExport also sets
    three attributes of the current dynGlobals node  It sets the useParticleRenderCache
    attribute to true, and the min/maxFrameOfLastParticleRenderCache attributes to correspond
    to the min and max frames   Exported .pda or .pdb files are assigned a name of form o
    
    :param allObjects: (C) Ignore the selection list and export all particle objects  If you
    also specify an object name, the -all flag will be ignored
    :type allObjects: boolean
    :param attribute: (C M) Name of attribute to be exported  If any specified object does not
    have one of the specified attributes, dynExport will issue an error and not do the
    :type attribute: string
    :param format: (C) Desired format: "binary" ("pdb"), "ascii" ("pda"), or "cache" ("pdc") 
    The pdc format is for use by the Maya particle system to cache particle data
    :type format: string
    :param maxFrame: (C) Ending frame to be exported
    :type maxFrame: time
    :param minFrame: (C) Starting frame to be exported  The export operation will play the
    scene through from min frame to max frame as it exports
    :type minFrame: time
    :param onlyUpdateParticles: (C) Specify to only update the particles before exporting
    :type onlyUpdateParticles: boolean
    :param overSampling: (C) OverSampling to be used during export
    :type overSampling: int
    :param path: (C) This option allows you to specify a subdirectory of the workspace
    "particles" directory where you want the exported files to be stored  By default, f
    :type path: string
    
    :returns: Path to the exported files
    :rtype: string
    """
    pass


def SetMeshSmoothTargetTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def move(*args, absolute=True, componentOffset=True, componentSpace=True,
         constrainAlongNormal=True, deletePriorHistory=True, localSpace=True, moveX=True,
         moveXY=True, moveXYZ=True, moveXZ=True, moveY=True, moveYZ=True, moveZ=True,
         objectSpace=True, orientJoint="", parameter=True, preserveChildPosition=False,
         preserveGeometryPosition=False, preserveUV=False, reflection=True,
         reflectionAboutBBox=True, reflectionAboutOrigin=True, reflectionAboutX=True,
         reflectionAboutY=True, reflectionAboutZ=True, reflectionTolerance=0.0, relative=True,
         rotatePivotRelative=True, scalePivotRelative=True, secondaryAxisOrient="",
         symNegative=True, worldSpace=True, worldSpaceDistance=True, xformConstraint="",
         **kwargs):
    """
    The move command is used to change the positions of geometric objects   The default
    behaviour, when no objects or flags are passed, is to do a absolute move on each currently
    selected object in the world space  The value of the coordinates are interpreted as being
    defined in the current linear unit unless the unit is explicitly mentioned   When usi
    
    :param absolute: (C) Perform an absolute operation
    :type absolute: boolean
    :param componentOffset: (C) Move components individually in local space
    :type componentOffset: boolean
    :param componentSpace: (C) Move in local component space
    :type componentSpace: boolean
    :param constrainAlongNormal: (C) When true, transform constraints are applied along the
    vertex normal first and only use the closest point when no intersection is found along the
    nor
    :type constrainAlongNormal: boolean
    :param deletePriorHistory: (C) If true then delete the history prior to the current
    operation
    :type deletePriorHistory: boolean
    :param localSpace: (C) Move in local space
    :type localSpace: boolean
    :param moveX: (C) Move in X direction
    :type moveX: boolean
    :param moveXY: (C) Move in XY direction
    :type moveXY: boolean
    :param moveXYZ: (C) Move in all directions (default)
    :type moveXYZ: boolean
    :param moveXZ: (C) Move in XZ direction
    :type moveXZ: boolean
    :param moveY: (C) Move in Y direction
    :type moveY: boolean
    :param moveYZ: (C) Move in YZ direction
    :type moveYZ: boolean
    :param moveZ: (C) Move in Z direction
    :type moveZ: boolean
    :param objectSpace: (C) Move in object space
    :type objectSpace: boolean
    :param orientJoint: (C) Default is xyz
    :type orientJoint: string
    :param parameter: (C) Move in parametric space
    :type parameter: boolean
    :param preserveChildPosition: (C) When true, transforming an object will apply an opposite
    transform to its child transform to keep them at the same world-space position  Default is
    f
    :type preserveChildPosition: boolean
    :param preserveGeometryPosition: (C) When true, transforming an object will apply an
    opposite transform to its geometry points to keep them at the same world-space position 
    Default is f
    :type preserveGeometryPosition: boolean
    :param preserveUV: (C) When true, UV values on translated components are projected along
    the translation in 3d space  For small edits, this will freeze the world space text
    :type preserveUV: boolean
    :param reflection: (C) To move the corresponding symmetric components also
    :type reflection: boolean
    :param reflectionAboutBBox: (C) Sets the position of the reflection axis at the geometry
    bounding box
    :type reflectionAboutBBox: boolean
    :param reflectionAboutOrigin: (C) Sets the position of the reflection axis at the origin
    :type reflectionAboutOrigin: boolean
    :param reflectionAboutX: (C) Specifies the X=0 as reflection plane
    :type reflectionAboutX: boolean
    :param reflectionAboutY: (C) Specifies the Y=0 as reflection plane
    :type reflectionAboutY: boolean
    :param reflectionAboutZ: (C) Specifies the Z=0 as reflection plane
    :type reflectionAboutZ: boolean
    :param reflectionTolerance: (C) Specifies the tolerance to findout the corresponding
    reflected components
    :type reflectionTolerance: float
    :param relative: (C) Perform a operation relative to the object's current position
    :type relative: boolean
    :param rotatePivotRelative: (C) Move relative to the object's rotate pivot point
    :type rotatePivotRelative: boolean
    :param scalePivotRelative: (C) Move relative to the object's scale pivot point
    :type scalePivotRelative: boolean
    :param secondaryAxisOrient: (C) Default is xyz
    :type secondaryAxisOrient: string
    :param symNegative: (C) When set the component transformation is flipped so it is relative
    to the negative side of the symmetry plane  The default (no flag) is to transform
    :type symNegative: boolean
    :param worldSpace: (C) Move in world space
    :type worldSpace: boolean
    :param worldSpaceDistance: (C) Move is specified in world space units
    :type worldSpaceDistance: boolean
    :param xformConstraint: (C) Apply a transform constraint to moving components  none - no
    constraint surface - constrain components to the surface edge - constrain components to
    :type xformConstraint: string
    
    :returns: 
    :rtype: None
    """
    pass


def toolDropped(*args, **kwargs):
    """
    This command builds and executes the commands necessary to recreate the specified tool
    button  It is invoked when a tool is dropped on the shelf
    
    
    :returns: 
    :rtype: None
    """
    pass


def soundControl(*args, annotation="", backgroundColor=None, beginScrub=True, defineTemplate="",
                 displaySound=True, docTag="", dragCallback=None, dropCallback=None,
                 enable=True, enableBackground=True, enableKeyboardFocus=True, endScrub=True,
                 exists=True, fullPathName=True, height=0, highlightColor=None, isObscured=True,
                 manage=True, maxTime=None, minTime=None, noBackground=True,
                 numberOfPopupMenus=True, parent="", popupMenuArray=True, pressCommand="",
                 preventOverride=True, releaseCommand="", repeatChunkSize=1.0,
                 repeatOnHold=True, resample=True, sound="", statusBarMessage="",
                 useTemplate="", visible=True, visibleChangeCommand=None, waveform="top",
                 width=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a control used for changing current time and scratching/scrubbing
    through sound files
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param beginScrub: (E) Set this widget up for sound scrubbing  Subsequent changes to
    current time will result in "sound scrubbing" behavior, until the "-endScrub" command i
    :type beginScrub: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param displaySound: (Q E) Turn sound display off  Query returns int
    :type displaySound: boolean
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param endScrub: (E) End sound scubbing for this widget  This stops sound scrubbing
    behavior and should be issued before any subsequent "-beginScrub" flags
    :type endScrub: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param maxTime: (C Q E) Controls the max time of the range displayed in the control  Query
    returns float
    :type maxTime: time
    :param minTime: (C Q E) Controls the min time of the range displayed in the control  Query
    returns float
    :type minTime: time
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param pressCommand: (C E) script to run on mouse-down in this control
    :type pressCommand: string
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param releaseCommand: (C E) script to run on mouse-up in this control
    :type releaseCommand: string
    :param repeatChunkSize: (Q E) How much sound (in the current time unit) is repeated when
    -repeatOnHold is true  Default is 1.0
    :type repeatChunkSize: float
    :param repeatOnHold: (Q E) Repeat sound during mouse-down events
    :type repeatOnHold: boolean
    :param resample: (E) Resample the sound display to fit the widget
    :type resample: boolean
    :param sound: (Q E) Name of audio depend node whose data should display in the
    sound-display widget  Query returns string
    :type sound: string
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param waveform: (Q E) Determines what part of the sound waveform to display, when
    -displaySound is "true"  Valid values are "top", "bottom", and "both"  Default is "top"
    :type waveform: string
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Name of created or edited control.
    :rtype: string
    """
    pass


def createRenderLayer(*args, empty=True, g=True, makeCurrent=True, name="", noRecurse=True,
                      number=0, **kwargs):
    """
    Create a new render layer  The render layer number will be assigned based on the first
    unassigned number not less than the base index number found in the render layer global
    parameters  Normally all objects and their descendants will be added to the new render
    layer but if '-noRecurse' is specified then only the objects themselves will be added  On
    
    :param empty: (C) If set then create an empty render layer  The global flag or specified
    member list will take precidence over use of this flag
    :type empty: boolean
    :param g: (C) If set then create a layer that contains all DAG objects in the scene  Any
    future objects created will also automatically become members of this laye
    :type g: boolean
    :param makeCurrent: (C) If set then make the new render layer the current one
    :type makeCurrent: boolean
    :param name: (C) Name of the new render layer being created
    :type name: string
    :param noRecurse: (C) If set then only add specified objects to the render layer  Otherwise
    all descendants will also be added
    :type noRecurse: boolean
    :param number: (C) Number for the new render layer being created
    :type number: int
    
    :returns: Name of render layer node that was created
    :rtype: string
    """
    pass


def dgstats(*args, **kwargs):
    """
    
    """
    pass


def CreateSpotLightOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def clearShear(*args, **kwargs):
    """
    
    """
    pass


def joint(*args, absolute=True, angleX=0.0, angleY=0.0, angleZ=0.0, assumePreferredAngles=True,
          automaticLimits=True, children=True, component=True, degreeOfFreedom="", exists="",
          limitSwitchX=True, limitSwitchY=True, limitSwitchZ=True, limitX=None, limitY=None,
          limitZ=None, name="", orientJoint="", orientation=None, position=None, radius=0.0,
          relative=True, rotationOrder="", scale=None, scaleCompensate=True,
          scaleOrientation=None, secondaryAxisOrient="", setPreferredAngles=True,
          stiffnessX=0.0, stiffnessY=0.0, stiffnessZ=0.0, symmetry=True, symmetryAxis="",
          zeroScaleOrient=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The joint command is used to create, edit, and query, joints within Maya  (The standard
    edit(-e) and query(-q) flags are used for edit and query functions)  If the object is not
    specified, the currently selected object (dag object) will be used   Multiple objects are
    allowed only for the edit mode  The same edit flags will be applied on all the joi
    
    :param absolute: (C Q E) The joint center position is in absolute world coordinates  (This
    is the default.)
    :type absolute: boolean
    :param angleX: (C Q E) Set the x-axis angle  When queried, this flag returns a float
    :type angleX: float
    :param angleY: (C Q E) Set the y-axis angle  When queried, this flag returns a float
    :type angleY: float
    :param angleZ: (C Q E) Set the z-axis angle  When queried, this flag returns a float
    :type angleZ: float
    :param assumePreferredAngles: (E) Meaningful only in the edit mode  It sets the joint
    angles to the corresponding preferred angles
    :type assumePreferredAngles: boolean
    :param automaticLimits: (C) Meaningful only in edit mode  It sets the joint to appropriate
    hinge joint with joint limits  It modifies the joint only if (a) it connects exactly t
    :type automaticLimits: boolean
    :param children: (E) It tells the command to apply all the edit options not only to the
    selected joints, but also to their descendent joints in the DAG
    :type children: boolean
    :param component: (C E) Use with the -position switch to position the joint relative to its
    parent (like -relative) but to compute new positions for all children joints so t
    :type component: boolean
    :param degreeOfFreedom: (C Q E) Specifies the degrees of freedom for the IK  Valid strings
    consist of non-duplicate letters from x, y, and z  The letters in the string indicate what
    :type degreeOfFreedom: string
    :param exists: (Q) Does the named joint exist? When queried, this flag returns a boolean
    :type exists: string
    :param limitSwitchX: (C Q E) Use the limit the x-axis rotation? When queried, this flag
    returns a boolean
    :type limitSwitchX: boolean
    :param limitSwitchY: (C Q E) Use the limit the y-axis rotation? When queried, this flag
    returns a boolean
    :type limitSwitchY: boolean
    :param limitSwitchZ: (C Q E) Use the Limit the z-axis rotation? When queried, this flag
    returns a boolean
    :type limitSwitchZ: boolean
    :param limitX: (C Q E) Set lower and upper limits on the x-axis of rotation  Also turns on
    the joint limit  When queried, this flag returns 2 floats
    :type limitX: [float, float]
    :param limitY: (C Q E) Set lower and upper limits on the y-axis of rotation  Also turns on
    the joint limit  When queried, this flag returns 2 floats
    :type limitY: [float, float]
    :param limitZ: (C Q E) Set lower and upper limits on the z-axis of rotation  Also turns on
    the joint limit  When queried, this flag returns 2 floats
    :type limitZ: [float, float]
    :param name: (C Q E) Specifies the name of the joint  When queried, this flag returns a
    string
    :type name: string
    :param orientJoint: (E) The argument can be one of the following strings: xyz, yzx, zxy,
    zyx, yxz, xzy, none  It modifies the joint orientation and scale orientation so that
    :type orientJoint: string
    :param orientation: (C Q E) The joint orientation  When queried, this flag returns 3
    floats
    :type orientation: [float, float, float]
    :param position: (C Q E) Specifies the position of the center of the joint  This position
    may be relative to the joint's parent or in absolute world coordinates (see -r and -
    :type position: [float, float, float]
    :param radius: (C Q E) Specifies the joint radius
    :type radius: float
    :param relative: (C Q E) The joint center position is relative to the joint's parent
    :type relative: boolean
    :param rotationOrder: (C Q E) The rotation order of the joint  The argument can be one of
    the following strings: xyz, yzx, zxy, zyx, yxz, xzy
    :type rotationOrder: string
    :param scale: (C Q E) Scale of the joint  When queried, this flag returns 3 floats
    :type scale: [float, float, float]
    :param scaleCompensate: (C Q E) It sets the scaleCompenstate attribute of the joint to the
    given argument  When this is true, the scale of the parent joint will be compensated befor
    :type scaleCompensate: boolean
    :param scaleOrientation: (C Q E) Set the orientation of the coordinate axes for scaling 
    When queried, this flag returns 3 floats
    :type scaleOrientation: [float, float, float]
    :param secondaryAxisOrient: (E) The argument can be one of the following strings: xup,
    xdown, yup, ydown, zup, zdown, none  This flag is used in conjunction with the
    -oj/orientJoint
    :type secondaryAxisOrient: string
    :param setPreferredAngles: (E) Meaningful only in the edit mode  It sets the preferred
    angles to the current joint angles
    :type setPreferredAngles: boolean
    :param stiffnessX: (C Q E) Set the stiffness (from 0 to 100.0) for x-axis  When queried,
    this flag returns a float
    :type stiffnessX: float
    :param stiffnessY: (C Q E) Set the stiffness (from 0 to 100.0) for y-axis  When queried,
    this flag returns a float
    :type stiffnessY: float
    :param stiffnessZ: (C Q E) Set the stiffness (from 0 to 100.0) for z-axis  When queried,
    this flag returns a float
    :type stiffnessZ: float
    :param symmetry: (C E) Create a symmetric joint from the current joint
    :type symmetry: boolean
    :param symmetryAxis: (C E) This flag specifies the axis used to mirror symmetric joints 
    Any combination of x, y, z can be used  This option is only used when the symmetry flag
    :type symmetryAxis: string
    :param zeroScaleOrient: (E) It sets the scale orientation to zero and compensate the change
    by modifing the translation and joint orientation for joint or rotation for general t
    :type zeroScaleOrient: boolean
    
    :returns: Command result
    :rtype: string
    """
    pass


def revolve(*args, autoCorrectNormal=False, axis=None, axisChoice=0, axisX=1, axisY=0, axisZ=0,
            bridge=False, caching=True, computePivotAndAxis=0, degree=3, endSweep=6.2831853,
            nodeState=0, pivot=None, pivotX=0, pivotY=0, pivotZ=0, radius=1, radiusAnchor=1,
            sections=8, startSweep=0, tolerance=0.01, useTolerance=False,
            constructionHistory=True, name="", object=True, polygon=0, range=True, rebuild=True,
            useLocalPivot=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a revolved surface by revolving the given profile curve about an axis 
    The profile curve can be a curve, curve-on-surface, surface isoparm, or trim edge
    
    :param autoCorrectNormal: (C Q E) If this is set to true we will attempt to reverse the
    direction of the axis in case it is necessary to do so for the surface normals to end up
    pointi
    :type autoCorrectNormal: boolean
    :param axis: (C Q E) Revolve axis
    :type axis: [float, float, float]
    :param axisChoice: (C Q E) Only used for computed axis/pivot case  As we are computing the
    axis for a planar curve, we have two choices for the major axis based axis  We will c
    :type axisChoice: int
    :param axisX: (C Q E) X of the axis Default: 1
    :type axisX: float
    :param axisY: (C Q E) Y of the axis Default: 0
    :type axisY: float
    :param axisZ: (C Q E) Z of the axis Default: 0
    :type axisZ: float
    :param bridge: (C Q E) If true, we will close a partial revolve to get a pie shaped surface
     The surface will be closed, but not periodic the way it is in the full revolve
    :type bridge: boolean
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param computePivotAndAxis: (C Q E) If this is set to 2, we will compute the axis, use the
    curve position and radius to compute the pivot for the revolve internally  The value of the
    pi
    :type computePivotAndAxis: int
    :param degree: (C Q E) The degree of the resulting surface  Default: 3
    :type degree: int
    :param endSweep: (C Q E) The value for the end sweep angle, in the current units  This must
    be no more than the maximum, 360 degrees, or 2 Pi radians  Default: 6.2831853
    :type endSweep: float
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param pivot: (C Q E) Revolve pivot point
    :type pivot: [float, float, float]
    :param pivotX: (C Q E) X of the pivot Default: 0
    :type pivotX: float
    :param pivotY: (C Q E) Y of the pivot Default: 0
    :type pivotY: float
    :param pivotZ: (C Q E) Z of the pivot Default: 0
    :type pivotZ: float
    :param radius: (C Q E) The pivot point will be this distance away from the bounding box of
    the curve, if computedPivot is set to true  The value of the pivot attribute is i
    :type radius: float
    :param radiusAnchor: (C Q E) The position on the curve for the anchor point so that we can
    compute the pivot using the radius value  If in 0 - 1 range, its on the curve, normaliz
    :type radiusAnchor: float
    :param sections: (C Q E) Number of sections of the resulting surface (if tolerance is not
    used)  Default: 8
    :type sections: int
    :param startSweep: (C Q E) The value for the start sweep angle, in the current units  This
    must be no more than the maximum, 360 degrees, or 2 Pi radians  Default: 0
    :type startSweep: float
    :param tolerance: (C Q E) Tolerance to build to (if useTolerance attribute is set) Default:
    0.01
    :type tolerance: float
    :param useTolerance: (C Q E) Use the tolerance, or the number of sections to control the
    sections  Default: false
    :type useTolerance: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param polygon: (C) The value of this argument controls the type of the object created by
    this operation 0: nurbs surface 1: polygon (use nurbsToPolygonsPref to set the
    :type polygon: int
    :param range: (C) Force a curve range on complete input curve
    :type range: boolean
    :param rebuild: (C) Rebuild the input curve(s) before using them in the operation  Use
    nurbsCurveRebuildPref to set the parameters for the conversion
    :type rebuild: boolean
    :param useLocalPivot: (C Q E) If true, then the pivot of the profile curve is used as the
    start point of the axis of revolution
    :type useLocalPivot: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def SelectUVBorder(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CopyKeysOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def texCutContext(*args, adjustSize=True, displayShellBorders=True, edgeSelectSensitive=0.0,
                  exists=True, history=True, image1="", image2="", image3="", mode="",
                  moveRatio=0.0, name="", size=0.0, steadyStroke=True, steadyStrokeDistance=0.0,
                  touchToSew=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a context for cut uv tool  This context only works in the UV editor
    
    :param adjustSize: (E) If true, puts the tool into the mode where dragging the mouse will
    edit the brush size  If false, puts the tool back into the previous mode
    :type adjustSize: boolean
    :param displayShellBorders: (Q E) Toggle the display of shell borders
    :type displayShellBorders: boolean
    :param edgeSelectSensitive: (Q E) Set the value of the edge selection sensitivity
    :type edgeSelectSensitive: float
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param mode: (Q E) Specifies the type of effect the brush will perform, Cut or Sew
    :type mode: string
    :param moveRatio: (Q E) The cut open ratio relative to edge length
    :type moveRatio: float
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param size: (Q E) Brush size value of the brush ring
    :type size: float
    :param steadyStroke: (Q E) Turn on steady stroke or not
    :type steadyStroke: boolean
    :param steadyStrokeDistance: (Q E) The distance for steady stroke
    :type steadyStrokeDistance: float
    :param touchToSew: (Q E) Toggle the touch to sew mode
    :type touchToSew: boolean
    
    :returns: Size of the brush rung, when querying brushSize
    :rtype: float
    """
    pass


def ToggleVertMetadata(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def spotLight(*args, barnDoors=True, bottomBarnDoorAngle=0.0, coneAngle=0.0, decayRate=0,
              discRadius=0.0, dropOff=0.0, exclusive=True, intensity=0.0, leftBarnDoorAngle=0.0,
              name="", penumbra=0.0, position=None, rgb=None, rightBarnDoorAngle=0.0,
              rotation=None, shadowColor=None, shadowDither=0.0, shadowSamples=0,
              softShadow=True, topBarnDoorAngle=0.0, useRayTraceShadows=True, q=True,
              query=True, e=True, edit=True, **kwargs):
    """
    TlightCmd is the base class for other light commands  TnonAmbientLightCmd is a class that
    looks like a command but is not  It is a base class for the extended/nonExtended lights 
    TnonExtendedLightCmd is a base class and not a real command  It is inherited by several
    lights: TpointLight, TdirectionalLight, TspotLight etc  The spotLight command is us
    
    :param barnDoors: (C Q E) Are the barn doors enabled?
    :type barnDoors: boolean
    :param bottomBarnDoorAngle: (C Q E) Angle of the bottom of the barn door
    :type bottomBarnDoorAngle: float
    :param coneAngle: (C Q E) angle of the spotLight
    :type coneAngle: float
    :param decayRate: (C) Decay rate of the light (0-no decay, 1-slow, 2-realistic, 3-fast)
    :type decayRate: int
    :param discRadius: (C Q) Radius of shadow disc
    :type discRadius: float
    :param dropOff: (C Q E) dropOff of the spotLight
    :type dropOff: float
    :param exclusive: (C Q) True if the light is exclusively assigned
    :type exclusive: boolean
    :param intensity: (C Q) Intensity of the light
    :type intensity: float
    :param leftBarnDoorAngle: (C Q E) Angle of the left of the barn door
    :type leftBarnDoorAngle: float
    :param name: (C Q) Name of the light
    :type name: string
    :param penumbra: (C Q E) specify penumbra region
    :type penumbra: float
    :param position: (C Q) Position of the light
    :type position: [float, float, float]
    :param rgb: (C Q) RGB colour of the light
    :type rgb: [float, float, float]
    :param rightBarnDoorAngle: (C Q E) Angle of the right of the barn door
    :type rightBarnDoorAngle: float
    :param rotation: (C Q) Rotation of the light for orientation, where applicable
    :type rotation: [float, float, float]
    :param shadowColor: (C Q) Color of the light's shadow
    :type shadowColor: [float, float, float]
    :param shadowDither: (C Q) Shadow dithering value
    :type shadowDither: float
    :param shadowSamples: (C Q) Numbr of shadow samples to use
    :type shadowSamples: int
    :param softShadow: (C Q) True if soft shadowing is to be enabled
    :type softShadow: boolean
    :param topBarnDoorAngle: (C Q E) Angle of the top of the barn door
    :type topBarnDoorAngle: float
    :param useRayTraceShadows: (C Q) True if ray trace shadows are to be used
    :type useRayTraceShadows: boolean
    
    :returns: Light shape name
    boolean Barn door enabled state
    angle Left barn door angle
    angle
    Right barn door angle
    angle Top barn door angle
    angle Bottom barn door angle
    angle Cone
    angle
    angle Penumbra angle
    float Dropoff value
    :rtype: string
    """
    pass


def subdTransferUVsToCache(*args, **kwargs):
    """
    The subdivision surface finer level uvs will get copied to the polygonToSubd node sent in
    as argument
    
    
    :returns: Command result
    :rtype: boolean
    """
    pass


def untrim(*args, caching=True, nodeState=0, constructionHistory=True, curveOnSurface=True,
           name="", noChanges=True, object=True, replaceOriginal=True, untrimAll=True, q=True,
           query=True, e=True, edit=True, **kwargs):
    """
    Untrim the surface
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param curveOnSurface: (C) If possible, create 2D curve as a result
    :type curveOnSurface: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param noChanges: (C Q E) If set then the operation node will be automatically put into
    pass-through mode
    :type noChanges: boolean
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    :param untrimAll: (Q E) if true, untrim all the trims for the surface else untrim only the
    last trim
    :type untrimAll: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def Unparent(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreatePolygonTorus(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UnfoldPackUVs3DInCurrentTile(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ScaleToolWithSnapMarkingMenu(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectSharedColorInstances(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RemoveJoint(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateReference(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorDiveIntoCompound(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddBifrostAdaptiveMesh(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def igBrushContext(*args, **kwargs):
    """
    
    """
    pass


def CreatePolygonPrismOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dynTestData(*args, **kwargs):
    """
    
    """
    pass


def dR_setRelaxAffectsInterior(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddBifrostCollider(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SmoothProxyOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateCurveFromPolyOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PointOnPolyConstraint(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def InsertJointTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def deformerWeights(*args, attribute="", defaultValue=0.0, deformer="", export=True, format="",
                    ignoreName=True, im=True, method="", path="", positionTolerance=0.0,
                    remap="", shape="", skip="", vertexConnections=True, weightPrecision=0,
                    weightTolerance=0.0, worldSpace=True, q=True, query=True, e=True, edit=True,
                    **kwargs):
    """
    Command to import and export deformer weights to and from a simple XML file  The weight
    data is stored in a per-vertex fashion along with a "point cloud" corresponding to the
    vertices from the geometry input to the deformer  For example a cluster deformer would have
    the following information:   On import the weights are then mapped back to a specif
    
    :param attribute: (C Q E M) Specify the long name of deformer attribute that should be
    imported/exported along with the deformerWeights  i.e  -at "envelope" -at "skinningMethod"
    :type attribute: string
    :param defaultValue: (C Q E) Manually set the default value  Default values are values that
    are not written to file  For example, for blendShapes the default value is automatical
    :type defaultValue: float
    :param deformer: (C Q E M) Specify the deformer whose weights should be exported or
    imported  If a pattern is supplied for the deformer name (i.e: cluster*), only the first
    def
    :type deformer: string
    :param export: (C Q E) Export the given deformer
    :type export: boolean
    :param format: (C Q E) Specify either "XML" or "JSON" as the file extension to save as
    :type format: string
    :param ignoreName: (C Q E) Ignore the names of the layers on import, just use the order of
    the layers instead  This can be used when joint names have been changed  Leaving it o
    :type ignoreName: boolean
    :param im: (C Q E) Import weights to the specified deformer  See the method flag for
    details on how the weights will be mapped to the destination deformer
    :type im: boolean
    :param method: (C Q E) Specify the method used to map the weight during import  Valid
    values are: "index", "nearest", "barycentric", "bilinear" and "over"  The "index" meth
    :type method: string
    :param path: (C Q E) The path to the given file  Default to the current project
    :type path: string
    :param positionTolerance: (C Q E) The position tolerance is used to determine the radius of
    search for the nearest method  This flag is only used with import  Defaults to a huge
    numbe
    :type positionTolerance: float
    :param remap: (C Q E M) Remap maps source regular expression to destination format  It maps
    any name that matches the regular expression (before the semi-colon) to the expre
    :type remap: string
    :param shape: (C Q E M) Specify the source shape  Export will write out all the deformers
    on the shape node into one file  If a pattern is supplied for the shape name (i.e:
    :type shape: string
    :param skip: (C Q E M) Skip any deformer, shape, or layer that whose name matches the given
    regular expression string
    :type skip: string
    :param vertexConnections: (C Q E) Export vertex connection information, which is required
    for -m/-method "barycentric" and "bilinear"  The flag is only used with -ex/-export flag 
    The
    :type vertexConnections: boolean
    :param weightPrecision: (C Q E) Sets the output decimal precision for exported weights  The
    default value is 3
    :type weightPrecision: int
    :param weightTolerance: (C Q E) The weight tolerance is used to decide if a given weight
    value is close enough to the default value that it does not need to be included  This flag
    i
    :type weightTolerance: float
    :param worldSpace: (C Q E) For spatially based association methods (nearest), the position
    should be based on the world space position rather then the local object space
    :type worldSpace: boolean
    
    :returns: path to the file imported/exported, if successful
    :rtype: STRING
    """
    pass


def MatchRotation(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportBakeComplexEnd(*args, **kwargs):
    """
    
    """
    pass


def ParameterTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nodeIconButton(*args, align="", annotation="", backgroundColor=None, command=None,
                   defineTemplate="", disabledImage="", docTag="", dragCallback=None,
                   dropCallback=None, enable=True, enableBackground=True,
                   enableKeyboardFocus=True, exists=True, flipX=True, flipY=True, font="",
                   fullPathName=True, height=0, highlightColor=None, image="", image1="",
                   image2="", image3="", imageOverlayLabel="", isObscured=True, label="",
                   labelOffset=0, ltVersion="", manage=True, marginHeight=0, marginWidth=0,
                   noBackground=True, numberOfPopupMenus=True, overlayLabelBackColor=None,
                   overlayLabelColor=None, parent="", popupMenuArray=True, preventOverride=True,
                   rotation=0.0, statusBarMessage="", style="", useAlpha=True, useTemplate="",
                   version="", visible=True, visibleChangeCommand=None, width=0, q=True,
                   query=True, e=True, edit=True, **kwargs):
    """
    This control supports up to 3 icon images and 4 different display styles  The icon image
    displayed is the one that best fits the current size of the control given its current style
      This command creates a button that can be displayed with different icons, with or without
    a text label  If the button is drag and dropped onto other controls (e.g., Hy
    
    :param align: (C Q E) The label alignment  Alignment values are "left", "right", and
    "center"  By default, the label is aligned "center"  Currently only available when -st
    :type align: string
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param command: (C Q E) Command executed when the control is pressed  The command should
    return a string which will be used to facilitate node drag and drop
    :type command: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param disabledImage: (C Q E) Image used when the button is disabled  Image size must be
    the same as the image specified with the i/image flag  This is a Windows only flag
    :type disabledImage: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param flipX: (C Q E) Is the image flipped horizontally?
    :type flipX: boolean
    :param flipY: (C Q E) Is the image flipped vertically?
    :type flipY: boolean
    :param font: (C Q E) The font for the text  Valid values are "boldLabelFont",
    "smallBoldLabelFont", "tinyBoldLabelFont", "plainLabelFont", "smallPlainLabelFont",
    "oblique
    :type font: string
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param image: (C Q E) If you are not providing images with different sizes then you may use
    this flag for the control's image  If the "iconOnly" style is set, the icon wil
    :type image: string
    :param image1: (C Q E) First of three possible icons  The icon that best fits the current
    size of the control will be displayed
    :type image1: string
    :param image2: (C Q E) Second of three possible icons  The icon that best fits the current
    size of the control will be displayed
    :type image2: string
    :param image3: (C Q E) Third of three possible icons  The icon that best fits the current
    size of the control will be displayed
    :type image3: string
    :param imageOverlayLabel: (C Q E) A short string, up to 6 characters, representing a label
    that will be displayed on top of the image
    :type imageOverlayLabel: string
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C Q E) The text that appears in the control
    :type label: string
    :param labelOffset: (C Q E) The label offset  Default is 0  Currently only available when
    -st/style is set to "iconAndTextCentered"
    :type labelOffset: int
    :param ltVersion: (C Q E) This flag is used to specify the Maya LT version that this
    control feature was introduced, if the version flag is not specified, or if the version fl
    :type ltVersion: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param marginHeight: (C Q E) The number of pixels above and below the control content  The
    default value is 1 pixel
    :type marginHeight: int
    :param marginWidth: (C Q E) The number of pixels on either side of the control content  The
    default value is 1 pixel
    :type marginWidth: int
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param overlayLabelBackColor: (C Q E) The RGBA color of the shadow behind the label defined
    by imageOverlayLabel  Default is 50% transparent black: 0 0 0 .5
    :type overlayLabelBackColor: [float, float, float, float]
    :param overlayLabelColor: (C Q E) The RGB color of the label defined by imageOverlayLabel 
    Default is a light grey: .8 .8 .8
    :type overlayLabelColor: [float, float, float]
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rotation: (C Q E) The rotation value of the image in radians
    :type rotation: float
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param style: (C Q E) The draw style of the control  Valid styles are "iconOnly",
    "textOnly", "iconAndTextHorizontal", "iconAndTextVertical", and "iconAndTextCentered"  (N
    :type style: string
    :param useAlpha: (C Q E) Is the image using alpha channel?
    :type useAlpha: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param version: (C Q E) Specify the version that this control feature was introduced  The
    argument should be given as a string of the version number (e.g  "2013", "2014")  C
    :type version: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the button
    :rtype: string
    """
    pass


def PaintEffectsToCurve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorToggleExtendParentsPress(*args, **kwargs):
    """
    unknown
    """
    pass


def PasteSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def movIn(*args, file="", startTime=None, **kwargs):
    """
    Imports a .mov file into animation curves connected to the listed attributes  The attribute
    must be writable, since an animation curve will be created and connected to the attribute 
    If an animation curve already is connected to the attribute, the imported data is pasted
    onto that curve   The starting time used for the .mov file importation is the 
    
    :param file: (C) The name of the .mov file  If no extension is used, a .mov will be added
    :type file: string
    :param startTime: (C) The default start time for importing the .mov file is the current
    time  The startTime option sets the starting time for the .mov data in the current
    :type startTime: time
    
    :returns: 
    :rtype: None
    """
    pass


def SplitMeshWithProjectedCurveOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddHolder(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgExpressionEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CenterPivot(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyCheck(*args, edge=True, face=True, faceOffset=True, openFile="", **kwargs):
    """
    Dumps a description of internal memory representation of poly objects
    
    :param edge: (C) Check edge descriptions  If no flag is set, a complete check is performed
    :type edge: boolean
    :param face: (C) Check face descriptions  If no flag is set, a complete check is performed
    :type face: boolean
    :param faceOffset: (C) Check face offset descriptions  If no flag is set, a complete check
    is performed
    :type faceOffset: boolean
    :param openFile: (C) Opens a file that contains a poly description, as dumped out by the
    debug commands
    :type openFile: string
    
    :returns: The number of errors.
    :rtype: int
    """
    pass


def DeleteAllClips(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeRenderTextureRangeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NURBSSmoothnessFine(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def customerInvolvementProgram(*args, **kwargs):
    """
    
    """
    pass


def ReducePolygonOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateParticleDiskCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyCreateFacet(*args, constructionHistory=True, hole=True, name="", point=None,
                    subdivision=1, texture=0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Create a new polygonal object with the specified face, which will be closed  List of
    arguments must have at least 3 points
    
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param hole: (C M) Add a hole  The following points will define a hole  Holes can be
    defined either clockwise or counterclockwise  Note that this flag is not recommende
    :type hole: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param point: (C M) Adds a new point to the face  Coordinates of points are given in world
    reference  The point flag may also be passed with no arguments  That indicates
    :type point: [[, float, float, float, ]]
    :param subdivision: (C Q E) This flag specifies the level of subdivision  Subdivides edges
    into the given number of edges  C: Default is 1 (no subdivision)  Q: When queried, thi
    :type subdivision: int
    :param texture: (C Q E) Specifies how the face is mapped  0 - None; 1 - Normalize; 2 -
    Unitize C: Default is 0 (no mapping)  Q: When queried, this flag returns an int
    :type texture: int
    
    :returns: Object name and node name.
    :rtype: string[]
    """
    pass


def rampWidgetAttrless(*args, **kwargs):
    """
    
    """
    pass


def DisableParticles(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OpenVisorForMeshes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UpdateEraseSurface(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddPointsTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def graphTrackCtx(*args, exists=True, history=True, image1="", image2="", image3="", name="",
                  q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command can be used to create a track context for the graph editor
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: Context name
    :rtype: string
    """
    pass


def ArtPaintSkinWeightsToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorImportAnimation(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeDraggerToolDeactivate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nClothRemove(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FloatSelectedObjects(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorExplodeCompound(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def intField(*args, annotation="", backgroundColor=None, changeCommand=None, defineTemplate="",
             docTag="", dragCallback=None, dragCommand=None, dropCallback=None, editable=True,
             enable=True, enableBackground=True, enableKeyboardFocus=True, enterCommand=None,
             exists=True, fullPathName=True, height=0, highlightColor=None, isObscured=True,
             manage=True, maxValue=0, minValue=0, noBackground=True, numberOfPopupMenus=True,
             parent="", popupMenuArray=True, preventOverride=True, receiveFocusCommand=None,
             statusBarMessage="", step=0, useTemplate="", value=0, visible=True,
             visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
             **kwargs):
    """
    Create a field control that accepts only integer values and is bound by a minimum and
    maximum value  An invisible slider is attached to the field and accessed by holding down
    the Ctrl modifier key while pressing one of the mouse buttons  Dragging the invisible
    slider to the right with the middle mouse button increases the field value by the amount
    
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Command executed when the value changes  This command is not
    invoked when the value changes via the -v/value flag
    :type changeCommand: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dragCommand: (C E) Command executed when the value changes by dragging the invisible
    slider
    :type dragCommand: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param editable: (C Q E) The edit state of the field  By default, this flag is set to true
    and the field value may be changed by typing into it  If false then the field is 'r
    :type editable: boolean
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param enterCommand: (C E) Command executed when the keypad 'Enter' key is pressed
    :type enterCommand: script
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param maxValue: (C Q E) Upper limit of the field
    :type maxValue: int
    :param minValue: (C Q E) Lower limit of the field
    :type minValue: int
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param receiveFocusCommand: (C E) Command executed when the field receives focus
    :type receiveFocusCommand: script
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param step: (C Q E) Increment for the invisible slider  The field value will change by
    this amount when the invisible slider is dragged
    :type step: int
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param value: (C Q E) Value of the field
    :type value: int
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def HideLightManipulators(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_setExtendBorder(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Create2DContainerEmitterOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NURBSSmoothnessMedium(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Smoke(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateGhost(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TexSculptDeactivateBrushSize(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def LowQualityDisplay(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateIllustratorCurvesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeToggleUseAssetsAndPublishedAttributes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UVSetEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sbs_GetAllInputsFromSubstanceNode(*args, **kwargs):
    """
    
    """
    pass


def unassignInputDevice(*args, clutch="", device="", q=True, query=True, **kwargs):
    """
    This command deletes all command strings associated with this device
    
    :param clutch: (C) Only delete command attachments with this clutch
    :type clutch: string
    :param device: (C) Specifies the device to work on
    :type device: string
    
    :returns: 
    :rtype: None
    """
    pass


def dR_selectModeTweakMarquee(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BrushPresetBlendShading(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSetDensityBrushTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def mouldSubdiv(*args, **kwargs):
    """
    
    """
    pass


def removeListItem(*args, **kwargs):
    """
    
    """
    pass


def loadFluid(*args, currentTime=True, frame=0.0, initialConditions=True, q=True, query=True,
              e=True, edit=True, **kwargs):
    """
    A command to set builtin fluid attributes such as Density, Velocity, etc for all cells in
    the grid from the initial state cache
    
    :param currentTime: (C Q E) This flag is now obsolete  Move the cache clip in the Trax
    editor to view different frames of the playback cache
    :type currentTime: boolean
    :param frame: (C Q E) This flag is now obsolete  Move the cache clip in the Trax editor to
    view different frames of the playback cache
    :type frame: float
    :param initialConditions: (C Q E) load initial conditions cache
    :type initialConditions: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def AddBoatLocator(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AddFaceDivisions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RemoveBifrostField(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def QualityDisplayMarkingMenu(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DetachComponent(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmDraRender(*args, **kwargs):
    """
    
    """
    pass


def DisableSnapshots(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_convertSelectionToFace(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def trimCtx(*args, **kwargs):
    """
    
    """
    pass


def polyUVCoverage(*args, uvRange=None, **kwargs):
    """
    Return the UV space coverage of the specified components
    
    :param uvRange: (C) UV space range for calculating the coverage The 4 values specify the
    minimum U, V and maximum U, V in that order  Default is 0.0 0.0 1.0 1.0
    :type uvRange: [float, float, float, float]
    
    :returns: UV space coverage percentage
    :rtype: float[]
    """
    pass


def dR_selConstraintUVEdgeLoop(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FitBSplineOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ReassignBoneLatticeJoint(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def EnableIKSolvers(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def symmetrizeUV(*args, **kwargs):
    """
    
    """
    pass


def AddCombinationTargetOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def artAttrSkinPaintCtx(*args, accopacity=False, activeListChangedProc="", afterStrokeCmd="",
                        alphaclamp="none", alphaclamplower=0.0, alphaclampupper=1.0,
                        attrSelected="", beforeStrokeCmd="", brushalignment=True,
                        brushfeedback=True, clamp="none", clamplower=0.0, clampupper=1.0,
                        clear=True, colorAlphaValue=0.0, colorRGBAValue=None,
                        colorRGBValue=None, colorRamp="", colorfeedback=False,
                        colorfeedbackOverride=False, colorrangelower=0.0, colorrangeupper=1.0,
                        dataTypeIndex=0, disablelighting=False, dragSlider="",
                        duringStrokeCmd="", dynclonemode=True, exists=True, expandfilename=True,
                        exportaspectratio=0.0, exportfilemode="luminance/rgb",
                        exportfilesave="", exportfilesizex=0, exportfilesizey=0,
                        exportfiletype="", filterNodes=True, history=True, image1="", image2="",
                        image3="", importfileload="", importfilemode="alpha",
                        importreassign=False, influence="", interactiveUpdate=True,
                        lastRecorderCmd="", lastStampName="", lowerradius=0.0, makeStroke=0,
                        mappressure="none", maxvalue=1.0, minvalue=0.0, name="",
                        objattrArray="", opacity=1.0, outline=True, outwhilepaint=False,
                        paintNodeArray="", paintSelectMode=0, paintattrselected="",
                        paintmode="screen", paintoperationtype="Paint", pickColor=True,
                        pickValue=True, playbackCursor=None, playbackPressure=0.0,
                        preserveclonesource=True, profileShapeFile="", projective=False,
                        radius=1.0, rampMaxColor=None, rampMinColor=None, record=True,
                        reflection=False, reflectionaboutorigin=True, reflectionaxis="x",
                        screenRadius=0.0, selectclonesource=True, selectedattroper="absolute",
                        showactive=True, skinPaintMode=0, stampDepth=0.0, stampProfile="",
                        stampSpacing=1.0, strokesmooth="", surfaceConformedBrushVertices=True,
                        tablet=True, tangentOutline=True, toolOffProc="", toolOnProc="",
                        useColorRamp=True, useMaxMinColor=True, usepressure=False, value=0.0,
                        whichTool="", worldRadius=0.0, xrayJoints=True, q=True, query=True,
                        e=True, edit=True, **kwargs):
    """
    This is a context command to set the flags on the artAttrContext, which is the base context
    for attribute painting operations  All commands require the name of the context as the last
    argument as this provides the name of the context to create, edit or query   This is a
    context command to set the flags on the Paint skin weights tool context
    
    :param accopacity: (C Q E) Sets opacity accumulation on/off  C: Default is false (Except
    for sculpt tool for which it is true by default)  Q: When queried, it returns a boolean
    :type accopacity: boolean
    :param activeListChangedProc: (C Q E) Accepts a string that contains a MEL command that is
    invoked whenever the active list changes  There may be some situations where the UI, for
    example
    :type activeListChangedProc: string
    :param afterStrokeCmd: (C Q E) The passed string is executed as a MEL command immediately
    after the end of a stroke  C: Default is no command  Q: When queried, it returns the curre
    :type afterStrokeCmd: string
    :param alphaclamp: (C Q E) Specifies if the weight value should be alpha clamped to the
    lower and upper bounds  There are four options here: "none" - no clamping is performed,
    :type alphaclamp: string
    :param alphaclamplower: (C Q E) Specifies the lower bound for the alpha values  C: Default
    is 0.0  Q: When queried, it returns a float
    :type alphaclamplower: float
    :param alphaclampupper: (C Q E) Specifies the upper bound for the alpha values  C: Default
    is 1.0  Q: When queried, it returns a float
    :type alphaclampupper: float
    :param attrSelected: (Q) Returns a name of the currently selected attribute  Q: When
    queried, it returns a string
    :type attrSelected: string
    :param beforeStrokeCmd: (C Q E) The passed string is executed as a MEL command immediately
    before the start of a stroke  C: Default is no command  Q: When queried, it returns the cu
    :type beforeStrokeCmd: string
    :param brushalignment: (C Q E) Specifies the path brush alignemnt  If true, the brush will
    align to stroke path, otherwise it will align to up vector  C: Default is true  Q: When q
    :type brushalignment: boolean
    :param brushfeedback: (C Q E) Specifies if the brush additional feedback should be drawn 
    C: Default is TRUE  Q: When queried, it returns a boolean
    :type brushfeedback: boolean
    :param clamp: (C Q E) Specifies if the weight value should be clamped to the lower and
    upper bounds  There are four options here: "none" - no clamping is performed, "lower
    :type clamp: string
    :param clamplower: (C Q E) Specifies the lower bound for the values  C: Default is 0.0  Q:
    When queried, it returns a float
    :type clamplower: float
    :param clampupper: (C Q E) Specifies the upper bound for the values  C: Default is 1.0  Q:
    When queried, it returns a float
    :type clampupper: float
    :param clear: (C E) Floods all cvs/vertices to the current value
    :type clear: boolean
    :param colorAlphaValue: (C Q E) The Alpha value of the color
    :type colorAlphaValue: float
    :param colorRGBAValue: (C Q E) The RGBA value of the color
    :type colorRGBAValue: [float, float, float, float]
    :param colorRGBValue: (C Q E) The RGB value of the color
    :type colorRGBValue: [float, float, float]
    :param colorRamp: (C Q E) Allows a user defined color ramp to be used to map values to
    colors
    :type colorRamp: string
    :param colorfeedback: (C Q E) Sets on/off the color feedback display  C: Default is FALSE 
    Q: When queried, it returns a boolean
    :type colorfeedback: boolean
    :param colorfeedbackOverride: (C Q E) Sets on/off the color feedback override  C: Default
    is FALSE  Q: When queried, it returns a boolean
    :type colorfeedbackOverride: boolean
    :param colorrangelower: (C Q E) Specifies the value that maps to black when color feedback
    mode is on  C: Default is 0.0  Q: When queried, it returns a float
    :type colorrangelower: float
    :param colorrangeupper: (C Q E) Specifies the value that maps to the maximum color when
    color feedback mode is on  C: Default is 1.0  Q: When queried, it returns a float
    :type colorrangeupper: float
    :param dataTypeIndex: (Q E) When the selected paintable attribute is a vectorArray, it
    specifies which field to paint on
    :type dataTypeIndex: int
    :param disablelighting: (C Q E) If color feedback is on, this flag determines whether
    lighting is disabled or not for the surfaces that are affected  C: Default is FALSE  Q:
    When qu
    :type disablelighting: boolean
    :param dragSlider: (C E) Sets the current brush drag state for resizing or offsetting the
    brush (like the 'b' and 'm' default hotkeys)  The string argument is one of: "radius
    :type dragSlider: string
    :param duringStrokeCmd: (C Q E) The passed string is executed as a MEL command during the
    stroke, each time the mouse is dragged  C: Default is no command  Q: When queried, it
    retur
    :type duringStrokeCmd: string
    :param dynclonemode: (C Q E) Enable or disable dynamic clone mode
    :type dynclonemode: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param expandfilename: (C E) If true, it will expand the name of the export file and
    concatenate it with the surface name  Otherwise it will take the name as it is  C: Default
    is
    :type expandfilename: boolean
    :param exportaspectratio: (C Q E) Value of aspect ratio for export
    :type exportaspectratio: float
    :param exportfilemode: (C Q E) Specifies the export channel.The valid entries here are:
    "alpha", "luminance", "rgb", "rgba"  C: Default is "luminance/rgb"  Q: When queried, it
    retu
    :type exportfilemode: string
    :param exportfilesave: (E) Exports the attribute map and saves to a specified file
    :type exportfilesave: string
    :param exportfilesizex: (C Q E) Specifies the width of the attribute map to export  C:
    Default width is 256  Q: When queried, it returns an integer
    :type exportfilesizex: int
    :param exportfilesizey: (C Q E) Specifies the width of the attribute map to export  C:
    Default width is 256  Q: When queried, it returns an integer
    :type exportfilesizey: int
    :param exportfiletype: (C Q E) Specifies the image file format  It can be one of the
    following: "iff", "tiff", "jpeg", "alias", "rgb", "fit" "postScriptEPS", "softimage",
    "wavefron
    :type exportfiletype: string
    :param filterNodes: (E) Sets the node filter
    :type filterNodes: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param importfileload: (E) Load the attribute map a specified file
    :type importfileload: string
    :param importfilemode: (C Q E) Specifies the channel to import  The valid entries here are:
    "alpha", "luminance", "red", "green", "blue", and "rgb" C: Default is "alpha"  Q: When q
    :type importfilemode: string
    :param importreassign: (C Q E) Specifies if the multiply atrribute maps are to be
    reassigned while importing  Only maps previously exported from within Artisan can be
    reassigned  C
    :type importreassign: boolean
    :param influence: (Q E) Specifies which joint has been selected by the user for painting 
    Q: When queried, it returns a string
    :type influence: string
    :param interactiveUpdate: (C Q E) Specifies how often to transfer the painted values into
    the attribute  TRUE: transfer them "continuously" (many times per stroke) FALSE: transfer
    the
    :type interactiveUpdate: boolean
    :param lastRecorderCmd: (C Q E) Value of last recorded command
    :type lastRecorderCmd: string
    :param lastStampName: (C Q E) Value of the last stamp name
    :type lastStampName: string
    :param lowerradius: (C Q E) Sets the lower size of the brush (only apply on tablet)
    :type lowerradius: float
    :param makeStroke: (C Q E M) Stroke point values
    :type makeStroke: int
    :param mappressure: (C Q E) Sets the tablet pressure mapping when the table is used  There
    are four options: "none" - the pressure has no effect, "opacity" - the pressure is map
    :type mappressure: string
    :param maxvalue: (C Q E) Specifies the maximum value for each attribute  C: Default is 1.0 
    Q: When queried, it returns a float
    :type maxvalue: float
    :param minvalue: (C Q E) Specifies the minimum value for each attribute  C: Default is 0.0 
    Q: When queried, it returns a float
    :type minvalue: float
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param objattrArray: (Q) An array of all paintable attributes  Each element of the array is
    a string with the following information: NodeType.NodeName.AttributeName.MenuType
    :type objattrArray: string
    :param opacity: (C Q E) Sets the brush opacity  C: Default is 1.0  Q: When queried, it
    returns a float
    :type opacity: float
    :param outline: (C Q E) Specifies if the brush should be drawn  C: Default is TRUE  Q: When
    queried, it returns a boolean
    :type outline: boolean
    :param outwhilepaint: (C Q E) Specifies if the brush outline should be drawn while painting
     C: Default is FALSE  Q: When queried, it returns a boolean
    :type outwhilepaint: boolean
    :param paintNodeArray: (Q) An array of paintable nodes  Q: When queried, it returns a
    string
    :type paintNodeArray: string
    :param paintSelectMode: (Q E) Specifies whether the paint select tool: adds to selection
    (1) removes from selection (2), toggles selection (3) Q: When queried, it returns an int a
    :type paintSelectMode: int
    :param paintattrselected: (E) An array of selected paintable attributes  Each element of
    the array is a string with the following information: NodeType.NodeName.AttributeName
    :type paintattrselected: string
    :param paintmode: (C Q E) Specifies the paint mode  There are two possibilities: "screen"
    and "tangent"  C: Default is "screen"  Q: When queried, it returns a string
    :type paintmode: string
    :param paintoperationtype: (C Q E) Specifies the operation type used by the Paint Tool 
    Currently, we support the following paint modes: "Paint", "Smear", "Blur", "Erase" and
    "Clone"
    :type paintoperationtype: string
    :param pickColor: (C Q E) Set pick color mode on or off
    :type pickColor: boolean
    :param pickValue: (C Q E) Toggle for picking
    :type pickValue: boolean
    :param playbackCursor: (C Q E M) Values for the playback cursor
    :type playbackCursor: [float, float]
    :param playbackPressure: (C Q E M) Valus for the playback pressure
    :type playbackPressure: float
    :param preserveclonesource: (C Q E) Whether or not to preserve a clone source
    :type preserveclonesource: boolean
    :param profileShapeFile: (Q E) Passes a name of the image file for the stamp shape profile
    :type profileShapeFile: string
    :param projective: (C Q E) Specifies the projective paint mode  C: Default is 'false'  Q:
    When queried, it returns a boolean
    :type projective: boolean
    :param radius: (C Q E) Sets the size of the brush  C: Default is 1.0 cm  Q: When queried,
    it returns a float
    :type radius: float
    :param rampMaxColor: (C Q E) Defines a special color to be used when the value is greater
    than or equal to the maximum value
    :type rampMaxColor: [float, float, float]
    :param rampMinColor: (C Q E) Defines a special color to be used when the value is less than
    or equal to the minimum value
    :type rampMinColor: [float, float, float]
    :param record: (C Q E) Toggle on for recording
    :type record: boolean
    :param reflection: (C Q E) Specifies the reflection mode  C: Default is 'false'  Q: When
    queried, it returns a boolean
    :type reflection: boolean
    :param reflectionaboutorigin: (C Q E) Toggle on to reflect about the origin
    :type reflectionaboutorigin: boolean
    :param reflectionaxis: (C Q E) Specifies the reflection axis  There are three
    possibilities: "x", "y" and "z"  C: Default is "x"  Q: When queried, it returns a string
    :type reflectionaxis: string
    :param screenRadius: (C Q E) Brush radius on the screen
    :type screenRadius: float
    :param selectclonesource: (C Q E) Toggle on to select the clone source
    :type selectclonesource: boolean
    :param selectedattroper: (C Q E) Sets the edit weight operation  Four edit weights
    operations are provided : "absolute" - the value of the weight is replaced by the current
    one, "add
    :type selectedattroper: string
    :param showactive: (C Q E) Sets on/off the display of the surface isoparms  C: Default is
    TRUE  Q: When queried, it returns a boolean
    :type showactive: boolean
    :param skinPaintMode: (Q E) Specifies whether the skin paint tool is in paint skin weights
    mode (1) Marquee select mode (0), or paint select mode (2) Q: When queried, it returns
    :type skinPaintMode: int
    :param stampDepth: (C Q E) Depth of the stamps
    :type stampDepth: float
    :param stampProfile: (C Q E) Sets the brush profile of the current stamp  Currently, the
    following profiles are supported: "gaussian", "poly", "solid" and "square"  C: Default is
    :type stampProfile: string
    :param stampSpacing: (C Q E) Specifies the stamp spacing  Default is 1.0
    :type stampSpacing: float
    :param strokesmooth: (C Q E) Stroke smoothing type name
    :type strokesmooth: string
    :param surfaceConformedBrushVertices: (C Q E) Enables/disables the the display of the
    effective brush area as affected vertices
    :type surfaceConformedBrushVertices: boolean
    :param tablet: (Q) Returns true if the tablet device is present, false if it is absent
    :type tablet: boolean
    :param tangentOutline: (C Q E) Enables/disables the display of the brush circle tangent to
    the surface
    :type tangentOutline: boolean
    :param toolOffProc: (C Q E) Accepts a strings describing the name of a MEL procedure that
    is invoked whenever the tool is turned off  For example, cloth invokes "clothPaintToolO
    :type toolOffProc: string
    :param toolOnProc: (C Q E) Accepts a strings describing the name of a MEL procedure that is
    invoked whenever the tool is turned on  For example, cloth invokes "clothPaintToolOn
    :type toolOnProc: string
    :param useColorRamp: (C Q E) Specifies whether the user defined color ramp should be used
    to map values from to colors  If this is turned off, the default greyscale feedback will
    :type useColorRamp: boolean
    :param useMaxMinColor: (C Q E) Specifies whether the out of range colors should be used 
    See rampMinColor and rampMaxColor flags for further details
    :type useMaxMinColor: boolean
    :param usepressure: (C Q E) Sets the tablet pressure on/off  C: Default is false  Q: When
    queried, it returns a boolean
    :type usepressure: boolean
    :param value: (C Q E) Specifies the value for each attribute  C: Default is 0.0  Q: When
    queried, it returns a float
    :type value: float
    :param whichTool: (C Q E) The string defines the name of the tool to be used for the
    Artisan context  An example is "artClothPaint"  In query mode, the tool name for the given
    :type whichTool: string
    :param worldRadius: (C Q E) Radius in worldspace
    :type worldRadius: float
    :param xrayJoints: (Q E) Specifies whether joints should be displayed in xray mode while
    painting Q: When queried, it returns a boolean
    :type xrayJoints: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def RemoveBifrostFoamMask(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Boundary(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypergraphDGWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_bevelTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RemoveConstraintTarget(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def iconTextRadioCollection(*args, collectionItemArray=True, defineTemplate="",
                            disableCommands=True, exists=True, gl=True,
                            numberOfCollectionItems=True, parent="", select="", useTemplate="",
                            q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a cluster for iconTextRadioButtons  Clusters will be parented to the
    current default layout if no parent is specified with the -p/parent flag  As children of
    the layout they will be deleted when the layout is deleted  Clusters may also span more
    than one window if the -g/global flag is used  In this case the cluster has no pare
    
    :param collectionItemArray: (Q) Returns a string list giving the long names of all the
    items in this collection
    :type collectionItemArray: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param disableCommands: (E) Allows a particular iconTextRadioButton in the collection to be
    selected without invoking the commands attached to the -cc/changeCommand, -onc/onComm
    :type disableCommands: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param gl: (C Q) Set the collection to have no parent layout  If the collection has a
    parent layout then it will be deleted with that layout, otherwise if it is speci
    :type gl: boolean
    :param numberOfCollectionItems: (Q) Returns the number of items that are in this
    collection
    :type numberOfCollectionItems: boolean
    :param parent: (C) Set the specified layout to be the parent layout of the cluster
    :type parent: string
    :param select: (C Q E) Select the specified collection item  If queried will return the
    name of the currently selected collection item
    :type select: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: The name of the iconTextRadioCollection created.
    :rtype: string
    """
    pass


def LevelOfDetailGroupOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ClearPaintEffectsView(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CurveFlow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleDisplayGradient(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ScriptPaintTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeEditTexture(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DetachCurve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def commandLine(*args, annotation="", backgroundColor=None, command=None, defineTemplate="",
                docTag="", dragCallback=None, dropCallback=None, enable=True,
                enableBackground=True, enableKeyboardFocus=True, enterCommand=None, exists=True,
                fullPathName=True, height=0, highlightColor=None, holdFocus=True,
                inputAnnotation="", isObscured=True, manage=True, noBackground=True,
                numberOfHistoryLines=0, numberOfPopupMenus=True, outputAnnotation="", parent="",
                popupMenuArray=True, preventOverride=True, sourceType="", statusBarMessage="",
                useTemplate="", visible=True, visibleChangeCommand=None, width=0, q=True,
                query=True, e=True, edit=True, **kwargs):
    """
    This command creates a single line for command input/output.
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param command: (C E) Command executed when the command line text changes
    :type command: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param enterCommand: (C E) Command executed when the keypad 'Enter' key is pressed
    :type enterCommand: script
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param holdFocus: (C Q E) Sets whether the command line should hold focus after exectuing a
    command
    :type holdFocus: boolean
    :param inputAnnotation: (C Q E) Annotate the input field with an extra string value
    :type inputAnnotation: string
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfHistoryLines: (C Q E) Sets the maximum number of commands saved to the
    command line history  Up to -nhl/numberOfHistoryLines previous commands will be available
    by pressin
    :type numberOfHistoryLines: int
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param outputAnnotation: (C Q E) Annotate the output field with an extra string value
    :type outputAnnotation: string
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param sourceType: (C Q E) Sets the source type of this command line  Currently supports
    "mel" (enabled by default) and "python"
    :type sourceType: string
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: : Full path name to the control.
    :rtype: string
    """
    pass


def DeleteAllExpressions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def createPolyTorusCtx(*args, **kwargs):
    """
    
    """
    pass


def FBXExportCameras(*args, **kwargs):
    """
    
    """
    pass


def ToggleSceneTimecode(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MergeVerticesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleFullScreenMode(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_viewFront(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def addIK2BsolverCallbacks(*args, **kwargs):
    """
    
    """
    pass


def AddPondBoatLocator(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def texTweakUVContext(*args, exists=True, image1="", image2="", image3="", position=True,
                      tolerance=0.0, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command can be used to create, edit, or query a texture editor move manip context 
    Note that the above flags control the global behaviour of all texture editor move manip
    contexts  Changing one context independently is not allowed  Changing a context's behaviour
    using the above flags, will change all existing texture editor move manip contexts
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param position: (Q) Returns the current position of the manipulator
    :type position: boolean
    :param tolerance: (C Q E) Controls the initial selection snapping tolerance
    :type tolerance: float
    
    :returns: (the name of the new context)
    :rtype: string
    """
    pass


def ShowCameras(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def createNurbsSquareCtx(*args, **kwargs):
    """
    
    """
    pass


def MatchUVs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UVIsolateLoadSet(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyStraightenUVBorder(*args, blendOriginal=0.0, caching=True, constructionHistory=True,
                           curvature=0.0, gapTolerance=0, name="", nodeState=0,
                           preserveLength=0.0, uvSetName="", worldSpace=True, q=True,
                           query=True, e=True, edit=True, **kwargs):
    """
    Move border UVs along a simple curve
    
    :param blendOriginal: (C Q) Interpolation factor between the target and original UV shape 
    When the value is 0, the UVs will exactly fit the target curve  When the value is 1, n
    :type blendOriginal: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param curvature: (C Q) How curved the UV path will be  0 is a straight line  When the
    values is 1, the mid point of the curve will be moved away from a straight line by 1/2
    :type curvature: float
    :param gapTolerance: (C Q) When non 0, Small gaps between UV selection are filled  The
    integer number represent how many UVs must be traversed to connect togeterh selected piec
    :type gapTolerance: int
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param preserveLength: (C Q) How much we want to respect the UV edge ratios  When the value
    is 1, we build new UV position along the desired curve, respecting the original UV spa
    :type preserveLength: float
    :param uvSetName: (C) Name of the UV set to be created
    :type uvSetName: string
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name
    :rtype: string
    """
    pass


def TexSculptActivateBrushSize(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectMaskToolMarkingMenuPopDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UVCylindricProjectionOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateNURBSConeOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def artAttrSkinPaintCmd(*args, **kwargs):
    """
    
    """
    pass


def ConvertSelectionToFaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorSetTraversalDepthUnlim(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ScriptEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GameExporterWnd(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OptimizeScene(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SubdivSmoothnessMedium(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SurfaceEditingToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeConvertPSDToLayeredTexture(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OffsetCurveOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GraphSnap(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def deltaMush(*args, after=True, afterReference=True, before=True, deformerTools=True,
              envelope=1, exclusive="", frontOfChain=True, geometry="", geometryIndices=True,
              ignoreSelected=True, includeHiddenSelections=False, inwardConstraint=0.0, name="",
              outwardConstraint=0.0, parallel=True, pinBorderVertices=True, prune=True,
              remove=True, smoothingIterations=10, smoothingStep=0.5, split=True, q=True,
              query=True, e=True, edit=True, **kwargs):
    """
    This command is used to create, edit and query deltaMush nodes
    
    :param after: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type after: boolean
    :param afterReference: (C E) The -afterReference flag is used to specify deformer ordering
    in a hybrid way that choses between -before and -after automatically  If the geometry b
    :type afterReference: boolean
    :param before: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type before: boolean
    :param deformerTools: (Q) Returns the name of the deformer tool objects (if any) as string
    string ..
    :type deformerTools: boolean
    :param envelope: (C Q E) Envelope of the delta mush node  The envelope determines the
    percent of deformation  Value is clamped to [0, 1] range  Default is 1
    :type envelope: float
    :param exclusive: (C Q) Puts the deformation set in a deform partition
    :type exclusive: string
    :param frontOfChain: (C E) This command is used to specify that the new deformer node
    should be placed ahead (upstream) of existing deformer and skin nodes in the shape's histo
    :type frontOfChain: boolean
    :param geometry: (Q E M) The specified object will be added to the list of objects being
    deformed by this deformer object, unless the -rm flag is also specified  When queried
    :type geometry: string
    :param geometryIndices: (Q) Complements the -geometry flag in query mode  Returns the multi
    index of each geometry
    :type geometryIndices: boolean
    :param ignoreSelected: (C) Tells the command to not deform objects on the current selection
    list
    :type ignoreSelected: boolean
    :param includeHiddenSelections: (C) Apply the deformer to any visible and hidden objects in
    the selection list  Default is false
    :type includeHiddenSelections: boolean
    :param inwardConstraint: (C Q E) Constrains the movement of the vertex to not move inward
    from the input deforming shape to preserve the contour  Value is in the [0,1] range 
    Default
    :type inwardConstraint: float
    :param name: (C) Used to specify the name of the node being created
    :type name: string
    :param outwardConstraint: (C Q E) Constrains the movement of the vertex to not move outward
    from the input deforming shape to preserve the contour  Value is in the [0,1] range 
    Defaul
    :type outwardConstraint: float
    :param parallel: (C E) Inserts the new deformer in a parallel chain to any existing
    deformers in the history of the object  A blendShape is inserted to blend the parallel r
    :type parallel: boolean
    :param pinBorderVertices: (C Q E) If enabled, vertices on mesh borders will be pinned to
    their current position during smoothing  Default is true
    :type pinBorderVertices: boolean
    :param prune: (E) Removes any points not being deformed by the deformer in its current
    configuration from the deformer set
    :type prune: boolean
    :param remove: (E M) Specifies that objects listed after the -g flag should be removed from
    this deformer
    :type remove: boolean
    :param smoothingIterations: (C Q E) Number of smoothing iterations performed by the delta
    mush node  Default is 10
    :type smoothingIterations: int
    :param smoothingStep: (C Q E) Step amount used per smoothing iteration  Value is clamped to
    [0, 1] range  A higher value may lead to instabilities but converges faster compared to
    :type smoothingStep: float
    :param split: (C E) Branches off a new chain in the dependency graph instead of
    inserting/appending the deformer into/onto an existing chain  Works in create mode (and e
    :type split: boolean
    
    :returns: Delta mush deformer node name
    :rtype: string
    """
    pass


def SelectUnmappedFaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SymmetrizeUVContext(*args, **kwargs):
    """
    
    """
    pass


def CreatePassiveRigidBodyOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_outlinerTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteAllRigidBodies(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectObjectsShadowedByLight(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_targetWeldTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteFBIKSelectedKeys(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShadingGroupAttributeEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SoftModDeformerOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def imageWindowEditor(*args, **kwargs):
    """
    
    """
    pass


def DisableConstraints(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PickWalkUpSelect(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def checkDefaultRenderGlobals(*args, q=True, query=True, e=True, edit=True, **kwargs):
    """
    To query whether or not the defaultRenderGlobals node has been modified since the last file
    save, use `ls -modified`  To force the scene to be dirty/clean use `file -modified`
    
    
    :returns: 
    :rtype: None
    """
    pass


def HideUnselectedObjects(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GreasePencilTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeDraggerToolActivate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreatePolygonToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def cMuscleSplineBind(*args, **kwargs):
    """
    
    """
    pass


def TimeEditorToggleSnapToClipRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def arclen(*args, caching=True, constructionHistory=True, nodeState=0, q=True, query=True,
           e=True, edit=True, **kwargs):
    """
    This command returns the arclength of a curve if the history flag is not set (the default) 
    If the history flag is set, a node is created that can produce the arclength, and is
    connected and its name returned  Having the construction history option on makes this
    command useful for expressions
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    
    :returns: Length in non history mode.
    :rtype: float
    """
    pass


def dimWhen(*args, clear=True, false=True, true=True, **kwargs):
    """
    This method attaches the named UI object (first argument) to the named condition (second
    argument) so that the object will be dimmed when the condition is in a particular state  
    This command will fail if the object does not exist  If the condition does not exist (yet),
    that's okay --- a placeholder will be used until such a condition comes into ex
    
    :param clear: (C) Remove the condition on the specified dimmable
    :type clear: boolean
    :param false: (C) Dim the object when the condition is false
    :type false: boolean
    :param true: (C) Dim the object when the condition is true  (default)
    :type true: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def DeleteMotionPaths(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyUniteSkinned(*args, centerPivot=True, constructionHistory=True, mergeUVSets=1,
                     objectPivot=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Command to combine poly mesh objects (as polyUnite) while retaining the smooth skinning
    setup on the combined object
    
    :param centerPivot: (C Q E) Set the resulting object's pivot to the center of the selected
    objects bounding box
    :type centerPivot: boolean
    :param constructionHistory: (C Q E) Turn the construction history on or off
    :type constructionHistory: boolean
    :param mergeUVSets: (C Q E) Specify how UV sets will be merged on the output mesh  The
    choices are 0 | 1 | 2  0 = Do not merge  Each UV set on each mesh will become a new UV set
    :type mergeUVSets: int
    :param objectPivot: (C Q E) Set the resulting object's pivot to last selected object's
    pivot
    :type objectPivot: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def polyMapDel(*args, caching=True, constructionHistory=True, name="", nodeState=0, q=True,
               query=True, e=True, edit=True, **kwargs):
    """
    Deletes texture coordinates (UVs) from selected faces
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def swatchDisplayPort(*args, annotation="", backgroundColor=None, borderColor=None,
                      borderWidth=0, defineTemplate="", docTag="", dragCallback=None,
                      dropCallback=None, enable=True, enableBackground=True,
                      enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
                      highlightColor=None, isObscured=True, manage=True, noBackground=True,
                      numberOfPopupMenus=True, parent="", popupMenuArray=True,
                      pressCommand=None, preventOverride=True, renderPriority=0, renderSize=0,
                      shadingNode=None, statusBarMessage="", useTemplate="", visible=True,
                      visibleChangeCommand=None, width=0, widthHeight=None, q=True, query=True,
                      e=True, edit=True, **kwargs):
    """
    This command creates a 3dPort that displays a swatch representing the shading node   The
    optional argument is the name of the 3dPort
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param borderColor: (C Q E) The border color of the swatch
    :type borderColor: [float, float, float]
    :param borderWidth: (C Q E) The border width of the swatch  The value will be clamped
    between 0 and 4
    :type borderWidth: int
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param pressCommand: (C E) Specifies the command to be run when the swatch is clicked on
    :type pressCommand: script
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param renderPriority: (C E) Specifies the priority to render the swatch  This flag can
    only be used in parallel swatch rendering  When more than one swatch are waiting in the re
    :type renderPriority: int
    :param renderSize: (C Q E) The render size of the swatch  The value will be clamped between
    32 and 512
    :type renderSize: int
    :param shadingNode: (C Q E) Name of the shadingNode
    :type shadingNode: name
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    :param widthHeight: (C E) The width and height of the port
    :type widthHeight: [int, int]
    
    :returns: - the name of the port created or modified
    :rtype: string
    """
    pass


def particleFill(*args, closePacking=True, doubleWalled=True, maxX=0.0, maxY=0.0, maxZ=0.0,
                 minX=0.0, minY=0.0, minZ=0.0, particleDensity=0.0, resolution=0, **kwargs):
    """
    This command generates an nParticle system that fills the selected object with a grid of
    particles
    
    :param closePacking: (C) If this is on then the particles are positioned as closely as
    possible in a hexagonal close packing arrangement  Otherwise particles are packed in a
    :type closePacking: boolean
    :param doubleWalled: (C) This flag should be used if the thickness of the object to fill
    has been modeled( for example a mug )  Otherwise the particles will be created inside
    :type doubleWalled: boolean
    :param maxX: (C) The fill max bounds of the particles in X relative to the X bounds of the
    object  A value of zero is totally empty and one is totally full  The defau
    :type maxX: float
    :param maxY: (C) The fill max bounds of the particles in Y relative to the Y bounds of the
    object  A value of zero is totally empty and one is totally full  The defau
    :type maxY: float
    :param maxZ: (C) The fill max bounds of the particles in Z relative to the Z bounds of the
    object  A value of zero is totally empty and one is totally full  The defau
    :type maxZ: float
    :param minX: (C) The fill lower bounds of the particles in X relative to the X bounds of
    the object  A value of zero is totally full and one is totally empty  The def
    :type minX: float
    :param minY: (C) The fill lower bounds of the particles in Y relative to the Y bounds of
    the object  A value of zero is totally full and one is totally empty  The def
    :type minY: float
    :param minZ: (C) The fill lower bounds of the particles in Z relative to the Z bounds of
    the object  A value of zero is totally full and one is totally empty  The def
    :type minZ: float
    :param particleDensity: (C) This controls the size of the particles  At a value of 1.0 the
    particle size will exactly match the grid spacing determined by the resolution paramet
    :type particleDensity: float
    :param resolution: (C) This determines the total number of particles generated  It
    represent the resolution along the largest axis of the object's bounding box  For a cube
    :type resolution: int
    
    :returns: 
    :rtype: None
    """
    pass


def SnapKeys(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyOptUvs(*args, applyToShell=True, areaWeight=0.0, caching=True, constructionHistory=True,
               globalBlend=0.0, globalMethodBlend=0.0, iterations=0, name="", nodeState=0,
               optimizeAxis=0, pinSelected=True, pinUvBorder=True, scale=0.0,
               stoppingThreshold=0.0, useScale=True, uvSetName="", worldSpace=True, q=True,
               query=True, e=True, edit=True, **kwargs):
    """
    Optimizes selected UVs
    
    :param applyToShell: (C) Specifies where the whole object or just shells that are selected
    or pinned should be affected
    :type applyToShell: boolean
    :param areaWeight: (C) Surface driven importance  0 treat all faces equal  1 gives more
    importance to large ones
    :type areaWeight: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param globalBlend: (C) This allows the user to blend between a local optimization method
    (globalBlend = 0.0) and a global optimization method (globalBlend = 1.0)  The local
    :type globalBlend: float
    :param globalMethodBlend: (C) The global optimization method uses two functions to compute
    a minimization  The first function controls edge stretch by using edges lengths between
    :type globalMethodBlend: float
    :param iterations: (C) Maximum number of iterations for each connected UV piece
    :type iterations: int
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param optimizeAxis: (C) Degree of freedom for optimization: 0=Optimize freely, 1=Move
    vertically only, 2=Move horzontally only
    :type optimizeAxis: int
    :param pinSelected: (C) Specifies that the selected components should be pinned instead of
    the unselected components
    :type pinSelected: boolean
    :param pinUvBorder: (C) Specifies that the UV border should be pinned when doing the solve 
    By default only unselected components are pinned
    :type pinUvBorder: boolean
    :param scale: (C) Ratio between 2d and 3d space
    :type scale: float
    :param stoppingThreshold: (C) Minimum distorsion improvement between two steps in %
    :type stoppingThreshold: float
    :param useScale: (C) Adjust the scale or not
    :type useScale: boolean
    :param uvSetName: (C) Name of the UV set to be created
    :type uvSetName: string
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def arnoldTemperatureToColor(*args, **kwargs):
    """
    
    """
    pass


def ShowAllEditedComponents(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeDeleteAllShadingGroupsAndMaterials(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CommandWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Uniform(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateFlexorWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UnparentOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UntrimSurfacesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def snapshotBeadContext(*args, **kwargs):
    """
    
    """
    pass


def UVEditorInvertPin(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyUVRectangle(*args, caching=True, constructionHistory=True, name="", nodeState=0, q=True,
                    query=True, e=True, edit=True, **kwargs):
    """
    Given two vertices, does one of the following: 1) If the vertices define opposite corners
    of a rectangular area of quads, assigns a grid of UVs spanning the 0-1 area to that
    rectangle  2) If the vertices define an edge in a rectangular and topologically cylindrical
    area of quads, assigns UVs spanning the 0-1 area to that cylindrical patch, using th
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def keyframeRegionTrackCtx(*args, exists=True, history=True, image1="", image2="", image3="",
                           name="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command can be used to create a track context for the dope sheet editor
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: Context name
    :rtype: string
    """
    pass


def PaintEffectsToNurbsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateEmptyGroup(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def createPolyCylinderCtx(*args, **kwargs):
    """
    
    """
    pass


def dR_curveSnapRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXImportMode(*args, **kwargs):
    """
    
    """
    pass


def FBXGetTakeReferenceTimeSpan(*args, **kwargs):
    """
    
    """
    pass


def nexOpt(*args, **kwargs):
    """
    
    """
    pass


def polyCacheMonitor(*args, cacheValue=True, nodeName="", **kwargs):
    """
    When the cacheInput attribute has a positive value the midModifier node caches the output
    mesh improving performance in computations of downstream nodes  When the counter has a zero
    value the midModifier releases the cached data
    
    :param cacheValue: (C) Flag to indicate whether the node's cache counter should be
    incremented or decremented  True increments the counter, false decrements the counter
    :type cacheValue: boolean
    :param nodeName: (C) Name of the node whose cache counter needs to be changed
    :type nodeName: string
    
    :returns: 
    :rtype: None
    """
    pass


def VolumeAxis(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RotateToolWithSnapMarkingMenu(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BreakTangents(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TogglePolyDisplayLimitToSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeToggleShowNamespace(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UncreaseSubdivSurface(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AnimationTurntableOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RemoveShrinkWrapSurfaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_viewRight(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateContainer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideIntermediateObjects(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AlembicExportAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportDeleteOriginalTakeOnSplitAnimation(*args, **kwargs):
    """
    
    """
    pass


def dR_multiCutPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorClipTrimToggle(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectAllInput(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RenderViewPrevImage(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeletePolyElements(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def exclusiveLightCheckBox(*args, annotation="", backgroundColor=None, defineTemplate="",
                           docTag="", dragCallback=None, dropCallback=None, enable=True,
                           enableBackground=True, enableKeyboardFocus=True, exists=True,
                           fullPathName=True, height=0, highlightColor=None, isObscured=True,
                           label="", light=None, manage=True, noBackground=True,
                           numberOfPopupMenus=True, parent="", popupMenuArray=True,
                           preventOverride=True, statusBarMessage="", useTemplate="",
                           visible=True, visibleChangeCommand=None, width=0, q=True, query=True,
                           e=True, edit=True, **kwargs):
    """
    This command creates a checkBox that controls a light's exclusive non-exclusive status  An
    exclusive light is one that is not hooked up to the default-light-list, thus it does not
    illuminate all objects be default  However an exclusive light can be linked to an object
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C E) Value of the checkbox label
    :type label: string
    :param light: (C) The light that is to be made exclusive/non-exclusive
    :type light: name
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full name to the control
    :rtype: string
    """
    pass


def PlayblastOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleCVs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportEmbeddedTextures(*args, **kwargs):
    """
    
    """
    pass


def DuplicateCurveOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeDeleteNodes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def fluidAppend(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def setNClothStartState(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TrimToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetMeshKnifeTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleColorFeedback(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateTextOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleSubdDetails(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorSoloSelectedTracks(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def fluidReplaceCache(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def debugNamespace(*args, **kwargs):
    """
    
    """
    pass


def CreateActiveRigidBody(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleHulls(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AttachToPathOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GetHIKNodeName(*args, **kwargs):
    """
    
    """
    pass


def JointTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MakeMotorBoats(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PickWalkDownSelect(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def normalConstraint(*args, aimVector=None, layer="", name="", remove=True, targetList=True,
                     upVector=None, weight=0.0, weightAliasList=True, worldUpObject=None,
                     worldUpType="", worldUpVector=None, q=True, query=True, e=True, edit=True,
                     **kwargs):
    """
    Constrain an object's orientation based on the normal of the target surface(s) at the
    closest point(s) to the object   A normalConstraint takes as input one or more surface
    shapes (the targets) and a DAG transform node (the object)  The normalConstraint orients
    the constrained object such that the aimVector (in the object's local coordinate system)
    
    :param aimVector: (C Q E) Set the aim vector  This is the vector in local coordinates that
    points at the target  If not given at creation time, the default value of (1.0, 0.0,
    :type aimVector: [float, float, float]
    :param layer: (C E) Specify the name of the animation layer where the constraint should be
    added
    :type layer: string
    :param name: (C Q E) Sets the name of the constraint node to the specified name  Default
    name is constrainedObjectName_constraintType
    :type name: string
    :param remove: (E) removes the listed target(s) from the constraint
    :type remove: boolean
    :param targetList: (Q) Return the list of target objects
    :type targetList: boolean
    :param upVector: (C Q E) Set local up vector  This is the vector in local coordinates that
    aligns with the world up vector  If not given at creation time, the default value o
    :type upVector: [float, float, float]
    :param weight: (C Q E) Sets the weight value for the specified target(s)  If not given at
    creation time, the default value of 1.0 is used
    :type weight: float
    :param weightAliasList: (Q) Returns the names of the attributes that control the weight of
    the target objects  Aliases are returned in the same order as the targets are returned
    :type weightAliasList: boolean
    :param worldUpObject: (C Q E) Set the DAG object use for worldUpType "object" and
    "objectrotation"  See worldUpType for greater detail  The default value is no up object,
    which is
    :type worldUpObject: name
    :param worldUpType: (C Q E) Set the type of the world up vector computation  The
    worldUpType can have one of 5 values: "scene", "object", "objectrotation", "vector", or
    "none"
    :type worldUpType: string
    :param worldUpVector: (C Q E) Set world up vector  This is the vector in world coordinates
    that up vector should align with  See -wut/worldUpType (below)for greater detail  If not
    :type worldUpVector: [float, float, float]
    
    :returns: Name of the created constraint node
    :rtype: string[]
    """
    pass


def DeleteAllStrokes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteAllHistory(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def baseTemplate(*args, exists=True, fileName="", force=True, load=True, matchFile="",
                 silent=True, unload=True, viewList="", q=True, query=True, e=True, edit=True,
                 **kwargs):
    """
    This is the class for the commands that edit and/or query templates
    
    :param exists: (Q) Returns true or false depending upon whether the specified template
    exists  When used with the matchFile argument, the query will return true if the
    :type exists: boolean
    :param fileName: (C Q) Specifies the filename associated with the template  This argument
    can be used in conjunction with load, save or query modes  If no filename is assoc
    :type fileName: string
    :param force: (C) This flag is used with some actions to allow them to proceed with an
    overwrite or destructive operation  When used with load, it will allow an existi
    :type force: boolean
    :param load: () Load an existing template from a file  If a filename is specified for the
    template, the entire file (and all templates in it) will be loaded  If no f
    :type load: boolean
    :param matchFile: (Q) Used in query mode in conjunction with other flags this flag
    specifies an optional file name that is to be matched as part of the query operation  In
    :type matchFile: string
    :param silent: (C Q E) Silent mode will suppress any error or warning messages that would
    normally be reported from the command execution  The return values are unaffected
    :type silent: boolean
    :param unload: (C) Unload the specified template  This action will not delete the
    associated template file if one exists, it merely removes the template definition from
    :type unload: boolean
    :param viewList: (C Q) Used in query mode, returns a list of all views defined on the
    template
    :type viewList: string
    
    :returns: 
    :rtype: None
    """
    pass


def HideCameras(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorToggleUseAssetsAndPublishedAttributes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleSymmetryDisplay(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def setKeyframe(*args, animLayer="", animated=False, attribute="", breakdown=False, clip="",
                controlPoints=False, dirtyDG=True, float=0.0, hierarchy="", identity=True,
                inTangentType="", insert=True, insertBlend=True, minimizeRotation=False,
                noResolve=True, outTangentType="", respectKeyable=True, shape=True, time=None,
                useCurrentLockedWeights=False, value=0.0, q=True, query=True, e=True, edit=True,
                **kwargs):
    """
    This command creates keyframes for the specified objects, or the active objects if none are
    specified on the command line   The default time for the new keyframes is the current time 
    Override this behavior with the "-t" flag on the command line   The default value for the
    keyframe is the current value of the attribute for which a keyframe is set  
    
    :param animLayer: (C) Specifies that the new key should be placed in the specified
    animation layer  Note that if the objects being keyframed are not already part of the la
    :type animLayer: string
    :param animated: (C) Add the keyframe only to the attribute(s) that have already a keyframe
    on  Default: false
    :type animated: boolean
    :param attribute: (C M) Attribute name to set keyframes on
    :type attribute: string
    :param breakdown: (C Q E) Sets the breakdown state for the key  Default is false
    :type breakdown: boolean
    :param clip: (C) Specifies that the new key should be placed in the specified clip  Note
    that if the objects being keyframed are not already part of the clip, this fl
    :type clip: string
    :param controlPoints: (C) Explicitly specify whether or not to include the control points
    of a shape (see "-s" flag) in the list of attributes  Default: false
    :type controlPoints: boolean
    :param dirtyDG: (C) Allow dirty messages to be sent out when a keyframe is set
    :type dirtyDG: boolean
    :param float: (C M) Float time at which to set a keyframe on float-based animation curves
    :type float: float
    :param hierarchy: (C) Controls the objects this command acts on, relative to the specified
    (or active) target objects  Valid values are "above," "below," "both," and "none
    :type hierarchy: string
    :param identity: (C) Sets an identity key on an animation layer  An identity key is one
    that nullifies the effect of the anim layer  This flag has effect only when the at
    :type identity: boolean
    :param inTangentType: (C) The in tangent type for keyframes set by this command  Valid
    values are: "auto", clamped", "fast", "flat", "linear", "plateau", "slow", "spline", and
    :type inTangentType: string
    :param insert: (C) Insert keys at the given time(s) and preserve the shape of the animation
    curve(s)  Note: the tangent type on inserted keys will be fixed so that the
    :type insert: boolean
    :param insertBlend: (C) If true, a pairBlend node will be inserted for channels that have
    nodes other than animCurves driving them, so that such channels can have blended an
    :type insertBlend: boolean
    :param minimizeRotation: (C) For rotations, ensures that the key that is set is a minimum
    distance away from the previous key  Default is false
    :type minimizeRotation: boolean
    :param noResolve: (C) When used with the -value flag, causes the specified value to be set
    directly onto the animation curve, without attempting to resolve the value acros
    :type noResolve: boolean
    :param outTangentType: (C) The out tangent type for keyframes set by this command  Valid
    values are: "auto", "clamped", "fast", "flat", "linear", "plateau", "slow", "spline", "
    :type outTangentType: string
    :param respectKeyable: (C) When used with the -attribute flag, prevents the keying of the
    non keyable attributes
    :type respectKeyable: boolean
    :param shape: (C) Consider attributes of shapes below transforms as well, except
    "controlPoints"  Default: true
    :type shape: boolean
    :param time: (C M) Time at which to set a keyframe on time-based animation curves
    :type time: time
    :param useCurrentLockedWeights: (C) If we are setting a key over an existing key, use that
    key tangent's locked weight value for the new locked weight value  Default is false
    :type useCurrentLockedWeights: boolean
    :param value: (C) Value at which to set the keyframe  Using the value flag will not cause
    the keyed attribute to change to the specified value until the scene re-evalu
    :type value: float
    
    :returns: Number of keyframes set by this command.
    :rtype: int
    """
    pass


def ToggleHikDetails(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreatePolygonPlaneOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def InTangentSpline(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectUVBackFacingComponents(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolyRemoveCrease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def hardenPointCurve(*args, caching=True, multiplicity=1, nodeState=0, constructionHistory=True,
                     name="", object=True, replaceOriginal=True, q=True, query=True, e=True,
                     edit=True, **kwargs):
    """
    The hardenPointCurve command changes the knots of a curve given a list of control point
    indices so that the knot corresponding to that control point gets the specified
    multiplicity  Multiplicity of -1 is the universal value used for multiplicity equal to the
    degree of the curve.  limitations The CV whose multiplicity is being raised needs to have
    i
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param multiplicity: (C Q E) the required multiplicity of the curve knot Default: -1
    :type multiplicity: int
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def AbcImport(*args, **kwargs):
    """
    
    """
    pass


def stackTrace(*args, **kwargs):
    """
    
    """
    pass


def createPolyConeCtx(*args, **kwargs):
    """
    
    """
    pass


def LODGenerateMeshesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def selLoadSettings(*args, activeProxy="", deferReference=True, fileName="", numSettings=0,
                    proxyManager="", proxySetFiles="", proxySetTags="", proxyTag="",
                    referenceNode="", shortName=True, unresolvedName=True, q=True, query=True,
                    e=True, edit=True, **kwargs):
    """
    This command is used to edit and query information about the implicit load settings 
    Currently this is primarily intended for internal use within the Preload Reference Editor 
    selLoadSettings acts on load setting IDs  When implict load settings are built for a target
    scene, there will be one load setting for each reference in the target scene  Each
    
    :param activeProxy: (C Q E) Change or query the active proxy of a proxy set  In query mode,
    returns the proxyTag of the active proxy; in edit mode, finds the proxy in the proxyS
    :type activeProxy: string
    :param deferReference: (C Q E) Change or query the load state of a reference
    :type deferReference: boolean
    :param fileName: (C Q) Return the file name reference file(s) associated with the indicated
    load setting(s)
    :type fileName: string
    :param numSettings: (C Q) Return the number of settings in the group of implicit load
    settings  This is equivalent to number of references in the scene plus 1
    :type numSettings: int
    :param proxyManager: (C Q) Return the name(s) of the proxy manager(s) associated with the
    indicated load setting(s)
    :type proxyManager: string
    :param proxySetFiles: (C Q) Return the name(s) of the proxy(ies) available in the proxy set
    associated with the indicated load setting(s)
    :type proxySetFiles: string
    :param proxySetTags: (C Q) Return the name(s) of the proxy tag(s) available in the proxy
    set associated with the indicated load setting(s)
    :type proxySetTags: string
    :param proxyTag: (C Q) Return the name(s) of the proxy tag(s) associated with the indicated
    load setting(s)
    :type proxyTag: string
    :param referenceNode: (C Q) Return the name(s) of the reference node(s) associated with the
    indicated load setting(s)
    :type referenceNode: string
    :param shortName: (C Q) Formats the return value of the 'fileName' query flag to only
    return the short name(s) of the reference file(s)
    :type shortName: boolean
    :param unresolvedName: (C Q) Formats the return value of the 'fileName' query flag to
    return the unresolved name(s) of the reference file(s)  The unresolved file name is the
    file
    :type unresolvedName: boolean
    
    :returns: For query execution.
    :rtype: string
    """
    pass


def CompleteCurrentTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ProfilerTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nucleusDisplayOtherNodes(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def BevelPolygonOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def isDirty(*args, connection=True, datablock=True, **kwargs):
    """
    The isDirty command is used to check if a plug is dirty  The return value is 0 if it is not
    and 1 if it is  If more than one plug is specified then the result is the logical "or" of
    all objects (ie  returns 1 if *any* of the plugs are dirty)
    
    :param connection: (C) Check the connection of the plug (default)
    :type connection: boolean
    :param datablock: (C) Check the datablock entry for the plug
    :type datablock: boolean
    
    :returns: Is the plug dirty? If more than one plug is given then it returns the
    logical
    "and" of all dirty states.
    :rtype: boolean
    """
    pass


def meshRemap(*args, **kwargs):
    """
    
    """
    pass


def dR_activeHandleXY(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_activeHandleXZ(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleCharacterControls(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def lattice(*args, after=True, afterReference=True, before=True, commonParent=True,
            deformerTools=True, divisions=None, dualBase=True, exclusive="", freezeMapping=True,
            frontOfChain=True, geometry="", geometryIndices=True, ignoreSelected=True,
            includeHiddenSelections=False, latticeReset=True, ldivisions=None, name="",
            objectCentered=True, outsideFalloffDistance=0.0, outsideLattice=0, parallel=True,
            position=None, prune=True, remove=True, removeTweaks=True, rotation=None,
            scale=None, split=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a lattice deformer that will deform the selected objects  If the
    object centered flag is used, the initial lattice will fit around the selected objects  The
    lattice will be selected when the command is completed  The lattice deformer has an
    associated base lattice  Only objects which are contained by the base lattice will be
    de
    
    :param after: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type after: boolean
    :param afterReference: (C E) The -afterReference flag is used to specify deformer ordering
    in a hybrid way that choses between -before and -after automatically  If the geometry b
    :type afterReference: boolean
    :param before: (C E) If the default behavior for insertion/appending into/onto the existing
    chain is not the desired behavior then this flag can be used to force the comm
    :type before: boolean
    :param commonParent: (C) Group the base lattice and the deformed lattice under a common
    transform  This means that you can resize the lattice without affecting the deformatio
    :type commonParent: boolean
    :param deformerTools: (Q) Returns the name of the deformer tool objects (if any) as string
    string ..
    :type deformerTools: boolean
    :param divisions: (C Q E) Set the number of lattice slices in x, y, z  Default is 2, 5, 2 
    When queried, this flag returns float float float  When you change the number of div
    :type divisions: [int, int, int]
    :param dualBase: (C) Create a special purpose ffd deformer node which accepts 2 base
    lattices  The default is off which results in the creation of a normal ffd deformer n
    :type dualBase: boolean
    :param exclusive: (C Q) Puts the deformation set in a deform partition
    :type exclusive: string
    :param freezeMapping: (C Q E) The base position of the geometries points is fixed at the
    time this flag is set  When mapping is frozen, moving the geometry with respect to the lat
    :type freezeMapping: boolean
    :param frontOfChain: (C E) This command is used to specify that the new deformer node
    should be placed ahead (upstream) of existing deformer and skin nodes in the shape's histo
    :type frontOfChain: boolean
    :param geometry: (Q E M) The specified object will be added to the list of objects being
    deformed by this deformer object, unless the -rm flag is also specified  When queried
    :type geometry: string
    :param geometryIndices: (Q) Complements the -geometry flag in query mode  Returns the multi
    index of each geometry
    :type geometryIndices: boolean
    :param ignoreSelected: (C) Tells the command to not deform objects on the current selection
    list
    :type ignoreSelected: boolean
    :param includeHiddenSelections: (C) Apply the deformer to any visible and hidden objects in
    the selection list  Default is false
    :type includeHiddenSelections: boolean
    :param latticeReset: (E) Reset the lattice to match its base position  This will undo any
    deformations that the lattice is causing  The lattice will only deform points that a
    :type latticeReset: boolean
    :param ldivisions: (C Q E) Set the number of local lattice slices in x, y, z
    :type ldivisions: [int, int, int]
    :param name: (C) Used to specify the name of the node being created
    :type name: string
    :param objectCentered: (C) Centers the lattice around the selected object(s) or components 
    Default is off which centers the lattice at the origin
    :type objectCentered: boolean
    :param outsideFalloffDistance: (C) Set the falloff distance used when the setting for
    transforming points outside of the base lattice is set to 2  The distance value is a
    positive numb
    :type outsideFalloffDistance: float
    :param outsideLattice: (C) Set the mode describing how points outside the base lattice are
    transformed  0 (the default) specifies that no outside points are transformed  1 spec
    :type outsideLattice: int
    :param parallel: (C E) Inserts the new deformer in a parallel chain to any existing
    deformers in the history of the object  A blendShape is inserted to blend the parallel r
    :type parallel: boolean
    :param position: (C) Used to specify the position of the newly created lattice
    :type position: [float, float, float]
    :param prune: (E) Removes any points not being deformed by the deformer in its current
    configuration from the deformer set
    :type prune: boolean
    :param remove: (E M) Specifies that objects listed after the -g flag should be removed from
    this deformer
    :type remove: boolean
    :param removeTweaks: (E) Remove any lattice deformations caused by moving lattice points 
    Translations/rotations and scales on the lattice itself are not removed
    :type removeTweaks: boolean
    :param rotation: (C) Used to specify the initial rotation of the newly created lattice
    :type rotation: [float, float, float]
    :param scale: (C) Used to specify the initial scale of the newly created lattice
    :type scale: [float, float, float]
    :param split: (C E) Branches off a new chain in the dependency graph instead of
    inserting/appending the deformer into/onto an existing chain  Works in create mode (and e
    :type split: boolean
    
    :returns: Ffd node name, lattice name, base lattice name.
    :rtype: string[]
    """
    pass


def pointCurveConstraint(*args, caching=True, nodeState=0, pointConstraintUVW=None,
                         pointWeight=1.0, position=None, weight=0.0, constructionHistory=True,
                         name="", object=True, replaceOriginal=True, q=True, query=True, e=True,
                         edit=True, **kwargs):
    """
    The command enables direct manipulation of a NURBS curve  It does so by apply a position
    constraint at the specified parameter location on the NURBS curve   If construction history
    for the cmd is enabled, a locator is created to enable subsequent interactive manipulation
    of the curve  The locator position may be key framed or transformed and the "c
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param pointConstraintUVW: (C Q E) Point constraint parameter space location on input NURBS
    Object
    :type pointConstraintUVW: [float, float, float]
    :param pointWeight: (C Q E) Point constraint weight  Determines how strong an influence the
    constraint has on the input NURBS object  Default: 1.0
    :type pointWeight: float
    :param position: (C) The new desired position in space for the nurbs object at the
    specified parameter space component  If not specified, the position is taken to be the
    :type position: [float, float, float]
    :param weight: (C) weight of the lsq constraint  The larger the weight, the least squares
    constraint is strictly met
    :type weight: float
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    
    :returns: Object Name(s), node name.
    :rtype: string[]
    """
    pass


def createSubdivRegion(*args, **kwargs):
    """
    Creates a subdivision surface region based on the selection list  Once a selection region
    is created, only the components in the selection list or converted from the selection list
    will be displayed and selectible through the UI
    
    
    :returns: Command result
    :rtype: boolean
    """
    pass


def hotkeyCheck(*args, altModifier=True, commandModifier=True, ctrlModifier=True,
                isRepeatable=True, keyString="", keyUp=True, optionModifier=True, **kwargs):
    """
    This command checks if the given hotkey is mapped to a nameCommand object  If so, the
    annotation of the nameCommand object is returned  Otherwise an empty string is returned
    
    :param altModifier: (C) Specifies if the Alt key is pressed
    :type altModifier: boolean
    :param commandModifier: (C) Specifies if the command key is pressed
    :type commandModifier: boolean
    :param ctrlModifier: (C) Specifies if the Ctrl key is pressed
    :type ctrlModifier: boolean
    :param isRepeatable: (C) Specify this flag if the hotkey is repeatable
    :type isRepeatable: boolean
    :param keyString: (C) The key to check
    :type keyString: string
    :param keyUp: (C) Specifies if the hotkey is on keyup or keydown (i.e  Release or Press)
    :type keyUp: boolean
    :param optionModifier: (C) Specifies if the option key is pressed
    :type optionModifier: boolean
    
    :returns: Contains all clients name, each followed by the annotation of the corresponding
    nameCommand object, or
    an empty string.
    :rtype: string
    """
    pass


def moduleInfo(*args, definition=True, listModules=True, moduleName="", path=True, version=True,
               **kwargs):
    """
    Returns information on modules found by Maya
    
    :param definition: (C) Returns module definition file name for the module specified by the
    -moduleName parameter
    :type definition: boolean
    :param listModules: (C) Returns an array containing the names of all currently loaded
    modules
    :type listModules: boolean
    :param moduleName: (C) The name of the module whose information you want to retrieve  Has
    to be used with either -definition / -path / -version flags
    :type moduleName: string
    :param path: (C) Returns the module path for the module specified by the -moduleName
    parameter
    :type path: boolean
    :param version: (C) Returns the module version for the module specified by the -moduleName
    parameter
    :type version: boolean
    
    :returns: Command result
    :rtype: string[]
    """
    pass


def whatsNewHighlight(*args, highlightColor=None, highlightOn=True, showStartupDialog=True,
                      q=True, query=True, **kwargs):
    """
    This command is used to toggle the What's New highlighting feature, and the display of the
    settings dialog for the feature that appears on startup
    
    :param highlightColor: (C Q) Set the color of the What's New highlight  The arguments
    correspond to the red, green, and blue color components  Each color component ranges in
    valu
    :type highlightColor: [float, float, float]
    :param highlightOn: (C Q) Toggle the What's New highlighting feature  When turned on, menu
    items and buttons introduced in the latest version will be highlighted
    :type highlightOn: boolean
    :param showStartupDialog: (C Q) Set whether the settings dialog for this feature appears on
    startup
    :type showStartupDialog: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def ShowStrokePathCurves(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NextViewArrangement(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleCommandLine(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyFlipEdge(*args, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Command to flip the edges shared by 2 adjacent triangles  When used with the edit flag, new
    edges can be added to the same node, instead of creating a separate node in the chain
    
    
    :returns: Success or Failure.
    :rtype: boolean
    """
    pass


def ToggleVertIDs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DisplacementToPolygon(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UVStraighten(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def filePathEditor(*args, attributeOnly=True, attributeType="", byType="", copyAndRepath=None,
                   deregisterType="", force=True, listDirectories="", listFiles="",
                   listRegisteredTypes=True, preview=True, recursive=True, refresh=True,
                   registerType="", relativeNames=True, repath="", replaceAll=True,
                   replaceField="", replaceString=None, status=True, temporary=True,
                   typeLabel="", unresolved=True, withAttribute=True, q=True, query=True,
                   **kwargs):
    """
    Maya can reference and use external files, such as textures or other Maya scenes  This
    command is used to get the information about those file paths and modify them in bulk  By
    default, only the most frequently used types of files are presented to the user:  Texture
    Scene reference Audio Image plane   For the command to manage more file types, thos
    
    :param attributeOnly: (Q) Used with "listFiles" to return the node and attribute name that
    are using the files
    :type attributeOnly: boolean
    :param attributeType: (Q) Query the attribute type for the specified plug
    :type attributeType: string
    :param byType: (Q) Used with "listFiles" to query files that are used by the specified node
    type or attribute type  In query mode, this flag needs a value
    :type byType: string
    :param copyAndRepath: (C) Copy a source file to the destination path and repath the plug
    data to the new file  The source file must have the same name as the one in the plug
    :type copyAndRepath: [string, string]
    :param deregisterType: (C) Deregister a file type from the list of registered types so the
    command stops handling it  Unless the "temporary" flag is used, the type will be remo
    :type deregisterType: string
    :param force: (C) Used with flag "repath" to repath all files to the new location,
    including the resolved files  Otherwise, "repath" will only deal with the missing fi
    :type force: boolean
    :param listDirectories: (Q) List all sub directories of the specified directory  Only
    directories containing at least one file whose type is registered (see "registerType")
    will
    :type listDirectories: string
    :param listFiles: (Q) List files in the specified directory  No recursion in subdirectories
    will be performed  In query mode, this flag needs a value
    :type listFiles: string
    :param listRegisteredTypes: (Q) Query the list of registered attribute types  The
    registered types include the auto-loaded types from the preference file and the types
    explicitly re
    :type listRegisteredTypes: boolean
    :param preview: (C) Used with "repath", "replaceString" or "copyAndRepath" to preview the
    result of the operation instead of excuting it  When it is used with "repath" o
    :type preview: boolean
    :param recursive: (C) Used with flag "repath" to search the files in the target directory
    and its subdirectories recursively  If the flag is on, the command will repath th
    :type recursive: boolean
    :param refresh: (C) Clear and re-collect the file information in the scene  The command
    does not automatically track file path modifications in the scene  So it is the u
    :type refresh: boolean
    :param registerType: (C) Register a new file type that the command will handle and
    recognize from now on  Unless the "temporary" flag is used, the registered type is saved
    in
    :type registerType: string
    :param relativeNames: (Q) Used with "listDirectories" or "listFiles" to return the relative
    path of each directory or file  Paths are relative to the current project folder  I
    :type relativeNames: boolean
    :param repath: (C) Replace the directory part of a file path with a specified location  The
    file name will be preserved
    :type repath: string
    :param replaceAll: (C) Used with flag "replaceString", specifies how many times the matched
    string will be replaced  When the flag is false, only the first matched string w
    :type replaceAll: boolean
    :param replaceField: (C) Used with the "replaceString" flag to control the scope of the
    replacement  Possible values are: "pathOnly" - only replace strings in the directory p
    :type replaceField: string
    :param replaceString: (C) Replace the target string with the new string in the file paths 
    The flag needs two arguments: the first one is the target string and the second one
    :type replaceString: [string, string]
    :param status: (Q) Used with "listFiles", this will cause the returned list of files to
    include one status flag per file: 0 if it cannot be resolved and 1 if it can  Us
    :type status: boolean
    :param temporary: (C) Make the effect of the "register"/"deregister" flag only applicable
    in the current session  Normally, a type registration/deregistration is permanent
    :type temporary: boolean
    :param typeLabel: (C Q) Used with "registerType" to set the label name for the new file
    type  Used with "query" to return the type label for the specified attribute type  Fo
    :type typeLabel: string
    :param unresolved: (Q) Used with "listFiles" to query the unresolved files that are being
    used in the scene
    :type unresolved: boolean
    :param withAttribute: (Q) Used with "listFiles" to return the name of the plug using a
    given file  For example, if "file.jpg" is used by the plug "node1.fileTextureName", then
    :type withAttribute: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def DisableExpressions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def shadingNode(*args, asLight=True, asPostProcess=True, asRendering=True, asShader=True,
                asTexture=True, asUtility=True, isColorManaged=True, name="", parent="",
                shared=True, skipSelect=True, **kwargs):
    """
    This command creates a new node in the dependency graph of the specified type   The
    shadingNode command classifies any DG node as a shader, texture light, post process, or
    utility so that it can be properly organized in the multi-lister  Recall that any DG node
    can be used a part of a a shader, texture or light - regardless of how it is classified 
    
    :param asLight: (C) classify the current DG node as a light
    :type asLight: boolean
    :param asPostProcess: (C) classify the current DG node as a post process
    :type asPostProcess: boolean
    :param asRendering: (C) classify the current DG node as a rendering node
    :type asRendering: boolean
    :param asShader: (C) classify the current DG node as a shader
    :type asShader: boolean
    :param asTexture: (C) classify the current DG node as a texture
    :type asTexture: boolean
    :param asUtility: (C) classify the current DG node as a utility
    :type asUtility: boolean
    :param isColorManaged: (C) classify the current DG node as being color managed
    :type isColorManaged: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param parent: (C) Specifies the parent in the DAG under which the new node belongs
    :type parent: string
    :param shared: (C) This node is shared across multiple files, so only create it if it does
    not already exist
    :type shared: boolean
    :param skipSelect: (C) This node is not to be selected after creation, the original
    selection will be preserved
    :type skipSelect: boolean
    
    :returns: The name of the new node.
    :rtype: string
    """
    pass


def SendAsNewSceneMudbox(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sbs_SetGlobalTextureWidth(*args, **kwargs):
    """
    
    """
    pass


def MakePaintable(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteCurrentUVSet(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polyPlane(*args, axis=None, createUVs=1, height=1.0, subdivisionsHeight=0,
              subdivisionsWidth=10, subdivisionsX=5, subdivisionsY=5, texture=1, width=1.0,
              caching=True, constructionHistory=True, name="", nodeState=0, object=True, q=True,
              query=True, e=True, edit=True, **kwargs):
    """
    Create a new polygonal plane
    
    :param axis: (C Q E) This flag specifies the primitive axis used to build the plane
    :type axis: [float, float, float]
    :param createUVs: (C Q E) Create UVs or not  0: No UVs 1: No Normalization 2: Normalize and
    Preserve Aspect Ratio Default: 1
    :type createUVs: int
    :param height: (C Q E) Height of the plane  Default: 1.0
    :type height: float
    :param subdivisionsHeight: (C Q E) Subdivisions along the height of the sphere
    :type subdivisionsHeight: int
    :param subdivisionsWidth: (C Q E) Subdivisions along the width of the plane  Default: 10
    :type subdivisionsWidth: int
    :param subdivisionsX: (C Q E) This specifies the number of subdivisions in the X direction
    for the plane  Default is 5
    :type subdivisionsX: int
    :param subdivisionsY: (C Q E) This flag specifies the number of subdivisions in the Y
    direction for the plane  Default is 5
    :type subdivisionsY: int
    :param texture: (C Q E) What texture mechanism to be applied  0=No textures; 1=stretch to
    fit; 2=preserve aspect ratio Default: 1
    :type texture: int
    :param width: (C Q E) Width of the plane  Default: 1.0
    :type width: float
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param object: (C) Create the result, or just the dependency node (where applicable)
    :type object: boolean
    
    :returns: Object name and node name.
    :rtype: string[]
    """
    pass


def xgmDensityBrushContext(*args, **kwargs):
    """
    
    """
    pass


def texturePlacementContext(*args, exists=True, history=True, image1="", image2="", image3="",
                            labelMapping=True, name="", q=True, query=True, e=True, edit=True,
                            **kwargs):
    """
    Create a command for creating new texture placement contexts  By default label mapping is
    on when the context is created
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param labelMapping: (C Q E) Set the context to label mapping
    :type labelMapping: boolean
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: The name of the context created
    :rtype: string
    """
    pass


def floatField(*args, annotation="", backgroundColor=None, changeCommand=None,
               defineTemplate="", docTag="", dragCallback=None, dragCommand=None,
               dropCallback=None, editable=True, enable=True, enableBackground=True,
               enableKeyboardFocus=True, enterCommand=None, exists=True, fullPathName=True,
               height=0, highlightColor=None, isObscured=True, manage=True, maxValue=0.0,
               minValue=0.0, noBackground=True, numberOfPopupMenus=True, parent="",
               popupMenuArray=True, precision=0, preventOverride=True, receiveFocusCommand=None,
               showTrailingZeros=True, statusBarMessage="", step=0.0, useTemplate="", value=0.0,
               visible=True, visibleChangeCommand=None, width=0, q=True, query=True, e=True,
               edit=True, **kwargs):
    """
    Create a field control that accepts only float values and is bound by a minimum and maximum
    value  An invisible slider is attached to the field and accessed by holding down the Ctrl
    modifier key while pressing one of the mouse buttons  Dragging the invisible slider to the
    right with the middle mouse button increases the field value by the amount sp
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Command executed when the field changes  This command is not
    invoked when the value changes via the -v/value flag
    :type changeCommand: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dragCommand: (C E) Command executed when dragging in the field
    :type dragCommand: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param editable: (C Q E) The edit state of the field  By default, this flag is set to true
    and the field value may be changed by typing into it  If false then the field can n
    :type editable: boolean
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param enterCommand: (C E) Command executed when the keypad 'Enter' key is pressed
    :type enterCommand: script
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param maxValue: (C Q E) Upper limit of the field
    :type maxValue: float
    :param minValue: (C Q E) Lower limit of the field
    :type minValue: float
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param precision: (C Q E) Number of digits to the right of the decimal place
    :type precision: int
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param receiveFocusCommand: (C E) Command executed when the field receives focus
    :type receiveFocusCommand: script
    :param showTrailingZeros: (C Q E) Show trailing zeros or not
    :type showTrailingZeros: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param step: (C Q E) Increment for the invisible slider  The field value will change by
    this amount when the invisible slider is dragged
    :type step: float
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param value: (C Q E) Value of the field
    :type value: float
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def dR_multiCutSlicePointCmd(*args, **kwargs):
    """
    
    """
    pass


def CustomNURBSComponentsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeSortByType(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GridUV(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sbs_GetGlobalTextureWidth(*args, **kwargs):
    """
    
    """
    pass


def SimplifyStrokePathCurves(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectCurveCVsAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectPolygonSelectionBoundary(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FrontPerspViewLayout(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polySewEdge(*args, caching=True, constructionHistory=True, name="", nodeState=0,
                texture=True, tolerance=0.0, worldSpace=True, q=True, query=True, e=True,
                edit=True, **kwargs):
    """
    Merge border edges within a given threshold.
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param texture: (C Q E) If true : texture is sewn as well as the 3d edge  C: Default is
    true  Q: When queried, this flag returns an int
    :type texture: boolean
    :param tolerance: (C Q E) The tolerance to sew edges (edge distance) C: Default is 0.0  Q:
    When queried, this flag returns a float
    :type tolerance: float
    :param worldSpace: (C Q E) This flag specifies which reference to use  If "on" : all
    geometrical values are taken in world reference  If "off" : all geometrical values are
    take
    :type worldSpace: boolean
    
    :returns: The node name.
    :rtype: string
    """
    pass


def EnableNRigids(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def renderLayerPostProcess(*args, keepImages=True, sceneName="", q=True, query=True, **kwargs):
    """
    Post process the results when rendering is done with  Presently this generates a layered
    PSD file using individual iff files
    
    :param keepImages: (C Q) When set to on, the original iff images are kept after the
    conversion to PSD  Default is to remove them
    :type keepImages: boolean
    :param sceneName: (C Q) Specifies the scene name for interactive batch rendering
    :type sceneName: string
    
    :returns: 
    :rtype: None
    """
    pass


def polyPrimitive(*args, axis=None, createUVs=0, polyType=0, radius=1.0, sideLength=1.0,
                  texture=0, caching=True, constructionHistory=True, name="", nodeState=0,
                  object=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    Create a polygon primative
    
    :param axis: (C Q E) This flag specifies the primitive axis used to build the primitive
    polygon  Q: When queried, this flag returns a float[3]
    :type axis: [float, float, float]
    :param createUVs: (C Q E) Create UVs or not  0: No UVs 1: No Normalization 2: Normalize
    Each Face Separately 3: Normalize Collectively 4: Normalize and Preserve Aspect Ratio
    :type createUVs: int
    :param polyType: (C) This flag allows a specific primitive poly to be selected for creation
    of mesh, The valid values is 0 0 implies soccer ball to be created  C: Default
    :type polyType: int
    :param radius: (C Q E) This flag specifies the radius of the primitive polygon  C: Default
    is 1.0  Q: When queried, this flag returns a float
    :type radius: float
    :param sideLength: (C Q E) This flag specifies the side length of primitive polygon  C:
    Default is 1.0  Q: When queried, this flag returns a float
    :type sideLength: float
    :param texture: (C Q E) What texture mechanism to be applied 0=No textures, 1=Object,
    2=Faces
    :type texture: int
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param object: (C) Create the result, or just the dependency node (where applicable)
    :type object: boolean
    
    :returns: Object name and node name.
    :rtype: string[]
    """
    pass


def HypershadeDisplayAsList(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def textCurves(*args, font="", name="", object=True, text="", q=True, query=True, e=True,
               edit=True, **kwargs):
    """
    The textCurves command creates NURBS curves from a text string using the specified font   A
    single letter can be made up of more than one NURBS curve  The number of curves per letter
    varies with the font
    
    :param font: (C) The font to use
    :type font: string
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param text: (C) The string to create the curves for
    :type text: string
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def textureLassoContext(*args, **kwargs):
    """
    
    """
    pass


def vortex(*args, attenuation=0.0, axisX=0.0, axisY=0.0, axisZ=0.0, magnitude=0.0,
           maxDistance=0.0, name="", perVertex=True, position=None, torusSectionRadius=0.0,
           volumeExclusion=True, volumeOffset=None, volumeShape="", volumeSweep=0.0, q=True,
           query=True, e=True, edit=True, **kwargs):
    """
    For each listed object, the command creates a new field  The field has a shape which lives
    in the DAG and it has an associated dependency node  The field is added to the list of
    fields owned by the object  Use connectDynamic to cause the field to affect a dynamic
    object  Note that if more than one object is listed, a separate field is created for e
    
    :param attenuation: (Q E) Attentuation rate of field
    :type attenuation: float
    :param axisX: (Q E) X-component of vortex axis
    :type axisX: float
    :param axisY: (Q E) Y-component of vortex axis
    :type axisY: float
    :param axisZ: (Q E) Z-component of vortex axis
    :type axisZ: float
    :param magnitude: (Q E) Strength of field
    :type magnitude: float
    :param maxDistance: (Q E) Maximum distance at which field is exerted  -1 indicates that the
    field has no maximum distance
    :type maxDistance: float
    :param name: (Q E) name of field
    :type name: string
    :param perVertex: (Q E) Per-vertex application  If this flag is set true, then each
    individual point (CV, particle, vertex,etc.) of the chosen object exerts an identical cop
    :type perVertex: boolean
    :param position: (Q E M) Position in space (x,y,z) where you want to place a gravity field 
    The gravity then emanates from this position in space rather than from an object
    :type position: [float, float, float]
    :param torusSectionRadius: (Q E) Section radius for a torus volume  Applies only to torus 
    Similar to the section radius in the torus modelling primitive
    :type torusSectionRadius: float
    :param volumeExclusion: (Q E) Volume exclusion of the field  If true, points outside the
    volume (defined by the volume shape attribute) are affected, If false, points inside the v
    :type volumeExclusion: boolean
    :param volumeOffset: (Q E) Volume offset of the field  Volume offset translates the field's
    volume by the specified amount from the actual field location  This is in the field'
    :type volumeOffset: [float, float, float]
    :param volumeShape: (Q E) Volume shape of the field  Sets/edits/queries the field's volume
    shape attribute  If set to any value other than "none", determines a 3-D volume with
    :type volumeShape: string
    :param volumeSweep: (Q E) Volume sweep of the field  Applies only to sphere, cone, cylinder,
    and torus  Similar effect to the sweep attribute in modelling
    :type volumeSweep: float
    
    :returns: Command result
    :rtype: string
    """
    pass


def TransformPolygonComponentOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeGraphRemoveDownstream(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ikSolver(*args, epsilon=0.0, maxIterations=0, name="", solverType="", q=True, query=True,
             e=True, edit=True, **kwargs):
    """
    The ikSolver command is used to set the attributes for an IK Solver or create a new one 
    The standard edit (-e) and query (-q) flags are used for edit and query functions
    
    :param epsilon: (C Q E) max error
    :type epsilon: float
    :param maxIterations: (C Q E) Sets the max iterations for a solution
    :type maxIterations: int
    :param name: (C Q E) Name of solver
    :type name: string
    :param solverType: (C Q E) valid solverType (only ikSystem knows what is valid) for
    creation of a new solver (required)
    :type solverType: string
    
    :returns: Command result
    :rtype: string
    """
    pass


def CreateDirectionalLight(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def fluidCacheInfo(*args, attribute="", cacheTime=None, endFrame=True, hasCache=True,
                   hasData=True, initialConditions=True, playback=True, resolution=True,
                   startFrame=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    A command to get information about the fluids cache  Get the startFrame and resolution for
    InitialConditions  Get the endFrame as well for a playback cache  Note that for the
    playback cache, it will look at the current time (or last frame if the current time is past
    end of cache)
    
    :param attribute: (C Q E) Modifier to the "hasData" flag, used to query whether a cache has
    data (at the current time) for a specific fluid attribute  Valid attribute values a
    :type attribute: string
    :param cacheTime: (C Q E) Only valid with the -hasData flag  The time the -hasData flag
    uses when it queries the cache to see if there is data
    :type cacheTime: time
    :param endFrame: (C Q E) Returns end time of cache as float
    :type endFrame: boolean
    :param hasCache: (C Q E) Returns true if fluid has specified cache, false if not
    :type hasCache: boolean
    :param hasData: (C Q E) Queries whether a given cache has data in it at the time specified
    by the -time flag  (If not -time flag is present, -hasData assumes the current tim
    :type hasData: boolean
    :param initialConditions: (C Q E) Specifies the cache to be queried is the "Initial
    Conditions" cache
    :type initialConditions: boolean
    :param playback: (C Q E) Specifies the cache to be queried is the "Playback" cache
    :type playback: boolean
    :param resolution: (C Q E) Returns cache resolution as float[]
    :type resolution: boolean
    :param startFrame: (C Q E) Returns start time for cache as float
    :type startFrame: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def soft(*args, convert=True, duplicate=True, duplicateHistory=True, goal=0.0,
         hideOriginal=True, name="", q=True, query=True, **kwargs):
    """
    Makes a soft body from the object(s) passed on the command line or in the selection list 
    The geometry can be a NURBS, polygonal, lattice object  The resulting soft body is made up
    of a hierarchy with a particle shape and a geometry shape, thus:     T   / \   T G   /   P 
       Dynamics are applied to the particle shape and the resulting particle posi
    
    :param convert: (C) This tells the command that you want the original object to be the
    actual deformed object  The particle shape portion of the soft body will be insert
    :type convert: boolean
    :param duplicate: (C) This tells the command that you want to make a copy of the original
    object and use the copy as the deforming geometry  Input connections to the origi
    :type duplicate: boolean
    :param duplicateHistory: (C) This is the same as -d, except that upstream history, is
    duplicated as well, instead of just input connections  This flag and -d are mutually
    exclusi
    :type duplicateHistory: boolean
    :param goal: (C) This is the same as -d, but in addition it tells the command that you want
    the resulting soft body to try to follow the original geometry, using the
    :type goal: float
    :param hideOriginal: (C) This flag is used only when duplicating (-d, -g, or -dh)  If set
    to true, whichever of the two objects is NOT the soft object will be hidden  In othe
    :type hideOriginal: boolean
    :param name: () This flag is obsolete  If you wish to give your new soft object a name, use
    the rename command (or from the UI, use the outliner)
    :type name: string
    
    :returns: array
    :rtype: string
    """
    pass


def reloadImage(*args, **kwargs):
    """
    This command reloads an xpm image from disk  This can be used when the file has changed on
    disk and needs to be reloaded   The first string argument is the file name of the .xpm file
     The second string argument is the name of a control using the specified pixmap
    
    
    :returns: True if image is successfully loaded, false otherwise.
    :rtype: boolean
    """
    pass


def Quit(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetMaxInfluences(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AssignTemplate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateSubdivCube(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def transferShadingSets(*args, sampleSpace=0, searchMethod=0, q=True, query=True, e=True,
                        edit=True, **kwargs):
    """
    Command to transfer shading set assignments between meshes  The last mesh in the list
    receives the shading assignments from the other meshes
    
    :param sampleSpace: (C Q E) Selects which space the attribute transfer is performed in  0
    is world space, 1 is model space  The default is world space
    :type sampleSpace: int
    :param searchMethod: (C Q E) Specifies which search method to use when correlating points 
    0 is closest along normal, 3 is closest to point  The default is closest to point
    :type searchMethod: int
    
    :returns: 
    :rtype: None
    """
    pass


def tumble(*args, azimuthAngle=0.0, elevationAngle=0.0, localTumble=0, pivotPoint=None,
           rotationAngles=None, **kwargs):
    """
    The tumble command revolves the camera(s) by varying the azimuth and elevation angles in
    the perspective window  When both the azimuth and the elevation angles are supplied on the
    command line, the camera is firstly tumbled for the azimuth angle, then tumbled for the
    elevation angle    When no camera name is supplied, this command is applied to the
    
    :param azimuthAngle: (C) Degrees to change the azimuth angle
    :type azimuthAngle: float
    :param elevationAngle: (C) Degrees to change the elevation angle
    :type elevationAngle: float
    :param localTumble: (C) Describes what point the camera will tumble around: 0 for the
    camera's tumble pivot, 1 for the camera's center of interest, and 2 for the camera's lo
    :type localTumble: int
    :param pivotPoint: (C) Three dimensional point used as the pivot point in the world space
    :type pivotPoint: [float, float, float]
    :param rotationAngles: (C) Two values in degrees to change the azimuth and elevation
    angles
    :type rotationAngles: [float, float]
    
    :returns: 
    :rtype: None
    """
    pass


def dispatchGenericCommand(*args, **kwargs):
    """
    unknown
    """
    pass


def workspaceControlState(*args, defaultTopLeftCorner=None, defaultWidthHeight=None,
                          exists=True, height=0, leftEdge=0, maximized=True, remove=True,
                          topEdge=0, topLeftCorner=None, width=0, widthHeight=None, q=True,
                          query=True, e=True, edit=True, **kwargs):
    """
    Create or modify preferred window attributes for workspace controls  The size and position
    of a workspace control is retained during application sessions (although position only
    applies to workspace controls that are alone in a floating workspace docking panel)  A
    default workspace control state is created when a workspace control is closed  Worksp
    
    :param defaultTopLeftCorner: (C Q E) Top and left edge position that the window will have
    when "Remember size and position" is off and when the panel is first opened  The values
    will be
    :type defaultTopLeftCorner: [int, int]
    :param defaultWidthHeight: (C Q E) Width and height that the window will have when
    "Remember size and position" is off and when the panel is first opened  The values will be
    DPI scaled
    :type defaultWidthHeight: [int, int]
    :param exists: (C) Returns true|false depending upon whether the specified object exists 
    Other flags are ignored
    :type exists: boolean
    :param height: (C Q E) Height of the window
    :type height: int
    :param leftEdge: (C Q E) Left edge position of the window
    :type leftEdge: int
    :param maximized: (C Q E) Maximize the window
    :type maximized: boolean
    :param remove: (C) Remove a window preference
    :type remove: boolean
    :param topEdge: (C Q E) Top edge position of the window
    :type topEdge: int
    :param topLeftCorner: (C Q E) Top and left edge position of the window
    :type topLeftCorner: [int, int]
    :param width: (C Q E) Width of the window
    :type width: int
    :param widthHeight: (C Q E) Width and height of the window
    :type widthHeight: [int, int]
    
    :returns: 
    :rtype: None
    """
    pass


def bezierAnchorPreset(*args, preset=0, **kwargs):
    """
    This command provides a queryable interface for Bezier curve shapes
    
    :param preset: (C) Selects a preset to apply to selected Bezier anchors  Valid arguments
    are: 0: Bezier 1: Bezier Corner 2: Corner
    :type preset: int
    
    :returns: (number of modified anchors)
    :rtype: int
    """
    pass


def NodeEditorToggleLockUnlock(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_softSelStickyRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShrinkPolygonSelectionRegion(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def arnoldPlugins(*args, **kwargs):
    """
    
    """
    pass


def AlembicOpen(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def bezierInfo(*args, anchorFromCV=0, cvFromAnchor=0, isAnchorSelected=True,
               isTangentSelected=True, onlyAnchorsSelected=True, onlyTangentsSelected=True,
               **kwargs):
    """
    This command provides a queryable interface for Bezier curve shapes
    
    :param anchorFromCV: (C) Returns the Bezier anchor index from a given CV index
    :type anchorFromCV: int
    :param cvFromAnchor: (C) Returns the CV index for a given Bezier anchor index
    :type cvFromAnchor: int
    :param isAnchorSelected: (C) Returns 1 if an anchor CV is currently selected  0, otherwise
    :type isAnchorSelected: boolean
    :param isTangentSelected: (C) Returns 1 if a tangent CV is currently selected  0,
    otherwise
    :type isTangentSelected: boolean
    :param onlyAnchorsSelected: (C) Returns 1 if the only CV components selected are anchor CVs
     0, otherwise
    :type onlyAnchorsSelected: boolean
    :param onlyTangentsSelected: (C) Returns 1 if the only CV components selected are tangent
    CVs  0, otherwise
    :type onlyTangentsSelected: boolean
    
    :returns: Queried value
    :rtype: int
    """
    pass


def dR_customPivotTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AppendToPolygonTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DisableRigidBodies(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateNURBSCone(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sceneEditor(*args, control=True, defineTemplate="", docTag="", exists=True, filter="",
                forceMainConnection="", highlightConnection="", lockMainConnection=True,
                mainListConnection="", onlyParents=True, panel="", parent="",
                refreshReferences=True, selectCommand=None, selectItem=0, selectReference="",
                selectionConnection="", shortName=True, stateString=True, unParent=True,
                unlockMainConnection=True, unresolvedName=True, updateMainConnection=True,
                useTemplate="", withoutCopyNumber=True, q=True, query=True, e=True, edit=True,
                **kwargs):
    """
    This creates an editor for managing the files in a scene
    
    :param control: (Q) Query only  Returns the top level control for this editor  Usually used
    for getting a parent to attach popup menus  Caution: It is possible for an ed
    :type control: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Attaches a tag to the editor
    :type docTag: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param filter: (C Q E) Specifies the name of an itemFilter object to be used with this
    editor  This filters the information coming onto the main list of the editor
    :type filter: string
    :param forceMainConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type forceMainConnection: string
    :param highlightConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its highlight list  Not all editors have a highlight list 
    F
    :type highlightConnection: string
    :param lockMainConnection: (C E) Locks the current list of objects within the
    mainConnection, so that only those objects are displayed within the editor  Further changes
    to the origi
    :type lockMainConnection: boolean
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type mainListConnection: string
    :param onlyParents: (Q) When used with the 'selectItem' or 'selectReference' queries it
    indicates that, if both a parent and a child file or reference are selected, only the
    :type onlyParents: boolean
    :param panel: (C Q) Specifies the panel for this editor  By default if an editor is created
    in the create callback of a scripted panel it will belong to that panel  If a
    :type panel: string
    :param parent: (C Q E) Specifies the parent layout for this editor  This flag will only
    have an effect if the editor is currently un-parented
    :type parent: string
    :param refreshReferences: (E) Force refresh of references
    :type refreshReferences: boolean
    :param selectCommand: (C Q E) A script to be executed when an item is selected
    :type selectCommand: script
    :param selectItem: (Q E) Query or change the currently selected item  When queried, the
    currently selected file name will be return
    :type selectItem: int
    :param selectReference: (Q) Query the currently selected reference  Returns the name of the
    currently selected reference node
    :type selectReference: string
    :param selectionConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its own selection list  As the user selects things in this
    e
    :type selectionConnection: string
    :param shortName: (Q) When used with the 'selectItem' query it indicates that the file name
    returned will be the short name (i.e  just a file name without any directory pa
    :type shortName: boolean
    :param stateString: (Q) Query only flag  Returns the MEL command that will create an editor
    to match the current editor state  The returned command string uses the string va
    :type stateString: boolean
    :param unParent: (C E) Specifies that the editor should be removed from its layout  This
    cannot be used in query mode
    :type unParent: boolean
    :param unlockMainConnection: (C E) Unlocks the mainConnection, effectively restoring the
    original mainConnection (if it is still available), and dynamic updates
    :type unlockMainConnection: boolean
    :param unresolvedName: (Q) When used with the 'selectItem' query it indicates that the file
    name returned will be unresolved (i.e  it will be the path originally specified when
    :type unresolvedName: boolean
    :param updateMainConnection: (C E) Causes a locked mainConnection to be updated from the
    orginal mainConnection, but preserves the lock state
    :type updateMainConnection: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param withoutCopyNumber: (Q) When used with the 'selectItem' query it indicates that the
    file name returned will not have a copy number appended to the end  If this flag is not p
    :type withoutCopyNumber: boolean
    
    :returns: Name of editor.
    :rtype: string
    """
    pass


def RenderTextureRange(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def insertListItemBefore(*args, **kwargs):
    """
    
    """
    pass


def NodeEditorGraphRearrange(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MoveIKtoFK(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GamePipeline(*args, **kwargs):
    """
    
    """
    pass


def CreatePolygonCylinder(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetMeshPinchTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorAddIterationStatePorts(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def attrCompatibility(*args, addAttr=True, clear=True, dumpTable=True, enable=True,
                      nodeRename="", pluginNode="", removeAttr=True, renameAttr="", type="",
                      version="", **kwargs):
    """
    This command is used by Maya to handle compatibility issues between file format versions by
    providing a mechanism to describe differences between two versions  Plug-in writers can
    make use of this command to handle attribute compatibility changes to files. The first
    optional command argument argument is a node type name and the second optional comm
    
    :param addAttr: (C) Add the given attribute to the named node
    :type addAttr: boolean
    :param clear: (C) Clear out the compatibility table  This is only used internally for
    debugging purposes
    :type clear: boolean
    :param dumpTable: (C) Dump the current contents of the compatibility table  This is only
    used internally for debugging purposes
    :type dumpTable: boolean
    :param enable: (C) Enable or disable the compatibility table  This is only used internally
    for debugging purposes
    :type enable: boolean
    :param nodeRename: (C) Replace all uses of the node type 'nodeName' with given string
    :type nodeRename: string
    :param pluginNode: (C) Registers the string argument as a plug-in node type  This is
    necessary for subsequent attrCompatibility calls that reference node attributes of unlo
    :type pluginNode: string
    :param removeAttr: (C) Remove the given attribute from the named node
    :type removeAttr: boolean
    :param renameAttr: (C) Change the short name of the attribute specified in the command's
    arguments to the new short name provided as a parameter to this flag  Once the mapp
    :type renameAttr: string
    :param type: (C) Change the type of the given attribute to the given type
    :type type: string
    :param version: (C) Set the version target for subsequent commands to the given string
    :type version: string
    
    :returns: 
    :rtype: None
    """
    pass


def timeEditor(*args, allClips="", clipId=0, commonParentTrack=True, composition="",
               drivingClipsForAttr="", drivingClipsForObj=None, includeParent=True, mute=True,
               selectedClips="", topLevelClips="", q=True, query=True, **kwargs):
    """
    General Time Editor commands
    
    :param allClips: (C) Return an exhaustive (recursive) list of all clip IDs from the active
    composition  Arguments may be used to filter the returning result  An empty str
    :type allClips: string
    :param clipId: (C M) ID of the clip to be edited
    :type clipId: int
    :param commonParentTrack: (C) Locate the common parent track node and track index of the
    given clip IDs  Requires a list of clip IDs to be specified using the clipId flag  The for
    :type commonParentTrack: boolean
    :param composition: (C) A flag to use in conjunction with -dca/drivingClipsForObj to
    indicate the name of composition to use  By default if this flag is not provided, curren
    :type composition: string
    :param drivingClipsForAttr: (C) Return a list of clips driving the specified attribute(s) 
    If the composition is not specified, current active composition will be used
    :type drivingClipsForAttr: string
    :param drivingClipsForObj: (C) Return a list of clips driving the specified object(s) with
    an integer value indicating the matching mode  If no object is specified explicitly, the
    :type drivingClipsForObj: [string, int]
    :param includeParent: (C) A toggle flag to use in conjunction with -dca/drivingClipsForObj 
    When toggled, parent clip is included in selection (the entire hierarchy will be se
    :type includeParent: boolean
    :param mute: (C Q) Mute/unmute Time Editor
    :type mute: boolean
    :param selectedClips: (C) Return a list of clip IDs of currently selected Time Editor clips
     Arguments may be used to filter the returning result  An empty string will return
    :type selectedClips: string
    :param topLevelClips: (C) Return a list of all top-level clip IDs from the active
    composition  Arguments may be used to filter the returning result  An empty string will
    retur
    :type topLevelClips: string
    
    :returns: Command result
    :rtype: string
    """
    pass


def ParticleInstancerOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PerformanceSettingsWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def smoothTangentSurface(*args, caching=True, direction=1, nodeState=0, parameter=0.0,
                         smoothness=1, constructionHistory=True, name="", object=True,
                         replaceOriginal=True, q=True, query=True, e=True, edit=True,
                         **kwargs):
    """
    The smoothTangentSurface command smooths the surface along an isoparm at each parameter
    value  The name of the surface is returned and if history is on, the name of the resulting
    dependency node is also returned  This command only applies to parameter values with a
    multiple knot value  (If the given parameter value has no multiple knot associated w
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param direction: (C Q E) Direction in which to smooth knot: 0 - V direction, 1 - U
    direction Default: 1
    :type direction: int
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param parameter: (C Q E M) Parameter value(s) where knots are added Default: 0.0
    :type parameter: float
    :param smoothness: (C Q E) Smoothness to get: 0 - Tangent, 1 - Maximum (based on the
    degree) Default: 1
    :type smoothness: int
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def SetFullBodyIKKeysSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolygonCollapseFaces(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSplineCacheCreateOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSplineCacheExport(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetEditor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeRestoreLastClosedTab(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HIKSetFullBodyKey(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolyBrushMarkingMenu(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def baseView(*args, itemInfo="", itemList=True, viewDescription=True, viewLabel=True,
             viewList=True, viewName="", q=True, query=True, e=True, edit=True, **kwargs):
    """
    A view defines the layout information for the attributes of a particular node type or
    container  Views can be selected from a set of built-in views or may be defined on an
    associated container template  This command queries the view-related information for a
    container node or for a given template  The information returned from this command will be
    
    
    :param itemInfo: (Q) Used in query mode in conjunction with the itemList flag  The command
    will return a list of information for each item in the view, the information fi
    :type itemInfo: string
    :param itemList: (Q) Used in query mode, the command will return a list of information for
    each item in the view  The viewName flag is used to select the view to query  T
    :type itemList: boolean
    :param viewDescription: (Q) Used in query mode, returns the description field associated
    with the selected view  If no description was defined for this view, the value will be e
    :type viewDescription: boolean
    :param viewLabel: (Q) Used in query mode, returns the display label associated with the
    view  An appropriate label suitable for the user interface will be returned based o
    :type viewLabel: boolean
    :param viewList: (Q) Used in query mode, command will return a list of all views defined
    for the given target (container or template)
    :type viewList: boolean
    :param viewName: (Q) Used in query mode, specifies the name of the queried view when used
    in conjunction with a template target  When used in conjunction with a container
    :type viewName: string
    
    :returns: 
    :rtype: None
    """
    pass


def ProjectTangentOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RoundToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorSetSmallNodeSwatchSize(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolygonPaste(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def nurbsToSubdivPref(*args, bridge=0, capType=0, collapsePoles=True, matchPeriodic=True,
                      maxPolyCount=0, offset=0.0, reverseNormal=True, solidType=0, trans00=0.0,
                      trans01=0.0, trans02=0.0, trans10=0.0, trans11=0.0, trans12=0.0,
                      trans20=0.0, trans21=0.0, trans22=0.0, trans30=0.0, trans31=0.0,
                      trans32=0.0, q=True, query=True, **kwargs):
    """
    This command sets the values used by the nurbs-to-subdivision surface preference  This
    preference is used by the nurbs creation commands and is saved between Maya sessions   To
    query any of the flags, use the "-query" flag   For more information on the flags, see the
    node documentation for the "nurbsToSubdivProc" node
    
    :param bridge: (C Q) Valid values are 0, 1, 2 or 3
    :type bridge: int
    :param capType: (C Q) Valid values are 0 or 1
    :type capType: int
    :param collapsePoles: (C Q) 
    :type collapsePoles: boolean
    :param matchPeriodic: (C Q) 
    :type matchPeriodic: boolean
    :param maxPolyCount: (C Q) 
    :type maxPolyCount: int
    :param offset: (C Q) 
    :type offset: float
    :param reverseNormal: (C Q) 
    :type reverseNormal: boolean
    :param solidType: (C Q) Valid values are 0, 1 or 2
    :type solidType: int
    :param trans00: (C Q) 
    :type trans00: float
    :param trans01: (C Q) 
    :type trans01: float
    :param trans02: (C Q) 
    :type trans02: float
    :param trans10: (C Q) 
    :type trans10: float
    :param trans11: (C Q) 
    :type trans11: float
    :param trans12: (C Q) 
    :type trans12: float
    :param trans20: (C Q) 
    :type trans20: float
    :param trans21: (C Q) 
    :type trans21: float
    :param trans22: (C Q) 
    :type trans22: float
    :param trans30: (C Q) 
    :type trans30: float
    :param trans31: (C Q) 
    :type trans31: float
    :param trans32: (C Q) 
    :type trans32: float
    
    :returns: 
    :rtype: None
    """
    pass


def audioTrack(*args, insertTrack=0, lock=True, mute=True, numTracks=0, removeEmptyTracks=True,
               removeTrack=0, solo=True, swapTracks=None, title="", track=0, q=True, query=True,
               e=True, edit=True, **kwargs):
    """
    This command is used for inserting and removing tracks related to the audio clips displayed
    in the sequencer  It can also be used to modify the track state, for example, to lock or
    mute a track
    
    :param insertTrack: (C) This flag is used to insert a new empty track at the track index
    specified  Indices are 1-based
    :type insertTrack: int
    :param lock: (C Q E) This flag specifies whether all audio clips on the same track as the
    specified audio node are to be locked at their current location and track
    :type lock: boolean
    :param mute: (C Q E) This flag specifies whether all audio clips on the same track as the
    specified audio node are to be muted or not
    :type mute: boolean
    :param numTracks: (Q) To query the number of audio tracks
    :type numTracks: int
    :param removeEmptyTracks: (C) This flag is used to remove all tracks that have no clips
    :type removeEmptyTracks: boolean
    :param removeTrack: (C) This flag is used to remove the track with the specified index  The
    track must have no clips on it before it can be removed
    :type removeTrack: int
    :param solo: (C Q E) This flag specifies whether all audio clips on the same track as the
    specified audio node are to be soloed or not
    :type solo: boolean
    :param swapTracks: (C) This flag is used to swap the contents of two specified tracks 
    Indices are 1-based
    :type swapTracks: [int, int]
    :param title: (C Q E) This flag specifies the title for the track
    :type title: string
    :param track: (C Q E) Specify the track on which to operate by using the track's
    trackNumber  In query mode, this flag needs a value
    :type track: int
    
    :returns: 
    :rtype: None
    """
    pass


def imfPlugins(*args, extension="", keyword="", multiFrameSupport="", pluginName="",
               readSupport="", writeSupport="", q=True, query=True, **kwargs):
    """
    This command queries all the available imf plugins for its name, keyword or image file
    extension  Only one of the attributes (name, keyword or extension) can be queried at a time
     If no flags are specified, this command returns a list of all available plugin names
    
    :param extension: (C Q) image file extension
    :type extension: string
    :param keyword: (C Q) imf keyword
    :type keyword: string
    :param multiFrameSupport: (C Q) multi frame IO is supported
    :type multiFrameSupport: string
    :param pluginName: (C Q) imf plugin name
    :type pluginName: string
    :param readSupport: (C Q) read operation is supported
    :type readSupport: string
    :param writeSupport: (C Q) write operation is supported
    :type writeSupport: string
    
    :returns: Command result
    :rtype: string[]
    """
    pass


def UnitizeUVsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def polySmooth(*args, caching=True, constructionHistory=True, name="", nodeState=0,
               continuity=1.0, degree=0, divisions=1, divisionsPerEdge=0, keepBorder=True,
               keepHardEdge=False, keepMapBorders=0, keepSelectionBorder=False,
               keepTesselation=True, keepTessellation=True, method=0, osdCreaseMethod=0,
               osdFvarBoundary=0, osdFvarPropagateCorners=True, osdSmoothTriangles=True,
               osdVertBoundary=0, propagateEdgeHardness=False, pushStrength=0.0, roundness=0.0,
               smoothUVs=True, subdivisionLevels=0, subdivisionType=0, q=True, query=True,
               e=True, edit=True, **kwargs):
    """
    Smooth a polygonal object  This command works on polygonal objects or faces
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param continuity: (C Q E) This flag specifies the smoothness parameter  The minimum value
    of 0.0 specifies that the faces should only be subdivided  Maximum value of 1.0 smoot
    :type continuity: float
    :param degree: (C) Degree of the resulting limit surface
    :type degree: int
    :param divisions: (C Q E) This flag specifies the number of recursive smoothing steps  C:
    Default is 1  Q: When queried, this flag returns an int
    :type divisions: int
    :param divisionsPerEdge: (C) Number of subdivisions along one edge for each step
    :type divisionsPerEdge: int
    :param keepBorder: (C Q E) If on, the border of the object will not move during smoothing
    operation  C: Default is "on"  Q: When queried, this flag returns an int
    :type keepBorder: boolean
    :param keepHardEdge: (C Q E) If true, vertices on hard edges will not be modified  C:
    Default is false  Q: When queried, this flag returns a boolean
    :type keepHardEdge: boolean
    :param keepMapBorders: (C) Treatment of UV map borders 0 - all map border edges will be
    smoothed 1 - map borders that are also geometry borders will be smoothed 2 - no map bord
    :type keepMapBorders: int
    :param keepSelectionBorder: (C Q E) If true, vertices on border of the selection will not
    be modified  C: Default is false  Q: When queried, this flag returns a boolean
    :type keepSelectionBorder: boolean
    :param keepTesselation: (C) If true: the object will be smoothed consistently from frame to
    frame  This is best when the object is being deformed or animated   If false: non-sta
    :type keepTesselation: boolean
    :param keepTessellation: (C) If true: the object will be smoothed consistently from frame
    to frame  This is best when the object is being deformed or animated   If false: non-sta
    :type keepTessellation: boolean
    :param method: (C) Type of smoothing algorithm to use 0 - exponential - traditional
    smoothing 1 - linear - number of faces per edge grows linearly
    :type method: int
    :param osdCreaseMethod: (C Q E) Controls how boundary edges and vertices are interpolated
    :type osdCreaseMethod: int
    :param osdFvarBoundary: (C Q E) Controls how boundaries are treated for face-varying data
    (UVs and Vertex Colors)
    :type osdFvarBoundary: int
    :param osdFvarPropagateCorners: (C Q E) 
    :type osdFvarPropagateCorners: boolean
    :param osdSmoothTriangles: (C Q E) Apply a special subdivision rule be applied to all
    triangular faces that was empirically determined to make triangles subdivide more smoothly
    :type osdSmoothTriangles: boolean
    :param osdVertBoundary: (C Q E) Controls how boundary edges and vertices are interpolated
    :type osdVertBoundary: int
    :param propagateEdgeHardness: (C Q E) If true, edges which are a result of smoothed edges
    will be given the same value for their edge hardness  New subdivided edges will always be
    smooth
    :type propagateEdgeHardness: boolean
    :param pushStrength: (C) COMMENT 0.0 is approximation, 1.0 is interpolation scheme
    :type pushStrength: float
    :param roundness: (C) When 1.0, push vectors are renormalized to keep length constant
    :type roundness: float
    :param smoothUVs: (C) If true: UVs as well as geometry will be smoothed
    :type smoothUVs: boolean
    :param subdivisionLevels: (C) Number of times the subdivide and smooth operation is run
    :type subdivisionLevels: int
    :param subdivisionType: (C Q E) The subdivision method used for smoothing  C: Default is 0 
    0: Maya Catmull-Clark 1: OpenSubdiv Catmull-Clark
    :type subdivisionType: int
    
    :returns: The node name.
    :rtype: string
    """
    pass


def progressBar(*args, annotation="", backgroundColor=None, beginProgress=True,
                defineTemplate="", docTag="", dragCallback=None, dropCallback=None, enable=True,
                enableBackground=True, enableKeyboardFocus=True, endProgress=True, exists=True,
                fullPathName=True, height=0, highlightColor=None, isCancelled=True,
                isInterruptable=True, isMainProgressBar=True, isObscured=True, manage=True,
                maxValue=0, minValue=0, noBackground=True, numberOfPopupMenus=True, parent="",
                popupMenuArray=True, preventOverride=True, progress=0, status="",
                statusBarMessage="", step=0, useTemplate="", visible=True,
                visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
                **kwargs):
    """
    Creates a progress bar control that graphically fills in as its progress value increases.
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param beginProgress: (C E) Only valid for the main progress bar Shows the main progress
    bar (normally in the Help Line)  This is normally issued through MEL when a length compu
    :type beginProgress: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param endProgress: (E) Only valid for the main progress bar Hides the progress bar  No
    other flags can be used at the same time  This is normally issued through MEL in resp
    :type endProgress: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isCancelled: (Q) Returns true if the user has tried to cancel the operation  Returns
    false otherwise
    :type isCancelled: boolean
    :param isInterruptable: (C Q E) Only valid for the main progress bar Returns true if the
    isCancelled flag should respond to attempts to cancel the operation  Setting this to true
    wi
    :type isInterruptable: boolean
    :param isMainProgressBar: (C Q E) Determines whether this progressBar is used to show the
    progress of all basic operations such as Open/Save file  The main progressBar behaves very
    di
    :type isMainProgressBar: boolean
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param maxValue: (C Q E) The maximum or "ending" value of the progress indicator  If the
    progress value is greater than the -max/maxValue, the progress value will be set to t
    :type maxValue: int
    :param minValue: (C Q E) The minimum or "starting" value of the progress indicator  If the
    progress value is less than the -min/minValue, the progress value will be set to th
    :type minValue: int
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param progress: (C Q E) The amount of progress currently shown on the control  The value
    will always be between min and max  Default is equal to the minimum when the control
    :type progress: int
    :param status: (C Q E) Only valid for the main progress bar Sets the contents of the
    helpLine control when the progressBar is showing  Use this instead of setting the helpL
    :type status: string
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param step: (E) Increments the -pr/progress value by the amount specified
    :type step: int
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def FrameSelectedWithoutChildren(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def getModifiers(*args, **kwargs):
    """
    This command returns the current state of the modifier keys  The state of each modifier can
    be obtained by testing for the modifier's corresponding bit value in the return value 
    Shift is bit 1, Ctrl is bit 3, Alt is bit 4, and bit 5 is the 'Windows' key on Windows
    keyboards and the Command key on Mac keyboards  See the provided example for more de
    
    
    :returns: indicating which modifier keys are pressed.
    :rtype: int
    """
    pass


def texRotateContext(*args, editPivotMode=True, exists=True, image1="", image2="", image3="",
                     position=True, snap=True, snapRelative=True, snapValue=0.0, tweakMode=True,
                     q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command can be used to create, edit, or query a rotate context for the UV Editor  Note
    that the above flag controls the global behaviour of all texture editor rotate contexts 
    Changing one context independently is not allowed  Changing a context's behaviour using the
    above flag, will change all existing texture editor rotate contexts
    
    :param editPivotMode: (Q) Returns true when the manipulator is in edit pivot mode
    :type editPivotMode: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param position: (Q) Returns the current position of the manipulator
    :type position: boolean
    :param snap: (Q E) Sets or queries whether snapping is to be used
    :type snap: boolean
    :param snapRelative: (Q E) Sets or queries whether snapping is relative
    :type snapRelative: boolean
    :param snapValue: (Q E) Sets or queries the size of the snapping increment
    :type snapValue: float
    :param tweakMode: (Q E) When true, the manipulator is hidden and highlighted components can
    be selected and rotated in one step using a click-drag interaction
    :type tweakMode: boolean
    
    :returns: : name of the context created
    :rtype: string
    """
    pass


def GpuCacheImport(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ConvertToBreakdown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def WhatsNewStartupDialogOn(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSetFreezeBrushToolOption(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def viewLookAt(*args, position=None, **kwargs):
    """
    The viewLookAt command positions the specified camera so it is looking at the centroid of
    all selected objects  If no objects are specified the camera will look at the ground plane
    
    :param position: (C) Position in world space to make the camera look at
    :type position: [float, float, float]
    
    :returns: 
    :rtype: None
    """
    pass


def scriptTable(*args, afterCellChangedCmd=None, annotation="", backgroundColor=None,
                cellBackgroundColorCommand=None, cellChangedCmd=None,
                cellForegroundColorCommand=None, cellIndex=None, cellValue="", clearRow=0,
                clearTable=True, columnFilter=None, columnWidth=None, columns=0,
                defineTemplate="", deleteRow=0, docTag="", dragCallback=None, dropCallback=None,
                editable=True, enable=True, enableBackground=True, enableKeyboardFocus=True,
                excludingHeaders=True, exists=True, fullPathName=True, getCellCmd=None,
                height=0, highlightColor=None, insertRow=0, isObscured=True, label=None,
                manage=True, multiEditEnabled=True, noBackground=True, numberOfPopupMenus=True,
                parent="", popupMenuArray=True, preventOverride=True, rowHeight=0, rows=0,
                rowsRemovedCmd=None, rowsToBeRemovedCmd=None, selectedCells=None,
                selectedColumns=None, selectedRow=True, selectedRows=None, selectionBehavior=0,
                selectionChangedCmd=None, selectionMode=0, sortEnabled=True,
                statusBarMessage="", underPointerColumn=True, underPointerRow=True,
                useDoubleClickEdit=True, useTemplate="", visible=True,
                visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
                **kwargs):
    """
    This command creates/edits/queries the script table control
    
    :param afterCellChangedCmd: (C E) Sets the script to call after the value of a cell has
    been changed  The procedure is called with 2 integer arguments specifying the row and
    column fo
    :type afterCellChangedCmd: script
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param cellBackgroundColorCommand: (C E) Sets the script to call when it requires the
    background color of a cell  The procedure is called with 2 integer arguments specifying the
    row and colu
    :type cellBackgroundColorCommand: script
    :param cellChangedCmd: (C E) Sets the script to call when somebody has changed the value of
    a cell  The procedure is called with 2 integer arguments specifying the row and column
    :type cellChangedCmd: script
    :param cellForegroundColorCommand: (C E) Sets the script to call when it requires the
    foreground color of a cell  The procedure is called with 2 integer arguments specifying the
    row and colu
    :type cellForegroundColorCommand: script
    :param cellIndex: (Q E) used with cellValue , to give the index of row and column This flag
    and its argument must be passed to the command before the -q flag (see examples)
    :type cellIndex: [int, int]
    :param cellValue: (Q E) query and set the cell value on the table by the index of row and
    column referred in flag -cellIndex  In edit mode, if flag -multiEditEnabled is True
    :type cellValue: string
    :param clearRow: (E) Clear the contents for all the cells on the specified row  Any
    procedure specified by the -gcc flag will be called to populate the cleared cells The
    :type clearRow: int
    :param clearTable: (E) Clears the contents of all the cells in the table  Any procedure
    specified by the -gcc flag will be called to populate the cleared cells
    :type clearTable: boolean
    :param columnFilter: (C E) Filter the specified column with the string value provided  Set
    filter to columns 0 will apply the filter to all columns  The filter is case insensit
    :type columnFilter: [int, string]
    :param columnWidth: (C E M) Set the width of the specified column The column number is
    1-based (ie  the first column is 1 not 0)
    :type columnWidth: [int, int]
    :param columns: (C Q E) Set the number of columns in the table
    :type columns: int
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param deleteRow: (E) Delete the specified row The row number is 1-based (i.e  the first
    row is 1 not 0)
    :type deleteRow: int
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param editable: (C Q E) The edit state of the table  By default, this flag is set to true,
    and the table can be edited  If false, then the table is 'read only' and cannot be
    :type editable: boolean
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param excludingHeaders: (Q) when querying the count for the rows or the columns , the
    number returned will not include the headers
    :type excludingHeaders: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param getCellCmd: (C E) Sets the script to call when it requires the contents of a cell 
    The procedure is called with 2 integer arguments specifying the row and column for w
    :type getCellCmd: script
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param insertRow: (E) Insert an empty row before the specified row  Any procedure specified
    by the -gcc flag will be called to populate the new new cells  The row number i
    :type insertRow: int
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param label: (C E M) Set the label of the specified column  The column number is 1-based
    (ie  the first column is 1 not 0)
    :type label: [int, string]
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param multiEditEnabled: (C Q E) True: scriptTable support multi-editing function
    :type multiEditEnabled: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param rowHeight: (C Q E) Sets the height for each row in the scriptTable
    :type rowHeight: int
    :param rows: (C Q E) Set the number of rows in the table
    :type rows: int
    :param rowsRemovedCmd: (C E) Sets the script to call after rows are removed by pressing
    'delete' or 'backspace' key  The procedure is called with one argument specifying that sel
    :type rowsRemovedCmd: script
    :param rowsToBeRemovedCmd: (C E) Sets the script to call when 'delete' or 'backspace' key
    is pressed  The procedure is called with one argument specifying the selected rows to be
    rem
    :type rowsToBeRemovedCmd: script
    :param selectedCells: (Q E) Select the cells or return the cells currently selected  This
    returns a list of indices, the first of each pair is the row, the second is the column,
    :type selectedCells: int[]
    :param selectedColumns: (Q E) select the columns or return the columns currently selected 
    This returns a list of indices of each column completely selected The returned column nu
    :type selectedColumns: int[]
    :param selectedRow: (Q) The current row selected  The returned row number is 1-based (ie 
    the first row is 1 not 0)
    :type selectedRow: boolean
    :param selectedRows: (Q E) In edit mode, select the rows given as argument  In query mode,
    return a list of indices of completely selected rows  The row numbers are 1-based
    :type selectedRows: int[]
    :param selectionBehavior: (C Q E) Set the selection behavior, valid values are from 0 to 2
    (inclusive) 0 - Selecting single items  1 - Selecting only rows  2 - Selecting only
    columns
    :type selectionBehavior: int
    :param selectionChangedCmd: (C E) Sets the script to call when a complete selection
    operation triggered by the user has occurred successfully  The script does not pass any
    parameters
    :type selectionChangedCmd: script
    :param selectionMode: (C Q E) Set the selection Mode, valid values are from 0 to 4
    (inclusive) 0 - Items cannot be selected  1 - When the user selects an item, any
    already-selecte
    :type selectionMode: int
    :param sortEnabled: (C Q E) enable scriptTable sorted by column default value is false and
    the whole row will be sorted
    :type sortEnabled: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param underPointerColumn: (Q) The column under the pointer  The returned column number is
    1-based (i.e  the first column is 1 not 0)
    :type underPointerColumn: boolean
    :param underPointerRow: (Q) The row under the pointer  The returned row number is 1-based
    (i.e  the first row is 1 not 0)
    :type underPointerRow: boolean
    :param useDoubleClickEdit: (C Q E) this controls the cell edit mode False: Click in the
    cell to select (in Row selection, the last cell of the row is edited, in Column selection,
    the l
    :type useDoubleClickEdit: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The full path name to the created script table control.
    :rtype: string
    """
    pass


def dR_decreaseManipSize(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetToFaceNormals(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ChamferVertex(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def about(*args, apiVersion=True, application=True, batch=True, buildDirectory=True,
          buildVariant=True, codeset=True, compositingManager=True, connected=True, ctime=True,
          currentDate=True, currentTime=True, cutIdentifier=True, date=True,
          environmentFile=True, evalVersion=True, file=True, fontInfo=True,
          helpDataDirectory=True, installedVersion=True, ioVersion=True, irix=True, is64=True,
          languageResources=True, linux=True, linux64=True, liveUpdate=True,
          localizedResourceLocation=True, ltVersion=True, macOS=True, macOSppc=True,
          macOSx86=True, majorVersion=True, minorVersion=True, ntOS=True, operatingSystem=True,
          operatingSystemVersion=True, patchVersion=True, preferences=True, product=True,
          qtVersion=True, tablet=True, tabletMode=True, uiLanguage=True,
          uiLanguageForStartup=True, uiLanguageIsLocalized=True, uiLocaleLanguage=True,
          version=True, win64=True, windowManager=True, windows=True, **kwargs):
    """
    This command displays version information about the application if it is executed without
    flags  If one of the above flags is specified then the specified version information is
    returned
    
    :param apiVersion: (C) Returns the api version
    :type apiVersion: boolean
    :param application: (C) Returns the application name string
    :type application: boolean
    :param batch: (C) Returns true if application is in batch mode
    :type batch: boolean
    :param buildDirectory: (C) Returns the build directory string
    :type buildDirectory: boolean
    :param buildVariant: (C) Returns the build variant string
    :type buildVariant: boolean
    :param codeset: (C) Returns a string identifying the codeset (codepage) of the locale that
    Maya is running in  Example return values include "UTF-8", "ISO-8859-1", "1252
    :type codeset: boolean
    :param compositingManager: (C) On Linux, returns true if there is a compositing manager
    running; on all other platforms, it always returns true
    :type compositingManager: boolean
    :param connected: (C) Return whether the user is connected or not to the Internet
    :type connected: boolean
    :param ctime: (C) Returns the current time in the format Wed Jan 02 02:03:55 1980\n\0
    :type ctime: boolean
    :param currentDate: (C) Returns the current date in the format yyyy/mm/dd, e.g  2003/05/04
    :type currentDate: boolean
    :param currentTime: (C) Returns the current time in the format hh:mm:ss, e.g  14:27:53
    :type currentTime: boolean
    :param cutIdentifier: (C) Returns the cut string
    :type cutIdentifier: boolean
    :param date: (C) Returns the build date string
    :type date: boolean
    :param environmentFile: (C) Returns the location of the application defaults file
    :type environmentFile: boolean
    :param evalVersion: (C) This flag is now deprecated  Always returns false, as the eval
    version is no longer supported
    :type evalVersion: boolean
    :param file: (C) Returns the file version string
    :type file: boolean
    :param fontInfo: (C) Returns a string of the specifications of the fonts requested, and the
    specifications of the fonts that are actually being used
    :type fontInfo: boolean
    :param helpDataDirectory: (C) Returns the help data directory
    :type helpDataDirectory: boolean
    :param installedVersion: (C) Returns the product version string
    :type installedVersion: boolean
    :param ioVersion: (C) Returns true if this is the Maya IO version of the application
    :type ioVersion: boolean
    :param irix: (C) Returns true if the operating system is Irix  Always false with support
    for Irix removed
    :type irix: boolean
    :param is64: (C) Returns true if the application is 64 bit
    :type is64: boolean
    :param languageResources: (C) Returns a string array of the currently installed language
    resources  Each string entry consists of three elements delimited with a colon (':')  The
    :type languageResources: boolean
    :param linux: (C) Returns true if the operating system is Linux
    :type linux: boolean
    :param linux64: (C) Returns true if the operating system is Linux 64 bit
    :type linux64: boolean
    :param liveUpdate: (C) This flag is deprecated(2019) and may be removed in future releases
    of Maya  Returns Autodesk formatted product information
    :type liveUpdate: boolean
    :param localizedResourceLocation: (C) Returns the path to the top level of the localized
    resource directory, if we are running in an alternate language  Returns an empty string if
    we are
    :type localizedResourceLocation: boolean
    :param ltVersion: (C) Returns true if this is the Maya LT version of the application
    :type ltVersion: boolean
    :param macOS: (C) Returns true if the operating system is Macintosh
    :type macOS: boolean
    :param macOSppc: (C) Returns true if the operating system is a PowerPC Macintosh
    :type macOSppc: boolean
    :param macOSx86: (C) Returns true if the operating system is an Intel Macintosh
    :type macOSx86: boolean
    :param majorVersion: (C) Returns the major version of Maya
    :type majorVersion: boolean
    :param minorVersion: (C) Returns the minor version of Maya
    :type minorVersion: boolean
    :param ntOS: (C) Returns true if the operating system is Windows
    :type ntOS: boolean
    :param operatingSystem: (C) Returns the operating system type  Valid return types are "nt",
    "win64", "mac", "linux" and "linux64"
    :type operatingSystem: boolean
    :param operatingSystemVersion: (C) Returns the operating system version  on Linux this
    returns the equivalent of uname -srvm
    :type operatingSystemVersion: boolean
    :param patchVersion: (C) Returns the patch version of Maya
    :type patchVersion: boolean
    :param preferences: (C) Returns the location of the preferences directory
    :type preferences: boolean
    :param product: (C) Returns the license product name
    :type product: boolean
    :param qtVersion: (C) Returns Qt version string
    :type qtVersion: boolean
    :param tablet: (C) Windows only  Returns true if the PC is a Tablet PC
    :type tablet: boolean
    :param tabletMode: (C) Windows 8 (and above) only  If your device is a Tablet PC, then the
    convertible mode the device is currently running in  Returns either: tablet or la
    :type tabletMode: boolean
    :param uiLanguage: (C) Returns the language that Maya's running in  Example return values
    include "en_US" for English and "ja_JP" for Japanese
    :type uiLanguage: boolean
    :param uiLanguageForStartup: (C) Returns the language that is used for Maya's next start up
     This is read from config file and is rewritten after setting ui language in preference
    :type uiLanguageForStartup: boolean
    :param uiLanguageIsLocalized: (C) Returns true if we are running in an alternate language,
    not the default (English)
    :type uiLanguageIsLocalized: boolean
    :param uiLocaleLanguage: (C) Returns the language locale of the OS  English is default
    :type uiLocaleLanguage: boolean
    :param version: (C) Returns the version string
    :type version: boolean
    :param win64: (C) Returns true if the operating system is Windows x64 based
    :type win64: boolean
    :param windowManager: (C) Returns the name of the Window Manager that is assumed to be
    running
    :type windowManager: boolean
    :param windows: (C) Returns true if the operating system is Windows based
    :type windows: boolean
    
    :returns: The application's version information.
    :rtype: string
    """
    pass


def curveEPCtx(*args, bezier=True, degree=0, exists=True, history=True, image1="", image2="",
               image3="", name="", preserveShape=True, preserveShapeFraction=0.0, refit=True,
               uniform=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    The curveEPCtx command creates a new context for creating curves by placing edit points
    
    :param bezier: (C Q E) Use bezier curves
    :type bezier: boolean
    :param degree: (C Q E) Curve degree
    :type degree: int
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param preserveShape: (C Q E) Set this flag to make the operation preserve the shape
    :type preserveShape: boolean
    :param preserveShapeFraction: (C Q E) Fraction value used when preserving the shape
    :type preserveShapeFraction: float
    :param refit: (C Q E) Set this flag to refit the curve
    :type refit: boolean
    :param uniform: (C Q E) Should the curve use uniform parameterization?
    :type uniform: boolean
    
    :returns: (name of the new context)
    :rtype: string
    """
    pass


def selectType(*args, allComponents=True, allObjects=True, animBreakdown=True, animCurve=True,
               animInTangent=True, animKeyframe=True, animOutTangent=True, byName=None,
               camera=True, cluster=True, collisionModel=True, controlVertex=True, curve=True,
               curveKnot=True, curveOnSurface=True, curveParameterPoint=True, dimension=True,
               dynamicConstraint=True, edge=True, editPoint=True, emitter=True, facet=True,
               field=True, fluid=True, follicle=True, hairSystem=True, handle=True, hull=True,
               ikEndEffector=True, ikHandle=True, imagePlane=True, implicitGeometry=True,
               isoparm=True, joint=True, jointPivot=True, lattice=True, latticePoint=True,
               light=True, localRotationAxis=True, locator=True, locatorUV=True,
               locatorXYZ=True, meshUVShell=True, motionTrailPoint=True,
               motionTrailTangent=True, nCloth=True, nParticle=True, nParticleShape=True,
               nRigid=True, nonlinear=True, nurbsCurve=True, nurbsSurface=True,
               objectComponent=True, orientationLocator=True, particle=True, particleShape=True,
               plane=True, polymesh=True, polymeshEdge=True, polymeshFace=True,
               polymeshFreeEdge=True, polymeshUV=True, polymeshVertex=True,
               polymeshVtxFace=True, queryByName="", rigidBody=True, rigidConstraint=True,
               rotatePivot=True, scalePivot=True, sculpt=True, selectHandle=True, spring=True,
               springComponent=True, stroke=True, subdiv=True, subdivMeshEdge=True,
               subdivMeshFace=True, subdivMeshPoint=True, subdivMeshUV=True, surfaceEdge=True,
               surfaceFace=True, surfaceKnot=True, surfaceParameterPoint=True,
               surfaceRange=True, surfaceUV=True, texture=True, vertex=True, q=True, query=True,
               **kwargs):
    """
    The selectType command is used to change the set of allowable types of objects that can be
    selected when using the select tool  It accepts no other arguments besides the flags  
    There are basically two different types of items that are selectable when interactively
    selecting objects in the 3D views  They are classified as objects (entire objects) o
    
    :param allComponents: (C Q) Set all component selection masks on/off
    :type allComponents: boolean
    :param allObjects: (C Q) Set all object selection masks on/off
    :type allObjects: boolean
    :param animBreakdown: (C Q) Set animation breakdown selection mask on/off
    :type animBreakdown: boolean
    :param animCurve: (C Q) Set animation curve selection mask on/off
    :type animCurve: boolean
    :param animInTangent: (C Q) Set animation in-tangent selection mask on/off
    :type animInTangent: boolean
    :param animKeyframe: (C Q) Set animation keyframe selection mask on/off
    :type animKeyframe: boolean
    :param animOutTangent: (C Q) Set animation out-tangent selection mask on/off
    :type animOutTangent: boolean
    :param byName: (C M) Set the specified user-defined selection mask on/off  (object flag)
    :type byName: [string, boolean]
    :param camera: (C Q) Set camera selection mask on/off  (object flag)
    :type camera: boolean
    :param cluster: (C Q) Set cluster selection mask on/off  (object flag)
    :type cluster: boolean
    :param collisionModel: (C Q) Set collision model selection mask on/off  (object flag)
    :type collisionModel: boolean
    :param controlVertex: (C Q) Set control vertex selection mask on/off  (component flag)
    :type controlVertex: boolean
    :param curve: (C Q) Set curve selection mask on/off  (object flag)
    :type curve: boolean
    :param curveKnot: (C Q) Set curve knot selection mask on/off  (component flag)
    :type curveKnot: boolean
    :param curveOnSurface: (C Q) Set curve-on-surface selection mask on/off  (object flag)
    :type curveOnSurface: boolean
    :param curveParameterPoint: (C Q) Set curve parameter point selection mask on/off 
    (component flag)
    :type curveParameterPoint: boolean
    :param dimension: (C Q) Set dimension shape selection mask on/off  (object flag)
    :type dimension: boolean
    :param dynamicConstraint: (C Q) Set dynamicConstraint selection mask on/off  (object flag)
    :type dynamicConstraint: boolean
    :param edge: (C Q) Set mesh edge selection mask on/off  (component flag)
    :type edge: boolean
    :param editPoint: (C Q) Set edit-point selection mask on/off  (component flag)
    :type editPoint: boolean
    :param emitter: (C Q) Set emitter selection mask on/off  (object flag)
    :type emitter: boolean
    :param facet: (C Q) Set mesh face selection mask on/off  (component flag)
    :type facet: boolean
    :param field: (C Q) Set field selection mask on/off  (object flag)
    :type field: boolean
    :param fluid: (C Q) Set fluid selection mask on/off  (object flag)
    :type fluid: boolean
    :param follicle: (C Q) Set follicle selection mask on/off  (object flag)
    :type follicle: boolean
    :param hairSystem: (C Q) Set hairSystem selection mask on/off  (object flag)
    :type hairSystem: boolean
    :param handle: (C Q) Set object handle selection mask on/off  (object flag)
    :type handle: boolean
    :param hull: (C Q) Set hull selection mask on/off  (component flag)
    :type hull: boolean
    :param ikEndEffector: (C Q) Set ik end effector selection mask on/off  (object flag)
    :type ikEndEffector: boolean
    :param ikHandle: (C Q) Set ik handle selection mask on/off  (object flag)
    :type ikHandle: boolean
    :param imagePlane: (C Q) Set image plane selection mask on/off  (component flag)
    :type imagePlane: boolean
    :param implicitGeometry: (C Q) Set implicit geometry selection mask on/off  (object flag)
    :type implicitGeometry: boolean
    :param isoparm: (C Q) Set surface iso-parm selection mask on/off  (component flag)
    :type isoparm: boolean
    :param joint: (C Q) Set ik handle selection mask on/off  (object flag)
    :type joint: boolean
    :param jointPivot: (C Q) Set joint pivot selection mask on/off  (component flag)
    :type jointPivot: boolean
    :param lattice: (C Q) Set lattice selection mask on/off  (object flag)
    :type lattice: boolean
    :param latticePoint: (C Q) Set lattice point selection mask on/off  (component flag)
    :type latticePoint: boolean
    :param light: (C Q) Set light selection mask on/off  (object flag)
    :type light: boolean
    :param localRotationAxis: (C Q) Set local rotation axis selection mask on/off  (component
    flag)
    :type localRotationAxis: boolean
    :param locator: (C Q) Set locator (all types) selection mask on/off  (object flag)
    :type locator: boolean
    :param locatorUV: (C Q) Set uv locator selection mask on/off  (object flag)
    :type locatorUV: boolean
    :param locatorXYZ: (C Q) Set xyz locator selection mask on/off  (object flag)
    :type locatorXYZ: boolean
    :param meshUVShell: (C Q) Set uv shell component mask on/off
    :type meshUVShell: boolean
    :param motionTrailPoint: (C Q) Set motion point selection mask on/off
    :type motionTrailPoint: boolean
    :param motionTrailTangent: (C Q) Set motion point tangent mask on/off
    :type motionTrailTangent: boolean
    :param nCloth: (C Q) Set nCloth selection mask on/off  (object flag)
    :type nCloth: boolean
    :param nParticle: (C Q) Set nParticle point selection mask on/off  (component flag)
    :type nParticle: boolean
    :param nParticleShape: (C Q) Set nParticle shape selection mask on/off  (object flag)
    :type nParticleShape: boolean
    :param nRigid: (C Q) Set nRigid selection mask on/off  (object flag)
    :type nRigid: boolean
    :param nonlinear: (C Q) Set nonlinear selection mask on/off  (object flag)
    :type nonlinear: boolean
    :param nurbsCurve: (C Q) Set nurbs-curve selection mask on/off  (object flag)
    :type nurbsCurve: boolean
    :param nurbsSurface: (C Q) Set nurbs-surface selection mask on/off  (object flag)
    :type nurbsSurface: boolean
    :param objectComponent: (C Q) Component flags apply to object mode
    :type objectComponent: boolean
    :param orientationLocator: (C Q) Set orientation locator selection mask on/off  (object
    flag)
    :type orientationLocator: boolean
    :param particle: (C Q) Set particle point selection mask on/off  (component flag)
    :type particle: boolean
    :param particleShape: (C Q) Set particle shape selection mask on/off  (object flag)
    :type particleShape: boolean
    :param plane: (C Q) Set sketch plane selection mask on/off  (object flag)
    :type plane: boolean
    :param polymesh: (C Q) Set poly-mesh selection mask on/off  (object flag)
    :type polymesh: boolean
    :param polymeshEdge: (C Q) Set poly-mesh edge selection mask on/off  (component flag)
    :type polymeshEdge: boolean
    :param polymeshFace: (C Q) Set poly-mesh face selection mask on/off  (component flag)
    :type polymeshFace: boolean
    :param polymeshFreeEdge: (C Q) Set poly-mesh free-edge selection mask on/off  (component
    flag)
    :type polymeshFreeEdge: boolean
    :param polymeshUV: (C Q) Set poly-mesh UV point selection mask on/off  (component flag)
    :type polymeshUV: boolean
    :param polymeshVertex: (C Q) Set poly-mesh vertex selection mask on/off  (component flag)
    :type polymeshVertex: boolean
    :param polymeshVtxFace: (C Q) Set poly-mesh vertexFace selection mask on/off  (component
    flag)
    :type polymeshVtxFace: boolean
    :param queryByName: (Q) Query the specified user-defined selection mask  (object flag) In
    query mode, this flag needs a value
    :type queryByName: string
    :param rigidBody: (C Q) Set rigid body selection mask on/off  (object flag)
    :type rigidBody: boolean
    :param rigidConstraint: (C Q) Set rigid constraint selection mask on/off  (object flag)
    :type rigidConstraint: boolean
    :param rotatePivot: (C Q) Set rotate pivot selection mask on/off  (component flag)
    :type rotatePivot: boolean
    :param scalePivot: (C Q) Set scale pivot selection mask on/off  (component flag)
    :type scalePivot: boolean
    :param sculpt: (C Q) Set sculpt selection mask on/off  (object flag)
    :type sculpt: boolean
    :param selectHandle: (C Q) Set select handle selection mask on/off  (component flag)
    :type selectHandle: boolean
    :param spring: (C Q) Set spring shape selection mask on/off  (object flag)
    :type spring: boolean
    :param springComponent: (C Q) Set individual spring selection mask on/off  (component
    flag)
    :type springComponent: boolean
    :param stroke: (C Q) Set the Paint Effects stroke selection mask on/off  (object flag)
    :type stroke: boolean
    :param subdiv: (C Q) Set subdivision surfaces selection mask on/off  (object flag)
    :type subdiv: boolean
    :param subdivMeshEdge: (C Q) Set subdivision surfaces mesh edge selection mask on/off 
    (component flag)
    :type subdivMeshEdge: boolean
    :param subdivMeshFace: (C Q) Set subdivision surfaces mesh face selection mask on/off 
    (component flag)
    :type subdivMeshFace: boolean
    :param subdivMeshPoint: (C Q) Set subdivision surfaces mesh point selection mask on/off 
    (component flag)
    :type subdivMeshPoint: boolean
    :param subdivMeshUV: (C Q) Set subdivision surfaces mesh UV map selection mask on/off 
    (component flag)
    :type subdivMeshUV: boolean
    :param surfaceEdge: (C Q) Set surface edge selection mask on/off  (component flag)
    :type surfaceEdge: boolean
    :param surfaceFace: (C Q) Set surface face selection mask on/off  (component flag)
    :type surfaceFace: boolean
    :param surfaceKnot: (C Q) Set surface knot selection mask on/off  (component flag)
    :type surfaceKnot: boolean
    :param surfaceParameterPoint: (C Q) Set surface parameter point selection mask on/off 
    (component flag)
    :type surfaceParameterPoint: boolean
    :param surfaceRange: (C Q) Set surface range selection mask on/off  (component flag)
    :type surfaceRange: boolean
    :param surfaceUV: (C Q) Set surface uv selection mask on/off  (component flag)
    :type surfaceUV: boolean
    :param texture: (C Q) Set texture selection mask on/off  (object flag)
    :type texture: boolean
    :param vertex: (C Q) Set mesh vertex selection mask on/off  (component flag)
    :type vertex: boolean
    
    :returns: if a query operation
    :rtype: boolean
    """
    pass


def ShowResultsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GraphEditorFrameCenterView(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetMeshCloneTargetTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleCustomNURBSComponents(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RenderDiagnostics(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_defLightTGL(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeSetLargeNodeSwatchSize(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ResolveInterpenetrationOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def WedgePolygon(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AttachCurveOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXGetTakeLocalTimeSpan(*args, **kwargs):
    """
    
    """
    pass


def colorIndex(*args, hueSaturationValue=True, resetToFactory=True, resetToSaved=True, q=True,
               query=True, **kwargs):
    """
    The index specifies a color index in the color palette  The r, g, and b values (between
    0-1) specify the RGB values (or the HSV values if the -hsv flag is used) for the color
    
    :param hueSaturationValue: (C Q) Indicates that rgb values are really hsv values  Upon
    query, returns the HSV valuses as an array of 3 floats
    :type hueSaturationValue: boolean
    :param resetToFactory: (C) Resets all color index palette entries to their factory
    defaults
    :type resetToFactory: boolean
    :param resetToSaved: (C) Resets all color palette entries to their saved values
    :type resetToSaved: boolean
    
    :returns: Returns 1 on success.
    :rtype: int
    """
    pass


def NURBSSmoothnessMediumOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ExtendSurfacesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HideSculptObjects(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TangetConstraintOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sbs_SetGlobalTextureHeight(*args, **kwargs):
    """
    
    """
    pass


def ToggleUVTextureImage(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetMeshImprintTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def createNurbsConeCtx(*args, **kwargs):
    """
    
    """
    pass


def iconTextScrollList(*args, allowMultiSelection=True, annotation="", append="",
                       backgroundColor=None, changeCommand=None, defineTemplate="",
                       deselectAll=True, docTag="", doubleClickCommand=None, dragCallback=None,
                       dragFeedbackVisible=True, dropCallback=None, dropRectCallback=None,
                       editIndexed=0, editable=True, enable=True, enableBackground=True,
                       enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
                       highlightColor=None, isObscured=True, itemAt=None, itemTextColor=None,
                       manage=True, noBackground=True, numberOfIcons=0, numberOfPopupMenus=True,
                       numberOfRows=True, parent="", popupMenuArray=True, preventOverride=True,
                       removeAll=True, selectCommand=None, selectIndexedItem=0, selectItem="",
                       statusBarMessage="", useTemplate="", visible=True,
                       visibleChangeCommand=None, visualRectAt=None, width=0, q=True,
                       query=True, e=True, edit=True, **kwargs):
    """
    This command creates/edits/queries a text scrolling list  The list can be in single select
    mode where only one item at at time is selected, or in multi-select mode where many items
    may be selected
    
    :param allowMultiSelection: (C Q E) Specify multi or single selection mode
    :type allowMultiSelection: boolean
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param append: (C E M) Add an item to the end of the list
    :type append: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Script to run when the list changes
    :type changeCommand: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param deselectAll: (C E) Deselect all items
    :type deselectAll: boolean
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param doubleClickCommand: (C E) Specify the command to be executed when an item is double
    clicked
    :type doubleClickCommand: script
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dragFeedbackVisible: (C E) Should the drag feedback be shown in the scrollbar?
    :type dragFeedbackVisible: boolean
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param dropRectCallback: (E) Adds a callback that is called when a drag and drop operation
    is hovering above the drop site  It returns the shape of the rectangle to be drawn to h
    :type dropRectCallback: script
    :param editIndexed: (C E) Index of the edited field
    :type editIndexed: int
    :param editable: (C E) Set the field to be editable or not
    :type editable: boolean
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param itemAt: (Q) Return the name of the item, if any, located at given point In query
    mode, this flag needs a value
    :type itemAt: [int, int]
    :param itemTextColor: (C E M) Set the text color of the item at the given index  Arguments
    are: index, red, green, and blue  Indices are 1-based  Each color component ranges in va
    :type itemTextColor: [int, float, float, float]
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfIcons: (Q) Number of icons
    :type numberOfIcons: int
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param numberOfRows: (Q) Number of visible rows
    :type numberOfRows: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param removeAll: (C E) Remove all items
    :type removeAll: boolean
    :param selectCommand: (C E) Specify the command to be executed when an item is selected
    :type selectCommand: script
    :param selectIndexedItem: (C Q E M) Select the indexed item  Indices are 1-based
    :type selectIndexedItem: int
    :param selectItem: (C Q E M) Select the item that contains the specified text
    :type selectItem: string
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param visualRectAt: (Q) Return the visual rectangle of the item, if any, located at given
    point  The result is a an array of 4 integers, in local coordinates, describing the
    :type visualRectAt: [int, int]
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def renderer(*args, addGlobalsNode="", addGlobalsTab=None, batchRenderOptionsProcedure="",
             batchRenderOptionsStringProcedure="", batchRenderProcedure="",
             cancelBatchRenderProcedure="", changeIprRegionProcedure="",
             commandRenderProcedure="", exists=True, globalsNodes=True,
             globalsTabCreateProcNames=True, globalsTabLabels=True,
             globalsTabUpdateProcNames=True, iprOptionsMenuLabel="", iprOptionsProcedure="",
             iprOptionsSubMenuProcedure="", iprRenderProcedure="", iprRenderSubMenuProcedure="",
             isRunningIprProcedure="", logoCallbackProcedure="", logoImageName="",
             materialViewRendererList=True, materialViewRendererPause=True,
             materialViewRendererSuspend=True, namesOfAvailableRenderers=True,
             pauseIprRenderProcedure="", polyPrelightProcedure="", refreshIprRenderProcedure="",
             renderDiagnosticsProcedure="", renderGlobalsProcedure="", renderMenuProcedure="",
             renderOptionsProcedure="", renderProcedure="", renderRegionProcedure="",
             renderSequenceProcedure="", rendererUIName="", renderingEditorsSubMenuProcedure="",
             showBatchRenderLogProcedure="", showBatchRenderProcedure="",
             showRenderLogProcedure="", startIprRenderProcedure="", stopIprRenderProcedure="",
             supportColorManagement=True, textureBakingProcedure="", unregisterRenderer=True,
             q=True, query=True, e=True, edit=True, **kwargs):
    """
    Command to register renders  This command allows you to specify the UI name and procedure
    names for renderers  The command also allow you to query the UI name and the procedure
    names for the registered renders
    
    :param addGlobalsNode: (C Q E) This flag allows the user to add a globals node the
    specified renderer uses
    :type addGlobalsNode: string
    :param addGlobalsTab: (C E) Add a tab associated with the specified renderer for the
    unified render globals window
    :type addGlobalsTab: [string, string, string]
    :param batchRenderOptionsProcedure: (C Q E) Set or query the batch render options procedure
    associated with the specified renderer
    :type batchRenderOptionsProcedure: string
    :param batchRenderOptionsStringProcedure: (C Q E) Set or query the argument string that
    will be used with the command line utility 'Render' when doing a batch render
    :type batchRenderOptionsStringProcedure: string
    :param batchRenderProcedure: (C Q E) Set or query the batch render procedure associated
    with the specified renderer
    :type batchRenderProcedure: string
    :param cancelBatchRenderProcedure: (C Q E) Set or query returns the cancel batch render
    procedure associated with the specified renderer
    :type cancelBatchRenderProcedure: string
    :param changeIprRegionProcedure: (C Q E) Set or query the change IPR region procedure
    associated with the specified renderer
    :type changeIprRegionProcedure: string
    :param commandRenderProcedure: (C Q E) Set or query the command line rendering procedure
    associated with the specified renderer
    :type commandRenderProcedure: string
    :param exists: (Q E) The flag returns true if the specified renderer is registered in the
    registry, and it returns false otherwise
    :type exists: boolean
    :param globalsNodes: (C Q E) This flag returns the list of render globals nodes the
    specified renderer uses
    :type globalsNodes: boolean
    :param globalsTabCreateProcNames: (C Q E) This flag returns the names of procedures that
    are used to create the unified render globals window tabs that are associated with the
    specified rende
    :type globalsTabCreateProcNames: boolean
    :param globalsTabLabels: (C Q E) This flag returns the labels of unified render globals
    window tabs that are associated with the specified renderer
    :type globalsTabLabels: boolean
    :param globalsTabUpdateProcNames: (C Q E) This flag returns the names of procedures that
    are used to update the unified render globals window tabs that are associated with the
    specified rende
    :type globalsTabUpdateProcNames: boolean
    :param iprOptionsMenuLabel: (C Q E) Set or query the label for the IPR update options menu
    which is under the render view's IPR menu
    :type iprOptionsMenuLabel: string
    :param iprOptionsProcedure: (C Q E) Set or query the IPR render options procedure
    associated with the specified renderer
    :type iprOptionsProcedure: string
    :param iprOptionsSubMenuProcedure: (C Q E) Set or query the procedure for creating the sub
    menu for the IPR update options menu which is under the render view's IPR menu
    :type iprOptionsSubMenuProcedure: string
    :param iprRenderProcedure: (C Q E) Set or query the IPR render command associated with the
    specified renderer
    :type iprRenderProcedure: string
    :param iprRenderSubMenuProcedure: (C Q E) Set or query the procedure for creating the sub
    menu for the IPR render menu which is under the render view's IPR menu
    :type iprRenderSubMenuProcedure: string
    :param isRunningIprProcedure: (C Q E) Set or query the isRunningIpr command associated with
    the specified renderer
    :type isRunningIprProcedure: string
    :param logoCallbackProcedure: (C Q E) Set or query the procedure which is a callback
    associated to the logo for the specified renderer  For example, the logo and the callback
    can be used
    :type logoCallbackProcedure: string
    :param logoImageName: (C Q E) Set or query the logo image name for the specified renderer 
    The logo is a image representing the renderer
    :type logoImageName: string
    :param materialViewRendererList: (Q E) Returns the names of material view renderers that
    are currently registered
    :type materialViewRendererList: boolean
    :param materialViewRendererPause: (Q E) Specifies whether to pause the material viewer 
    Useful for globally halting updates to the material viewer  The material view renderer will
    remain su
    :type materialViewRendererPause: boolean
    :param materialViewRendererSuspend: (Q E) Specifies whether to suspend or resume the
    material view renderer  Useful for temporarily stopping the material view renderer while
    another rendering
    :type materialViewRendererSuspend: boolean
    :param namesOfAvailableRenderers: (Q E) Returns the names of renderers that are currently
    registered
    :type namesOfAvailableRenderers: boolean
    :param pauseIprRenderProcedure: (C Q E) Set or query the pause IPR render procedure
    associated with the specified renderer
    :type pauseIprRenderProcedure: string
    :param polyPrelightProcedure: (C Q E) Set or query the polygon prelight procedure
    associated with the specified renderer
    :type polyPrelightProcedure: string
    :param refreshIprRenderProcedure: (C Q E) Set or query the refresh IPR render procedure
    associated with the specified renderer
    :type refreshIprRenderProcedure: string
    :param renderDiagnosticsProcedure: (C Q E) Set or query the render diagnostics procedure
    associated with the specified renderer
    :type renderDiagnosticsProcedure: string
    :param renderGlobalsProcedure: (C Q E) This flag is obsolete  It will be removed in the
    next release
    :type renderGlobalsProcedure: string
    :param renderMenuProcedure: (C Q E) This flag is obsolete  It will be removed in the next
    release
    :type renderMenuProcedure: string
    :param renderOptionsProcedure: (C Q E) Set or query the render options procedure associated
    with the specified renderer
    :type renderOptionsProcedure: string
    :param renderProcedure: (C Q E) Set or query the render command associated with the
    specified renderer
    :type renderProcedure: string
    :param renderRegionProcedure: (C Q E) Set or query the render region procedure associated
    with the specified renderer
    :type renderRegionProcedure: string
    :param renderSequenceProcedure: (C Q E) Set or query the sequence rendering procedure
    associated with the specified renderer
    :type renderSequenceProcedure: string
    :param rendererUIName: (C Q E) Set or query the rendererUIName for the specified renderer 
    The rendererUIName is the name of the renderer as it would appear in menus
    :type rendererUIName: string
    :param renderingEditorsSubMenuProcedure: (C Q E) Set or query the procedure reponsible for
    creating renderer specific editors submenu under the "Rendering Editors" menu for the
    specified renderer
    :type renderingEditorsSubMenuProcedure: string
    :param showBatchRenderLogProcedure: (C Q E) Set or query the log file batch procedure
    associated with the specified renderer
    :type showBatchRenderLogProcedure: string
    :param showBatchRenderProcedure: (C Q E) Set or query the show batch render procedure
    associated with the specified renderer
    :type showBatchRenderProcedure: string
    :param showRenderLogProcedure: (C Q E) Set or query the log file render procedure
    associated with the specified renderer
    :type showRenderLogProcedure: string
    :param startIprRenderProcedure: (C Q E) Set or query the start IPR render procedure
    associated with the specified renderer
    :type startIprRenderProcedure: string
    :param stopIprRenderProcedure: (C Q E) Set or query the stop IPR render procedure
    associated with the specified renderer
    :type stopIprRenderProcedure: string
    :param supportColorManagement: (Q E) Specifies whether the renderer supports color
    management
    :type supportColorManagement: boolean
    :param textureBakingProcedure: (C Q E) Set or query the texture baking procedure associated
    with the specified renderer
    :type textureBakingProcedure: string
    :param unregisterRenderer: (Q E) Unregister the specified renderer
    :type unregisterRenderer: boolean
    
    :returns: 
    :rtype: None
    """
    pass


def CreateSetOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DisableAll(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleIKAllowRotation(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MakeMotionField(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectAllOutput(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorPickWalkDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmGeoRender(*args, **kwargs):
    """
    
    """
    pass


def HypershadeDuplicateWithConnections(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PolyMergeVerticesOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def EPCurveTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PaintFluidsTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetWorkingFrame(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def artFluidAttrCtx(*args, accopacity=False, activeListChangedProc="", afterStrokeCmd="",
                    alphaclamp="none", alphaclamplower=0.0, alphaclampupper=1.0,
                    attrSelected="", autoSave="", beforeStrokeCmd="", brushalignment=True,
                    brushfeedback=True, clamp="none", clamplower=0.0, clampupper=1.0,
                    clear=True, colorAlphaValue=0.0, colorRGBAValue=None, colorRGBValue=None,
                    colorRamp="", colorfeedback=False, colorfeedbackOverride=False,
                    colorrangelower=0.0, colorrangeupper=1.0, currentPaintableFluid="",
                    dataTypeIndex=0, delaySelectionChanged=True, disablelighting=False,
                    displayAsRender=True, displayVelocity=True, doAutoSave=True, dragSlider="",
                    duringStrokeCmd="", dynclonemode=True, exists=True, expandfilename=True,
                    exportaspectratio=0.0, exportfilemode="luminance/rgb", exportfilesave="",
                    exportfilesizex=0, exportfilesizey=0, exportfiletype="", filterNodes=True,
                    history=True, image1="", image2="", image3="", importfileload="",
                    importfilemode="alpha", importreassign=False, interactiveUpdate=True,
                    lastRecorderCmd="", lastStampName="", lowerradius=0.0, makeStroke=0,
                    mappressure="none", maxvalue=1.0, minvalue=0.0, name="", objattrArray="",
                    opacity=1.0, outline=True, outwhilepaint=False, paintNodeArray="",
                    paintattrselected="", paintmode="screen", paintoperationtype="Paint",
                    pickColor=True, pickValue=True, playbackCursor=None, playbackPressure=0.0,
                    preserveclonesource=True, profileShapeFile="", projective=False,
                    property="", radius=1.0, rampMaxColor=None, rampMinColor=None, record=True,
                    reflection=False, reflectionaboutorigin=True, reflectionaxis="x",
                    rgbValue=None, screenRadius=0.0, selectclonesource=True,
                    selectedattroper="absolute", showactive=True, stampDepth=0.0,
                    stampProfile="", stampSpacing=1.0, strokesmooth="",
                    surfaceConformedBrushVertices=True, tablet=True, tangentOutline=True,
                    toolOffProc="", toolOnProc="", useColorRamp=True, useMaxMinColor=True,
                    useStrokeDirection=True, usepressure=False, value=0.0, velocity=None,
                    whichTool="", worldRadius=0.0, q=True, query=True, e=True, edit=True,
                    **kwargs):
    """
    This is a context command to set the flags on the artAttrContext, which is the base context
    for attribute painting operations  All commands require the name of the context as the last
    argument as this provides the name of the context to create, edit or query   This command
    is used to paint properties (such as density) of selected fluid volumes
    
    :param accopacity: (C Q E) Sets opacity accumulation on/off  C: Default is false (Except
    for sculpt tool for which it is true by default)  Q: When queried, it returns a boolean
    :type accopacity: boolean
    :param activeListChangedProc: (C Q E) Accepts a string that contains a MEL command that is
    invoked whenever the active list changes  There may be some situations where the UI, for
    example
    :type activeListChangedProc: string
    :param afterStrokeCmd: (C Q E) The passed string is executed as a MEL command immediately
    after the end of a stroke  C: Default is no command  Q: When queried, it returns the curre
    :type afterStrokeCmd: string
    :param alphaclamp: (C Q E) Specifies if the weight value should be alpha clamped to the
    lower and upper bounds  There are four options here: "none" - no clamping is performed,
    :type alphaclamp: string
    :param alphaclamplower: (C Q E) Specifies the lower bound for the alpha values  C: Default
    is 0.0  Q: When queried, it returns a float
    :type alphaclamplower: float
    :param alphaclampupper: (C Q E) Specifies the upper bound for the alpha values  C: Default
    is 1.0  Q: When queried, it returns a float
    :type alphaclampupper: float
    :param attrSelected: (Q) Returns a name of the currently selected attribute  Q: When
    queried, it returns a string
    :type attrSelected: string
    :param autoSave: (C Q E) A MEL command to save the fluid state  Called before an event
    which could overwrite unsaved values of painted fluid properties  Such events include:
    :type autoSave: string
    :param beforeStrokeCmd: (C Q E) The passed string is executed as a MEL command immediately
    before the start of a stroke  C: Default is no command  Q: When queried, it returns the cu
    :type beforeStrokeCmd: string
    :param brushalignment: (C Q E) Specifies the path brush alignemnt  If true, the brush will
    align to stroke path, otherwise it will align to up vector  C: Default is true  Q: When q
    :type brushalignment: boolean
    :param brushfeedback: (C Q E) Specifies if the brush additional feedback should be drawn 
    C: Default is TRUE  Q: When queried, it returns a boolean
    :type brushfeedback: boolean
    :param clamp: (C Q E) Specifies if the weight value should be clamped to the lower and
    upper bounds  There are four options here: "none" - no clamping is performed, "lower
    :type clamp: string
    :param clamplower: (C Q E) Specifies the lower bound for the values  C: Default is 0.0  Q:
    When queried, it returns a float
    :type clamplower: float
    :param clampupper: (C Q E) Specifies the upper bound for the values  C: Default is 1.0  Q:
    When queried, it returns a float
    :type clampupper: float
    :param clear: (C E) Floods all cvs/vertices to the current value
    :type clear: boolean
    :param colorAlphaValue: (C Q E) The Alpha value of the color
    :type colorAlphaValue: float
    :param colorRGBAValue: (C Q E) The RGBA value of the color
    :type colorRGBAValue: [float, float, float, float]
    :param colorRGBValue: (C Q E) The RGB value of the color
    :type colorRGBValue: [float, float, float]
    :param colorRamp: (C Q E) Allows a user defined color ramp to be used to map values to
    colors
    :type colorRamp: string
    :param colorfeedback: (C Q E) Sets on/off the color feedback display  C: Default is FALSE 
    Q: When queried, it returns a boolean
    :type colorfeedback: boolean
    :param colorfeedbackOverride: (C Q E) Sets on/off the color feedback override  C: Default
    is FALSE  Q: When queried, it returns a boolean
    :type colorfeedbackOverride: boolean
    :param colorrangelower: (C Q E) Specifies the value that maps to black when color feedback
    mode is on  C: Default is 0.0  Q: When queried, it returns a float
    :type colorrangelower: float
    :param colorrangeupper: (C Q E) Specifies the value that maps to the maximum color when
    color feedback mode is on  C: Default is 1.0  Q: When queried, it returns a float
    :type colorrangeupper: float
    :param currentPaintableFluid: (Q) Query the name of the fluid on which this context is
    currently painting  Returns string
    :type currentPaintableFluid: string
    :param dataTypeIndex: (Q E) When the selected paintable attribute is a vectorArray, it
    specifies which field to paint on
    :type dataTypeIndex: int
    :param delaySelectionChanged: (C Q E) Internal use only  Under normal conditions, the tool
    responds to changes to the selection list so it can update its list of paintable geometry 
    When
    :type delaySelectionChanged: boolean
    :param disablelighting: (C Q E) If color feedback is on, this flag determines whether
    lighting is disabled or not for the surfaces that are affected  C: Default is FALSE  Q:
    When qu
    :type disablelighting: boolean
    :param displayAsRender: (C Q E) When true, sets the "Shaded Display" attribute of the fluid
    to "AsRender": all fluid properties displayed as hardware rendered  When false, displays
    :type displayAsRender: boolean
    :param displayVelocity: (C Q E) Turns on/off velocity display, independently of the above
    "dar/displayAsRender" setting  Use this flag to enable velocity display while only
    displayi
    :type displayVelocity: boolean
    :param doAutoSave: (E) Execute the -autoSave command if there are unsaved painted fluid
    properties
    :type doAutoSave: boolean
    :param dragSlider: (C E) Sets the current brush drag state for resizing or offsetting the
    brush (like the 'b' and 'm' default hotkeys)  The string argument is one of: "radius
    :type dragSlider: string
    :param duringStrokeCmd: (C Q E) The passed string is executed as a MEL command during the
    stroke, each time the mouse is dragged  C: Default is no command  Q: When queried, it
    retur
    :type duringStrokeCmd: string
    :param dynclonemode: (C Q E) Enable or disable dynamic clone mode
    :type dynclonemode: boolean
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param expandfilename: (C E) If true, it will expand the name of the export file and
    concatenate it with the surface name  Otherwise it will take the name as it is  C: Default
    is
    :type expandfilename: boolean
    :param exportaspectratio: (C Q E) Value of aspect ratio for export
    :type exportaspectratio: float
    :param exportfilemode: (C Q E) Specifies the export channel.The valid entries here are:
    "alpha", "luminance", "rgb", "rgba"  C: Default is "luminance/rgb"  Q: When queried, it
    retu
    :type exportfilemode: string
    :param exportfilesave: (E) Exports the attribute map and saves to a specified file
    :type exportfilesave: string
    :param exportfilesizex: (C Q E) Specifies the width of the attribute map to export  C:
    Default width is 256  Q: When queried, it returns an integer
    :type exportfilesizex: int
    :param exportfilesizey: (C Q E) Specifies the width of the attribute map to export  C:
    Default width is 256  Q: When queried, it returns an integer
    :type exportfilesizey: int
    :param exportfiletype: (C Q E) Specifies the image file format  It can be one of the
    following: "iff", "tiff", "jpeg", "alias", "rgb", "fit" "postScriptEPS", "softimage",
    "wavefron
    :type exportfiletype: string
    :param filterNodes: (E) Sets the node filter
    :type filterNodes: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param importfileload: (E) Load the attribute map a specified file
    :type importfileload: string
    :param importfilemode: (C Q E) Specifies the channel to import  The valid entries here are:
    "alpha", "luminance", "red", "green", "blue", and "rgb" C: Default is "alpha"  Q: When q
    :type importfilemode: string
    :param importreassign: (C Q E) Specifies if the multiply atrribute maps are to be
    reassigned while importing  Only maps previously exported from within Artisan can be
    reassigned  C
    :type importreassign: boolean
    :param interactiveUpdate: (C Q E) Specifies how often to transfer the painted values into
    the attribute  TRUE: transfer them "continuously" (many times per stroke) FALSE: transfer
    the
    :type interactiveUpdate: boolean
    :param lastRecorderCmd: (C Q E) Value of last recorded command
    :type lastRecorderCmd: string
    :param lastStampName: (C Q E) Value of the last stamp name
    :type lastStampName: string
    :param lowerradius: (C Q E) Sets the lower size of the brush (only apply on tablet)
    :type lowerradius: float
    :param makeStroke: (C Q E M) Stroke point values
    :type makeStroke: int
    :param mappressure: (C Q E) Sets the tablet pressure mapping when the table is used  There
    are four options: "none" - the pressure has no effect, "opacity" - the pressure is map
    :type mappressure: string
    :param maxvalue: (C Q E) Specifies the maximum value for each attribute  C: Default is 1.0 
    Q: When queried, it returns a float
    :type maxvalue: float
    :param minvalue: (C Q E) Specifies the minimum value for each attribute  C: Default is 0.0 
    Q: When queried, it returns a float
    :type minvalue: float
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    :param objattrArray: (Q) An array of all paintable attributes  Each element of the array is
    a string with the following information: NodeType.NodeName.AttributeName.MenuType
    :type objattrArray: string
    :param opacity: (C Q E) Sets the brush opacity  C: Default is 1.0  Q: When queried, it
    returns a float
    :type opacity: float
    :param outline: (C Q E) Specifies if the brush should be drawn  C: Default is TRUE  Q: When
    queried, it returns a boolean
    :type outline: boolean
    :param outwhilepaint: (C Q E) Specifies if the brush outline should be drawn while painting
     C: Default is FALSE  Q: When queried, it returns a boolean
    :type outwhilepaint: boolean
    :param paintNodeArray: (Q) An array of paintable nodes  Q: When queried, it returns a
    string
    :type paintNodeArray: string
    :param paintattrselected: (E) An array of selected paintable attributes  Each element of
    the array is a string with the following information: NodeType.NodeName.AttributeName
    :type paintattrselected: string
    :param paintmode: (C Q E) Specifies the paint mode  There are two possibilities: "screen"
    and "tangent"  C: Default is "screen"  Q: When queried, it returns a string
    :type paintmode: string
    :param paintoperationtype: (C Q E) Specifies the operation type used by the Paint Tool 
    Currently, we support the following paint modes: "Paint", "Smear", "Blur", "Erase" and
    "Clone"
    :type paintoperationtype: string
    :param pickColor: (C Q E) Set pick color mode on or off
    :type pickColor: boolean
    :param pickValue: (C Q E) Toggle for picking
    :type pickValue: boolean
    :param playbackCursor: (C Q E M) Values for the playback cursor
    :type playbackCursor: [float, float]
    :param playbackPressure: (C Q E M) Valus for the playback pressure
    :type playbackPressure: float
    :param preserveclonesource: (C Q E) Whether or not to preserve a clone source
    :type preserveclonesource: boolean
    :param profileShapeFile: (Q E) Passes a name of the image file for the stamp shape profile
    :type profileShapeFile: string
    :param projective: (C Q E) Specifies the projective paint mode  C: Default is 'false'  Q:
    When queried, it returns a boolean
    :type projective: boolean
    :param property: (C Q E) Specifies a property to paint on the fluid  Valid values are
    "color", "density", "densityAndColor," "densityAndFuel," "temperature," "fuel", "velocit
    :type property: string
    :param radius: (C Q E) Sets the size of the brush  C: Default is 1.0 cm  Q: When queried,
    it returns a float
    :type radius: float
    :param rampMaxColor: (C Q E) Defines a special color to be used when the value is greater
    than or equal to the maximum value
    :type rampMaxColor: [float, float, float]
    :param rampMinColor: (C Q E) Defines a special color to be used when the value is less than
    or equal to the minimum value
    :type rampMinColor: [float, float, float]
    :param record: (C Q E) Toggle on for recording
    :type record: boolean
    :param reflection: (C Q E) Specifies the reflection mode  C: Default is 'false'  Q: When
    queried, it returns a boolean
    :type reflection: boolean
    :param reflectionaboutorigin: (C Q E) Toggle on to reflect about the origin
    :type reflectionaboutorigin: boolean
    :param reflectionaxis: (C Q E) Specifies the reflection axis  There are three
    possibilities: "x", "y" and "z"  C: Default is "x"  Q: When queried, it returns a string
    :type reflectionaxis: string
    :param rgbValue: (C Q E) Specifies the values of the red, green, and blue components of the
    color to use when painting the property "color."
    :type rgbValue: [float, float, float]
    :param screenRadius: (C Q E) Brush radius on the screen
    :type screenRadius: float
    :param selectclonesource: (C Q E) Toggle on to select the clone source
    :type selectclonesource: boolean
    :param selectedattroper: (C Q E) Sets the edit weight operation  Four edit weights
    operations are provided : "absolute" - the value of the weight is replaced by the current
    one, "add
    :type selectedattroper: string
    :param showactive: (C Q E) Sets on/off the display of the surface isoparms  C: Default is
    TRUE  Q: When queried, it returns a boolean
    :type showactive: boolean
    :param stampDepth: (C Q E) Depth of the stamps
    :type stampDepth: float
    :param stampProfile: (C Q E) Sets the brush profile of the current stamp  Currently, the
    following profiles are supported: "gaussian", "poly", "solid" and "square"  C: Default is
    :type stampProfile: string
    :param stampSpacing: (C Q E) Specifies the stamp spacing  Default is 1.0
    :type stampSpacing: float
    :param strokesmooth: (C Q E) Stroke smoothing type name
    :type strokesmooth: string
    :param surfaceConformedBrushVertices: (C Q E) Enables/disables the the display of the
    effective brush area as affected vertices
    :type surfaceConformedBrushVertices: boolean
    :param tablet: (Q) Returns true if the tablet device is present, false if it is absent
    :type tablet: boolean
    :param tangentOutline: (C Q E) Enables/disables the display of the brush circle tangent to
    the surface
    :type tangentOutline: boolean
    :param toolOffProc: (C Q E) Accepts a strings describing the name of a MEL procedure that
    is invoked whenever the tool is turned off  For example, cloth invokes "clothPaintToolO
    :type toolOffProc: string
    :param toolOnProc: (C Q E) Accepts a strings describing the name of a MEL procedure that is
    invoked whenever the tool is turned on  For example, cloth invokes "clothPaintToolOn
    :type toolOnProc: string
    :param useColorRamp: (C Q E) Specifies whether the user defined color ramp should be used
    to map values from to colors  If this is turned off, the default greyscale feedback will
    :type useColorRamp: boolean
    :param useMaxMinColor: (C Q E) Specifies whether the out of range colors should be used 
    See rampMinColor and rampMaxColor flags for further details
    :type useMaxMinColor: boolean
    :param useStrokeDirection: (C Q E) Applicable only during "velocity" painting  Specifies
    whether the value of the painted velocity should come from the direction of the brush
    stroke, o
    :type useStrokeDirection: boolean
    :param usepressure: (C Q E) Sets the tablet pressure on/off  C: Default is false  Q: When
    queried, it returns a boolean
    :type usepressure: boolean
    :param value: (C Q E) Specifies the value for each attribute  C: Default is 0.0  Q: When
    queried, it returns a float
    :type value: float
    :param velocity: (C Q E) Specifies the values of the x, y, and z components of the velocity
    to use when painting the property "velocity"
    :type velocity: [float, float, float]
    :param whichTool: (C Q E) The string defines the name of the tool to be used for the
    Artisan context  An example is "artClothPaint"  In query mode, the tool name for the given
    :type whichTool: string
    :param worldRadius: (C Q E) Radius in worldspace
    :type worldRadius: float
    
    :returns: 
    :rtype: None
    """
    pass


def AddOceanSurfaceLocator(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmSyncPatchVisibility(*args, **kwargs):
    """
    
    """
    pass


def CreaseProxyEdgeTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def hotkeyMapSet(*args, **kwargs):
    """
    
    """
    pass


def nClothDeleteCacheFramesOpt(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DetachEdgeComponent(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CoarsenSelectedComponents(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TogglePanZoomRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GetSettingsFromSelectedStroke(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def setNodeTypeFlag(*args, display=True, threadSafe=True, q=True, query=True, **kwargs):
    """
    This command sets static data on the specified node type  This will affect the class of
    node type as a whole  The argument passed may be the name of the node type or the node type
    tag  Node type tags may be found using the objectType command
    
    :param display: (C Q) Sets whether the node type will appear in the UI or not  Setting
    display to false will cause the node type to not appear in the UI  Query mode to obt
    :type display: boolean
    :param threadSafe: (C Q) This flag is obsolete  Has no effect
    :type threadSafe: boolean
    
    :returns: Did the command succeed?
    :rtype: boolean
    """
    pass


def CreateAmbientLightOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TranslateToolWithSnapMarkingMenu(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SelectBorderEdgeTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeSetSmallNodeSwatchSize(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SurfaceBooleanIntersectToolOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXImportMergeAnimationLayers(*args, **kwargs):
    """
    
    """
    pass


def SelectAllHairSystem(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def cMuscleCache(*args, **kwargs):
    """
    
    """
    pass


def TesselateSubdivSurface(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def arrayMapper(*args, destAttr="", inputU="", inputV="", mapTo="", target="", type="",
                **kwargs):
    """
    Create an arrayMapper node and connect it to a target object  If the -type flag is used,
    then this command also creates an external node used for computing the output values  If
    the input attribute does not already exist, it will be created  The output attribute must
    exists  If a flag is omitted, the selection list will be used to supply the needed
    
    :param destAttr: (C) Specifies the attribute which will be the downstream connection for
    the output data from the mapper node  The attribute type will be used to determin
    :type destAttr: string
    :param inputU: (C) Specifies the upstream attribute to connect to the mapper's uCoordPP
    attribute  If the flag is omitted, no input connection is made
    :type inputU: string
    :param inputV: (C) Specifies the upstream attribute to connect to the mapper's vCoordPP
    attribute  If the flag is omitted, no input connection is made
    :type inputV: string
    :param mapTo: (C) Specifies an existing node to be used to compute the output values  This
    node must be of the appropriate type  Currently, only ramp nodes may be used
    :type mapTo: string
    :param target: (C M) Specifies the target object to be connected to
    :type target: string
    :param type: (C) Specifies the node type to create which will be used to compute the output
    values  Currently, only ramp is valid  If the flag is omitted, no connecti
    :type type: string
    
    :returns: Names of created arrayMapper nodes.
    :rtype: string[]
    """
    pass


def printStudio(*args, **kwargs):
    """
    
    """
    pass


def imagePlane(*args, camera="", counter=True, detach=True, dropFrame=True, fileName="",
               frameDuration=0, height=0.0, imageSize=None, lookThrough="", maintainRatio=True,
               name="", negTimesOK=True, numFrames=0, quickTime=True, showInAllViews=True,
               timeCode=0, timeCodeTrack=True, timeScale=0, twentyFourHourMax=True, width=0.0,
               q=True, query=True, e=True, edit=True, **kwargs):
    """
    The imagePlane command allows querying of various properties of an image plane and any
    movie in use by the image plane  It also supports creating and edit  The object passed to
    the command may either be an imagePlane node, or a camera, in which case the command uses
    the image plane attached to the camera (if any)  If no object is passed in, the cur
    
    :param camera: (C Q E) When creating, it will try to attach the created image plane to the
    specified camera  If the given camera is invalid, creating will fail  When queryi
    :type camera: string
    :param counter: () Query the 'counter' flag of the movie's timecode format  If this is true,
    the timecode returned by the -timeCode flag will be a simple counter  If fa
    :type counter: boolean
    :param detach: (E) This flag can only be used in the edit mode, when this flag is used in
    edit, it will detach current image plane from any camera it attaches to and ma
    :type detach: boolean
    :param dropFrame: (Q) Query the 'drop frame' flag of the movie's timecode format
    :type dropFrame: boolean
    :param fileName: (C E) Set the image name for image plane to read
    :type fileName: string
    :param frameDuration: (Q) Query the frame duration of the movie's timecode format
    :type frameDuration: int
    :param height: (C Q E) Height of the image plane  When creating, if this flag is not
    specified, it will use 10.0 as default height
    :type height: float
    :param imageSize: (Q) Get size of the loaded image
    :type imageSize: [int, int]
    :param lookThrough: (C Q E) The camera currently used for image plane to look through
    :type lookThrough: string
    :param maintainRatio: (C Q E) Let the image plane respect the picture aspect ratio  When
    creating, if this flag is not specified, it will use true as default value
    :type maintainRatio: boolean
    :param name: (C Q) Set the image plane node name when creating or return the image plane
    name when querying
    :type name: string
    :param negTimesOK: (Q) Query the 'neg times OK' flag of the movie's timecode format
    :type negTimesOK: boolean
    :param numFrames: (Q) Query the whole number of frames per second of the movie's timecode
    format
    :type numFrames: int
    :param quickTime: (Q) Query whether the image plane is using a QuickTime movie
    :type quickTime: boolean
    :param showInAllViews: (C Q E) The flag is used to show the current image plane in all
    views or not
    :type showInAllViews: boolean
    :param timeCode: (Q) Query the whole number of frames per second of the movie's timecode
    format
    :type timeCode: int
    :param timeCodeTrack: (Q) Query whether the movie on the image plane has a timecode track
    :type timeCodeTrack: boolean
    :param timeScale: (Q) Query the timescale of the movie's timecode format
    :type timeScale: int
    :param twentyFourHourMax: (Q) Query the '24 hour max' flag of the movie's timecode format
    :type twentyFourHourMax: boolean
    :param width: (C Q E) Width of the image plane  When creating, if this flag is not
    specified, it will use 10.0 as default width
    :type width: float
    
    :returns: Command result
    :rtype: boolean
    """
    pass


def DeleteAllWires(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ScaleCurvature(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def MakeUVInstanceCurrent(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleOriginAxis(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FBXExportHardEdges(*args, **kwargs):
    """
    
    """
    pass


def alignCurve(*args, caching=True, curvatureContinuity=False, curvatureScale1=0.0,
               curvatureScale2=0.0, joinParameter=123456.0, nodeState=0,
               positionalContinuity=True, positionalContinuityType=1, reverse1=False,
               reverse2=False, tangentContinuity=True, tangentContinuityType=1,
               tangentScale1=1.0, tangentScale2=1.0, attach=True, constructionHistory=True,
               keepMultipleKnots=True, name="", object=True, replaceOriginal=True, q=True,
               query=True, e=True, edit=True, **kwargs):
    """
    The curve align command is used to align curves in maya  The main alignment options are
    positional, tangent and curvature continuity  Curvature continuity implies tangent
    continuity   Positional continuity means the curves (move) or the ends of the curves
    (modify) are changed   Tangent continuity means one of the curves is modified to be tangent
    at
    
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param curvatureContinuity: (C Q E) Curvature continuity is on if true and off otherwise 
    Default: false
    :type curvatureContinuity: boolean
    :param curvatureScale1: (C Q E) Curvature scale applied to curvature of first curve for
    curvature continuity  Default: 0.0
    :type curvatureScale1: float
    :param curvatureScale2: (C Q E) Curvature scale applied to curvature of second curve for
    curvature continuity  Default: 0.0
    :type curvatureScale2: float
    :param joinParameter: (C Q E) Parameter on reference curve where modified curve is to be
    aligned to  Default: 123456.0
    :type joinParameter: float
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param positionalContinuity: (C Q E) Positional continuity is on if true and off otherwise 
    Default: true
    :type positionalContinuity: boolean
    :param positionalContinuityType: (C Q E) Positional continuity type legal values: 1 - move
    first curve, 2 - move second curve, 3 - move both curves, 4 - modify first curve, 5 -
    modify second
    :type positionalContinuityType: int
    :param reverse1: (C Q E) If true, reverse the first input curve before doing align 
    Otherwise, do nothing to the first input curve before aligning  NOTE: setting this attribu
    :type reverse1: boolean
    :param reverse2: (C Q E) If true, reverse the second input curve before doing align 
    Otherwise, do nothing to the second input curve before aligning  NOTE: setting this attri
    :type reverse2: boolean
    :param tangentContinuity: (C Q E) Tangent continuity is on if true and off otherwise 
    Default: true
    :type tangentContinuity: boolean
    :param tangentContinuityType: (C Q E) Tangent continuity type legal values: 1 - do tangent
    continuity on first curve, 2 - do tangent continuity on second curve Default: 1
    :type tangentContinuityType: int
    :param tangentScale1: (C Q E) Tangent scale applied to tangent of first curve for tangent
    continuity  Default: 1.0
    :type tangentScale1: float
    :param tangentScale2: (C Q E) Tangent scale applied to tangent of second curve for tangent
    continuity  Default: 1.0
    :type tangentScale2: float
    :param attach: (C) True if the curve is to be attached
    :type attach: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param keepMultipleKnots: (C) True if multiple knots should be left as-is
    :type keepMultipleKnots: boolean
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param replaceOriginal: (C) Create "in place" (i.e., replace)
    :type replaceOriginal: boolean
    
    :returns: Object name and node name
    :rtype: string[]
    """
    pass


def editRenderLayerGlobals(*args, baseId=0, currentRenderLayer=None, enableAutoAdjustments=True,
                           mergeType=0, useCurrent=True, q=True, query=True, **kwargs):
    """
    Edit the parameter values common to all render layers  Some of these paremeters, eg  baseId
    and mergeType, are stored as preferences and some, eg  currentRenderLayer, are stored in
    the file
    
    :param baseId: (C Q) Set base layer ID  This is the number at which new layers start
    searching for a unique ID
    :type baseId: int
    :param currentRenderLayer: (C Q) Set current render layer  This will will update the
    renderLayerManger and all DAG objects to identify them as members of the render layer  This
    flag
    :type currentRenderLayer: name
    :param enableAutoAdjustments: (C Q) Set whether or not to enable automatic creation of
    adjustments when certain attributes (ie  surface render stats, shading group assignment, or
    render
    :type enableAutoAdjustments: boolean
    :param mergeType: (C Q) Set file import merge type  Valid values are 0, none, 1, by number,
    and 2, by name
    :type mergeType: int
    :param useCurrent: (C Q) Set whether or not to enable usage of the current render layer as
    the destination for all new nodes
    :type useCurrent: boolean
    
    :returns: Command success
    :rtype: boolean
    """
    pass


def xgmClumpMap(*args, **kwargs):
    """
    
    """
    pass


def GraphEditorFrameSelected(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PaintVertexColorTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def AlembicImport(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PickColorActivate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Twist(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def artAttr(*args, **kwargs):
    """
    
    """
    pass


def CreatePartitionOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeOpenGraphEditorWindow(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def OffsetCurveOnSurface(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetPassiveKey(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def NodeEditorToggleSyncedSelection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ShowFollicles(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteAllLights(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetFullBodyIKKeysOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def FilletBlendTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorRippleEditToggleRelease(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSplineCacheDelete(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateUVsBasedOnCameraOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeCollapseAsset(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def XgmSplineGeometryConvert(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_extrudeBevelPress(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def Snap3PointsTo3PointsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def InsertKeyToolDeactivate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def TimeEditorExportSelection(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def manipOptions(*args, enableSmartDuplicate=True, enableSmartExtrude=True, forceRefresh=True,
                 handleSize=0.0, hideManipOnCtrl=True, hideManipOnShift=True,
                 hideManipOnShiftCtrl=True, linePick=0.0, lineSize=0.0,
                 middleMouseRepositioning=True, pivotRotateHandleOffset=0, planeHandleOffset=0,
                 pointSize=0.0, preselectHighlight=True, refreshMode=0, relative=True,
                 rememberActiveHandle=True, rememberActiveHandleAfterToolSwitch=True, scale=0.0,
                 showExtrudeSliders=True, showPivotRotateHandle=True, showPlaneHandles=True,
                 smartDuplicateType=0, q=True, query=True, **kwargs):
    """
    Changes the global manipulator parameters
    
    :param enableSmartDuplicate: (C Q) Enables Shift-Duplicate option on t/r/s manips
    :type enableSmartDuplicate: boolean
    :param enableSmartExtrude: (C Q) Enables Shift-Extrude option on t/r/s manips
    :type enableSmartExtrude: boolean
    :param forceRefresh: (C) Force a refresh if there is any deferred evaluation
    :type forceRefresh: boolean
    :param handleSize: (C Q) Sets the maximum handles size in pixels, for small handles
    :type handleSize: float
    :param hideManipOnCtrl: (C Q) Hide transform manip when the Ctrl key is pressed
    :type hideManipOnCtrl: boolean
    :param hideManipOnShift: (C Q) Hide transform manip when the Shift key is pressed
    :type hideManipOnShift: boolean
    :param hideManipOnShiftCtrl: (C Q) Hide transform manip when the Shift and Ctrl keys are
    both pressed
    :type hideManipOnShiftCtrl: boolean
    :param linePick: (C Q) Set the width of picking zone for long handles
    :type linePick: float
    :param lineSize: (C Q) Set the width of long handles (drawn as lines)
    :type lineSize: float
    :param middleMouseRepositioning: (C Q) Specify if the middle mouse should reposition
    :type middleMouseRepositioning: boolean
    :param pivotRotateHandleOffset: (C Q) Set the offset of the pivot rotation handle
    :type pivotRotateHandleOffset: int
    :param planeHandleOffset: (C Q) Set the offset of the planar drag handles
    :type planeHandleOffset: int
    :param pointSize: (C Q) Set the size of points (used to display previous states)
    :type pointSize: float
    :param preselectHighlight: (C Q) Set whether manip handles should be highlighted when
    moving mouse
    :type preselectHighlight: boolean
    :param refreshMode: (C Q) Set the global refresh mode
    :type refreshMode: int
    :param relative: (C) All values are interpreted as multiplication factors instead of final
    values
    :type relative: boolean
    :param rememberActiveHandle: (C Q) Set whether manip handles should be remembered after
    selection change
    :type rememberActiveHandle: boolean
    :param rememberActiveHandleAfterToolSwitch: (C Q) Set whether manip handles should be
    remembered after manipulator change
    :type rememberActiveHandleAfterToolSwitch: boolean
    :param scale: (C Q) Global scaling factor of all manipulators
    :type scale: float
    :param showExtrudeSliders: (C Q) Specify if the extrude sliders are to be shown on the
    manip
    :type showExtrudeSliders: boolean
    :param showPivotRotateHandle: (C Q) Toggles the visibility of the pivot rotation handle
    :type showPivotRotateHandle: boolean
    :param showPlaneHandles: (C Q) Toggles the visibility of the planar drag handles
    :type showPlaneHandles: boolean
    :param smartDuplicateType: (C Q) Change Shift-Duplicate or Shift-Extrude between Copy and
    Instance on t/r/s manips
    :type smartDuplicateType: int
    
    :returns: 
    :rtype: None
    """
    pass


def polyPrism(*args, axis=None, caching=True, constructionHistory=True, createUVs=2, length=2.0,
              name="", nodeState=0, numberOfSides=3, numderOfSides=3, object=True,
              sideLength=2.0, subdivisionsCaps=2, subdivisionsHeight=1, texture=0, q=True,
              query=True, e=True, edit=True, **kwargs):
    """
    The prism command creates a new polygonal prism
    
    :param axis: (C Q E) This flag specifies the primitive axis used to build the prism  Q:
    When queried, this flag returns a float[3]
    :type axis: [float, float, float]
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param createUVs: (C) This flag alows a specific UV mechanism to be selected, while
    creating the primitive  The valid values are 0, 1, 2 or 3  0 implies that no UVs will b
    :type createUVs: int
    :param length: (C Q E) This flag specifies the length of the prism  C: Default is 2.0  Q:
    When queried, this flag returns a float
    :type length: float
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param numberOfSides: (C Q E) This specifies the number of sides for the prism  C: Default
    is 3  Q: When queried, this flag returns an int
    :type numberOfSides: int
    :param numderOfSides: (C Q E) This specifies the number of sides for the prism  C: Default
    is 3  Q: When queried, this flag returns an int
    :type numderOfSides: int
    :param object: (C) Create the result, or just the dependency node (where applicable)
    :type object: boolean
    :param sideLength: (C Q E) This flag specifies the edge length of the prism  C: Default is
    2.0  Q: When queried, this flag returns a float
    :type sideLength: float
    :param subdivisionsCaps: (C Q E) This flag specifies the subdivisions on the caps for the
    prism  C: Default is 2  Q: When queried, this flag returns an int
    :type subdivisionsCaps: int
    :param subdivisionsHeight: (C Q E) This specifies the subdivisions along the height for the
    prism  C: Default is 1  Q: When queried, this flag returns an int
    :type subdivisionsHeight: int
    :param texture: (C) This flag is obsolete and will be removed in the next release  The
    -cuv/createUVs flag should be used instead
    :type texture: int
    
    :returns: Object name and node name.
    :rtype: string[]
    """
    pass


def AddKeyToolActivate(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def RaiseApplicationWindows(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DisplayViewport(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def floatSlider2(*args, annotation="", backgroundColor=None, changeCommand1="",
                 changeCommand2="", defineTemplate="", docTag="", dragCallback=None,
                 dropCallback=None, enable=True, enableBackground=True,
                 enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
                 highlightColor=None, isObscured=True, manage=True, maximum=0.0, minimum=0.0,
                 noBackground=True, numberOfPopupMenus=True, parent="", polarity=0,
                 popupMenuArray=True, positionControl1="", positionControl2="",
                 preventOverride=True, statusBarMessage="", useTemplate="", value1=0.0,
                 value2=0.0, values=None, visible=True, visibleChangeCommand=None, width=0,
                 q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a float slider containing two handles  The two handles are arranged
    such that they cannot pass one another, thus handle 1 will always have a value less than or
    or equal to handle 2 when you adjust the values  Each handle may have a MEL command
    associated with it which is issued when the handle moves and thus can be used to upda
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand1: (C E) Command to be associated with handle 1 and issued whenever the
    value of the handle is changed (except when values are changed via the -hv/handleValue
    :type changeCommand1: string
    :param changeCommand2: (C E) Command to be associated with handle 2 and issued whenever the
    value of the handle is changed (except when values are changed via the -hv/handleValue
    :type changeCommand2: string
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param maximum: (C Q E) Maximum limit of the slider  The default value is 10.0  The maximum
    value occurs at the top(right) end of the slider unless -polarity was specified
    :type maximum: float
    :param minimum: (C Q E) Minimum limit of the slider  The default value is 0.0  The minimum
    value occurs at the bottom end of the slider unless -polarity was specified  Note:
    :type minimum: float
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param polarity: (C Q E) Specifies the polarity of the slider  If 0 (the default), the
    minimum value (specified by the -minimum flag) occurs at the bottom end of the slider a
    :type polarity: int
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param positionControl1: (C E) Set the name of the control (if any) which is associated
    with handle 1 of this slider  The control must be a "floatField"  The control always
    display
    :type positionControl1: string
    :param positionControl2: (C E) Set the name of the control (if any) which is associated
    with handle 2 of this slider  The control must be a "floatField"  The control always
    display
    :type positionControl2: string
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param value1: (C Q E) Value of handle 1  To ensure that handle 1 stays at or below handle
    2, an error will occur if the value specified is too large  If you wish to set bo
    :type value1: float
    :param value2: (C Q E) Value of handle 2  To ensure that handle 2 stays at or above handle
    2, an error will occur if the value specified is too large  If you wish to set bo
    :type value2: float
    :param values: (C E) Sets the value for handles 1 and 2 simulteneously  The first argument
    is applied to handle 1 and must be less than or equal to the second (handle 2)
    :type values: [float, float]
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the port created or modified
    :rtype: string
    """
    pass


def GpuCacheExportAllOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SetMeshSprayTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def paneLayout(*args, activeFrameThickness=0, activePane="", activePaneIndex=0, annotation="",
               backgroundColor=None, childArray=True, configuration="", defineTemplate="",
               docTag="", dragCallback=None, dropCallback=None, enable=True,
               enableBackground=True, enableKeyboardFocus=True, exists=True, fullPathName=True,
               height=0, highlightColor=None, isObscured=True, manage=True, noBackground=True,
               numberOfChildren=True, numberOfPopupMenus=True, numberOfVisiblePanes=True,
               pane1=True, pane2=True, pane3=True, pane4=True, paneSize=None,
               paneUnderPointer=True, parent="", popupMenuArray=True, preventOverride=True,
               separatorMovedCommand=None, separatorThickness=0, setPane=None,
               staticHeightPane=0, staticWidthPane=0, statusBarMessage="", useTemplate="",
               visible=True, visibleChangeCommand=None, width=0, q=True, query=True, e=True,
               edit=True, **kwargs):
    """
    This command creates a pane layout  A pane layout may have any number of children but at
    any one time only certain children may be visible, as determined by the current layout
    configuration  For example a horizontally split pane shows only two children, one on top of
    the other and a visible separator between the two  The separator may be moved to v
    
    :param activeFrameThickness: (C Q E) The thickness of the frame drawn around the active
    frame  Specify an integer value greater than or equal to 0
    :type activeFrameThickness: int
    :param activePane: (C Q E) The active pane has a colored border surrounding it  Only one
    pane may be active at any one time  Using either of the flags -ap/activePane or -api/ac
    :type activePane: string
    :param activePaneIndex: (C Q E) The active pane index  The active pane has a colored border
    surrounding it  Only one pane may be active at any one time  Using either of the flags -a
    :type activePaneIndex: int
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param childArray: (Q) Returns a string array of the names of the layout's immediate
    children
    :type childArray: boolean
    :param configuration: (C Q E) Set the layout configuration for the panes  Valid values are:
    "single", "horizontal2", "vertical2", "horizontal3", "vertical3", "top3", "left3", "bot
    :type configuration: string
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfChildren: (Q) Returns in an int the number of immediate children of the
    layout
    :type numberOfChildren: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param numberOfVisiblePanes: (Q) Return the number of panes visible for the present
    configuration
    :type numberOfVisiblePanes: boolean
    :param pane1: (Q) 
    :type pane1: boolean
    :param pane2: (Q) 
    :type pane2: boolean
    :param pane3: (Q) 
    :type pane3: boolean
    :param pane4: (Q) Return the name of the control in the respective pane
    :type pane4: boolean
    :param paneSize: (C Q E M) The size of a pane in the current pane layout configuration  The
    first argument specifies the pane index and is an integer value ranging from 1 to 4
    :type paneSize: [int, int, int]
    :param paneUnderPointer: (Q) Return the name of the child occupying the pane that the
    pointer is currently over  An empty string is returned if the pointer is not over a pane
    :type paneUnderPointer: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param separatorMovedCommand: (C E) This command executed when the pane separators are
    moved
    :type separatorMovedCommand: script
    :param separatorThickness: (C Q E) The thickness of the separators between the panes 
    Specify an integer value greater than 0  This flag has no effect on Windows systems
    :type separatorThickness: int
    :param setPane: (C E M) This flag allows you to put a child of this layout in a particular
    pane  The first argument is the full or short name of the control  The second argu
    :type setPane: [string, int]
    :param staticHeightPane: (C E) Set a pane to have a static height, i.e  its height will not
    change when the layout is dynamically resized  Only one pane can be set to have a static
    :type staticHeightPane: int
    :param staticWidthPane: (C E) Set a pane to have a static width, i.e  its width will not
    change when the layout is dynamically resized  Only one pane can be set to have a static w
    :type staticWidthPane: int
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def SmoothCurve(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def getLastError(*args, **kwargs):
    """
    
    """
    pass


def polyTransfer(*args, alternateObject="", caching=True, constructionHistory=True, name="",
                 nodeState=0, uvSets=True, vertexColor=True, vertices=True, q=True, query=True,
                 e=True, edit=True, **kwargs):
    """
    Transfer information from one polygonal object to another one  Both objects must have
    identical topology, that is same vertex, edge, and face numbering  The flags specify which
    of the vertices, UV sets or vertex colors will be copied
    
    :param alternateObject: (C Q E) Name of the alternate object
    :type alternateObject: string
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param constructionHistory: (C Q) Turn the construction history on or off (where
    applicable)  If construction history is on then the corresponding node will be inserted
    into the histo
    :type constructionHistory: boolean
    :param name: (C) Give a name to the resulting node
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param uvSets: (C Q E) When true, the UV sets are copied from the alternate object  C:
    Default is "on"
    :type uvSets: boolean
    :param vertexColor: (C Q E) When true, the colors per vertex are copied from the alternate
    object  C: Default is "off"
    :type vertexColor: boolean
    :param vertices: (C Q E) When true, the vertices positions are copied from the alternate
    object  C: Default is "off"
    :type vertices: boolean
    
    :returns: representing the node name.
    :rtype: string
    """
    pass


def percent(*args, addPercent=True, dropoffAxis=None, dropoffCurve="", dropoffDistance=0.0,
            dropoffPosition=None, dropoffType="", multiplyPercent=True, value=1, q=True,
            query=True, **kwargs):
    """
    This command sets percent values on members of a weighted node such as a cluster or a
    jointCluster  With no flags specified the command sets the percent value for selected
    components of the specified node to the specified percent value  A dropoff from the
    specified percent value to 0 can be specified from a point, plane or curve using a dropoff
    dis
    
    :param addPercent: (C) Add the percent value specified with the -v flag to the existing
    percent values
    :type addPercent: boolean
    :param dropoffAxis: (C) Specifies the axis along which to dropoff the percent value,
    starting from the dropoffPosition
    :type dropoffAxis: [float, float, float]
    :param dropoffCurve: (C) Specifies the curve around which to dropoff the percent value
    :type dropoffCurve: string
    :param dropoffDistance: (C) Specifies the dropoff distance from the point, plane or curve
    that was specified using the -dp -dax or -dc flags
    :type dropoffDistance: float
    :param dropoffPosition: (C) Specifies the point around which to dropoff the percent value
    :type dropoffPosition: [float, float, float]
    :param dropoffType: (C) Specifies the type of dropoff  Used in conjunction with the -dp,
    -dax or -dc flags  Default is linear  Valid values are: linear, sine, exponential, l
    :type dropoffType: string
    :param multiplyPercent: (C) Multiply the percent value specified with the -v flag with
    existing percent values
    :type multiplyPercent: boolean
    :param value: (C Q) The percent value to be applied  The default is 1  In query mode,
    returns an array of doubles corresponding to the weights of the selected object com
    :type value: float
    
    :returns: 
    :rtype: None
    """
    pass


def MoveTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def xgmPartBrushContext(*args, **kwargs):
    """
    
    """
    pass


def selectMode(*args, component=True, hierarchical=True, leaf=True, object=True, preset=True,
               root=True, template=True, q=True, query=True, **kwargs):
    """
    The selectMode command is used to change the selection mode  Object, component, root, leaf
    and template modes are mutually exclusive
    
    :param component: (C Q) Set component selection on  Component selection mode allows
    filtered selection based on the component selection mask  The component selection mask is
    :type component: boolean
    :param hierarchical: (C Q) Set hierarchical selection on  There are three types of
    hierarchical selection: root, leaf and template  Hierarchical mode is set if root, leaf or
    te
    :type hierarchical: boolean
    :param leaf: (C Q) Set leaf selection mode on  This mode allows the leaf level objects to
    be selected  It is similar to object selection mode but ignores the object sel
    :type leaf: boolean
    :param object: (C Q) Set object selection on  Object selection mode allows filtered
    selection based on the object selection mask  The object selection mask is the set of
    :type object: boolean
    :param preset: (C Q) Allow selection of anything with the mask set, independent of it being
    an object or a component
    :type preset: boolean
    :param root: (C Q) Set root selection mode on  This mode allows the root of a hierarchy to
    be selected by selecting any of its descendents  It ignores the object select
    :type root: boolean
    :param template: (C Q) Set template selection mode on  This mode allows selection of
    templated objects  It selects the templated object closest to the root of the hierarchy
    :type template: boolean
    
    :returns: if a query operation
    :rtype: boolean
    """
    pass


def contextInfo(*args, c=True, escapeContext=True, exists=True, image1=True, image2=True,
                image3=True, title=True, q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command allows you to get information on named contexts
    
    :param c: (C) Return the class type of the named context
    :type c: boolean
    :param escapeContext: (C) Return the command string that will allow you to exit the current
    tool
    :type escapeContext: boolean
    :param exists: (C) Return true if the context exists, false if it does not exists (or is
    internal and therefore untouchable)
    :type exists: boolean
    :param image1: (C) Returns the name of an xpm associated with the named context
    :type image1: boolean
    :param image2: (C) Returns the name of an xpm associated with the named context
    :type image2: boolean
    :param image3: (C) Returns the name of an xpm associated with the named context
    :type image3: boolean
    :param title: (C) Return the title string of the named context
    :type title: boolean
    
    :returns: Info requested
    :rtype: string
    """
    pass


def CutCurveOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def HypershadeRefreshSelectedSwatches(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateVolumeSphere(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def DeleteAllFurs(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ToggleEvaluationManagerVisibility(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def bifMeshImport(*args, **kwargs):
    """
    
    """
    pass


def ConnectComponentsOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CircularFillet(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def optionVar(*args, arraySize="", clearArray="", exists="", floatValue=None,
              floatValueAppend=None, intValue=None, intValueAppend=None, list=True, remove="",
              removeFromArray=None, stringValue=None, stringValueAppend=None, version=0, q=True,
              query=True, **kwargs):
    """
    This command allows you to set and query variables which are persistent between different
    invocations of Maya  These variables are stored as part of the preferences
    
    :param arraySize: (C) returns the size of the array named "string"  If no such variable
    exists, it returns 0  If the variable is not an array, it returns 1
    :type arraySize: string
    :param clearArray: (C M) If there is an array named "string", it is set to be empty  Empty
    arrays are not saved
    :type clearArray: string
    :param exists: (C) returns 1 if a variable named "string" exists, 0 otherwise  All other
    flags will be ignored if this is used  (Query has higher precedence)
    :type exists: string
    :param floatValue: (C M) creates a new variable named "string" with double value "float" 
    If a variable already exists with this name, it is overridden in favour of the new v
    :type floatValue: [string, float]
    :param floatValueAppend: (C M) adds this value to the end of the array of floats named
    "string"  If no such array exists, one is created  If there was a float value with this
    name
    :type floatValueAppend: [string, float]
    :param intValue: (C M) creates a new variable named "string" with integer value "int"  If a
    variable already exists with this name, it is overridden in favour of the new va
    :type intValue: [string, int]
    :param intValueAppend: (C M) adds this value to the end of the array of ints named "string"
     If no such array exists, one is created  If there was an int value with this name bef
    :type intValueAppend: [string, int]
    :param list: (C) this returns a list of all the defined variable names  All other flags
    will be ignored if this one is used  (Query and exists flags have a higher pre
    :type list: boolean
    :param remove: (C M) removes the variable named "string", if one exists  Note: all removals
    are done before any value setting, if both the -r and other (-sv, -iv, -fv) fl
    :type remove: string
    :param removeFromArray: (C M) removes the element numbered "int" in the array named
    "string"  Everything beyond it then gets shuffled down
    :type removeFromArray: [string, int]
    :param stringValue: (C M) creates a new variable named using the first string with value
    given by the second string  If a variable already exists with this name, it is overrid
    :type stringValue: [string, string]
    :param stringValueAppend: (C M) adds the value given by the second string to the end of the
    array of strings named by the first string  If no such array exists, one is created  If t
    :type stringValueAppend: [string, string]
    :param version: (C) Preferences version number to warn about incompatbile preference files
    :type version: int
    
    :returns: 0 or 1 for the exists option
    :rtype: int
    """
    pass


def ambientLight(*args, ambientShade=0.0, discRadius=0.0, exclusive=True, intensity=0.0,
                 name="", position=None, rgb=None, rotation=None, shadowColor=None,
                 shadowDither=0.0, shadowSamples=0, softShadow=True, useRayTraceShadows=True,
                 q=True, query=True, e=True, edit=True, **kwargs):
    """
    TlightCmd is the base class for other light commands  The ambientLight command is used to
    edit the parameters of existing ambientLights, or to create new ones  The default behaviour
    is to create a new ambientlight   This is the commmand that instantiates an ambientLight or
    edits the parameters of an existing one  TambientLightCmd inherits from Tlig
    
    :param ambientShade: (C Q E) ambientShade
    :type ambientShade: float
    :param discRadius: (C Q E) radius of the disc around the light
    :type discRadius: float
    :param exclusive: (C Q) True if the light is exclusively assigned
    :type exclusive: boolean
    :param intensity: (C Q) Intensity of the light
    :type intensity: float
    :param name: (C Q) Name of the light
    :type name: string
    :param position: (C Q) Position of the light
    :type position: [float, float, float]
    :param rgb: (C Q) RGB colour of the light
    :type rgb: [float, float, float]
    :param rotation: (C Q) Rotation of the light for orientation, where applicable
    :type rotation: [float, float, float]
    :param shadowColor: (C Q) Color of the light's shadow
    :type shadowColor: [float, float, float]
    :param shadowDither: (C Q E) dither the shadow
    :type shadowDither: float
    :param shadowSamples: (C Q E) number of shadow samples
    :type shadowSamples: int
    :param softShadow: (C Q E) soft shadow
    :type softShadow: boolean
    :param useRayTraceShadows: (C Q) True if ray trace shadows are to be used
    :type useRayTraceShadows: boolean
    
    :returns: when querying the rgb or shadowColor flags
    double when querying the intensity
    flag
    boolean when querying the useRayTraceShadows or exclusive flags
    linear[] when querying
    the position flag
    angle[] when querying the rotation flag
    string when querying the name
    flag
    :rtype: double[]
    """
    pass


def OutlinerDoHide(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def bakeDeformer(*args, colorizeSkeleton=True, customRangeOfMotion=None, dstMeshName="",
                 dstSkeletonName="", hierarchy=True, influences=None, maxInfluences=0,
                 pruneWeights=0.0, smoothWeights=0, srcMeshName="", srcSkeletonName="",
                 **kwargs):
    """
    Given a rigged character, whose mesh shape is determined by a set of deformers,
    bakeDeformer calculates linear blend skin weights most closely approximating observed
    deformations  To do this, a test set of examples is generated by moving the rig through a
    range of motion  Results mesh and pose pairs are then used to solve a constrained
    optimization
    
    :param colorizeSkeleton: (C) The new skin cluster created will have its skeleton colorized 
    Must be used with the -srcSkeletonName and -dstSkeletonName flags
    :type colorizeSkeleton: boolean
    :param customRangeOfMotion: (C) When this flag is specified with the frames for the range
    of motion to be used, the tool will step through each frame as a separate pose  Otherwise
    t
    :type customRangeOfMotion: timerange
    :param dstMeshName: (C) The destination mesh name
    :type dstMeshName: string
    :param dstSkeletonName: (C) The destination skeleton name
    :type dstSkeletonName: string
    :param hierarchy: (C) All children of the passed joints that are used in the influences
    flag are used
    :type hierarchy: boolean
    :param influences: (C) A list of joints that are used as the influences to determine new
    weights
    :type influences: string[]
    :param maxInfluences: (C) The maximum number of influences per vertex
    :type maxInfluences: int
    :param pruneWeights: (C) On the newly created skin cluster, set any weight below the given
    the value to zero (post-processing)  This will call the skinPercent command as foll
    :type pruneWeights: float
    :param smoothWeights: (C) The number of smoothing iterations for smoothing weights
    (post-processing)  This also renormalizes the remaining the weights
    :type smoothWeights: int
    :param srcMeshName: (C) The source mesh name
    :type srcMeshName: string
    :param srcSkeletonName: (C) The source skeleton name
    :type srcSkeletonName: string
    
    :returns: BakeDeformer name
    :rtype: string
    """
    pass


def texSelectContext(*args, exists=True, image1="", image2="", image3="", q=True, query=True,
                     e=True, edit=True, **kwargs):
    """
    Command used to register the texSelectCtx tool
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    
    :returns: : name of the context created
    :rtype: string
    """
    pass


def subdDuplicateAndConnect(*args, **kwargs):
    """
    This command duplicates the input subdivision surface object, connects up the outSubdiv
    attribute of the original subd shape to the create attribute of the newly created duplicate
    shape and copies over the shader assignments from the original shape to the new duplicated
    shape   The command will fail if no objects are selected or sent as argument or
    
    
    :returns: 
    :rtype: None
    """
    pass


def PolyExtrude(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def listHistory(*args, allConnections=True, allFuture=True, allGraphs=True, breadthFirst=True,
                future=True, futureLocalAttr=True, futureWorldAttr=True, groupLevels=True,
                historyAttr=True, interestLevel=0, leaf=True, levels=0, pruneDagObjects=True,
                q=True, query=True, **kwargs):
    """
    This command traverses backwards or forwards in the graph from the specified node and
    returns all of the nodes whose construction history it passes through  The construction
    history consists of connections to specific attributes of a node defined as the creators
    and results of the node's main data, eg  the curve for a Nurbs Curve node   For informa
    
    :param allConnections: (C) If specified, the traversal that searches for the history or
    future will not restrict its traversal across nodes to only dependent plugs  Thus it wil
    :type allConnections: boolean
    :param allFuture: (C) If listing the future, list all of it  Otherwise if a shape has an
    attribute that represents its output geometry data, and that plug is connected, on
    :type allFuture: boolean
    :param allGraphs: (C) This flag is obsolete and has no effect
    :type allGraphs: boolean
    :param breadthFirst: (C) The breadth first traversal will return the closest nodes in the
    traversal first  The depth first traversal will follow a complete path away from the
    :type breadthFirst: boolean
    :param future: (C) List the future instead of the history
    :type future: boolean
    :param futureLocalAttr: (Q) This flag allows querying of the local-space future-related
    attribute(s) on shape nodes
    :type futureLocalAttr: boolean
    :param futureWorldAttr: (Q) This flag allows querying of the world-space future-related
    attribute(s) on shape nodes
    :type futureWorldAttr: boolean
    :param groupLevels: (C) The node names are grouped depending on the level  > 1 is the lead,
    the rest are grouped with it
    :type groupLevels: boolean
    :param historyAttr: (Q) This flag allows querying of the attribute where history connects
    on shape nodes
    :type historyAttr: boolean
    :param interestLevel: (C) If this flag is set, only nodes whose historicallyInteresting
    attribute value is not less than the value will be listed  The historicallyInteresting
    :type interestLevel: int
    :param leaf: (C) If transform is selected, show history for its leaf shape  Default is
    true
    :type leaf: boolean
    :param levels: (C) Levels deep to traverse  Setting the number of levels to 0 means do all
    levels  All levels is the default
    :type levels: int
    :param pruneDagObjects: (C) If this flag is set, prune at dag objects
    :type pruneDagObjects: boolean
    
    :returns: List of history nodes
    :rtype: string[]
    """
    pass


def CreateCameraAimOptions(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PostInfinityConstant(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def GraphEditorFramePlaybackRange(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def ikSpringSolverRestPose(*args, **kwargs):
    """
    
    """
    pass


def XgmSetWidthBrushTool(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def SewUVs3D(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def workspaceLayoutManager(*args, collapseMainWindowControls=None, current=True, delete="",
                           i="", listLayouts=True, listModuleLayouts=True, listUserLayouts=True,
                           modified="", parentWorkspaceControl="", reset=True,
                           restoreMainWindowControls=True, save=True, saveAs="", setCurrent="",
                           setCurrentCallback="", setModifiedCallback="", type="", q=True,
                           query=True, e=True, edit=True, **kwargs):
    """
    The Workspace Layout Manager loads and saves the layout of the various toolbars and windows
    in the user interface  This command allows listing and managing their properties
    
    :param collapseMainWindowControls: (C) Saves main window layout and collapses all other
    controls in main window except the given one (first parameter) if it does not have any size
    constrai
    :type collapseMainWindowControls: [string, boolean]
    :param current: (C Q) Get the name of the current layout
    :type current: boolean
    :param delete: (C) Delete the given workspace  The string is the name of the layout, not
    the file name
    :type delete: string
    :param i: (C) Import the given workspace file to the workspaces directory  The string is an
    absolute path
    :type i: string
    :param listLayouts: (C) List the names of all registered layouts
    :type listLayouts: boolean
    :param listModuleLayouts: (C) List the names of module layouts
    :type listModuleLayouts: boolean
    :param listUserLayouts: (C) List the names of user layouts
    :type listUserLayouts: boolean
    :param modified: (C) Check whether or not the specified layout has been modified
    :type modified: string
    :param parentWorkspaceControl: (C) Returns the parent workspace control of the given UI
    (panel) or an empty string if it does not exist
    :type parentWorkspaceControl: string
    :param reset: (C) Reset the current workspace to its original layout  Factory layouts will
    be reverted to default while user layouts will be reloaded from disk
    :type reset: boolean
    :param restoreMainWindowControls: (C) Restores the main window layout to the one saved with
    the -cmw/-collapseMainWindowControls flag  The loaded workspace file will be deleted once
    it is
    :type restoreMainWindowControls: boolean
    :param save: (C) Save the current layout
    :type save: boolean
    :param saveAs: (C) Save the current layout under the specified name
    :type saveAs: string
    :param setCurrent: (C) Load the given workspace  The string is the name of the layout, not
    the file name
    :type setCurrent: string
    :param setCurrentCallback: (C) MEL only  The string is interpreted as a MEL callback, which
    is called each time a layout is set as current (with -setCurrent flag)  The callback is
    :type setCurrentCallback: string
    :param setModifiedCallback: (C) MEL only  The string is interpreted as a MEL callback,
    which is called each time a layout is modified or restored, that is, each time the
    -modified f
    :type setModifiedCallback: string
    :param type: (C) Get the type of the specified layout: FACTORY, FACTORY_OVERRIDE, MODULE,
    MODULE_OVERRIDE or USER
    :type type: string
    
    :returns: depending on arguments
    :rtype: string[]
    """
    pass


def PolygonApplyColor(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dopeSheetEditor(*args, autoFit="", autoFitTime="", control=True, defineTemplate="",
                    displayActiveKeyTangents="", displayActiveKeys="", displayInfinities="",
                    displayKeys="", displayTangents="", displayValues="", docTag="",
                    exists=True, filter="", forceMainConnection="", hierarchyBelow=True,
                    highlightConnection="", lockMainConnection=True, lookAt="",
                    mainListConnection="", outliner="", panel="", parent="",
                    selectionConnection="", selectionWindow=None, showScene=True,
                    showSummary=True, showTicks=True, snapTime="", snapValue="",
                    stateString=True, unParent=True, unlockMainConnection=True,
                    updateMainConnection=True, useTemplate="", q=True, query=True, e=True,
                    edit=True, **kwargs):
    """
    Edit a characteristic of a dope sheet editor
    
    :param autoFit: (Q E) on | off | tgl Auto fit-to-view
    :type autoFit: string
    :param autoFitTime: (Q E) on | off | tgl Auto fit-to-view along the time axis, as well
    :type autoFitTime: string
    :param control: (Q) Query only  Returns the top level control for this editor  Usually used
    for getting a parent to attach popup menus  Caution: It is possible for an ed
    :type control: boolean
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param displayActiveKeyTangents: (E) on | off | tgl Display active key tangents in the
    editor
    :type displayActiveKeyTangents: string
    :param displayActiveKeys: (E) on | off | tgl Display active keys in the editor
    :type displayActiveKeys: string
    :param displayInfinities: (E) on | off | tgl Display infinities in the editor
    :type displayInfinities: string
    :param displayKeys: (E) on | off | tgl Display keyframes in the editor
    :type displayKeys: string
    :param displayTangents: (E) on | off | tgl Display tangents in the editor
    :type displayTangents: string
    :param displayValues: (E) on | off | tgl Display active keys and tangents values in the
    editor
    :type displayValues: string
    :param docTag: (C Q E) Attaches a tag to the editor
    :type docTag: string
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param filter: (C Q E) Specifies the name of an itemFilter object to be used with this
    editor  This filters the information coming onto the main list of the editor
    :type filter: string
    :param forceMainConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type forceMainConnection: string
    :param hierarchyBelow: (Q E) display animation for objects hierarchically
    :type hierarchyBelow: boolean
    :param highlightConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its highlight list  Not all editors have a highlight list 
    F
    :type highlightConnection: string
    :param lockMainConnection: (C E) Locks the current list of objects within the
    mainConnection, so that only those objects are displayed within the editor  Further changes
    to the origi
    :type lockMainConnection: boolean
    :param lookAt: (E) all | selected | currentTime FitView helpers
    :type lookAt: string
    :param mainListConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will use as its source of content  The editor will only display items contained
    in
    :type mainListConnection: string
    :param outliner: (Q E) the name of the outliner which is associated with the dope sheet
    :type outliner: string
    :param panel: (C Q) Specifies the panel for this editor  By default if an editor is created
    in the create callback of a scripted panel it will belong to that panel  If a
    :type panel: string
    :param parent: (C Q E) Specifies the parent layout for this editor  This flag will only
    have an effect if the editor is currently un-parented
    :type parent: string
    :param selectionConnection: (C Q E) Specifies the name of a selectionConnection object that
    the editor will synchronize with its own selection list  As the user selects things in this
    e
    :type selectionConnection: string
    :param selectionWindow: (Q E) The selection area specified as left, right, bottom, top
    respectively
    :type selectionWindow: [float, float, float, float]
    :param showScene: (Q E) display the scene summary object
    :type showScene: boolean
    :param showSummary: (Q E) display the summary object
    :type showSummary: boolean
    :param showTicks: (Q E) display per animation tick divider in channel
    :type showTicks: boolean
    :param snapTime: (Q E) none | integer | keyframe Keyframe move snap in time
    :type snapTime: string
    :param snapValue: (Q E) none | integer | keyframe Keyframe move snap in values
    :type snapValue: string
    :param stateString: (Q) Query only flag  Returns the MEL command that will create an editor
    to match the current editor state  The returned command string uses the string va
    :type stateString: boolean
    :param unParent: (C E) Specifies that the editor should be removed from its layout  This
    cannot be used in query mode
    :type unParent: boolean
    :param unlockMainConnection: (C E) Unlocks the mainConnection, effectively restoring the
    original mainConnection (if it is still available), and dynamic updates
    :type unlockMainConnection: boolean
    :param updateMainConnection: (C E) Causes a locked mainConnection to be updated from the
    orginal mainConnection, but preserves the lock state
    :type updateMainConnection: boolean
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    
    :returns: Editor name
    :rtype: string
    """
    pass


def AutobindContainer(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def keyframeRegionSelectKeyCtx(*args, exists=True, history=True, image1="", image2="",
                               image3="", name="", q=True, query=True, e=True, edit=True,
                               **kwargs):
    """
    This command creates a context which may be used to select keyframes within the keyframe
    region of the dope sheet editor
    
    :param exists: (C) Returns true or false depending upon whether the specified object exists
     Other flags are ignored
    :type exists: boolean
    :param history: (C) If this is a tool command, turn the construction history on for the
    tool in question
    :type history: boolean
    :param image1: (C Q E) First of three possible icons representing the tool associated with
    the context
    :type image1: string
    :param image2: (C Q E) Second of three possible icons representing the tool associated with
    the context
    :type image2: string
    :param image3: (C Q E) Third of three possible icons representing the tool associated with
    the context
    :type image3: string
    :param name: (C) If this is a tool command, name the tool appropriately
    :type name: string
    
    :returns: Context name
    :rtype: string
    """
    pass


def nurbsToSubdiv(*args, addUnderTransform=True, caching=True, collapsePoles=False,
                  constructionHistory=True, matchPeriodic=False, maxPolyCount=1000, name="",
                  nodeState=0, object=True, reverseNormal=True, q=True, query=True, e=True,
                  edit=True, **kwargs):
    """
    This command converts a NURBS surface and produces a subd surface  The name of the new
    subdivision surface is returned  If construction history is ON, then the name of the new
    dependency node is returned as well
    
    :param addUnderTransform: (C Q E) Specify whether the new surface should be added under the
    old transform or not
    :type addUnderTransform: boolean
    :param caching: (C Q E) Toggle caching for all attributes so that no recomputation is
    needed
    :type caching: boolean
    :param collapsePoles: (C Q E) Collapse poles into a single point Default: false
    :type collapsePoles: boolean
    :param constructionHistory: (C) Turn the construction history on or off
    :type constructionHistory: boolean
    :param matchPeriodic: (C Q E) Match periodic surface texture mapping in the result 
    Default: false
    :type matchPeriodic: boolean
    :param maxPolyCount: (C Q E) The maximum number of base mesh faces in the resulting
    subdivision surface  Default: 1000
    :type maxPolyCount: int
    :param name: (C) Sets the name of the newly-created node  If it contains namespace path,
    the new node will be created under the specified namespace; if the namespace
    :type name: string
    :param nodeState: (C Q E) This is implemented in the depend node base class and applies to
    all nodes  Blocking is applied during the evaluation phase to connections  An evalua
    :type nodeState: int
    :param object: (C) Create the result, or just the dependency node
    :type object: boolean
    :param reverseNormal: (C Q E) Reverse the NURBS surface normal in the conversion  Default:
    true
    :type reverseNormal: boolean
    
    :returns: The subd surface and optionally the dependency node name
    :rtype: string[]
    """
    pass


def UIModeMarkingMenuPopDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def CreateConstraintClip(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def dR_createCameraFromView(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def sbs_GetEnumName(*args, **kwargs):
    """
    
    """
    pass


def image(*args, annotation="", backgroundColor=None, defineTemplate="", docTag="",
          dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
          enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
          highlightColor=None, image="", isObscured=True, manage=True, noBackground=True,
          numberOfPopupMenus=True, parent="", popupMenuArray=True, preventOverride=True,
          statusBarMessage="", useTemplate="", visible=True, visibleChangeCommand=None, width=0,
          q=True, query=True, e=True, edit=True, **kwargs):
    """
    This command creates a static image for non-xpm files  Any image file format supported by
    the file texture node is supported by this command
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param image: (C Q E) Sets the image given the file name
    :type image: string
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: The name of the image created.
    :rtype: string
    """
    pass


def symbolCheckBox(*args, annotation="", backgroundColor=None, changeCommand=None,
                   defineTemplate="", disableOffImage="", disableOnImage="", docTag="",
                   dragCallback=None, dropCallback=None, enable=True, enableBackground=True,
                   enableKeyboardFocus=True, exists=True, fullPathName=True, height=0,
                   highlightColor=None, image="", innerMargin=True, isObscured=True,
                   ltVersion="", manage=True, noBackground=True, numberOfPopupMenus=True,
                   offCommand=None, offImage="", onCommand=None, onImage="", parent="",
                   popupMenuArray=True, preventOverride=True, statusBarMessage="",
                   useTemplate="", value=True, version="", visible=True,
                   visibleChangeCommand=None, width=0, q=True, query=True, e=True, edit=True,
                   **kwargs):
    """
    This command creates a symbol check box  A symbol check box is a simple control containing
    a pixmap and a state of either on or off  Commands can be attached to any or all of the
    following events: when the symbol check box is turned on, turned off, or simply when it's
    state is changed
    
    :param annotation: (C Q E) Annotate the control with an extra string value
    :type annotation: string
    :param backgroundColor: (C Q E) The background color of the control  The arguments
    correspond to the red, green, and blue color components  Each component ranges in value
    from 0.0 t
    :type backgroundColor: [float, float, float]
    :param changeCommand: (C E) Command executed when the check box's state is changed  Note
    that this flag should not be used in conjunction with onCommand and offCommand  That is,
    :type changeCommand: script
    :param defineTemplate: (C) Puts the command in a mode where any other flags and arguments
    are parsed and added to the command template specified in the argument  They will be u
    :type defineTemplate: string
    :param disableOffImage: (C Q E) Image displayed when the check box is off and disabled
    :type disableOffImage: string
    :param disableOnImage: (C Q E) Image displayed when the check box is on and disabled
    :type disableOnImage: string
    :param docTag: (C Q E) Add a documentation flag to the control  The documentation flag has
    a directory structure  (e.g., -dt render/multiLister/createNode/material)
    :type docTag: string
    :param dragCallback: (C E) Adds a callback that is called when the middle mouse button is
    pressed  The MEL version of the callback is of the form: global proc string[] callback
    :type dragCallback: script
    :param dropCallback: (C E) Adds a callback that is called when a drag and drop operation is
    released above the drop site  The MEL version of the callback is of the form: global
    :type dropCallback: script
    :param enable: (C Q E) The enable state of the control  By default, this flag is set to
    true and the control is enabled  Specify false and the control will appear dimmed or
    :type enable: boolean
    :param enableBackground: (C Q E) Enables the background color of the control
    :type enableBackground: boolean
    :param enableKeyboardFocus: (C Q E) If enabled, the user can navigate to the control with
    the tab key and select values with the keyboard  If not, the user can only use the mouse 
    This
    :type enableKeyboardFocus: boolean
    :param exists: (C) Returns whether the specified object exists or not  Other flags are
    ignored
    :type exists: boolean
    :param fullPathName: (Q) Return the full path name of the widget, which includes all the
    parents
    :type fullPathName: boolean
    :param height: (C Q E) The height of the control  The control will attempt to be this size
    if it is not overruled by parent layout conditions
    :type height: int
    :param highlightColor: (C Q E) The highlight color of the control  The arguments correspond
    to the red, green, and blue color components  Each component ranges in value from 0.0 to
    :type highlightColor: [float, float, float]
    :param image: (C Q E) Image of the check box
    :type image: string
    :param innerMargin: (C Q E) This flag will revert the symbolCheckBox to its pre Maya 2.5
    behaviour of having a 2 pixel inner margin  This flag is for backward compatibility on L
    :type innerMargin: boolean
    :param isObscured: (Q) Return whether the control can actually be seen by the user  The
    control will be obscured if its state is invisible, if it is blocked (entirely or pa
    :type isObscured: boolean
    :param ltVersion: (C Q E) This flag is used to specify the Maya LT version that this
    control feature was introduced, if the version flag is not specified, or if the version fl
    :type ltVersion: string
    :param manage: (C Q E) Manage state of the control  An unmanaged control is not visible,
    nor does it take up any screen real estate  All controls are created managed by def
    :type manage: boolean
    :param noBackground: (C E) Clear/reset the control's background  Passing true means the
    background should not be drawn at all, false means the background should be drawn  The s
    :type noBackground: boolean
    :param numberOfPopupMenus: (Q) Return the number of popup menus attached to this control
    :type numberOfPopupMenus: boolean
    :param offCommand: (C E) Command executed when the symbol check box is turned off
    :type offCommand: script
    :param offImage: (C Q E) Image displayed when the check box is off
    :type offImage: string
    :param onCommand: (C E) Command executed when the symbol check box is turned on
    :type onCommand: script
    :param onImage: (C Q E) Image displayed when the check box is on
    :type onImage: string
    :param parent: (C Q) The parent layout for this control
    :type parent: string
    :param popupMenuArray: (Q) Return the names of all the popup menus attached to this
    control
    :type popupMenuArray: boolean
    :param preventOverride: (C Q E) If true, this flag prevents overriding the control's
    attribute via the control's right mouse button menu
    :type preventOverride: boolean
    :param statusBarMessage: (C E) Extra string to display in the status bar when the mouse is
    over the control
    :type statusBarMessage: string
    :param useTemplate: (C) Forces the command to use a command template other than the current
    one
    :type useTemplate: string
    :param value: (C Q E) Value of the check box
    :type value: boolean
    :param version: (C Q E) Specify the version that this control feature was introduced  The
    argument should be given as a string of the version number (e.g  "2017", "2018")  C
    :type version: string
    :param visible: (C Q E) The visible state of the control  A control is created visible by
    default  Note that a control's actual appearance is also dependent on the visible s
    :type visible: boolean
    :param visibleChangeCommand: (C Q E) Command that gets executed when visible state of the
    control changes
    :type visibleChangeCommand: script
    :param width: (C Q E) The width of the control  The control will attempt to be this size if
    it is not overruled by parent layout conditions
    :type width: int
    
    :returns: Full path name to the control.
    :rtype: string
    """
    pass


def AddInbetween(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def PixelMoveDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def UnifyTangents(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


def KeyframeTangentMarkingMenuPopDown(*args, **kwargs):
    """
    runTimeCommand
    """
    pass


